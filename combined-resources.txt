################################################################################
#                                                                              #
#                    CLOUD RESOURCE COST MAPPERS                               #
#                      Combined Source Code                                    #
#                                                                              #
#                    Generated: 2026-01-16 20:43:45                          #
#                                                                              #
################################################################################

================================================================================
                              STATISTICS
================================================================================
  AWS : 113 resource mappers
  AZURE : 106 resource mappers
  GOOGLE : 39 resource mappers
  ----------------------------------------
  TOTAL: 258 files

================================================================================
                           DIRECTORY STRUCTURE
================================================================================

internal/resources/|-- aws/ (113 files)
|-- azure/ (106 files)
|-- google/ (39 files)

================================================================================
                              SOURCE FILES
================================================================================

################################################################################
#                                                                              #
#                              AWS RESOURCES                                  #
#                                                                              #
################################################################################

################################################################################
# FILE: internal/resources/aws/acm_certificate.go
# RESOURCE: aws_acm_certificate
# SIZE: 1192 bytes | LINES: 39
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type ACMCertificate struct {
	Address                 string
	Region                  string
	CertificateAuthorityARN string
}

func (r *ACMCertificate) CoreType() string {
	return "ACMCertificate"
}

func (r *ACMCertificate) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *ACMCertificate) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ACMCertificate) BuildResource() *schema.Resource {
	if r.CertificateAuthorityARN == "" {
		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	certAuthority := &ACMPCACertificateAuthority{
		Region: r.Region,
	}

	certCostComponent := certAuthority.certificateCostComponent("Certificate", "0", decimalPtr(decimal.NewFromInt(1)))

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: []*schema.CostComponent{certCostComponent},
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/acmpca_certificate_authority.go
# RESOURCE: aws_acmpca_certificate_authority
# SIZE: 4341 bytes | LINES: 111
################################################################################
package aws

import (
	"strings"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/infracost/infracost/internal/usage"

	"github.com/shopspring/decimal"
)

type ACMPCACertificateAuthority struct {
	Address         string
	Region          string
	UsageMode       string
	MonthlyRequests *int64 `infracost_usage:"monthly_requests"`
}

func (r *ACMPCACertificateAuthority) CoreType() string {
	return "ACMPCACertificateAuthority"
}

func (r *ACMPCACertificateAuthority) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_requests", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *ACMPCACertificateAuthority) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ACMPCACertificateAuthority) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.certificateAuthorityCostComponent(),
	}

	if r.MonthlyRequests != nil {
		monthlyCertificatesRequests := decimal.NewFromInt(*r.MonthlyRequests)

		if r.shortLived() {
			costComponents = append(costComponents, r.certificateCostComponent("Certificates (short-lived)", "0", &monthlyCertificatesRequests))
		} else {
			certificateTierLimits := []int{1000, 9000}
			certificateTiers := usage.CalculateTierBuckets(monthlyCertificatesRequests, certificateTierLimits)

			if certificateTiers[0].GreaterThan(decimal.NewFromInt(0)) {
				costComponents = append(costComponents, r.certificateCostComponent("Certificates (first 1K)", "0", &certificateTiers[0]))
			}

			if certificateTiers[1].GreaterThan(decimal.NewFromInt(0)) {
				costComponents = append(costComponents, r.certificateCostComponent("Certificates (next 9K)", "1000", &certificateTiers[1]))
			}

			if certificateTiers[2].GreaterThan(decimal.NewFromInt(0)) {
				costComponents = append(costComponents, r.certificateCostComponent("Certificates (over 10K)", "10000", &certificateTiers[2]))
			}
		}
	} else {
		var unknown *decimal.Decimal
		if r.shortLived() {
			costComponents = append(costComponents, r.certificateCostComponent("Certificates (short-lived)", "0", unknown))
		} else {
			costComponents = append(costComponents, r.certificateCostComponent("Certificates (first 1K)", "0", unknown))
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *ACMPCACertificateAuthority) shortLived() bool {
	return strings.ToLower(r.UsageMode) == "short_lived_certificate"
}

func (r *ACMPCACertificateAuthority) certificateAuthorityCostComponent() *schema.CostComponent {
	name := "Private certificate authority"
	regex := "/-PaidPrivateCA/"
	if r.shortLived() {
		name = "Private certificate authority (short-lived certificate mode)"
		regex = "/-ShortLivedCertificatePrivateCA/"
	}

	return &schema.CostComponent{
		Name:            name,
		Unit:            "months",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSCertificateManager"),
			ProductFamily: strPtr("AWS Certificate Manager"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: &regex},
			},
		},
	}
}

func (r *ACMPCACertificateAuthority) certificateCostComponent(displayName string, usageTier string, monthlyQuantity *decimal.Decimal) *schema.CostComponent {
	regex := "/-PrivateCertificatesIssued/"
	if r.shortLived() {
		regex = "/-ShortLivedCertificatesIssued/"
	}

	return &schema.CostComponent{
		Name:            displayName,
		Unit:            "requests",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: monthlyQuantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSCertificateManager"),
			ProductFamily: strPtr("AWS Certificate Manager"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: &regex},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(usageTier),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/api_gateway_rest_api.go
# RESOURCE: aws_api_gateway_rest_api
# SIZE: 2921 bytes | LINES: 70
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/usage"
)

type APIGatewayRestAPI struct {
	Address         string
	Region          string
	MonthlyRequests *int64 `infracost_usage:"monthly_requests"`
}

func (r *APIGatewayRestAPI) CoreType() string {
	return "APIGatewayRestAPI"
}

func (r *APIGatewayRestAPI) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_requests", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *APIGatewayRestAPI) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *APIGatewayRestAPI) BuildResource() *schema.Resource {
	var costComponents []*schema.CostComponent
	var monthlyRequests *decimal.Decimal

	if r.MonthlyRequests != nil {
		monthlyRequests = decimalPtr(decimal.NewFromInt(*r.MonthlyRequests))

		requestLimits := []int{333000000, 667000000, 19000000000}
		apiRequestQuantities := usage.CalculateTierBuckets(*monthlyRequests, requestLimits)

		costComponents = append(costComponents, r.requestsCostComponent("Requests (first 333M)", "0", &apiRequestQuantities[0]))

		if apiRequestQuantities[1].GreaterThan(decimal.NewFromInt(0)) {
			costComponents = append(costComponents, r.requestsCostComponent("Requests (next 667M)", "333000000", &apiRequestQuantities[1]))
		}

		if apiRequestQuantities[2].GreaterThan(decimal.NewFromInt(0)) {
			costComponents = append(costComponents, r.requestsCostComponent("Requests (next 19B)", "1000000000", &apiRequestQuantities[2]))
		}

		if apiRequestQuantities[3].GreaterThan(decimal.NewFromInt(0)) {
			costComponents = append(costComponents, r.requestsCostComponent("Requests (over 20B)", "20000000000", &apiRequestQuantities[3]))
		}
	} else {
		costComponents = append(costComponents, r.requestsCostComponent("Requests (first 333M)", "0", monthlyRequests))
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *APIGatewayRestAPI) requestsCostComponent(displayName string, usageTier string, quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            displayName,
		Unit:            "1M requests",
		UnitMultiplier:  decimal.NewFromInt(1000000),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonApiGateway"),
			ProductFamily: strPtr("API Calls"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/ApiGatewayRequest/")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(usageTier),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/api_gateway_stage.go
# RESOURCE: aws_api_gateway_stage
# SIZE: 1650 bytes | LINES: 54
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type APIGatewayStage struct {
	Address          string
	Region           string
	CacheClusterSize float64
	CacheEnabled     bool
}

func (r *APIGatewayStage) CoreType() string {
	return "APIGatewayStage"
}

func (r *APIGatewayStage) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *APIGatewayStage) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *APIGatewayStage) BuildResource() *schema.Resource {
	if !r.CacheEnabled {
		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	region := r.Region

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:           fmt.Sprintf("Cache memory (%s GB)", decimal.NewFromFloat(r.CacheClusterSize)),
				Unit:           "hours",
				UnitMultiplier: decimal.NewFromInt(1),
				HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(region),
					Service:       strPtr("AmazonApiGateway"),
					ProductFamily: strPtr("Amazon API Gateway Cache"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "cacheMemorySizeGb", ValueRegex: strPtr(fmt.Sprintf("/%s/", decimal.NewFromFloat(r.CacheClusterSize)))},
					},
				},
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/apigatewayv2_api.go
# RESOURCE: aws_apigatewayv2_api
# SIZE: 6523 bytes | LINES: 146
################################################################################
package aws

import (
	"fmt"
	"strings"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/usage"
)

type APIGatewayV2API struct {
	Address               string
	Region                string
	ProtocolType          string
	MessageSizeKB         *int64 `infracost_usage:"message_size_kb"`
	MonthlyConnectionMins *int64 `infracost_usage:"monthly_connection_mins"`
	MonthlyRequests       *int64 `infracost_usage:"monthly_requests"`
	RequestSizeKB         *int64 `infracost_usage:"request_size_kb"`
	MonthlyMessages       *int64 `infracost_usage:"monthly_messages"`
}

func (r *APIGatewayV2API) CoreType() string {
	return "APIGatewayV2API"
}

func (r *APIGatewayV2API) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "message_size_kb", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_connection_mins", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "request_size_kb", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_messages", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *APIGatewayV2API) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *APIGatewayV2API) BuildResource() *schema.Resource {
	var costComponents []*schema.CostComponent

	if strings.ToLower(r.ProtocolType) == "websocket" {
		costComponents = r.websocketAPICostComponent()
	}

	if strings.ToLower(r.ProtocolType) == "http" {
		costComponents = r.httpAPICostComponent()
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *APIGatewayV2API) httpAPICostComponent() []*schema.CostComponent {
	var monthlyRequests *decimal.Decimal
	requestSize := decimal.NewFromInt(512)

	billableRequestSize := decimal.NewFromInt(512)

	httpAPITiers := []int{300000000}

	costComponents := []*schema.CostComponent{}

	if r.MonthlyRequests != nil {
		monthlyRequests = decimalPtr(decimal.NewFromInt(*r.MonthlyRequests))

		if r.RequestSizeKB != nil {
			requestSize = decimal.NewFromInt(*r.RequestSizeKB)
		}

		if requestSize.GreaterThan(billableRequestSize) {
			monthlyRequests = calculateBillableRequests(&requestSize, &billableRequestSize, monthlyRequests)
		}

		apiRequestQuantities := usage.CalculateTierBuckets(*monthlyRequests, httpAPITiers)

		costComponents = append(costComponents, r.httpCostComponent("Requests (first 300M)", "0", &apiRequestQuantities[0]))

		if apiRequestQuantities[1].GreaterThan(decimal.NewFromInt(0)) {
			costComponents = append(costComponents, r.httpCostComponent("Requests (over 300M)", "300000000", &apiRequestQuantities[1]))
		}
	} else {
		costComponents = append(costComponents, r.httpCostComponent("Requests (first 300M)", "0", nil))
	}

	return costComponents
}

func (r *APIGatewayV2API) websocketAPICostComponent() []*schema.CostComponent {
	var monthlyMessages *decimal.Decimal
	var monthlyConnectionMinutes *decimal.Decimal

	messageSize := decimal.NewFromInt(32)

	billableRequestSize := decimal.NewFromInt(32)

	websocketAPITiers := []int{1000000000}

	costComponents := []*schema.CostComponent{}

	if r.MonthlyMessages != nil {
		monthlyMessages = decimalPtr(decimal.NewFromInt(*r.MonthlyMessages))

		if r.MessageSizeKB != nil {
			messageSize = decimal.NewFromInt(*r.MessageSizeKB)
		}

		if messageSize.GreaterThan(billableRequestSize) {
			monthlyMessages = calculateBillableRequests(&messageSize, &billableRequestSize, monthlyMessages)
		}

		apiRequestQuantities := usage.CalculateTierBuckets(*monthlyMessages, websocketAPITiers)

		costComponents = append(costComponents, r.websocketCostComponent("messages", "ApiGatewayMessage", "Messages (first 1B)", "0", &apiRequestQuantities[0]))

		if apiRequestQuantities[1].GreaterThan(decimal.NewFromInt(0)) {
			costComponents = append(costComponents, r.websocketCostComponent("messages", "ApiGatewayMessage", "Messages (over 1B)", "1000000000", &apiRequestQuantities[1]))
		}
	} else {
		costComponents = append(costComponents, r.websocketCostComponent("messages", "ApiGatewayMessage", "Messages (first 1B)", "0", nil))
	}

	if r.MonthlyConnectionMins != nil {
		monthlyConnectionMinutes = decimalPtr(decimal.NewFromInt(*r.MonthlyConnectionMins))
	}
	costComponents = append(costComponents, r.websocketCostComponent("minutes", "ApiGatewayMinute", "Connection duration", "0", monthlyConnectionMinutes))

	return costComponents
}

func calculateBillableRequests(requestSize *decimal.Decimal, billableRequestSize *decimal.Decimal, requests *decimal.Decimal) *decimal.Decimal {
	return decimalPtr(requests.Mul(requestSize.Div(*billableRequestSize).Ceil()))
}

func (r *APIGatewayV2API) httpCostComponent(displayName string, usageTier string, monthlyQuantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            displayName,
		Unit:            "1M requests",
		UnitMultiplier:  decimal.NewFromInt(1000000),
		MonthlyQuantity: monthlyQuantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonApiGateway"),
			ProductFamily: strPtr("API Calls"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/ApiGatewayHttpRequest/")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(usageTier),
		},
		UsageBased: true,
	}
}

func (r *APIGatewayV2API) websocketCostComponent(unit string, usageType string, displayName string, usageTier string, monthlyQuantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            displayName,
		Unit:            "1M " + unit,
		UnitMultiplier:  decimal.NewFromInt(1000000),
		MonthlyQuantity: monthlyQuantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonApiGateway"),
			ProductFamily: strPtr("WebSocket"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", usageType))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(usageTier),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/app_autoscaling_target.go
# RESOURCE: aws_app_autoscaling_target
# SIZE: 910 bytes | LINES: 32
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type AppAutoscalingTarget struct {
	Address string
	Region  string

	ResourceID        string
	ScalableDimension string

	MinCapacity int64
	MaxCapacity int64

	// "usage" args
	Capacity *int64 `infracost_usage:"capacity"`
}

func (r *AppAutoscalingTarget) CoreType() string {
	return "AppAutoscalingTarget"
}

func (r *AppAutoscalingTarget) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "capacity", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *AppAutoscalingTarget) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *AppAutoscalingTarget) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/autoscaling_group.go
# RESOURCE: aws_autoscaling_group
# SIZE: 3956 bytes | LINES: 107
################################################################################
package aws

import (
	"context"
	"math"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage/aws"
)

type AutoscalingGroup struct {
	// "required" args that can't really be missing.
	Address string
	Region  string
	Name    string

	// "optional" args, that may be empty depending on the resource config
	LaunchConfiguration *LaunchConfiguration
	LaunchTemplate      *LaunchTemplate
}

var AutoscalingGroupUsageSchema = append([]*schema.UsageItem{
	{Key: "instances", DefaultValue: 0, ValueType: schema.Int64},
}, InstanceUsageSchema...)

func (a *AutoscalingGroup) CoreType() string {
	return "AutoscalingGroup"
}

func (a *AutoscalingGroup) UsageSchema() []*schema.UsageItem {
	return a.getUsageSchemaWithDefaultInstanceCount()
}

func (a *AutoscalingGroup) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(a, u)

	// The usage keys for Launch Template and Configuration are specified on the Autoscaling Group resource
	if a.LaunchTemplate != nil {
		resources.PopulateArgsWithUsage(a.LaunchTemplate, u)
	}

	if a.LaunchConfiguration != nil {
		resources.PopulateArgsWithUsage(a.LaunchConfiguration, u)
	}
}

// getUsageSchemaWithDefaultInstanceCount is a temporary hack to make --sync-usage-file use the group's "desired_size"
// as the default value for the "instances" usage param.  Without this, --sync-usage-file sets instances=0 causing the
// costs for the node group to be $0.  This can be removed when --sync-usage-file creates the usage file with usgage keys
// commented out by default.
func (a *AutoscalingGroup) getUsageSchemaWithDefaultInstanceCount() []*schema.UsageItem {
	var instanceCount *int64
	if a.LaunchConfiguration != nil {
		instanceCount = a.LaunchConfiguration.InstanceCount
	} else if a.LaunchTemplate != nil {
		instanceCount = a.LaunchTemplate.InstanceCount
	}

	if instanceCount == nil || *instanceCount == 0 {
		return AutoscalingGroupUsageSchema
	}

	usageSchema := make([]*schema.UsageItem, 0, len(AutoscalingGroupUsageSchema))
	for _, u := range AutoscalingGroupUsageSchema {
		if u.Key == "instances" {
			usageSchema = append(usageSchema, &schema.UsageItem{Key: "instances", DefaultValue: intVal(instanceCount), ValueType: schema.Int64})
		} else {
			usageSchema = append(usageSchema, u)
		}
	}
	return usageSchema
}

func (a *AutoscalingGroup) BuildResource() *schema.Resource {
	costComponents := make([]*schema.CostComponent, 0)
	subResources := make([]*schema.Resource, 0)
	var estimateInstanceQualities schema.EstimateFunc

	if a.LaunchConfiguration != nil {
		lc := a.LaunchConfiguration.BuildResource()
		// If the Launch Configuration returns nil it is not supported so the Autoscaling Group should also return nil
		if lc == nil {
			return nil
		}
		subResources = append(subResources, lc)
		estimateInstanceQualities = lc.EstimateUsage
	} else if a.LaunchTemplate != nil {
		lt := a.LaunchTemplate.BuildResource()
		// If the Launch Template returns nil it is not supported so the Autoscaling Group should also return nil
		if lt == nil {
			return nil
		}
		subResources = append(subResources, lt)
		estimateInstanceQualities = lt.EstimateUsage
	}

	estimate := func(ctx context.Context, u map[string]interface{}) error {
		if estimateInstanceQualities != nil {
			err := estimateInstanceQualities(ctx, u)
			if err != nil {
				return err
			}
		}
		if a.Name != "" {
			count, err := aws.AutoscalingGetInstanceCount(ctx, a.Region, a.Name)
			if err != nil {
				return err
			}
			if count > 0 {
				u["instances"] = int64(math.Round(count))
			}
		}
		return nil
	}

	return &schema.Resource{
		Name:           a.Address,
		UsageSchema:    a.UsageSchema(),
		CostComponents: costComponents,
		SubResources:   subResources,
		EstimateUsage:  estimate,
	}
}

################################################################################
# FILE: internal/resources/aws/backup_vault.go
# RESOURCE: aws_backup_vault
# SIZE: 9197 bytes | LINES: 164
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type BackupVault struct {
	Address                       string
	Region                        string
	MonthlyEFSWarmBackupGB        *float64 `infracost_usage:"monthly_efs_warm_backup_gb"`
	MonthlyEFSColdRestoreGB       *float64 `infracost_usage:"monthly_efs_cold_restore_gb"`
	MonthlyRDSSnapshotGB          *float64 `infracost_usage:"monthly_rds_snapshot_gb"`
	MonthlyAuroraSnapshotGB       *float64 `infracost_usage:"monthly_aurora_snapshot_gb"`
	MonthlyDynamodbBackupGB       *float64 `infracost_usage:"monthly_dynamodb_backup_gb"`
	MonthlyDynamodbRestoreGB      *float64 `infracost_usage:"monthly_dynamodb_restore_gb"`
	MonthlyFSxWindowsBackupGB     *float64 `infracost_usage:"monthly_fsx_windows_backup_gb"`
	MonthlyFSxLustreBackupGB      *float64 `infracost_usage:"monthly_fsx_lustre_backup_gb"`
	MonthlyEFSColdBackupGB        *float64 `infracost_usage:"monthly_efs_cold_backup_gb"`
	MonthlyEFSWarmRestoreGB       *float64 `infracost_usage:"monthly_efs_warm_restore_gb"`
	MonthlyEFSItemRestoreRequests *int64   `infracost_usage:"monthly_efs_item_restore_requests"`
	MonthlyEBSSnapshotGB          *float64 `infracost_usage:"monthly_ebs_snapshot_gb"`
}

func (r *BackupVault) CoreType() string {
	return "BackupVault"
}

func (r *BackupVault) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_efs_warm_backup_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_efs_cold_restore_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_rds_snapshot_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_aurora_snapshot_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_dynamodb_backup_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_dynamodb_restore_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_fsx_windows_backup_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_fsx_lustre_backup_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_efs_cold_backup_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_efs_warm_restore_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_efs_item_restore_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_ebs_snapshot_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *BackupVault) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *BackupVault) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	bd := backupData{ref: "monthly_efs_warm_backup_gb", name: "EFS backup (warm)", unit: "GB", usageType: "WarmStorage-ByteHrs-EFS$", service: "AWSBackup", family: "AWS Backup Storage"}
	if r.MonthlyEFSWarmBackupGB != nil {
		bd.qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyEFSWarmBackupGB))
	}
	costComponents = append(costComponents, r.backupVaultCostComponent(bd))

	bd = backupData{ref: "monthly_efs_cold_backup_gb", name: "EFS backup (cold)", unit: "GB", usageType: "ColdStorage-ByteHrs-EFS$", service: "AWSBackup", family: "AWS Backup Storage"}
	if r.MonthlyEFSColdBackupGB != nil {
		bd.qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyEFSColdBackupGB))
	}
	costComponents = append(costComponents, r.backupVaultCostComponent(bd))

	bd = backupData{ref: "monthly_efs_warm_restore_gb", name: "EFS restore (warm)", unit: "GB", usageType: "PartialRestore-Warm-EFS", service: "AWSBackup", family: "AWS Backup Storage"}
	if r.MonthlyEFSWarmRestoreGB != nil {
		bd.qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyEFSWarmRestoreGB))
	}
	costComponents = append(costComponents, r.backupVaultCostComponent(bd))

	bd = backupData{ref: "monthly_efs_cold_restore_gb", name: "EFS restore (cold)", unit: "GB", usageType: "PartialRestore-Cold-EFS", service: "AWSBackup", family: "AWS Backup Storage"}
	if r.MonthlyEFSColdRestoreGB != nil {
		bd.qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyEFSColdRestoreGB))
	}
	costComponents = append(costComponents, r.backupVaultCostComponent(bd))

	bd = backupData{ref: "monthly_efs_item_restore_requests", name: "EFS restore (item-level)", unit: "requests", usageType: "PartialRestore-Jobs-EFS", service: "AWSBackup", family: "AWS Backup Storage"}
	if r.MonthlyEFSItemRestoreRequests != nil {
		bd.qty = decimalPtr(decimal.NewFromInt(*r.MonthlyEFSItemRestoreRequests))
	}
	costComponents = append(costComponents, r.backupVaultCostComponent(bd))

	bd = backupData{ref: "monthly_ebs_snapshot_gb", name: "EBS snapshot", unit: "GB", usageType: "EBS:SnapshotUsage$", service: "AmazonEC2", family: "Storage Snapshot"}
	if r.MonthlyEBSSnapshotGB != nil {
		bd.qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyEBSSnapshotGB))
	}
	costComponents = append(costComponents, r.backupVaultCostComponent(bd))

	bd = backupData{ref: "monthly_rds_snapshot_gb", name: "RDS snapshot", unit: "GB", usageType: "RDS:ChargedBackupUsage", service: "AmazonRDS", family: "Storage Snapshot"}
	if r.MonthlyRDSSnapshotGB != nil {
		bd.qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyRDSSnapshotGB))
	}
	costComponents = append(costComponents, r.backupVaultCostComponent(bd))

	bd = backupData{ref: "monthly_dynamodb_backup_gb", name: "DynamoDB backup", unit: "GB", usageType: "TimedBackupStorage-ByteHrs", service: "AmazonDynamoDB", family: "Amazon DynamoDB On-Demand Backup Storage"}
	if r.MonthlyDynamodbBackupGB != nil {
		bd.qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyDynamodbBackupGB))
	}
	costComponents = append(costComponents, r.backupVaultCostComponent(bd))

	bd = backupData{ref: "monthly_dynamodb_restore_gb", name: "DynamoDB restore", unit: "GB", usageType: "RestoreDataSize-Bytes", service: "AmazonDynamoDB", family: "Amazon DynamoDB Restore Data Size"}
	if r.MonthlyDynamodbRestoreGB != nil {
		bd.qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyDynamodbRestoreGB))
	}
	costComponents = append(costComponents, r.backupVaultCostComponent(bd))

	bd = backupData{ref: "monthly_aurora_snapshot_gb", name: "Aurora snapshot", unit: "GB", usageType: "Aurora:BackupUsage", service: "AmazonRDS", family: "Storage Snapshot", key: "databaseEngine", value: "Aurora PostgreSQL"}
	if r.MonthlyAuroraSnapshotGB != nil {
		bd.qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyAuroraSnapshotGB))
	}
	costComponents = append(costComponents, r.additionalBackupVaultCostComponent(bd))

	bd = backupData{ref: "monthly_fsx_windows_backup_gb", name: "FSx for Windows backup", unit: "GB", usageType: "BackupUsage", service: "AmazonFSx", family: "Storage", key: "fileSystemType", value: "Lustre"}
	if r.MonthlyFSxWindowsBackupGB != nil {
		bd.qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyFSxWindowsBackupGB))
	}
	costComponents = append(costComponents, r.additionalBackupVaultCostComponent(bd))

	bd = backupData{ref: "monthly_fsx_lustre_backup_gb", name: "FSx for Lustre backup", unit: "GB", usageType: "BackupUsage", service: "AmazonFSx", family: "Storage", key: "fileSystemType", value: "Lustre"}
	if r.MonthlyFSxLustreBackupGB != nil {
		bd.qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyFSxLustreBackupGB))
	}
	costComponents = append(costComponents, r.additionalBackupVaultCostComponent(bd))

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents, UsageSchema: r.UsageSchema(),
	}
}

type backupData struct {
	ref       string
	name      string
	unit      string
	usageType string
	service   string
	family    string
	key       string
	value     string
	qty       *decimal.Decimal
}

func (r *BackupVault) backupVaultCostComponent(bd backupData) *schema.CostComponent {
	filters := []*schema.AttributeFilter{
		{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", bd.usageType))},
	}

	if bd.name == "RDS snapshot" {
		filters = append(filters, &schema.AttributeFilter{Key: "operation", Value: strPtr("")})
	}

	return &schema.CostComponent{
		Name:            bd.name,
		Unit:            bd.unit,
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: bd.qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:       strPtr("aws"),
			Region:           strPtr(r.Region),
			Service:          strPtr(bd.service),
			ProductFamily:    strPtr(bd.family),
			AttributeFilters: filters,
		},
		UsageBased: true,
	}
}

func (r *BackupVault) additionalBackupVaultCostComponent(bd backupData) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            bd.name,
		Unit:            bd.unit,
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: bd.qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr(bd.service),
			ProductFamily: strPtr(bd.family),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", bd.usageType))},
				{Key: bd.key, Value: strPtr(bd.value)},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/cloudformation_stack.go
# RESOURCE: aws_cloudformation_stack
# SIZE: 3269 bytes | LINES: 84
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type CloudFormationStack struct {
	Address                  string
	Region                   string
	TemplateBody             string
	MonthlyHandlerOperations *int64 `infracost_usage:"monthly_handler_operations"`
	MonthlyDurationSecs      *int64 `infracost_usage:"monthly_duration_secs"`
}

func (r *CloudFormationStack) CoreType() string {
	return "CloudFormationStack"
}

func (r *CloudFormationStack) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_handler_operations", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_duration_secs", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *CloudFormationStack) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *CloudFormationStack) BuildResource() *schema.Resource {
	if r.checkAWS() || r.checkAlexa() || r.checkCustom() {
		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: r.costComponents(),
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *CloudFormationStack) costComponents() []*schema.CostComponent {
	var monthlyHandlerOperations, monthlyDurationSecs *decimal.Decimal

	if r.MonthlyHandlerOperations != nil {
		monthlyHandlerOperations = decimalPtr(decimal.NewFromInt(*r.MonthlyHandlerOperations))
	}
	if r.MonthlyDurationSecs != nil {
		monthlyDurationSecs = decimalPtr(decimal.NewFromInt(*r.MonthlyDurationSecs))
	}

	costComponents := make([]*schema.CostComponent, 0)

	costComponents = append(costComponents, r.cloudFormationCostComponent("Handler operations", "operations", "Resource-Invocation-Count", monthlyHandlerOperations))
	costComponents = append(costComponents, r.cloudFormationCostComponent("Durations above 30s", "seconds", "Resource-Processing-Time", monthlyDurationSecs))

	return costComponents
}

func (r *CloudFormationStack) cloudFormationCostComponent(name, unit, usagetype string, monthlyQuantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{

		Name:            name,
		Unit:            unit,
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: monthlyQuantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(r.Region),
			Service:    strPtr("AWSCloudFormation"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s$/i", usagetype))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *CloudFormationStack) checkAWS() bool {
	return strings.Contains(strings.ToLower(r.TemplateBody), "aws::")
}

func (r *CloudFormationStack) checkAlexa() bool {
	return strings.Contains(strings.ToLower(r.TemplateBody), "alexa::")
}

func (r *CloudFormationStack) checkCustom() bool {
	return strings.Contains(strings.ToLower(r.TemplateBody), "custom::")
}

################################################################################
# FILE: internal/resources/aws/cloudformation_stack_set.go
# RESOURCE: aws_cloudformation_stack_set
# SIZE: 1574 bytes | LINES: 45
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type CloudFormationStackSet struct {
	Address                  string
	Region                   string
	TemplateBody             string
	MonthlyHandlerOperations *int64 `infracost_usage:"monthly_handler_operations"`
	MonthlyDurationSecs      *int64 `infracost_usage:"monthly_duration_secs"`
}

func (r *CloudFormationStackSet) CoreType() string {
	return "CloudFormationStackSet"
}

func (r *CloudFormationStackSet) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_handler_operations", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_duration_secs", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *CloudFormationStackSet) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *CloudFormationStackSet) BuildResource() *schema.Resource {
	stack := &CloudFormationStack{
		Region:                   r.Region,
		TemplateBody:             r.TemplateBody,
		MonthlyHandlerOperations: r.MonthlyHandlerOperations,
		MonthlyDurationSecs:      r.MonthlyDurationSecs,
	}

	if stack.checkAWS() || stack.checkAlexa() || stack.checkCustom() {
		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: stack.costComponents(),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/cloudfront_distribution.go
# RESOURCE: aws_cloudfront_distribution
# SIZE: 25794 bytes | LINES: 597
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strconv"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/usage"
)

type CloudfrontDistribution struct {
	Address string
	Region  string

	IsOriginShieldEnabled     bool
	IsSSLSupportMethodVIP     bool
	HasLoggingConfigBucket    bool
	HasFieldLevelEncryptionID bool
	OriginShieldRegion        string

	// "usage" args
	MonthlyHTTPRequests             *cloudfrontDistributionRegionRequestsUsage     `infracost_usage:"monthly_http_requests"`
	MonthlyHTTPSRequests            *cloudfrontDistributionRegionRequestsUsage     `infracost_usage:"monthly_https_requests"`
	MonthlyShieldRequests           *cloudfrontDistributionShieldRequestsUsage     `infracost_usage:"monthly_shield_requests"`
	MonthlyInvalidationRequests     *int64                                         `infracost_usage:"monthly_invalidation_requests"`
	MonthlyEncryptionRequests       *int64                                         `infracost_usage:"monthly_encryption_requests"`
	MonthlyLogLines                 *int64                                         `infracost_usage:"monthly_log_lines"`
	MonthlyDataTransferToInternetGB *cloudfrontDistributionRegionDataTransferUsage `infracost_usage:"monthly_data_transfer_to_internet_gb"`
	MonthlyDataTransferToOriginGB   *cloudfrontDistributionRegionDataTransferUsage `infracost_usage:"monthly_data_transfer_to_origin_gb"`
	CustomSslCertificates           *int64                                         `infracost_usage:"custom_ssl_certificates"`
}

type cloudfrontDistributionRegionDataTransferUsage struct {
	US           *float64 `infracost_usage:"us"`
	Europe       *float64 `infracost_usage:"europe"`
	SouthAfrica  *float64 `infracost_usage:"south_africa"`
	SouthAmerica *float64 `infracost_usage:"south_america"`
	Japan        *float64 `infracost_usage:"japan"`
	Australia    *float64 `infracost_usage:"australia"`
	AsiaPacific  *float64 `infracost_usage:"asia_pacific"`
	India        *float64 `infracost_usage:"india"`
}

type cloudfrontDistributionRegionRequestsUsage struct {
	US           *int64 `infracost_usage:"us"`
	Europe       *int64 `infracost_usage:"europe"`
	SouthAfrica  *int64 `infracost_usage:"south_africa"`
	SouthAmerica *int64 `infracost_usage:"south_america"`
	Japan        *int64 `infracost_usage:"japan"`
	Australia    *int64 `infracost_usage:"australia"`
	AsiaPacific  *int64 `infracost_usage:"asia_pacific"`
	India        *int64 `infracost_usage:"india"`
}

type cloudfrontDistributionShieldRequestsUsage struct {
	US           *int64 `infracost_usage:"us"`
	Europe       *int64 `infracost_usage:"europe"`
	SouthAmerica *int64 `infracost_usage:"south_america"`
	Japan        *int64 `infracost_usage:"japan"`
	Australia    *int64 `infracost_usage:"australia"`
	Singapore    *int64 `infracost_usage:"singapore"`
	SouthKorea   *int64 `infracost_usage:"south_korea"`
	Indonesia    *int64 `infracost_usage:"indonesia"`
	India        *int64 `infracost_usage:"india"`
	MiddleEast   *int64 `infracost_usage:"middle_east"`
}

func (r *CloudfrontDistribution) CoreType() string {
	return "CloudfrontDistribution"
}

func (r *CloudfrontDistribution) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{
			Key:          "monthly_http_requests",
			DefaultValue: &usage.ResourceUsage{Name: "monthly_http_requests", Items: cloudfrontDistributionRegionRequestsSchema},
			ValueType:    schema.SubResourceUsage,
		},
		{
			Key:          "monthly_https_requests",
			DefaultValue: &usage.ResourceUsage{Name: "monthly_https_requests", Items: cloudfrontDistributionRegionRequestsSchema},
			ValueType:    schema.SubResourceUsage,
		},
		{
			Key:          "monthly_shield_requests",
			DefaultValue: &usage.ResourceUsage{Name: "monthly_shield_requests", Items: cloudfrontDistributionShieldRequestsSchema},
			ValueType:    schema.SubResourceUsage,
		},
		{Key: "monthly_invalidation_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_encryption_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_log_lines", ValueType: schema.Int64, DefaultValue: 0},
		{
			Key:          "monthly_data_transfer_to_internet_gb",
			DefaultValue: &usage.ResourceUsage{Name: "monthly_data_transfer_to_internet_gb", Items: cloudfrontDistributionRegionDataTransferSchema},
			ValueType:    schema.SubResourceUsage,
		},
		{
			Key:          "monthly_data_transfer_to_origin_gb",
			DefaultValue: &usage.ResourceUsage{Name: "monthly_data_transfer_to_origin_gb", Items: cloudfrontDistributionRegionDataTransferSchema},
			ValueType:    schema.SubResourceUsage,
		},
		{Key: "custom_ssl_certificates", ValueType: schema.Int64, DefaultValue: 0},
	}
}

var cloudfrontDistributionRegionRequestsSchema = []*schema.UsageItem{
	{Key: "us", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "europe", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "south_africa", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "south_america", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "japan", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "australia", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "asia_pacific", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "india", DefaultValue: 0, ValueType: schema.Float64},
}

var cloudfrontDistributionRegionDataTransferSchema = []*schema.UsageItem{
	{Key: "us", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "europe", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "south_africa", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "south_america", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "japan", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "australia", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "asia_pacific", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "india", DefaultValue: 0, ValueType: schema.Int64},
}

var cloudfrontDistributionShieldRequestsSchema = []*schema.UsageItem{
	{Key: "us", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "europe", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "south_america", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "japan", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "australia", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "singapore", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "south_korea", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "india", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "middle_east", DefaultValue: 0, ValueType: schema.Int64},
}

func (r *CloudfrontDistribution) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *CloudfrontDistribution) BuildResource() *schema.Resource {
	var components []*schema.CostComponent

	if r.MonthlyHTTPRequests == nil {
		r.MonthlyHTTPRequests = &cloudfrontDistributionRegionRequestsUsage{}
	}
	if r.MonthlyHTTPSRequests == nil {
		r.MonthlyHTTPSRequests = &cloudfrontDistributionRegionRequestsUsage{}
	}
	if r.MonthlyShieldRequests == nil {
		r.MonthlyShieldRequests = &cloudfrontDistributionShieldRequestsUsage{}
	}
	if r.MonthlyDataTransferToInternetGB == nil {
		r.MonthlyDataTransferToInternetGB = &cloudfrontDistributionRegionDataTransferUsage{}
	}
	if r.MonthlyDataTransferToOriginGB == nil {
		r.MonthlyDataTransferToOriginGB = &cloudfrontDistributionRegionDataTransferUsage{}
	}

	components = append(components, r.encryptionRequestsCostComponents()...)
	components = append(components, r.realtimeLogsCostComponents()...)
	components = append(components, r.customSSLCertificateCostComponents()...)
	components = append(components, r.shieldRequestsCostComponents()...)
	components = append(components, r.invalidationRequestsCostComponents()...)

	subResources := r.buildSubresources()

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: components,
		SubResources:   subResources,
	}
}

type cloudfrontDistributionRegionData struct {
	awsGroupedName                  string
	priceRegion                     string
	monthlyHTTPRequests             *int64
	monthlyHTTPSRequests            *int64
	monthlyDataTransferToInternetGB *float64
	monthlyDataTransferToOriginGB   *float64
}

func (c *cloudfrontDistributionRegionData) HasUsage() bool {
	return c.monthlyHTTPRequests != nil || c.monthlyHTTPSRequests != nil ||
		c.monthlyDataTransferToInternetGB != nil || c.monthlyDataTransferToOriginGB != nil
}

func (r *CloudfrontDistribution) buildSubresources() []*schema.Resource {
	regionsData := []*cloudfrontDistributionRegionData{
		{
			awsGroupedName:                  "US, Mexico, Canada",
			priceRegion:                     "United States",
			monthlyHTTPRequests:             r.MonthlyHTTPRequests.US,
			monthlyHTTPSRequests:            r.MonthlyHTTPSRequests.US,
			monthlyDataTransferToInternetGB: r.MonthlyDataTransferToInternetGB.US,
			monthlyDataTransferToOriginGB:   r.MonthlyDataTransferToOriginGB.US,
		},
		{
			awsGroupedName:                  "Europe, Israel",
			priceRegion:                     "Europe",
			monthlyHTTPRequests:             r.MonthlyHTTPRequests.Europe,
			monthlyHTTPSRequests:            r.MonthlyHTTPSRequests.Europe,
			monthlyDataTransferToInternetGB: r.MonthlyDataTransferToInternetGB.Europe,
			monthlyDataTransferToOriginGB:   r.MonthlyDataTransferToOriginGB.Europe,
		},
		{
			awsGroupedName:                  "South Africa, Kenya, Middle East",
			priceRegion:                     "South Africa",
			monthlyHTTPRequests:             r.MonthlyHTTPRequests.SouthAfrica,
			monthlyHTTPSRequests:            r.MonthlyHTTPSRequests.SouthAfrica,
			monthlyDataTransferToInternetGB: r.MonthlyDataTransferToInternetGB.SouthAfrica,
			monthlyDataTransferToOriginGB:   r.MonthlyDataTransferToOriginGB.SouthAfrica,
		},
		{
			awsGroupedName:                  "South America",
			priceRegion:                     "South America",
			monthlyHTTPRequests:             r.MonthlyHTTPRequests.SouthAmerica,
			monthlyHTTPSRequests:            r.MonthlyHTTPSRequests.SouthAmerica,
			monthlyDataTransferToInternetGB: r.MonthlyDataTransferToInternetGB.SouthAmerica,
			monthlyDataTransferToOriginGB:   r.MonthlyDataTransferToOriginGB.SouthAmerica,
		},
		{
			awsGroupedName:                  "Japan",
			priceRegion:                     "Japan",
			monthlyHTTPRequests:             r.MonthlyHTTPRequests.Japan,
			monthlyHTTPSRequests:            r.MonthlyHTTPSRequests.Japan,
			monthlyDataTransferToInternetGB: r.MonthlyDataTransferToInternetGB.Japan,
			monthlyDataTransferToOriginGB:   r.MonthlyDataTransferToOriginGB.Japan,
		},
		{
			awsGroupedName:                  "Australia, New Zealand",
			priceRegion:                     "Australia",
			monthlyHTTPRequests:             r.MonthlyHTTPRequests.Australia,
			monthlyHTTPSRequests:            r.MonthlyHTTPSRequests.Australia,
			monthlyDataTransferToInternetGB: r.MonthlyDataTransferToInternetGB.Australia,
			monthlyDataTransferToOriginGB:   r.MonthlyDataTransferToOriginGB.Australia,
		},
		{
			awsGroupedName:                  "Hong Kong, Philippines, Asia Pacific",
			priceRegion:                     "Asia Pacific",
			monthlyHTTPRequests:             r.MonthlyHTTPRequests.AsiaPacific,
			monthlyHTTPSRequests:            r.MonthlyHTTPSRequests.AsiaPacific,
			monthlyDataTransferToInternetGB: r.MonthlyDataTransferToInternetGB.AsiaPacific,
			monthlyDataTransferToOriginGB:   r.MonthlyDataTransferToOriginGB.AsiaPacific,
		},
		{
			awsGroupedName:                  "India",
			priceRegion:                     "India",
			monthlyHTTPRequests:             r.MonthlyHTTPRequests.India,
			monthlyHTTPSRequests:            r.MonthlyHTTPSRequests.India,
			monthlyDataTransferToInternetGB: r.MonthlyDataTransferToInternetGB.India,
			monthlyDataTransferToOriginGB:   r.MonthlyDataTransferToOriginGB.India,
		},
	}

	subresources := []*schema.Resource{}

	for _, data := range regionsData {
		if !data.HasUsage() {
			continue
		}

		subresources = append(subresources, r.buildRegionSubresource(data))
	}

	if len(subresources) == 0 {
		subresources = append(subresources, r.buildRegionSubresource(regionsData[0]))
	}

	return subresources
}

func (r *CloudfrontDistribution) buildRegionSubresource(regionData *cloudfrontDistributionRegionData) *schema.Resource {
	resource := &schema.Resource{
		Name: regionData.awsGroupedName,
	}

	components := []*schema.CostComponent{}
	components = append(components, r.dataOutToInternetCostComponents(regionData)...)
	components = append(components, r.dataOutToOriginCostComponents(regionData)...)
	components = append(components, r.httpRequestsCostComponents(regionData)...)
	components = append(components, r.httpsRequestsCostComponents(regionData)...)

	resource.CostComponents = components

	return resource
}

func (r *CloudfrontDistribution) dataOutToInternetCostComponents(regionData *cloudfrontDistributionRegionData) []*schema.CostComponent {
	tierStarts := []int{0, 10240, 51200, 153600, 512000, 1048576, 5242880}
	tierLimits := []int{10240, 40960, 102400, 358400, 536576, 4194304}
	tierNames := []string{"first 10TB", "next 40TB", "next 100TB", "next 350TB", "next 524TB", "next 4PB", "over 5PB"}

	fromLocation := regionData.priceRegion

	var quantity *decimal.Decimal
	if regionData.monthlyDataTransferToInternetGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*regionData.monthlyDataTransferToInternetGB))
	}

	if quantity == nil {
		return []*schema.CostComponent{
			r.buildDataOutCostComponent(tierNames[0], fromLocation, 0, nil),
		}
	}

	tiers := usage.CalculateTierBuckets(*quantity, tierLimits)
	var components []*schema.CostComponent
	for i := range tiers {
		if tiers[i].GreaterThan(decimal.Zero) {
			components = append(
				components,
				r.buildDataOutCostComponent(tierNames[i], fromLocation, tierStarts[i], &tiers[i]),
			)
		}
	}

	return components
}

func (r *CloudfrontDistribution) buildDataOutCostComponent(usageName, fromLocation string, startUsage int, quantity *decimal.Decimal) *schema.CostComponent {
	costName := "Data transfer out to internet"

	return &schema.CostComponent{
		Name:            fmt.Sprintf("%s (%s)", costName, usageName),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Service:    strPtr("AmazonCloudFront"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "transferType", Value: strPtr("CloudFront Outbound")},
				{Key: "fromLocation", Value: strPtr(fromLocation)},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(strconv.Itoa(startUsage)),
		},
		UsageBased: true,
	}
}

func (r *CloudfrontDistribution) dataOutToOriginCostComponents(regionData *cloudfrontDistributionRegionData) []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	apiRegion := regionData.priceRegion

	var quantity *decimal.Decimal

	if regionData.monthlyDataTransferToOriginGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*regionData.monthlyDataTransferToOriginGB))
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Data transfer out to origin",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Service:    strPtr("AmazonCloudFront"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "transferType", Value: strPtr("CloudFront to Origin")},
				{Key: "fromLocation", Value: strPtr(apiRegion)},
			},
		},
		UsageBased: true,
	})

	return costComponents
}

func (r *CloudfrontDistribution) httpRequestsCostComponents(regionData *cloudfrontDistributionRegionData) []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	apiRegion := regionData.priceRegion

	var quantity *decimal.Decimal
	if regionData.monthlyHTTPRequests != nil {
		quantity = decimalPtr(decimal.NewFromInt(*regionData.monthlyHTTPRequests))
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "HTTP requests",
		Unit:            "10k requests",
		UnitMultiplier:  decimal.NewFromInt(10000),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Service:    strPtr("AmazonCloudFront"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "location", Value: strPtr(apiRegion)},
				{Key: "requestType", Value: strPtr("CloudFront-Request-HTTP-Proxy")},
			},
		},
		UsageBased: true,
	})

	return costComponents
}

func (r *CloudfrontDistribution) httpsRequestsCostComponents(regionData *cloudfrontDistributionRegionData) []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	apiRegion := regionData.priceRegion

	var quantity *decimal.Decimal
	if regionData.monthlyHTTPSRequests != nil {
		quantity = decimalPtr(decimal.NewFromInt(*regionData.monthlyHTTPSRequests))
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "HTTPS requests",
		Unit:            "10k requests",
		UnitMultiplier:  decimal.NewFromInt(10000),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Service:    strPtr("AmazonCloudFront"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "location", Value: strPtr(apiRegion)},
				{Key: "requestType", Value: strPtr("CloudFront-Request-HTTPS-Proxy")},
			},
		},
		UsageBased: true,
	})

	return costComponents
}

// See https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html#choose-origin-shield-region for the list of regions that are supported for Origin Shield.
var regionShieldMapping = map[string]string{
	"us-gov-west-1":   "us",
	"us-gov-east-1":   "us",
	"us-east-1":       "us",
	"us-east-2":       "us",
	"us-west-1":       "us",
	"us-west-2":       "us",
	"us-west-2-lax-1": "us",
	"ca-central-1":    "us",
	"ap-south-1":      "india",
	"me-south-1":      "india",
	"ap-northeast-1":  "japan",
	"ap-northeast-2":  "south_korea",
	"ap-southeast-1":  "singapore",
	"ap-east-1":       "singapore",
	"ap-southeast-2":  "australia",
	"ap-southeast-6":  "australia",
	"eu-central-1":    "europe",
	"eu-west-1":       "europe",
	"eu-west-2":       "europe",
	"eu-south-1":      "europe",
	"eu-west-3":       "europe",
	"eu-north-1":      "europe",
	"af-south-1":      "europe",
	"sa-east-1":       "south_america",
	"me-central-1":    "middle_east",
}

func (r *CloudfrontDistribution) shieldRequestsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if !r.IsOriginShieldEnabled {
		return costComponents
	}

	region := r.Region
	if r.OriginShieldRegion != "" {
		region = r.OriginShieldRegion
	}

	var apiRegion string
	if v, ok := RegionMapping[region]; ok {
		apiRegion = v
	}

	if apiRegion == "" {
		logging.Logger.Warn().Msgf("Skipping Origin shield HTTP requests for resource %s. Could not find mapping for region %s", r.Address, region)
		return costComponents
	}

	var usageKey string
	if v, ok := regionShieldMapping[region]; ok {
		usageKey = v
	}

	if usageKey == "" {
		logging.Logger.Warn().Msgf("No usage for Origin shield HTTP requests for resource %s.  Region %s not supported in usage file.", r.Address, region)
	}

	regionData := map[string]*int64{
		"us":            r.MonthlyShieldRequests.US,
		"europe":        r.MonthlyShieldRequests.Europe,
		"south_america": r.MonthlyShieldRequests.SouthAmerica,
		"japan":         r.MonthlyShieldRequests.Japan,
		"australia":     r.MonthlyShieldRequests.Australia,
		"singapore":     r.MonthlyShieldRequests.Singapore,
		"south_korea":   r.MonthlyShieldRequests.SouthKorea,
		"indonesia":     r.MonthlyShieldRequests.Indonesia,
		"india":         r.MonthlyShieldRequests.India,
		"middle_east":   r.MonthlyShieldRequests.MiddleEast,
	}

	var quantity *decimal.Decimal
	if _, ok := regionData[usageKey]; ok && regionData[usageKey] != nil {
		quantity = decimalPtr(decimal.NewFromInt(*regionData[usageKey]))
	}

	pieces := strings.Split(apiRegion, "(")
	prettyName := strings.TrimSpace(pieces[0]) + " " + region

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            fmt.Sprintf("Origin shield HTTP requests (%s)", prettyName),
		Unit:            "10k requests",
		UnitMultiplier:  decimal.NewFromInt(10000),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Service:    strPtr("AmazonCloudFront"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "requestDescription", Value: strPtr("Origin Shield Requests")},
				{Key: "location", Value: strPtr(apiRegion)},
			},
		},
		UsageBased: true,
	})

	return costComponents
}

func (r *CloudfrontDistribution) invalidationRequestsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	var freeQuantity *decimal.Decimal
	var paidQuantity *decimal.Decimal
	if r.MonthlyInvalidationRequests != nil {
		usageAmount := *r.MonthlyInvalidationRequests
		if usageAmount < 1000 {
			freeQuantity = decimalPtr(decimal.NewFromInt(usageAmount))
		} else {
			freeQuantity = decimalPtr(decimal.NewFromInt(1000))
			paidQuantity = decimalPtr(decimal.NewFromInt(usageAmount - 1000))
		}
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Invalidation requests (first 1k)",
		Unit:            "paths",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: freeQuantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Service:    strPtr("AmazonCloudFront"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", Value: strPtr("Invalidations")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	})

	if paidQuantity != nil {
		costComponents = append(costComponents, &schema.CostComponent{
			Name:            "Invalidation requests (over 1k)",
			Unit:            "paths",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: paidQuantity,
			ProductFilter: &schema.ProductFilter{
				VendorName: strPtr("aws"),
				Service:    strPtr("AmazonCloudFront"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", Value: strPtr("Invalidations")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				StartUsageAmount: strPtr("1000"),
			},
			UsageBased: true,
		})
	}

	return costComponents
}

func (r *CloudfrontDistribution) encryptionRequestsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if !r.HasFieldLevelEncryptionID {
		return costComponents
	}

	var quantity *decimal.Decimal
	if r.MonthlyEncryptionRequests != nil {
		quantity = decimalPtr(decimal.NewFromInt(*r.MonthlyEncryptionRequests))
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Field level encryption requests",
		Unit:            "10k requests",
		UnitMultiplier:  decimal.NewFromInt(10000),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Service:    strPtr("AmazonCloudFront"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "requestDescription", Value: strPtr("HTTPS Proxy requests with Field Level Encryption")},
				{Key: "location", Value: strPtr("Europe")},
			},
		},
		UsageBased: true,
	})

	return costComponents
}

func (r *CloudfrontDistribution) realtimeLogsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if !r.HasLoggingConfigBucket {
		return costComponents
	}

	var quantity *decimal.Decimal
	if r.MonthlyLogLines != nil {
		quantity = decimalPtr(decimal.NewFromInt(*r.MonthlyLogLines))
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Real-time log requests",
		Unit:            "1M lines",
		UnitMultiplier:  decimal.NewFromInt(1000000),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Service:    strPtr("AmazonCloudFront"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "operation", Value: strPtr("RealTimeLog")},
			},
		},
		UsageBased: true,
	})

	return costComponents
}

func (r *CloudfrontDistribution) customSSLCertificateCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if !r.IsSSLSupportMethodVIP {
		return costComponents
	}

	quantity := decimalPtr(decimal.NewFromInt(1))
	if r.CustomSslCertificates != nil {
		quantity = decimalPtr(decimal.NewFromInt(*r.CustomSslCertificates))
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Dedicated IP custom SSLs",
		Unit:            "certificates",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Service:    strPtr("AmazonCloudFront"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", Value: strPtr("SSL-Cert-Custom")},
			},
		},
		UsageBased: true,
	})

	return costComponents
}

################################################################################
# FILE: internal/resources/aws/cloudfront_function.go
# RESOURCE: aws_cloudfront_function
# SIZE: 2767 bytes | LINES: 66
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/shopspring/decimal"
)

// CloudfrontFunction struct represents an AWS CloudFront Function. With
// CloudFront Functions, you can write lightweight functions in JavaScript
// for high-scale, latency-sensitive CDN customizations.
//
// Resource information: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-functions.html
// Pricing information: https://aws.amazon.com/cloudfront/pricing/
type CloudfrontFunction struct {
	Address string
	Region  string

	MonthlyRequests *int64 `infracost_usage:"monthly_requests"`
}

// CoreType returns the name of this resource type
func (r *CloudfrontFunction) CoreType() string {
	return "CloudfrontFunction"
}

// UsageSchema defines a list which represents the usage schema of CloudfrontFunction.
func (r *CloudfrontFunction) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "MonthlyRequests", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the CloudfrontFunction.
// It uses the `infracost_usage` struct tags to populate data into the CloudfrontFunction.
func (r *CloudfrontFunction) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid CloudfrontFunction struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *CloudfrontFunction) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	costComponents = append(costComponents, r.monthlyRequestsCostComponent())

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *CloudfrontFunction) monthlyRequestsCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Total number of invocations",
		Unit:            "1M invocations",
		UnitMultiplier:  decimal.NewFromInt(1000000),
		MonthlyQuantity: intPtrToDecimalPtr(r.MonthlyRequests),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Service:       strPtr("AmazonCloudFront"),
			ProductFamily: strPtr("Request"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", Value: strPtr("Executions-CloudFrontFunctions")},
				{Key: "groupDescription", ValueRegex: regexPtr("CloudFront Function")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("on_demand"),
			StartUsageAmount: strPtr("2000000"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/cloudhsm_v2_hsm.go
# RESOURCE: aws_cloudhsm_v2_hsm
# SIZE: 2896 bytes | LINES: 76
################################################################################
package aws

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// CloudHSMv2HSM struct represents an HSM module in a CloudHSM cluster.
//
// The HSM module is charged a hourly rate. Terraform allows you to specify the instance
// type of the HSM cluster, but at the moment AWS only supports one instance type, so
// each module has a set price depending on region.
//
// The cluster is counted as a free resource, but each cluster can have up to 32 HSM modules.
//
// Resource information: https://aws.amazon.com/cloudhsm/
// Pricing information: https://aws.amazon.com/cloudhsm/pricing/
type CloudHSMv2HSM struct {
	Address string
	Region  string

	MonthlyHours *float64 `infracost_usage:"monthly_hrs"`
}

// CoreType returns the name of this resource type
func (r *CloudHSMv2HSM) CoreType() string {
	return "CloudHSMv2HSM"
}

// UsageSchema defines a list which represents the usage schema of CloudHSMv2HSM.
func (r *CloudHSMv2HSM) UsageSchema() []*schema.UsageItem {
	hours, _ := schema.HourToMonthUnitMultiplier.Float64()

	return []*schema.UsageItem{
		{Key: "monthly_hrs", DefaultValue: hours, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the CloudHSMv2HSM.
// It uses the `infracost_usage` struct tags to populate data into the CloudHSMv2HSM.
func (r *CloudHSMv2HSM) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid CloudHSMv2HSM struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *CloudHSMv2HSM) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.hsmCostComponent(),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *CloudHSMv2HSM) hsmCostComponent() *schema.CostComponent {
	quantity := schema.HourToMonthUnitMultiplier
	if r.MonthlyHours != nil {
		quantity = decimal.NewFromFloat(*r.MonthlyHours)
	}

	return &schema.CostComponent{
		Name:            "HSM usage",
		Unit:            "hours",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(quantity),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("CloudHSM"),
			ProductFamily: strPtr("Dedicated-Host"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "instanceFamily", Value: strPtr("CloudHSM-v2")},
				{Key: "usagetype", ValueRegex: regexPtr("CloudHSMv2Usage$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/cloudtrail.go
# RESOURCE: aws_cloudtrail
# SIZE: 5691 bytes | LINES: 123
################################################################################
package aws

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

var (
	cloudTrailServiceName = strPtr("AWSCloudTrail")

	cloudTrailManagementEvent = "Management events (additional copies)"
	cloudTrailDataEvent       = "Data events"
	cloudTrailInsightEvent    = "Insight events"

	cloudTrailBillingMultiplier = decimal.NewFromInt(100000)
)

// Cloudtrail struct represents a cloudtrail instance to monitor activity across a set of resources.
// AWS Cloudtrail monitors and records account activity across infrastructure, keeping an audit log of activity.
// This is mostly used for security purposes.
//
// Resource information: https://aws.amazon.com/cloudtrail/
// Pricing information: https://aws.amazon.com/cloudtrail/pricing/
type Cloudtrail struct {
	Address                 string
	Region                  string
	IncludeManagementEvents bool
	IncludeInsightEvents    bool

	MonthlyAdditionalManagementEvents *float64 `infracost_usage:"monthly_additional_management_events"`
	MonthlyDataEvents                 *float64 `infracost_usage:"monthly_data_events"`
	MonthlyInsightEvents              *float64 `infracost_usage:"monthly_insight_events"`
}

func (r *Cloudtrail) CoreType() string {
	return "Cloudtrail"
}

func (r *Cloudtrail) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_additional_management_events", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_data_events", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_insight_events", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the Cloudtrail.
// It uses the `infracost_usage` struct tags to populate data into the Cloudtrail.
func (r *Cloudtrail) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid Cloudtrail struct.
// It returns Cloudtrail as a schema.Resource with 3 main cost components. All cost components are defined as "events".
// All cost components are charged per 100k events delivered/analyzed.
//
//  1. Additional Management events delivered to S3, charged at $2.00 per 100k management events delivered.
//     Management events are normally priced as free, however if a user specifies an additional replication of events
//     this is charged. We only show this cost therefore if Cloudtrail.IncludeManagementEvents is set. This is set at
//     a per IAC basis.
//  2. Data events delivered to S3, charged at $0.10 per 100k events delivered.
//  3. CloudTrail Insights, charged at $0.35 per 100k events analyzed. This again is configured optionally on a Cloudtrail
//     instance. Hence, we only include the cost component if Cloudtrail.IncludeInsightEvents. This is set at
//     a per IAC basis.
//
// This method is called after the resource is initialised by an IaC provider. See providers folder for more information.
func (r *Cloudtrail) BuildResource() *schema.Resource {
	var costComponents []*schema.CostComponent

	if r.IncludeManagementEvents || r.MonthlyAdditionalManagementEvents != nil {
		costComponents = append(costComponents, r.managementEventCostComponent())
	}

	costComponents = append(costComponents, r.dataEventsCostComponent())

	if r.IncludeInsightEvents || r.MonthlyInsightEvents != nil {
		costComponents = append(costComponents, r.insightEventsCostComponent())
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *Cloudtrail) managementEventCostComponent() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.MonthlyAdditionalManagementEvents != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyAdditionalManagementEvents))
	}

	return r.eventCostComponent(cloudTrailManagementEvent, quantity)
}

func (r *Cloudtrail) dataEventsCostComponent() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.MonthlyDataEvents != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataEvents))
	}

	return r.eventCostComponent(cloudTrailDataEvent, quantity)
}

func (r *Cloudtrail) insightEventsCostComponent() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.MonthlyInsightEvents != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyInsightEvents))
	}

	return r.eventCostComponent(cloudTrailInsightEvent, quantity)
}

func (r *Cloudtrail) eventCostComponent(name string, quantity *decimal.Decimal) *schema.CostComponent {
	productFamily := "Management Tools - AWS CloudTrail Paid Events Recorded"
	if name == cloudTrailDataEvent {
		productFamily = "Management Tools - AWS CloudTrail Data Events Recorded"
	}

	var attrFilters []*schema.AttributeFilter
	if name == cloudTrailInsightEvent {
		productFamily = "Management Tools - AWS CloudTrail Insights Events"
		attrFilters = []*schema.AttributeFilter{
			{Key: "usagetype", ValueRegex: regexPtr(".*-InsightsEvents$")},
		}
	}

	return &schema.CostComponent{
		Name:            name,
		Unit:            "100k events",
		UnitMultiplier:  cloudTrailBillingMultiplier,
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:       vendorName,
			Region:           strPtr(r.Region),
			Service:          cloudTrailServiceName,
			ProductFamily:    strPtr(productFamily),
			AttributeFilters: attrFilters,
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/cloudwatch_dashboard.go
# RESOURCE: aws_cloudwatch_dashboard
# SIZE: 1219 bytes | LINES: 40
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type CloudwatchDashboard struct {
	Address string
}

func (r *CloudwatchDashboard) CoreType() string {
	return "CloudwatchDashboard"
}

func (r *CloudwatchDashboard) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *CloudwatchDashboard) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *CloudwatchDashboard) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Dashboard",
				Unit:            "months",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Service:       strPtr("AmazonCloudWatch"),
					ProductFamily: strPtr("Dashboard"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", Value: strPtr("DashboardsUsageHour")},
					},
				},
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/cloudwatch_event_bus.go
# RESOURCE: aws_cloudwatch_event_bus
# SIZE: 5445 bytes | LINES: 141
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type CloudwatchEventBus struct {
	Address                      string
	Region                       string
	MonthlySchemaDiscoveryEvents *int64   `infracost_usage:"monthly_schema_discovery_events"`
	MonthlyCustomEvents          *int64   `infracost_usage:"monthly_custom_events"`
	MonthlyThirdPartyEvents      *int64   `infracost_usage:"monthly_third_party_events"`
	MonthlyArchiveProcessingGB   *float64 `infracost_usage:"monthly_archive_processing_gb"`
	ArchiveStorageGB             *float64 `infracost_usage:"archive_storage_gb"`
}

func (r *CloudwatchEventBus) CoreType() string {
	return "CloudwatchEventBus"
}

func (r *CloudwatchEventBus) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_schema_discovery_events", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_custom_events", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_third_party_events", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_archive_processing_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "archive_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *CloudwatchEventBus) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *CloudwatchEventBus) BuildResource() *schema.Resource {
	var monthlyCustomEvents *decimal.Decimal
	if r.MonthlyCustomEvents != nil {
		monthlyCustomEvents = decimalPtr(decimal.NewFromInt(*r.MonthlyCustomEvents))
	}
	var monthlyPartnerEvents *decimal.Decimal
	if r.MonthlyThirdPartyEvents != nil {
		monthlyPartnerEvents = decimalPtr(decimal.NewFromInt(*r.MonthlyThirdPartyEvents))
	}
	var monthlyArchiveProcessing *decimal.Decimal
	if r.MonthlyArchiveProcessingGB != nil {
		monthlyArchiveProcessing = decimalPtr(decimal.NewFromFloat(*r.MonthlyArchiveProcessingGB))
	}
	var monthlyArchivedEvents *decimal.Decimal
	if r.ArchiveStorageGB != nil {
		monthlyArchivedEvents = decimalPtr(decimal.NewFromFloat(*r.ArchiveStorageGB))
	}
	var monthlyIngestedEvents *decimal.Decimal
	if r.MonthlySchemaDiscoveryEvents != nil {
		monthlyIngestedEvents = decimalPtr(decimal.NewFromInt(*r.MonthlySchemaDiscoveryEvents))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Custom events published",
				Unit:            "1M events",
				UnitMultiplier:  decimal.NewFromInt(1000000),
				MonthlyQuantity: monthlyCustomEvents,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AWSEvents"),
					ProductFamily: strPtr("EventBridge"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "eventType", Value: strPtr("Custom Event")},
						{Key: "usagetype", ValueRegex: strPtr("/Event-64K-Chunks/")},
					},
				},
				UsageBased: true,
			},
			{
				Name:            "Third-party events published",
				Unit:            "1M events",
				UnitMultiplier:  decimal.NewFromInt(1000000),
				MonthlyQuantity: monthlyPartnerEvents,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AWSEvents"),
					ProductFamily: strPtr("EventBridge"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "eventType", Value: strPtr("Partner Event")},
						{Key: "usagetype", ValueRegex: strPtr("/Event-64K-Chunks/")},
					},
				},
				UsageBased: true,
			},
			{
				Name:            "Archive processing",
				Unit:            "GB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: monthlyArchiveProcessing,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AWSEvents"),
					ProductFamily: strPtr("CloudWatch Events"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/ArchivedEvents-Bytes/")},
					},
				},
				UsageBased: true,
			},
			{
				Name:            "Archive storage",
				Unit:            "GB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: monthlyArchivedEvents,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AWSEvents"),
					ProductFamily: strPtr("CloudWatch Events"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/TimedStorage-ByteHrs/")},
					},
				},
				UsageBased: true,
			},
			{
				Name:            "Schema discovery",
				Unit:            "1M events",
				UnitMultiplier:  decimal.NewFromInt(1000000),
				MonthlyQuantity: monthlyIngestedEvents,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AWSEvents"),
					ProductFamily: strPtr("EventBridge"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "eventType", Value: strPtr("Discovery Event")},
						{Key: "usagetype", ValueRegex: strPtr("/Event-8K-Chunks/")},
					},
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/cloudwatch_log_group.go
# RESOURCE: aws_cloudwatch_log_group
# SIZE: 3387 bytes | LINES: 95
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type CloudwatchLogGroup struct {
	Address               string
	Region                string
	MonthlyDataIngestedGB *float64 `infracost_usage:"monthly_data_ingested_gb"`
	StorageGB             *float64 `infracost_usage:"storage_gb"`
	MonthlyDataScannedGB  *float64 `infracost_usage:"monthly_data_scanned_gb"`
}

var CloudwatchLogGroupUsageSchema = []*schema.UsageItem{
	{Key: "monthly_data_ingested_gb", ValueType: schema.Float64, DefaultValue: 0},
	{Key: "storage_gb", ValueType: schema.Float64, DefaultValue: 0},
	{Key: "monthly_data_scanned_gb", ValueType: schema.Float64, DefaultValue: 0},
}

func (r *CloudwatchLogGroup) CoreType() string {
	return "CloudwatchLogGroup"
}

func (r *CloudwatchLogGroup) UsageSchema() []*schema.UsageItem {
	return CloudwatchLogGroupUsageSchema
}

func (r *CloudwatchLogGroup) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *CloudwatchLogGroup) BuildResource() *schema.Resource {
	var gbDataIngestion *decimal.Decimal
	var gbDataStorage *decimal.Decimal
	var gbDataScanned *decimal.Decimal

	if r.MonthlyDataIngestedGB != nil {
		gbDataIngestion = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataIngestedGB))
	}

	if r.StorageGB != nil {
		gbDataStorage = decimalPtr(decimal.NewFromFloat(*r.StorageGB))
	}

	if r.MonthlyDataScannedGB != nil {
		gbDataScanned = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataScannedGB))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Data ingested",
				Unit:            "GB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: gbDataIngestion,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AmazonCloudWatch"),
					ProductFamily: strPtr("Data Payload"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/-DataProcessing-Bytes/")},
					},
				},
				UsageBased: true,
			},
			{
				Name:            "Archival Storage",
				Unit:            "GB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: gbDataStorage,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AmazonCloudWatch"),
					ProductFamily: strPtr("Storage Snapshot"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/-TimedStorage-ByteHrs/")},
					},
				},
				UsageBased: true,
			},
			{
				Name:            "Insights queries data scanned",
				Unit:            "GB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: gbDataScanned,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AmazonCloudWatch"),
					ProductFamily: strPtr("Data Payload"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/-DataScanned-Bytes/")},
					},
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/cloudwatch_metric_alarm.go
# RESOURCE: aws_cloudwatch_metric_alarm
# SIZE: 2676 bytes | LINES: 77
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type CloudwatchMetricAlarm struct {
	Address            string
	Region             string
	ComparisonOperator string
	Metrics            int64
	Period             int64
}

func (r *CloudwatchMetricAlarm) CoreType() string {
	return "CloudwatchMetricAlarm"
}

func (r *CloudwatchMetricAlarm) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *CloudwatchMetricAlarm) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *CloudwatchMetricAlarm) BuildResource() *schema.Resource {
	costComponents := make([]*schema.CostComponent, 0)

	costComponents = append(costComponents, r.cloudwatchMetricAlarmCostComponent())

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *CloudwatchMetricAlarm) cloudwatchMetricAlarmCostComponent() *schema.CostComponent {
	var name string
	var alarmType string
	var anomalyDetection string

	unit := "alarm metrics"
	quantity := decimal.NewFromInt(int64(r.Metrics))

	if r.checkAnomalyDetection() {
		quantity = quantity.Mul(decimal.NewFromInt(3))
		anomalyDetection = " anomaly detection"
		unit = "alarms"
	}

	if r.CalcMetricResolution(decimal.NewFromInt(r.Period)) {
		name = fmt.Sprintf("%s%s", "Standard resolution", anomalyDetection)
		alarmType = "Standard"
	} else {
		name = fmt.Sprintf("%s%s", "High resolution", anomalyDetection)
		alarmType = "High Resolution"
	}

	return &schema.CostComponent{
		Name:            name,
		Unit:            unit,
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(quantity),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonCloudWatch"),
			ProductFamily: strPtr("Alarm"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "alarmType", ValueRegex: regexPtr(alarmType)},
				{Key: "usagetype", ValueRegex: regexPtr("AlarmMonitorUsage$")},
			},
		},
	}
}

func (r *CloudwatchMetricAlarm) CalcMetricResolution(metricPeriod decimal.Decimal) bool {
	return metricPeriod.Div(decimal.NewFromInt(60)).GreaterThanOrEqual(decimal.NewFromInt(1))
}

func (r *CloudwatchMetricAlarm) checkAnomalyDetection() bool {
	switch r.ComparisonOperator {
	case "LessThanLowerOrGreaterThanUpperThreshold", "LessThanLowerThreshold", "GreaterThanUpperThreshold":
		return true
	}
	return false
}

################################################################################
# FILE: internal/resources/aws/codebuild_project.go
# RESOURCE: aws_codebuild_project
# SIZE: 3062 bytes | LINES: 104
################################################################################
package aws

import (
	"fmt"
	"strings"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type CodeBuildProject struct {
	Address          string
	Region           string
	ComputeType      string
	EnvironmentType  string
	MonthlyBuildMins *int64 `infracost_usage:"monthly_build_mins"`
}

func (r *CodeBuildProject) CoreType() string {
	return "CodeBuildProject"
}

func (r *CodeBuildProject) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_build_mins", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *CodeBuildProject) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *CodeBuildProject) BuildResource() *schema.Resource {
	var monthlyBuildMinutes *decimal.Decimal
	if r.MonthlyBuildMins != nil {
		monthlyBuildMinutes = decimalPtr(decimal.NewFromInt(*r.MonthlyBuildMins))
	}

	computeType := r.mapComputeType()
	return &schema.Resource{
		Name:      r.Address,
		IsSkipped: computeType == "",
		CostComponents: []*schema.CostComponent{
			{
				Name:            r.nameLabel(),
				Unit:            "minutes",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: monthlyBuildMinutes,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("CodeBuild"),
					ProductFamily: strPtr("Compute"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/Build-Min:%s:%s/", r.mapEnvironmentType(), computeType))},
					},
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

func (r *CodeBuildProject) nameLabel() string {
	switch r.EnvironmentType {
	case "WINDOWS_SERVER_2019_CONTAINER":
		return r.osWithComputeTypeLabel("Windows")
	case "ARM_CONTAINER":
		return "Linux (arm1.large)"
	case "LINUX_GPU_CONTAINER":
		return "Linux (gpu1.large)"
	default:
		return r.osWithComputeTypeLabel("Linux")
	}
}

func (r *CodeBuildProject) osWithComputeTypeLabel(os string) string {
	pieces := strings.SplitAfter(r.ComputeType, "BUILD_")
	if len(pieces) < 2 {
		return os
	}

	computeType := strings.Replace(strings.ToLower(pieces[1]), "_", ".", 1)
	return fmt.Sprintf("%s (%s)", os, computeType)
}

func (r *CodeBuildProject) mapEnvironmentType() string {
	switch r.EnvironmentType {
	case "LINUX_CONTAINER":
		return "Linux"
	case "LINUX_GPU_CONTAINER":
		return "LinuxGPU"
	case "ARM_CONTAINER":
		return "ARM"
	case "WINDOWS_SERVER_2019_CONTAINER":
		return "Windows"
	default:
		return ""
	}
}

func (r *CodeBuildProject) mapComputeType() string {
	switch r.ComputeType {
	case "BUILD_GENERAL1_SMALL":
		return "g1.small"
	case "BUILD_GENERAL1_MEDIUM":
		return "g1.medium"
	case "BUILD_GENERAL1_LARGE":
		return "g1.large"
	case "BUILD_GENERAL1_2XLARGE":
		return "g1.2xlarge"
	default:
		return ""
	}
}

################################################################################
# FILE: internal/resources/aws/config_config_rule.go
# RESOURCE: aws_config_config_rule
# SIZE: 2814 bytes | LINES: 69
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/usage"
)

type ConfigConfigRule struct {
	Address                string
	Region                 string
	MonthlyRuleEvaluations *int64 `infracost_usage:"monthly_rule_evaluations"`
}

func (r *ConfigConfigRule) CoreType() string {
	return "ConfigConfigRule"
}

func (r *ConfigConfigRule) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_rule_evaluations", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *ConfigConfigRule) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ConfigConfigRule) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	if r.MonthlyRuleEvaluations != nil {
		monthlyConfigRules := decimal.NewFromInt(*r.MonthlyRuleEvaluations)

		configRulesLimits := []int{100000, 400000}

		rulesTiers := usage.CalculateTierBuckets(monthlyConfigRules, configRulesLimits)

		if rulesTiers[0].GreaterThan(decimal.NewFromInt(0)) {
			costComponents = append(costComponents, r.configRulesCostComponent("Rule evaluations (first 100K)", "0", &rulesTiers[0]))
		}
		if rulesTiers[1].GreaterThan(decimal.NewFromInt(0)) {
			costComponents = append(costComponents, r.configRulesCostComponent("Rule evaluations (next 400K)", "100000", &rulesTiers[1]))
		}
		if rulesTiers[2].GreaterThan(decimal.NewFromInt(0)) {
			costComponents = append(costComponents, r.configRulesCostComponent("Rule evaluations (over 500K)", "500000", &rulesTiers[2]))
		}
	} else {
		var unknown *decimal.Decimal

		costComponents = append(costComponents, r.configRulesCostComponent("Rule evaluations (first 100K)", "0", unknown))
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *ConfigConfigRule) configRulesCostComponent(displayName string, usageTier string, monthlyQuantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            displayName,
		Unit:            "evaluations",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: monthlyQuantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSConfig"),
			ProductFamily: strPtr("Management Tools - AWS Config Rules"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("^[A-Z0-9]*-ConfigRuleEvaluations$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(usageTier),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/config_configuration_recorder.go
# RESOURCE: aws_config_configuration_recorder
# SIZE: 2744 bytes | LINES: 72
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type ConfigConfigurationRecorder struct {
	Address                  string
	Region                   string
	MonthlyConfigItems       *int64 `infracost_usage:"monthly_config_items"`
	MonthlyCustomConfigItems *int64 `infracost_usage:"monthly_custom_config_items"`
}

func (r *ConfigConfigurationRecorder) CoreType() string {
	return "ConfigConfigurationRecorder"
}

func (r *ConfigConfigurationRecorder) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_config_items", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_custom_config_items", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *ConfigConfigurationRecorder) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ConfigConfigurationRecorder) BuildResource() *schema.Resource {
	var monthlyConfigItems *decimal.Decimal
	if r.MonthlyConfigItems != nil {
		monthlyConfigItems = decimalPtr(decimal.NewFromInt(*r.MonthlyConfigItems))
	}

	var monthlyCustomConfigItems *decimal.Decimal
	if r.MonthlyCustomConfigItems != nil {
		monthlyCustomConfigItems = decimalPtr(decimal.NewFromInt(*r.MonthlyCustomConfigItems))
	}

	costComponents := []*schema.CostComponent{}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Config items",
		Unit:            "records",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: monthlyConfigItems,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSConfig"),
			ProductFamily: strPtr("Management Tools - AWS Config"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("ConfigurationItemRecorded$")},
			},
		},
		UsageBased: true,
	})

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Custom config items",
		Unit:            "records",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: monthlyCustomConfigItems,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSConfig"),
			ProductFamily: strPtr("Management Tools - AWS Config"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("CustomConfigItemRecorded$")},
			},
		},
		UsageBased: true,
	})

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/data_transfer.go
# RESOURCE: aws_data_transfer
# SIZE: 9427 bytes | LINES: 244
################################################################################
package aws

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
)

// DataTransfer represents data transferred "in" to and "out" of Amazon EC2.
//
// Pricing information here: https://aws.amazon.com/ec2/pricing/on-demand/
type DataTransfer struct {
	Address string
	Region  string

	// "usage" args
	MonthlyInfraRegionGB            *float64 `infracost_usage:"monthly_intra_region_gb"`
	MonthlyOutboundInternetGB       *float64 `infracost_usage:"monthly_outbound_internet_gb"`
	MonthlyOutboundUsEastToUsEastGB *float64 `infracost_usage:"monthly_outbound_us_east_to_us_east_gb"`
	MonthlyOutboundOtherRegionsGB   *float64 `infracost_usage:"monthly_outbound_other_regions_gb"`
}

func (r *DataTransfer) CoreType() string {
	return "DataTransfer"
}

func (r *DataTransfer) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_intra_region_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_outbound_internet_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_outbound_us_east_to_us_east_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_outbound_other_regions_gb", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the DataTransfer.
// It uses the `infracost_usage` struct tags to populate data into the DataTransfer.
func (r *DataTransfer) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid DataTransfer.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *DataTransfer) BuildResource() *schema.Resource {
	_, ok := RegionMapping[r.Region]

	if !ok {
		logging.Logger.Warn().Msgf("Skipping resource %s. Could not find mapping for region %s", r.Address, r.Region)
		return nil
	}

	costComponents := []*schema.CostComponent{}

	costComponents = append(costComponents, r.intraRegionCostComponents()...)
	costComponents = append(costComponents, r.outboundInternetCostComponents()...)
	costComponents = append(costComponents, r.outboundUsEastCostComponents()...)
	costComponents = append(costComponents, r.outboundOtherRegionsCostComponents()...)

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
	}
}

// intraRegionCostComponents returns a cost component for Intra-region data
// transfer only when its usage is specified.
func (r *DataTransfer) intraRegionCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if r.MonthlyInfraRegionGB == nil {
		return costComponents
	}

	intraRegionGb := decimalPtr(decimal.NewFromFloat(*r.MonthlyInfraRegionGB))

	if intraRegionGb != nil {
		costComponents = append(costComponents, &schema.CostComponent{
			Name:            "Intra-region data transfer",
			Unit:            "GB",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: decimalPtr(intraRegionGb.Mul(decimal.NewFromInt(2))),
			ProductFilter:   r.buildProductFilter("IntraRegion", nil, "DataTransfer-Regional-Bytes"),
			UsageBased:      true,
		})
	}

	return costComponents
}

// intraRegionCostComponents returns a cost component for outbound data
// transfer to the Internet only when its usage is specified.
// China regions are calculated without tiers.
func (r *DataTransfer) outboundInternetCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if r.MonthlyOutboundInternetGB == nil {
		return costComponents
	}

	outboundInternetGb := decimalPtr(decimal.NewFromFloat(*r.MonthlyOutboundInternetGB))
	networkUsage := outboundInternetGb.IntPart()

	if r.Region == "cn-north-1" || r.Region == "cn-northwest-1" {
		costComponents = append(costComponents, r.buildOutboundInternetCostComponent(
			"Outbound data transfer to Internet",
			decimal.NewFromInt(networkUsage),
			"Inf",
		))
		return costComponents
	}

	type dataTransferRegionUsageFilterData struct {
		usageName      string
		tierCapacity   int64
		endUsageNumber int64
	}

	usageFiltersData := []*dataTransferRegionUsageFilterData{
		{
			usageName:      "first 10TB",
			tierCapacity:   10240,
			endUsageNumber: 10240,
		},
		{
			usageName:      "next 40TB",
			tierCapacity:   40960,
			endUsageNumber: 51200,
		},
		{
			usageName:      "next 100TB",
			tierCapacity:   102400,
			endUsageNumber: 153600,
		},
		{
			usageName:      "over 150TB",
			tierCapacity:   0,
			endUsageNumber: 0,
		},
	}

	tierLimits := make([]int, len(usageFiltersData)-1)
	for i, usageFilter := range usageFiltersData {
		if usageFilter.tierCapacity > 0 {
			tierLimits[i] = int(usageFilter.tierCapacity)
		}
	}

	tiers := usage.CalculateTierBuckets(decimal.NewFromInt(networkUsage), tierLimits)
	for i, usageFilter := range usageFiltersData {
		quantity := tiers[i]

		if quantity.Equals(decimal.Zero) {
			break
		}

		filter := fmt.Sprint(usageFilter.endUsageNumber)
		if usageFilter.endUsageNumber == 0 {
			filter = "Inf"
		}

		name := fmt.Sprintf("Outbound data transfer to Internet (%s)", usageFilter.usageName)
		costComponents = append(costComponents, r.buildOutboundInternetCostComponent(
			name,
			quantity,
			filter,
		))
	}

	return costComponents
}

// buildOutboundInternetCostComponent builds a cost component for
// outbound data transfer to Internet.
func (r *DataTransfer) buildOutboundInternetCostComponent(name string, networkUsage decimal.Decimal, endUsageAmount string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(networkUsage),
		ProductFilter:   r.buildProductFilter("AWS Outbound", nil, ""),
		PriceFilter: &schema.PriceFilter{
			EndUsageAmount: strPtr(endUsageAmount),
		},
		UsageBased: true,
	}
}

// outboundUsEastCostComponents returns a cost component for outbound data
// transfer to US East regions only when its usage is specified.
func (r *DataTransfer) outboundUsEastCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if r.MonthlyOutboundUsEastToUsEastGB == nil {
		return costComponents
	}

	toRegion := "us-east-1"

	if r.Region == "us-east-1" {
		toRegion = "us-east-2"
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Outbound data transfer to US East regions",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromFloat(*r.MonthlyOutboundUsEastToUsEastGB)),
		ProductFilter:   r.buildProductFilter("InterRegion Outbound", &toRegion, ""),
		UsageBased:      true,
	})

	return costComponents
}

// outboundOtherRegionsCostComponents returns a cost component for outbound data
// transfer to other regions only when its usage is specified.
func (r *DataTransfer) outboundOtherRegionsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if r.MonthlyOutboundOtherRegionsGB == nil {
		return costComponents
	}

	toRegion := "us-west-1"

	switch r.Region {
	case "us-east-1":
		toRegion = "us-west-2"
	case "us-west-1":
		toRegion = "us-west-2"
	case "cn-north-1":
		toRegion = "cn-northwest-1"
	case "cn-northwest-1":
		toRegion = "cn-north-1"
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Outbound data transfer to other regions",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromFloat(*r.MonthlyOutboundOtherRegionsGB)),
		ProductFilter:   r.buildProductFilter("InterRegion Outbound", &toRegion, ""),
		UsageBased:      true,
	})

	return costComponents
}

// buildProductFilter returns a filter for data transfer products. Desctination
// region is optional.
func (r *DataTransfer) buildProductFilter(transferType string, toRegion *string, usageTypeSuffix string) *schema.ProductFilter {
	fromLocation := RegionMapping[r.Region]

	attributeFilters := []*schema.AttributeFilter{
		{Key: "transferType", Value: strPtr(transferType)},
		{Key: "fromLocation", Value: strPtr(fromLocation)},
	}

	if toRegion != nil {
		toLocation := RegionMapping[*toRegion]
		attributeFilters = append(attributeFilters, &schema.AttributeFilter{
			Key:   "toLocation",
			Value: strPtr(toLocation),
		})
	}

	if regionCode, ok := RegionCodeMapping[r.Region]; ok {
		attributeFilters = append(attributeFilters, &schema.AttributeFilter{
			Key:        "usagetype",
			ValueRegex: regexPtr(fmt.Sprintf("^%s-", regionCode)),
		})
	}

	if usageTypeSuffix != "" {
		attributeFilters = append(attributeFilters, &schema.AttributeFilter{
			Key:        "usagetype",
			ValueRegex: regexPtr(fmt.Sprintf("%s$", usageTypeSuffix)),
		})
	}

	return &schema.ProductFilter{
		VendorName:       strPtr("aws"),
		Service:          strPtr("AWSDataTransfer"),
		ProductFamily:    strPtr("Data Transfer"),
		AttributeFilters: attributeFilters,
	}
}

################################################################################
# FILE: internal/resources/aws/db_instance.go
# RESOURCE: aws_db_instance
# SIZE: 23361 bytes | LINES: 560
################################################################################
package aws

import (
	"fmt"
	"strings"
	"time"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type DBInstance struct {
	Address                                      string
	Region                                       string
	LicenseModel                                 string
	StorageType                                  string
	BackupRetentionPeriod                        int64
	IOOptimized                                  bool
	PerformanceInsightsEnabled                   bool
	PerformanceInsightsLongTermRetention         bool
	MultiAZ                                      bool
	InstanceClass                                string
	Engine                                       string
	Version                                      string
	IOPS                                         float64
	AllocatedStorageGB                           *float64
	MonthlyStandardIORequests                    *int64   `infracost_usage:"monthly_standard_io_requests"`
	AdditionalBackupStorageGB                    *float64 `infracost_usage:"additional_backup_storage_gb"`
	MonthlyAdditionalPerformanceInsightsRequests *int64   `infracost_usage:"monthly_additional_performance_insights_requests"`
	ReservedInstanceTerm                         *string  `infracost_usage:"reserved_instance_term"`
	ReservedInstancePaymentOption                *string  `infracost_usage:"reserved_instance_payment_option"`
}

func (r *DBInstance) CoreType() string {
	return "DBInstance"
}

func (r *DBInstance) UsageSchema() []*schema.UsageItem {
	return DBInstanceUsageSchema
}

var DBInstanceUsageSchema = []*schema.UsageItem{
	{Key: "monthly_standard_io_requests", ValueType: schema.Int64, DefaultValue: 0},
	{Key: "additional_backup_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
	{Key: "monthly_additional_performance_insights_requests", ValueType: schema.Int64, DefaultValue: 0},
	{Key: "reserved_instance_term", DefaultValue: "", ValueType: schema.String},
	{Key: "reserved_instance_payment_option", DefaultValue: "", ValueType: schema.String},
}

func (r *DBInstance) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DBInstance) BuildResource() *schema.Resource {
	deploymentOption := "Single-AZ"
	if r.MultiAZ {
		deploymentOption = "Multi-AZ"
	}

	var monthlyIORequests *decimal.Decimal
	if r.MonthlyStandardIORequests != nil {
		monthlyIORequests = decimalPtr(decimal.NewFromInt(*r.MonthlyStandardIORequests))
	}

	var databaseEngine string
	switch strings.ToLower(r.Engine) {
	case "postgres":
		databaseEngine = "PostgreSQL"
	case "mysql":
		databaseEngine = "MySQL"
	case "mariadb":
		databaseEngine = "MariaDB"
	case "aurora", "aurora-mysql":
		databaseEngine = "Aurora MySQL"
	case "aurora-postgresql":
		databaseEngine = "Aurora PostgreSQL"
	case "oracle-se", "oracle-se1", "oracle-se2", "oracle-se2-cdb", "oracle-ee", "oracle-ee-cdb":
		databaseEngine = "Oracle"
	case "sqlserver-ex", "sqlserver-web", "sqlserver-se", "sqlserver-ee":
		databaseEngine = "SQL Server"
	}

	var databaseEdition string
	switch strings.ToLower(r.Engine) {
	case "oracle-se", "sqlserver-se":
		databaseEdition = "Standard"
	case "oracle-se1":
		databaseEdition = "Standard One"
	case "oracle-se2", "oracle-se2-cdb":
		databaseEdition = "Standard Two"
	case "oracle-ee", "oracle-ee-cdb", "sqlserver-ee":
		databaseEdition = "Enterprise"
	case "sqlserver-ex":
		databaseEdition = "Express"
	case "sqlserver-web":
		databaseEdition = "Web"
	}

	var licenseModel string
	engineVal := strings.ToLower(r.Engine)
	if engineVal == "oracle-se1" || engineVal == "oracle-se2" || engineVal == "oracle-se2-cdb" || strings.HasPrefix(engineVal, "sqlserver-") {
		licenseModel = "License included"
	}
	if strings.ToLower(r.LicenseModel) == "bring-your-own-license" {
		licenseModel = "Bring your own license"
	}

	iopsVal := decimal.NewFromFloat(r.IOPS)

	allocatedStorageVal := decimal.NewFromInt(20)
	if r.AllocatedStorageGB != nil {
		allocatedStorageVal = decimal.NewFromFloat(*r.AllocatedStorageGB)
	}

	volumeType := "General Purpose"
	storageName := "Storage (general purpose SSD, gp2)"
	iopsDescription := "RDS Provisioned IOPS"

	storageType := strings.ToLower(r.StorageType)
	switch storageType {
	case "io1":
		volumeType = "Provisioned IOPS"
		storageName = "Storage (provisioned IOPS SSD, io1)"
		if iopsVal.LessThan(decimal.NewFromInt(1000)) {
			iopsVal = decimal.NewFromInt(1000)
		}
		if allocatedStorageVal.LessThan(decimal.NewFromInt(100)) {
			allocatedStorageVal = decimal.NewFromInt(100)
		}
	case "standard":
		volumeType = "Magnetic"
		storageName = "Storage (magnetic)"
	case "gp3":
		volumeType = "General Purpose-GP3"
		storageName = "Storage (general purpose SSD, gp3)"
		iopsDescription = "RDS Provisioned GP3 IOPS"

	}

	instanceAttributeFilters := []*schema.AttributeFilter{
		{Key: "instanceType", Value: strPtr(r.InstanceClass)},
		{Key: "deploymentOption", Value: strPtr(deploymentOption)},
		{Key: "databaseEngine", Value: strPtr(databaseEngine)},
	}
	if databaseEdition != "" {
		instanceAttributeFilters = append(instanceAttributeFilters, &schema.AttributeFilter{
			Key:   "databaseEdition",
			Value: strPtr(databaseEdition),
		})
	}
	if licenseModel != "" {
		instanceAttributeFilters = append(instanceAttributeFilters, &schema.AttributeFilter{
			Key:   "licenseModel",
			Value: strPtr(licenseModel),
		})
	}
	if databaseEngine == "Oracle" {
		instanceAttributeFilters = append(instanceAttributeFilters, &schema.AttributeFilter{
			Key:   "deploymentModel",
			Value: strPtr(""),
		})
	}
	if strings.HasPrefix(databaseEngine, "Aurora") {
		// Example usage types for Aurora
		// InstanceUsage:db.t3.medium
		// InstanceUsageIOOptimized:db.t3.medium
		// EU-InstanceUsage:db.t3.medium
		// EU-InstanceUsageIOOptimized:db.t3.medium
		usageTypeFilter := "/InstanceUsage:/"
		if r.IOOptimized {
			usageTypeFilter = "/InstanceUsageIOOptimized:/"
		}

		instanceAttributeFilters = append(instanceAttributeFilters, &schema.AttributeFilter{
			Key:        "usagetype",
			ValueRegex: strPtr(usageTypeFilter),
		})
	}

	purchaseOptionLabel := "on-demand"
	priceFilter := &schema.PriceFilter{
		PurchaseOption: strPtr("on_demand"),
	}

	var err error
	if r.ReservedInstanceTerm != nil {
		resolver := &rdsReservationResolver{
			term:          strVal(r.ReservedInstanceTerm),
			paymentOption: strVal(r.ReservedInstancePaymentOption),
		}
		priceFilter, err = resolver.PriceFilter()
		if err != nil {
			logging.Logger.Warn().Msg(err.Error())
		}
		purchaseOptionLabel = "reserved"
	}

	storageFilters := []*schema.AttributeFilter{
		{Key: "deploymentOption", Value: strPtr(deploymentOption)},
		{Key: "databaseEngine", Value: strPtr("Any")},
		{Key: "volumeType", Value: strPtr(volumeType)},
	}

	if storageType == "gp3" {
		if deploymentOption == "Multi-AZ" {
			storageFilters = append(storageFilters, &schema.AttributeFilter{Key: "usagetype", ValueRegex: strPtr("/\\-RDS\\:Multi\\-AZ\\-GP3\\-Storage$/")})
		} else {
			storageFilters = append(storageFilters, &schema.AttributeFilter{Key: "usagetype", ValueRegex: strPtr("/\\-RDS\\:GP3\\-Storage$/")})
		}
	}

	costComponents := []*schema.CostComponent{
		{
			Name:           fmt.Sprintf("Database instance (%s, %s, %s)", purchaseOptionLabel, deploymentOption, r.InstanceClass),
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: &schema.ProductFilter{
				VendorName:       strPtr("aws"),
				Region:           strPtr(r.Region),
				Service:          strPtr("AmazonRDS"),
				ProductFamily:    strPtr("Database Instance"),
				AttributeFilters: instanceAttributeFilters,
			},
			PriceFilter: priceFilter,
		},
		{
			Name:            storageName,
			Unit:            "GB",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: &allocatedStorageVal,
			ProductFilter: &schema.ProductFilter{
				VendorName:       strPtr("aws"),
				Region:           strPtr(r.Region),
				Service:          strPtr("AmazonRDS"),
				ProductFamily:    strPtr("Database Storage"),
				AttributeFilters: storageFilters,
			},
		},
	}

	if strings.ToLower(volumeType) == "magnetic" {
		costComponents = append(costComponents, &schema.CostComponent{
			Name:            "I/O requests",
			Unit:            "1M requests",
			UnitMultiplier:  decimal.NewFromInt(1000000),
			MonthlyQuantity: monthlyIORequests,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonRDS"),
				ProductFamily: strPtr("System Operation"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: strPtr("/RDS:StorageIOUsage/i")},
				},
			},
			UsageBased: true,
		})
	}

	if storageType == "io1" || storageType == "gp3" {
		if storageType == "gp3" {
			// For GP3 Storage volumes, all IOPS and throughput use below the baseline is
			// included at no additional charge. For volumes below 400 GiB of allocated
			// storage, the baseline provisioned IOPS is 3,000 and baseline throughput is 125
			// MiBps. Volumes of 400 GiB and above, baseline provisioned IOPS is 12,000 and
			// baseline throughput is 500 MiBps. There is an additional charge for
			// provisioned IOPS and throughput above baseline.
			baseline := decimal.NewFromInt(3000)
			baselineStr := "3,000"
			if allocatedStorageVal.GreaterThanOrEqual(decimal.NewFromInt(400)) {
				baseline = decimal.NewFromInt(12000)
				baselineStr = "12,000"
			}

			if iopsVal.GreaterThan(baseline) {
				over := iopsVal.Sub(baseline)

				usageType := strPtr("/\\-RDS\\:GP3\\-PIOPS$/")
				if deploymentOption == "Multi-AZ" {
					usageType = strPtr("/\\-RDS\\:Multi\\-AZ\\-GP3\\-PIOPS$/")
				}

				costComponents = append(costComponents, &schema.CostComponent{
					Name:            fmt.Sprintf("Provisioned GP3 IOPS (above %s)", baselineStr),
					Unit:            "IOPS",
					UnitMultiplier:  decimal.NewFromInt(1),
					MonthlyQuantity: &over,
					ProductFilter: &schema.ProductFilter{
						VendorName:    strPtr("aws"),
						Region:        strPtr(r.Region),
						Service:       strPtr("AmazonRDS"),
						ProductFamily: strPtr("Provisioned IOPS"),
						AttributeFilters: []*schema.AttributeFilter{
							{Key: "deploymentOption", Value: strPtr(deploymentOption)},
							{Key: "groupDescription", Value: strPtr(iopsDescription)},
							{Key: "databaseEngine", Value: strPtr("Any")},
							{Key: "usagetype", ValueRegex: usageType},
						},
					},
				})
			}
		} else {
			costComponents = append(costComponents, &schema.CostComponent{
				Name:            "Provisioned IOPS",
				Unit:            "IOPS",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: &iopsVal,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AmazonRDS"),
					ProductFamily: strPtr("Provisioned IOPS"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "deploymentOption", Value: strPtr(deploymentOption)},
						{Key: "groupDescription", Value: strPtr(iopsDescription)},
						{Key: "databaseEngine", Value: strPtr("Any")},
					},
				},
			})
		}

	}

	var backupStorageGB *decimal.Decimal
	if r.AdditionalBackupStorageGB != nil {
		backupStorageGB = decimalPtr(decimal.NewFromFloat(*r.AdditionalBackupStorageGB))
	}

	if r.BackupRetentionPeriod > 0 || (backupStorageGB != nil && backupStorageGB.GreaterThan(decimal.Zero)) {
		backupStorageDBEngine := "Any"
		attrFilters := []*schema.AttributeFilter{
			{Key: "databaseEngine", Value: strPtr(backupStorageDBEngine)},
			{Key: "usagetype", ValueRegex: regexPtr("RDS:ChargedBackupUsage$")},
			{Key: "engineCode", ValueRegex: regexPtr("[0-9]+")},
			{Key: "operation", Value: strPtr("")},
		}

		if strings.HasPrefix(databaseEngine, "Aurora") {
			backupStorageDBEngine = databaseEngine
			attrFilters = []*schema.AttributeFilter{
				{Key: "databaseEngine", Value: strPtr(backupStorageDBEngine)},
				{Key: "usagetype", ValueRegex: regexPtr("Aurora:BackupUsage$")},
				{Key: "engineCode", ValueRegex: regexPtr("[0-9]+")},
			}
		}

		costComponents = append(costComponents, &schema.CostComponent{
			Name:            "Additional backup storage",
			Unit:            "GB",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: backupStorageGB,
			ProductFilter: &schema.ProductFilter{
				VendorName:       strPtr("aws"),
				Region:           strPtr(r.Region),
				Service:          strPtr("AmazonRDS"),
				ProductFamily:    strPtr("Storage Snapshot"),
				AttributeFilters: attrFilters,
			},
			UsageBased: true,
		})
	}

	if r.PerformanceInsightsEnabled {
		if r.PerformanceInsightsLongTermRetention {
			costComponents = append(costComponents, performanceInsightsLongTermRetentionCostComponent(r.Region, r.InstanceClass, databaseEngine, false, nil))
		}

		if r.MonthlyAdditionalPerformanceInsightsRequests == nil || *r.MonthlyAdditionalPerformanceInsightsRequests > 0 {
			costComponents = append(costComponents,
				performanceInsightsAPIRequestCostComponent(r.Region, r.MonthlyAdditionalPerformanceInsightsRequests))
		}
	}

	extendedSupport := extendedSupportCostComponent(r.Version, r.Region, r.Engine, r.InstanceClass)
	if extendedSupport != nil {
		costComponents = append(costComponents, extendedSupport)
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    DBInstanceUsageSchema,
	}
}
func performanceInsightsLongTermRetentionCostComponent(region, instanceClass, dbEngine string, isServerless bool, capacityUnits *float64) *schema.CostComponent {

	if isServerless {
		auroraCapacityUnits := decimal.Zero
		if capacityUnits != nil {
			auroraCapacityUnits = decimal.NewFromFloat(*capacityUnits)
		}
		return &schema.CostComponent{
			Name:            "Performance Insights Long Term Retention (serverless)",
			Unit:            "ACUs",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: &auroraCapacityUnits,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(region),
				Service:       strPtr("AmazonRDS"),
				ProductFamily: strPtr("Performance Insights"),
				AttributeFilters: []*schema.AttributeFilter{
					{
						Key:        "usagetype",
						ValueRegex: regexPtr("PI_LTR_FMR:Serverless$"),
					},
					{
						Key:   "databaseEngine",
						Value: &dbEngine,
					},
				},
			},
		}
	}

	instanceType := strings.TrimPrefix(instanceClass, "db.")

	vCPUCount := decimal.Zero
	if count, ok := InstanceTypeToVCPU[instanceType]; ok {
		// We were able to lookup thing VCPU count
		vCPUCount = decimal.NewFromInt(count)
	}

	var instanceFamily string
	split := strings.SplitN(instanceType, ".", 2)
	if len(split) > 0 {
		instanceFamily = split[0]
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Performance Insights Long Term Retention (%s)", strings.ToLower(instanceClass)),
		Unit:            "vCPU-month",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: &vCPUCount,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(region),
			Service:       strPtr("AmazonRDS"),
			ProductFamily: strPtr("Performance Insights"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("PI_LTR:" + strings.ToUpper(instanceFamily) + "$")},
			},
		},
	}
}

func performanceInsightsAPIRequestCostComponent(region string, additionalRequests *int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Performance Insights API",
		Unit:            "1000 requests",
		UnitMultiplier:  decimal.NewFromInt(1000),
		MonthlyQuantity: intPtrToDecimalPtr(additionalRequests),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(region),
			Service:       strPtr("AmazonRDS"),
			ProductFamily: strPtr("Performance Insights"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("PI_API$")},
			},
		},
		UsageBased: true,
	}
}

// ExtendedSupportDates contains the extended support dates for a specific RDS
// engine version Year1 is the date when the extended support starts, Year 3 is
// the date when the extended increases price.
type ExtendedSupportDates struct {
	UsagetypeVersion string
	Year1            time.Time
	Year3            time.Time
}

// ExtendedSupport contains the extended support dates for a specific RDS engine.
type ExtendedSupport struct {
	Engine   string
	Versions map[string]ExtendedSupportDates
}

// CostComponent returns the cost component for the extended support for the
// given version and date. If the version is not found then it will return nil.
func (s ExtendedSupport) CostComponent(version string, region string, d time.Time, quantity decimal.Decimal) *schema.CostComponent {
	matchingVersion := strings.ToLower(version)
	supportDates, ok := s.Versions[matchingVersion]
	if !ok {
		// if the version is not found then it is likely that the
		// version is a minor version, we should try and match the minor
		// version to a major version in the map. This is done by
		// progressively removing the last part of the version until
		// we find a match.
		parts := strings.Split(version, ".")
		for i := len(parts) - 1; i > 0; i-- {
			matchingVersion = strings.Join(parts[:i], ".")
			supportDates, ok = s.Versions[matchingVersion]
			if ok {
				break
			}
		}

		if !ok {
			return nil
		}
	}

	usagetypeVersion := supportDates.UsagetypeVersion
	if usagetypeVersion == "" {
		usagetypeVersion = matchingVersion
	}

	if !supportDates.Year3.IsZero() && d.After(supportDates.Year3) {
		return &schema.CostComponent{
			Name:           "Extended support (year 3)",
			Unit:           "vCPU-hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(quantity),
			ProductFilter: &schema.ProductFilter{
				VendorName: strPtr("aws"),
				Region:     strPtr(region),
				Service:    strPtr("AmazonRDS"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: regexPtr("ExtendedSupport:Yr3:" + s.Engine + usagetypeVersion)},
				},
			},
		}
	}

	if d.After(supportDates.Year1) {
		return &schema.CostComponent{
			Name:           "Extended support (year 1)",
			Unit:           "vCPU-hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(quantity),
			ProductFilter: &schema.ProductFilter{
				VendorName: strPtr("aws"),
				Region:     strPtr(region),
				Service:    strPtr("AmazonRDS"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: regexPtr("ExtendedSupport:Yr1-Yr2:" + s.Engine + usagetypeVersion)},
				},
			},
		}
	}

	return nil
}

var (
	// https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/MySQL.Concepts.VersionMgmt.html#MySQL.Concepts.VersionMgmt.ReleaseCalendar
	mysqlExtendedSupport = ExtendedSupport{
		Engine: "MySQL",
		Versions: map[string]ExtendedSupportDates{
			"5.7": {Year1: time.Date(2024, time.March, 1, 0, 0, 0, 0, time.UTC), Year3: time.Date(2026, time.March, 1, 0, 0, 0, 0, time.UTC)},
			"8":   {Year1: time.Date(2026, time.August, 1, 0, 0, 0, 0, time.UTC), Year3: time.Date(2028, time.August, 1, 0, 0, 0, 0, time.UTC)},
		},
	}

	// https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.VersionPolicy.html#Aurora.VersionPolicy.MajorVersions
	mysqlAuroraExtendedSupport = ExtendedSupport{
		Engine: "AuroraMySQL",
		Versions: map[string]ExtendedSupportDates{
			"5.7": {UsagetypeVersion: "2", Year1: time.Date(2024, time.December, 1, 0, 0, 0, 0, time.UTC)}, // Year3 is zero because it's N/A
			"8":   {UsagetypeVersion: "3", Year1: time.Date(2027, time.May, 1, 0, 0, 0, 0, time.UTC)},      // Year3 is zero because it's N/A
		},
	}

	// https://docs.aws.amazon.com/AmazonRDS/latest/PostgreSQLReleaseNotes/postgresql-release-calendar.html#Release.Calendar
	postgresExtendedSupport = ExtendedSupport{
		Engine: "PostgreSQL",
		Versions: map[string]ExtendedSupportDates{
			"11": {Year1: time.Date(2024, time.April, 1, 0, 0, 0, 0, time.UTC), Year3: time.Date(2026, time.April, 1, 0, 0, 0, 0, time.UTC)},
			"12": {Year1: time.Date(2025, time.March, 1, 0, 0, 0, 0, time.UTC), Year3: time.Date(2027, time.March, 1, 0, 0, 0, 0, time.UTC)},
			"13": {Year1: time.Date(2026, time.March, 1, 0, 0, 0, 0, time.UTC), Year3: time.Date(2028, time.March, 1, 0, 0, 0, 0, time.UTC)},
			"14": {Year1: time.Date(2027, time.March, 1, 0, 0, 0, 0, time.UTC), Year3: time.Date(2029, time.March, 1, 0, 0, 0, 0, time.UTC)},
			"15": {Year1: time.Date(2028, time.March, 1, 0, 0, 0, 0, time.UTC), Year3: time.Date(2030, time.March, 1, 0, 0, 0, 0, time.UTC)},
			"16": {Year1: time.Date(2029, time.March, 1, 0, 0, 0, 0, time.UTC), Year3: time.Date(2031, time.March, 1, 0, 0, 0, 0, time.UTC)},
		},
	}

	// https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.VersionPolicy.html#Aurora.VersionPolicy.MajorVersions
	postgresAuroraExtendedSupport = ExtendedSupport{
		Engine: "AuroraPostgreSQL",
		Versions: map[string]ExtendedSupportDates{
			"11": {Year1: time.Date(2024, time.April, 1, 0, 0, 0, 0, time.UTC), Year3: time.Date(2026, time.April, 1, 0, 0, 0, 0, time.UTC)},
			"12": {Year1: time.Date(2025, time.March, 1, 0, 0, 0, 0, time.UTC), Year3: time.Date(2027, time.March, 1, 0, 0, 0, 0, time.UTC)},
			"13": {Year1: time.Date(2026, time.March, 1, 0, 0, 0, 0, time.UTC), Year3: time.Date(2028, time.March, 1, 0, 0, 0, 0, time.UTC)},
			"14": {Year1: time.Date(2027, time.March, 1, 0, 0, 0, 0, time.UTC), Year3: time.Date(2029, time.March, 1, 0, 0, 0, 0, time.UTC)},
			"15": {Year1: time.Date(2028, time.March, 1, 0, 0, 0, 0, time.UTC), Year3: time.Date(2030, time.March, 1, 0, 0, 0, 0, time.UTC)},
		},
	}

	today = time.Now()
)

func extendedSupportCostComponent(version string, region string, engine string, instanceType string) *schema.CostComponent {
	if version == "" {
		return nil
	}

	vCPUCount := decimal.NewFromInt(1)
	if count, ok := InstanceTypeToVCPU[strings.TrimPrefix(instanceType, "db.")]; ok {
		// We were able to lookup thing VCPU count
		vCPUCount = decimal.NewFromInt(count)
	}

	switch engine {
	case "postgres":
		return postgresExtendedSupport.CostComponent(version, region, today, vCPUCount)
	case "mysql":
		return mysqlExtendedSupport.CostComponent(version, region, today, vCPUCount)
	case "aurora-postgresql":
		return postgresAuroraExtendedSupport.CostComponent(version, region, today, vCPUCount)
	case "aurora", "aurora-mysql":
		return mysqlAuroraExtendedSupport.CostComponent(version, region, today, vCPUCount)
	}

	return nil
}

################################################################################
# FILE: internal/resources/aws/directory_service_directory.go
# RESOURCE: aws_directory_service_directory
# SIZE: 8324 bytes | LINES: 182
################################################################################
package aws

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

const (
	dtMicrosoftAD = "Microsoft AD"
)

var (
	awsVendorFilter       = strPtr("aws")
	directorySvcSvcFilter = strPtr("AWSDirectoryService")
	productFmlyFilter     = strPtr("AWS Directory Service")
)

// DirectoryServiceDirectory represents a single AWS Directory Service "Directory".
// AWS Directory Service has three main types: Microsoft AD, AD Connector & Simple AD.
// All the types are meant to support some form of Active Directory integration.
// Microsoft Active Directory is used by Windows applications to manage access and enable single sign-on.
// For example, you can manage access to Microsoft SharePoint using different Microsoft Active Directory security groups.
//
// The Microsoft AD type is a fully managed Microsoft Active Directory service.
// The Simple AD type is a fully managed Samba service which is compatible with Microsoft Active Directory.
// The AD Connector type is a gateway with which you can redirect directory requests to your on-premises Microsoft Active Directory.
//
// Read more about Directory service here: https://aws.amazon.com/directoryservice/
// Microsoft Active Directory here: https://docs.aws.amazon.com/directoryservice/latest/admin-guide/directory_microsoft_ad.html
// Other Supported Active Directory types here:
//
//	https://docs.aws.amazon.com/directoryservice/latest/admin-guide/directory_simple_ad.html
//	https://docs.aws.amazon.com/directoryservice/latest/admin-guide/directory_simple_ad.html
//
// # DirectoryServicePricing pricing is based on
//
// > Hourly price based on the type and edition (only Microsoft AD) of the directory service directory
// > Additional hourly price added directory per account/vpc the directory is shared with (only Microsoft AD)
// > Costs for data transfer out (on a per-region basis)
//
// More information on pricing can be found here:
//
//	https://aws.amazon.com/directoryservice/pricing/
//	https://aws.amazon.com/directoryservice/other-directories-pricing/
type DirectoryServiceDirectory struct {
	// Address is the unique name of the resource in terraform/cloudfront.
	Address string
	// Region is the aws region the DirectoryServiceDirectory is provisioned within
	Region string
	// RegionName is the full region name used in product filters for the DirectoryService
	RegionName string

	// Type is the directory type. It can be one of (SimpleAD|ADConnector|MicrosoftAD)
	Type string
	// Edition is the edition of the MicrosoftAD type directory service. This field
	// is only applicable with MicrosoftAD and can either be (Standard|Enterprise).
	Edition string
	// The size of the directory, only applicable if the type is SimpleAD or ADConnector.
	// Values can be either (Small|Large)
	Size string

	// AdditionalDomainControllers represents a usage cost definition for the number controllers
	// above the default value (2) that are provisioned in this directory service.
	AdditionalDomainControllers *float64 `infracost_usage:"additional_domain_controllers"`

	// SharedAccounts represents the number of accounts/vpcs the directory is shared with.
	// This cost is only applicable if the type of directory is MicrosoftAD.
	// Directory Service sharing support is not supported by terraform aws at this time.
	// Therefore, this field is built from the usage cost file. An open issue referencing
	// shared directory support here: https://github.com/hashicorp/terraform-provider-aws/issues/6003
	SharedAccounts *float64 `infracost_usage:"shared_accounts"`
}

func (d *DirectoryServiceDirectory) CoreType() string {
	return "DirectoryServiceDirectory"
}

func (d *DirectoryServiceDirectory) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "additional_domain_controllers", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "shared_accounts", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.Usage into the DirectoryServiceDirectory.
// It uses the `infracost_usage` struct tags to populate data into the DirectoryServiceDirectory.
func (d *DirectoryServiceDirectory) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(d, u)
}

// BuildResource builds a schema.Resource from a valid DirectoryServiceDirectory.
func (d *DirectoryServiceDirectory) BuildResource() *schema.Resource {
	// set the size based on the type of resource.
	// MicrosoftAD uses edition in product filters under the directorySize attribute.
	size := d.Size
	if d.Type == dtMicrosoftAD {
		size = d.Edition
	}

	costComponents := []*schema.CostComponent{
		d.domainControllerCostComponent(
			2, // directory service provisions a minimum of 2 controllers
			fmt.Sprintf("Directory service (%s, %s)", d.Type, size),
			size,
		),
	}

	if d.AdditionalDomainControllers != nil {
		costComponents = append(
			costComponents,
			d.additionalDomainControllerCostComponent(*d.AdditionalDomainControllers, size),
		)
	}

	if d.SharedAccounts != nil && d.Type == dtMicrosoftAD {
		costComponents = append(costComponents, &schema.CostComponent{
			Name:           "Directory sharing",
			Unit:           "accounts",
			UnitMultiplier: schema.HourToMonthUnitMultiplier,
			HourlyQuantity: decimalPtr(decimal.NewFromFloat(*d.SharedAccounts)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    awsVendorFilter,
				Region:        strPtr(d.Region),
				Service:       directorySvcSvcFilter,
				ProductFamily: productFmlyFilter,
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "directorySize", Value: strPtr(size)},
					{Key: "directoryType", Value: strPtr("Shared " + d.Type)},
					{Key: "location", Value: strPtr(d.RegionName)},
				},
			},
			UsageBased: true,
		})
	}

	return &schema.Resource{
		Name:           d.Address,
		CostComponents: costComponents,
		UsageSchema:    d.UsageSchema(),
	}
}

func (d DirectoryServiceDirectory) domainControllerCostComponent(amount float64, name, size string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           name,
		Unit:           "controllers",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: decimalPtr(decimal.NewFromFloat(amount)),
		ProductFilter: &schema.ProductFilter{
			VendorName:       awsVendorFilter,
			Region:           strPtr(d.Region),
			Service:          directorySvcSvcFilter,
			ProductFamily:    productFmlyFilter,
			AttributeFilters: d.getAttributeFiltersForDirectory(size),
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
	}
}

func (d DirectoryServiceDirectory) additionalDomainControllerCostComponent(amount float64, size string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Additional domain controllers",
		Unit:           "controllers",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: decimalPtr(decimal.NewFromFloat(amount)),
		ProductFilter: &schema.ProductFilter{
			VendorName:       awsVendorFilter,
			Region:           strPtr(d.Region),
			Service:          directorySvcSvcFilter,
			ProductFamily:    productFmlyFilter,
			AttributeFilters: d.getAttributeFiltersForDirectory(size),
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (d DirectoryServiceDirectory) getAttributeFiltersForDirectory(size string) []*schema.AttributeFilter {
	if d.Type == dtMicrosoftAD {
		return []*schema.AttributeFilter{
			{Key: "directorySize", Value: strPtr(size)},
			{Key: "directoryType", Value: strPtr(d.Type)},
			{Key: "location", Value: strPtr(d.RegionName)},
		}
	}

	// Simple AD and AD Connector types have directoryType fields of "Shared AD or AD Connector"
	// depending on the size. Therefore, we'll build a regex to match one of the names.
	return []*schema.AttributeFilter{
		{Key: "directorySize", Value: strPtr(size)},
		{Key: "directoryType", ValueRegex: strPtr(fmt.Sprintf(`/%s/i`, strings.ReplaceAll(d.Type, " ", `\s`)))},
		{Key: "location", Value: strPtr(d.RegionName)},
	}
}

################################################################################
# FILE: internal/resources/aws/dms_replication_instance.go
# RESOURCE: aws_dms_replication_instance
# SIZE: 3374 bytes | LINES: 104
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type DMSReplicationInstance struct {
	Address                  string
	Region                   string
	AllocatedStorageGB       int64
	ReplicationInstanceClass string
	MultiAZ                  bool
}

func (r *DMSReplicationInstance) CoreType() string {
	return "DMSReplicationInstance"
}

func (r *DMSReplicationInstance) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *DMSReplicationInstance) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DMSReplicationInstance) BuildResource() *schema.Resource {
	instanceTypeParts := strings.Split(r.ReplicationInstanceClass, ".")
	if len(instanceTypeParts) < 3 {
		return &schema.Resource{
			Name:      r.Address,
			NoPrice:   true,
			IsSkipped: true,
		}
	}
	instanceType := strings.Join(instanceTypeParts[1:], ".")
	instanceFamily := instanceTypeParts[1]

	costComponents := make([]*schema.CostComponent, 0)
	costComponents = append(costComponents, r.instanceCostComponent(instanceType))
	costComponents = append(costComponents, r.storageCostComponent(instanceFamily))

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *DMSReplicationInstance) instanceCostComponent(instanceType string) *schema.CostComponent {
	availabilityZone := "Single"
	if r.MultiAZ {
		availabilityZone = "Multiple"
	}

	return &schema.CostComponent{
		Name:           fmt.Sprintf("Instance (%s)", instanceType),
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(r.Region),
			Service:    strPtr("AWSDatabaseMigrationSvc"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "instanceType", Value: strPtr(instanceType)},
				{Key: "availabilityZone", Value: strPtr(availabilityZone)},
			},
		},
	}
}

func (r *DMSReplicationInstance) storageCostComponent(instanceFamily string) *schema.CostComponent {
	availabilityZone := "Single"
	if r.MultiAZ {
		availabilityZone = "Multiple"
	}

	baseStorageSize := r.AllocatedStorageGB
	var freeStorageSize int64
	switch instanceFamily {
	case "c4":
		freeStorageSize = 100
	case "r4":
		freeStorageSize = 100
	case "r5":
		freeStorageSize = 100
	case "t2":
		freeStorageSize = 50
	case "t3":
		freeStorageSize = 50
	}
	var storageSize int64
	if baseStorageSize > freeStorageSize {
		storageSize = baseStorageSize - freeStorageSize
	}

	return &schema.CostComponent{
		Name:            "Storage (general purpose SSD, gp2)",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(storageSize)),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(r.Region),
			Service:    strPtr("AWSDatabaseMigrationSvc"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "storageMedia", Value: strPtr("SSD")},
				{Key: "availabilityZone", Value: strPtr(availabilityZone)},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/aws/docdb_cluster.go
# RESOURCE: aws_docdb_cluster
# SIZE: 1971 bytes | LINES: 58
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type DocDBCluster struct {
	Address               string
	Region                string
	BackupRetentionPeriod int64
	BackupStorageGB       *float64 `infracost_usage:"backup_storage_gb"`
}

func (r *DocDBCluster) CoreType() string {
	return "DocDBCluster"
}

func (r *DocDBCluster) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "backup_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *DocDBCluster) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DocDBCluster) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	if r.BackupRetentionPeriod > 1 {
		var backupStorage *decimal.Decimal
		if r.BackupStorageGB != nil {
			backupStorage = decimalPtr(decimal.NewFromFloat(*r.BackupStorageGB))
		}
		costComponents = append(costComponents, r.backupStorageCostComponent(backupStorage))
	} else {
		costComponents = append(costComponents, r.backupStorageCostComponent(nil))
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *DocDBCluster) backupStorageCostComponent(backupStorage *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Backup storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: backupStorage,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonDocDB"),
			ProductFamily: strPtr("Storage Snapshot"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(^|-)BackupUsage$")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/docdb_cluster_instance.go
# RESOURCE: aws_docdb_cluster_instance
# SIZE: 4301 bytes | LINES: 121
################################################################################
package aws

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type DocDBClusterInstance struct {
	Address             string
	Region              string
	InstanceClass       string
	DataStorageGB       *float64 `infracost_usage:"data_storage_gb"`
	MonthlyIORequests   *int64   `infracost_usage:"monthly_io_requests"`
	MonthlyCPUCreditHrs *int64   `infracost_usage:"monthly_cpu_credit_hrs"`
}

func (r *DocDBClusterInstance) CoreType() string {
	return "DocDBClusterInstance"
}

func (r *DocDBClusterInstance) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "data_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_io_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_cpu_credit_hrs", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *DocDBClusterInstance) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DocDBClusterInstance) BuildResource() *schema.Resource {
	var storageRate *decimal.Decimal
	if r.DataStorageGB != nil {
		storageRate = decimalPtr(decimal.NewFromFloat(*r.DataStorageGB))
	}

	var ioRequests *decimal.Decimal
	if r.MonthlyIORequests != nil {
		ioRequests = decimalPtr(decimal.NewFromInt(*r.MonthlyIORequests))
	}

	var cpuCredits *decimal.Decimal
	if r.MonthlyCPUCreditHrs != nil {
		cpuCredits = decimalPtr(decimal.NewFromInt(*r.MonthlyCPUCreditHrs))
	}

	costComponents := []*schema.CostComponent{
		{
			Name:           fmt.Sprintf("Database instance (%s, %s)", "on-demand", r.InstanceClass),
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonDocDB"),
				ProductFamily: strPtr("Database Instance"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "instanceType", Value: strPtr(r.InstanceClass)},
					{Key: "volumeType", Value: strPtr("General Purpose")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("on_demand"),
			},
		},
		{
			Name:            "Storage",
			Unit:            "GB",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: storageRate,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonDocDB"),
				ProductFamily: strPtr("Database Storage"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: regexPtr("(^|-)StorageUsage$")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("on_demand"),
			},
			UsageBased: true,
		},
		{
			Name:            "I/O requests",
			Unit:            "1M requests",
			UnitMultiplier:  decimal.NewFromInt(1000000),
			MonthlyQuantity: ioRequests,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonDocDB"),
				ProductFamily: strPtr("System Operation"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: regexPtr("(^|-)StorageIOUsage$")},
				},
			},
			UsageBased: true,
		},
	}

	if instanceFamily := getBurstableInstanceFamily([]string{"db.t3", "db.t4g"}, r.InstanceClass); instanceFamily != "" {
		costComponents = append(costComponents, &schema.CostComponent{
			Name:            "CPU credits",
			Unit:            "vCPU-hours",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: cpuCredits,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonDocDB"),
				ProductFamily: strPtr("CPU Credits"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: regexPtr("CPUCredits:" + instanceFamily + "$")},
				},
			},
			UsageBased: true,
		})
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/docdb_cluster_snapshot.go
# RESOURCE: aws_docdb_cluster_snapshot
# SIZE: 1259 bytes | LINES: 38
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type DocDBClusterSnapshot struct {
	Address         string
	Region          string
	BackupStorageGB *float64 `infracost_usage:"backup_storage_gb"`
}

func (r *DocDBClusterSnapshot) CoreType() string {
	return "DocDBClusterSnapshot"
}

func (r *DocDBClusterSnapshot) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "backup_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *DocDBClusterSnapshot) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DocDBClusterSnapshot) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	var backupStorage *decimal.Decimal
	if r.BackupStorageGB != nil {
		backupStorage = decimalPtr(decimal.NewFromFloat(*r.BackupStorageGB))
	}

	cluster := &DocDBCluster{
		Region: r.Region,
	}

	costComponents = append(costComponents, cluster.backupStorageCostComponent(backupStorage))

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/dx_connection.go
# RESOURCE: aws_dx_connection
# SIZE: 5461 bytes | LINES: 121
################################################################################
package aws

import (
	"fmt"
	"sort"
	"strings"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"

	"github.com/shopspring/decimal"
)

type DXConnection struct {
	Address                                         string
	Bandwidth                                       string
	Location                                        string
	Region                                          string
	MonthlyOutboundFromRegionToDXConnectionLocation *RegionsUsage `infracost_usage:"monthly_outbound_from_region_to_dx_connection_location"`
	MonthlyOutboundRegionToDxLocationGB             *float64      `infracost_usage:"monthly_outbound_region_to_dx_location_gb"`
	DxVirtualInterfaceType                          *string       `infracost_usage:"dx_virtual_interface_type"`
	DXConnectionType                                *string       `infracost_usage:"dx_connection_type"`
}

func (r *DXConnection) CoreType() string {
	return "DXConnection"
}

func (r *DXConnection) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{
			Key:          "monthly_outbound_from_region_to_dx_connection_location",
			ValueType:    schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "monthly_outbound_from_region_to_dx_connection_location", Items: RegionUsageSchema},
		},
		{Key: "monthly_outbound_region_to_dx_location_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "dx_virtual_interface_type", ValueType: schema.String, DefaultValue: "private"},
		{Key: "dx_connection_type", ValueType: schema.String, DefaultValue: "dedicated"},
	}
}

func (r *DXConnection) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DXConnection) BuildResource() *schema.Resource {
	components := []*schema.CostComponent{r.connectionComponent()}

	if r.MonthlyOutboundFromRegionToDXConnectionLocation != nil {
		regionUsages := r.MonthlyOutboundFromRegionToDXConnectionLocation.Values()
		sort.Slice(regionUsages, func(i, j int) bool {
			return regionUsages[i].Key < regionUsages[j].Key
		})

		for _, regionUsage := range regionUsages {
			dataProcessedGB := decimalPtr(decimal.NewFromFloat(regionUsage.Value))
			outboundDataTransferComponent := r.outboundDataTransferComponent(regionUsage.Key, dataProcessedGB)

			if outboundDataTransferComponent != nil {
				components = append(components, outboundDataTransferComponent)
			}
		}
	}

	if r.MonthlyOutboundFromRegionToDXConnectionLocation == nil && r.MonthlyOutboundRegionToDxLocationGB != nil {
		dataProcessedGB := decimalPtr(decimal.NewFromFloat(*r.MonthlyOutboundRegionToDxLocationGB))
		outboundDataTransferComponent := r.outboundDataTransferComponent(r.Region, dataProcessedGB)

		if outboundDataTransferComponent != nil {
			components = append(components, outboundDataTransferComponent)
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: components,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *DXConnection) connectionComponent() *schema.CostComponent {
	bandwidth := strings.Replace(r.Bandwidth, "bps", "", 1)

	connectionType := "dedicated"
	if r.DXConnectionType != nil {
		connectionType = *r.DXConnectionType
	}

	return &schema.CostComponent{
		Name:           "DX connection",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSDirectConnect"),
			ProductFamily: strPtr("Direct Connect"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "capacity", Value: strPtr(bandwidth)},
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/", r.Location))},
				{Key: "connectionType", ValueRegex: strPtr(fmt.Sprintf("/%s/i", connectionType))},
			},
		},
	}
}

func (r *DXConnection) outboundDataTransferComponent(fromRegion string, dataProcessedGB *decimal.Decimal) *schema.CostComponent {
	virtualInterfaceType := "private"
	if r.DxVirtualInterfaceType != nil {
		virtualInterfaceType = *r.DxVirtualInterfaceType
	}

	fromLocation, ok := RegionMapping[fromRegion]
	if !ok {
		// This shouldn't happen because we're loading the regions into the RegionsUsage struct
		// which should have same keys as the RegionMappings map
		logging.Logger.Warn().Msgf("Skipping resource %s usage cost: Outbound data transfer. Could not find mapping for region %s", r.Address, fromRegion)
		return nil
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Outbound data transfer (from %s, to %s)", fromRegion, r.Location),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: dataProcessedGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Service:       strPtr("AWSDirectConnect"),
			ProductFamily: strPtr("Data Transfer"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "fromLocation", Value: strPtr(fromLocation)},
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s-DataXfer-Out/", r.Location))},
				{Key: "virtualInterfaceType", ValueRegex: strPtr(fmt.Sprintf("/%s/i", virtualInterfaceType))},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/dx_gateway_association.go
# RESOURCE: aws_dx_gateway_association
# SIZE: 1436 bytes | LINES: 38
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type DXGatewayAssociation struct {
	Address                 string
	Region                  string
	AssociatedGatewayRegion string
	MonthlyDataProcessedGB  *float64 `infracost_usage:"monthly_data_processed_gb"`
}

func (r *DXGatewayAssociation) CoreType() string {
	return "DXGatewayAssociation"
}

func (r *DXGatewayAssociation) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_data_processed_gb", ValueType: schema.Float64, DefaultValue: 0}}
}

func (r *DXGatewayAssociation) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DXGatewayAssociation) BuildResource() *schema.Resource {
	region := r.Region

	if r.AssociatedGatewayRegion != "" {
		region = r.AssociatedGatewayRegion
	}

	var gbDataProcessed *decimal.Decimal

	if r.MonthlyDataProcessedGB != nil {
		gbDataProcessed = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataProcessedGB))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			transitGatewayDataProcessingCostComponent(region, "TransitGatewayDirectConnect", gbDataProcessed),
			transitGatewayAttachmentCostComponent(region, "TransitGatewayDirectConnect"),
		}, UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/dynamodb_table.go
# RESOURCE: aws_dynamodb_table
# SIZE: 15618 bytes | LINES: 417
################################################################################
package aws

import (
	"context"
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage/aws"
)

type DynamoDBTable struct {
	// "required" args that can't really be missing.
	Address        string
	Region         string
	Name           string
	BillingMode    string
	ReplicaRegions []string

	// "optional" args, that may be empty depending on the resource config
	WriteCapacity *int64
	ReadCapacity  *int64

	AppAutoscalingTarget       []*AppAutoscalingTarget
	PointInTimeRecoveryEnabled bool

	// "usage" args
	MonthlyWriteRequestUnits       *int64 `infracost_usage:"monthly_write_request_units"`
	MonthlyReadRequestUnits        *int64 `infracost_usage:"monthly_read_request_units"`
	StorageGB                      *int64 `infracost_usage:"storage_gb"`
	PitrBackupStorageGB            *int64 `infracost_usage:"pitr_backup_storage_gb"`
	OnDemandBackupStorageGB        *int64 `infracost_usage:"on_demand_backup_storage_gb"`
	MonthlyDataRestoredGB          *int64 `infracost_usage:"monthly_data_restored_gb"`
	MonthlyStreamsReadRequestUnits *int64 `infracost_usage:"monthly_streams_read_request_units"`
}

func (a *DynamoDBTable) CoreType() string {
	return "DynamoDBTable"
}

func (a *DynamoDBTable) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_write_request_units", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_read_request_units", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "storage_gb", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "pitr_backup_storage_gb", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "on_demand_backup_storage_gb", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_data_restored_gb", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_streams_read_request_units", DefaultValue: 0, ValueType: schema.Int64},
	}
}

func (a *DynamoDBTable) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(a, u)
}

func (a *DynamoDBTable) BuildResource() *schema.Resource {

	costComponents := make([]*schema.CostComponent, 0)
	subResources := make([]*schema.Resource, 0)

	if a.BillingMode == "PROVISIONED" {
		var wcuAutoscaling, rcuAutoscaling bool
		wcu := a.WriteCapacity
		rcu := a.ReadCapacity

		for _, target := range a.AppAutoscalingTarget {
			switch target.ScalableDimension {
			case "dynamodb:table:WriteCapacityUnits":
				wcuAutoscaling = true
				if target.Capacity != nil {
					wcu = target.Capacity
				} else {
					wcu = &target.MinCapacity
				}
			case "dynamodb:table:ReadCapacityUnits":
				rcuAutoscaling = true
				if target.Capacity != nil {
					rcu = target.Capacity
				} else {
					rcu = &target.MinCapacity
				}
			}
		}
		// Write capacity units (WCU)
		costComponents = append(costComponents, a.wcuCostComponent(a.Region, wcu, wcuAutoscaling))
		// Read capacity units (RCU)
		costComponents = append(costComponents, a.rcuCostComponent(a.Region, rcu, rcuAutoscaling))
	}

	// Infracost usage data

	if a.BillingMode == "PAY_PER_REQUEST" {
		// Write request units (WRU)
		costComponents = append(costComponents, a.wruCostComponent(a.Region, a.MonthlyWriteRequestUnits))
		// Read request units (RRU)
		costComponents = append(costComponents, a.rruCostComponent(a.Region, a.MonthlyReadRequestUnits))
	}

	// Data storage
	costComponents = append(costComponents, a.dataStorageCostComponent(a.Region, a.StorageGB))
	// Continuous backups (PITR)
	if a.PointInTimeRecoveryEnabled {
		costComponents = append(costComponents, a.continuousBackupCostComponent(a.Region, a.PitrBackupStorageGB))
	}

	// OnDemand backups
	costComponents = append(costComponents, a.onDemandBackupCostComponent(a.Region, a.OnDemandBackupStorageGB))
	// Restoring tables
	costComponents = append(costComponents, a.restoreCostComponent(a.Region, a.MonthlyDataRestoredGB))

	// Stream reads
	costComponents = append(costComponents, a.streamCostComponent(a.Region, a.MonthlyStreamsReadRequestUnits))

	// Global tables (replica)
	subResources = append(subResources, a.globalTables(a.BillingMode, a.ReplicaRegions, a.WriteCapacity, a.MonthlyWriteRequestUnits)...)

	estimate := func(ctx context.Context, values map[string]interface{}) error {
		storageB, err := aws.DynamoDBGetStorageBytes(ctx, a.Region, a.Name)
		if err != nil {
			return err
		}
		values["storage_gb"] = asGiB(storageB)

		if a.BillingMode == "PAY_PER_REQUEST" {
			reads, err := aws.DynamoDBGetRRU(ctx, a.Region, a.Name)
			if err != nil {
				return err
			}
			writes, err := aws.DynamoDBGetWRU(ctx, a.Region, a.Name)
			if err != nil {
				return err
			}
			values["monthly_read_request_units"] = ceil64(reads)
			values["monthly_write_request_units"] = ceil64(writes)
		}
		return nil
	}

	return &schema.Resource{
		Name:           a.Address,
		UsageSchema:    a.UsageSchema(),
		EstimateUsage:  estimate,
		CostComponents: costComponents,
		SubResources:   subResources,
	}
}

func (a *DynamoDBTable) wcuCostComponent(region string, provisionedWCU *int64, autoscaling bool) *schema.CostComponent {
	name := "Write capacity unit (WCU)"
	if autoscaling {
		name = "Write capacity unit (WCU, autoscaling)"
	}

	var quantity *decimal.Decimal
	if provisionedWCU != nil {
		quantity = decimalPtr(decimal.NewFromInt(*provisionedWCU))
	}
	return &schema.CostComponent{
		Name:           name,
		Unit:           "WCU",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(region),
			Service:       strPtr("AmazonDynamoDB"),
			ProductFamily: strPtr("Provisioned IOPS"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "group", Value: strPtr("DDB-WriteUnits")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("on_demand"),
			DescriptionRegex: regexPtr("^(?!.*\\(free tier\\)).*$"),
		},
		UsageBased: autoscaling,
	}
}

func (a *DynamoDBTable) rcuCostComponent(region string, provisionedRCU *int64, autoscaling bool) *schema.CostComponent {
	name := "Read capacity unit (RCU)"
	if autoscaling {
		name = "Read capacity unit (RCU, autoscaling)"
	}

	var quantity *decimal.Decimal
	if provisionedRCU != nil {
		quantity = decimalPtr(decimal.NewFromInt(*provisionedRCU))
	}
	return &schema.CostComponent{
		Name:           name,
		Unit:           "RCU",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(region),
			Service:       strPtr("AmazonDynamoDB"),
			ProductFamily: strPtr("Provisioned IOPS"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "group", Value: strPtr("DDB-ReadUnits")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("on_demand"),
			DescriptionRegex: regexPtr("^(?!.*\\(free tier\\)).*$"),
		},
		UsageBased: autoscaling,
	}
}

func (a *DynamoDBTable) globalTables(billingMode string, replicaRegions []string, writeCapacity *int64, monthlyWRU *int64) []*schema.Resource {
	resources := make([]*schema.Resource, 0)

	for _, region := range replicaRegions {
		name := fmt.Sprintf("Global table (%s)", region)
		if billingMode == "PROVISIONED" {
			resources = append(resources, a.newProvisionedDynamoDBGlobalTable(name, region, writeCapacity))
		} else if billingMode == "PAY_PER_REQUEST" {
			resources = append(resources, a.newOnDemandDynamoDBGlobalTable(name, region, monthlyWRU))
		}
	}

	return resources
}

func (a *DynamoDBTable) newProvisionedDynamoDBGlobalTable(name string, region string, provisionedWCU *int64) *schema.Resource {
	var quantity *decimal.Decimal
	if provisionedWCU != nil {
		quantity = decimalPtr(decimal.NewFromInt(*provisionedWCU))
	}

	return &schema.Resource{
		Name: name,
		CostComponents: []*schema.CostComponent{
			// Replicated write capacity units (rWCU)
			{
				Name:           "Replicated write capacity unit (rWCU)",
				Unit:           "rWCU",
				UnitMultiplier: schema.HourToMonthUnitMultiplier,
				HourlyQuantity: quantity,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(region),
					Service:       strPtr("AmazonDynamoDB"),
					ProductFamily: strPtr("DDB-Operation-ReplicatedWrite"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "group", Value: strPtr("DDB-ReplicatedWriteUnits")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					PurchaseOption:   strPtr("on_demand"),
					DescriptionRegex: regexPtr("^(?!.*\\(free tier\\)).*$"),
				},
			},
		},
	}
}

func (a *DynamoDBTable) newOnDemandDynamoDBGlobalTable(name string, region string, monthlyWRU *int64) *schema.Resource {
	var quantity *decimal.Decimal
	if monthlyWRU != nil {
		quantity = decimalPtr(decimal.NewFromInt(*monthlyWRU))
	}
	return &schema.Resource{
		Name: name,
		CostComponents: []*schema.CostComponent{
			// Replicated write capacity units (rWRU)
			{
				Name:            "Replicated write request unit (rWRU)",
				Unit:            "rWRU",
				UnitMultiplier:  schema.HourToMonthUnitMultiplier,
				MonthlyQuantity: quantity,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(region),
					Service:       strPtr("AmazonDynamoDB"),
					ProductFamily: strPtr("Amazon DynamoDB PayPerRequest Throughput"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "group", Value: strPtr("DDB-ReplicatedWriteUnits")},
					},
				},
			},
		},
	}
}

func (a *DynamoDBTable) wruCostComponent(region string, monthlyWRU *int64) *schema.CostComponent {
	var quantity *decimal.Decimal
	if monthlyWRU != nil {
		quantity = decimalPtr(decimal.NewFromInt(*monthlyWRU))
	}
	return &schema.CostComponent{
		Name:            "Write request unit (WRU)",
		Unit:            "WRUs",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(region),
			Service:       strPtr("AmazonDynamoDB"),
			ProductFamily: strPtr("Amazon DynamoDB PayPerRequest Throughput"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "group", Value: strPtr("DDB-WriteUnits")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (a *DynamoDBTable) rruCostComponent(region string, monthlyRRU *int64) *schema.CostComponent {
	var quantity *decimal.Decimal
	if monthlyRRU != nil {
		quantity = decimalPtr(decimal.NewFromInt(*monthlyRRU))
	}
	return &schema.CostComponent{
		Name:            "Read request unit (RRU)",
		Unit:            "RRUs",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(region),
			Service:       strPtr("AmazonDynamoDB"),
			ProductFamily: strPtr("Amazon DynamoDB PayPerRequest Throughput"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "group", Value: strPtr("DDB-ReadUnits")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (a *DynamoDBTable) dataStorageCostComponent(region string, storageGB *int64) *schema.CostComponent {
	var quantity *decimal.Decimal
	if storageGB != nil {
		quantity = decimalPtr(decimal.NewFromInt(*storageGB))
	}
	return &schema.CostComponent{
		Name:            "Data storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(region),
			Service:       strPtr("AmazonDynamoDB"),
			ProductFamily: strPtr("Database Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(?<!IA-)TimedStorage-ByteHrs$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("on_demand"),
			DescriptionRegex: regexPtr("^(?!.*\\$0.00 per GB-Month).*$"),
		},
		UsageBased: true,
	}
}

func (a *DynamoDBTable) continuousBackupCostComponent(region string, pitrBackupStorageGB *int64) *schema.CostComponent {
	var quantity *decimal.Decimal
	if pitrBackupStorageGB != nil {
		quantity = decimalPtr(decimal.NewFromInt(*pitrBackupStorageGB))
	}
	return &schema.CostComponent{
		Name:            "Point-In-Time Recovery (PITR) backup storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(region),
			Service:       strPtr("AmazonDynamoDB"),
			ProductFamily: strPtr("Database Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/TimedPITRStorage-ByteHrs/")},
			},
		},
		UsageBased: true,
	}
}

func (a *DynamoDBTable) onDemandBackupCostComponent(region string, onDemandBackupStorageGB *int64) *schema.CostComponent {
	var quantity *decimal.Decimal
	if onDemandBackupStorageGB != nil {
		quantity = decimalPtr(decimal.NewFromInt(*onDemandBackupStorageGB))
	}
	return &schema.CostComponent{
		Name:            "On-demand backup storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(region),
			Service:       strPtr("AmazonDynamoDB"),
			ProductFamily: strPtr("Amazon DynamoDB On-Demand Backup Storage"),
		},
		UsageBased: true,
	}
}

func (a *DynamoDBTable) restoreCostComponent(region string, monthlyDataRestoredGB *int64) *schema.CostComponent {
	var quantity *decimal.Decimal
	if monthlyDataRestoredGB != nil {
		quantity = decimalPtr(decimal.NewFromInt(*monthlyDataRestoredGB))
	}
	return &schema.CostComponent{
		Name:            "Table data restored",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(region),
			Service:       strPtr("AmazonDynamoDB"),
			ProductFamily: strPtr("Amazon DynamoDB Restore Data Size"),
		},
		UsageBased: true,
	}
}

func (a *DynamoDBTable) streamCostComponent(region string, monthlyStreamsRRU *int64) *schema.CostComponent {
	var quantity *decimal.Decimal
	if monthlyStreamsRRU != nil {
		quantity = decimalPtr(decimal.NewFromInt(*monthlyStreamsRRU))
	}
	return &schema.CostComponent{
		Name:            "Streams read request unit (sRRU)",
		Unit:            "sRRUs",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(region),
			Service:       strPtr("AmazonDynamoDB"),
			ProductFamily: strPtr("API Request"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "group", ValueRegex: strPtr("/DDB-StreamsReadRequests/")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			DescriptionRegex: regexPtr("^(?!.*\\(free tier\\)).*$"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/ebs_snapshot.go
# RESOURCE: aws_ebs_snapshot
# SIZE: 5294 bytes | LINES: 135
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type EBSSnapshot struct {
	Address                  string
	Region                   string
	SizeGB                   *float64
	MonthlyListBlockRequests *int64 `infracost_usage:"monthly_list_block_requests"`
	MonthlyGetBlockRequests  *int64 `infracost_usage:"monthly_get_block_requests"`
	MonthlyPutBlockRequests  *int64 `infracost_usage:"monthly_put_block_requests"`
	FastSnapshotRestoreHours *int64 `infracost_usage:"fast_snapshot_restore_hours"`
}

func (r *EBSSnapshot) CoreType() string {
	return "EBSSnapshot"
}

func (r *EBSSnapshot) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_list_block_requests", ValueType: schema.Int64, DefaultValue: 0}, {Key: "monthly_get_block_requests", ValueType: schema.Int64, DefaultValue: 0}, {Key: "monthly_put_block_requests", ValueType: schema.Int64, DefaultValue: 0}, {Key: "fast_snapshot_restore_hours", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *EBSSnapshot) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *EBSSnapshot) BuildResource() *schema.Resource {
	region := r.Region

	gbVal := decimal.NewFromFloat(float64(defaultVolumeSize))

	if r.SizeGB != nil {
		gbVal = decimal.NewFromFloat(*r.SizeGB)
	}

	var listBlockRequests *decimal.Decimal
	if r.MonthlyListBlockRequests != nil {
		listBlockRequests = decimalPtr(decimal.NewFromInt(*r.MonthlyListBlockRequests))
	}

	var getSnapshotBlockRequests *decimal.Decimal
	if r.MonthlyGetBlockRequests != nil {
		getSnapshotBlockRequests = decimalPtr(decimal.NewFromInt(*r.MonthlyGetBlockRequests))
	}

	var putSnapshotBlockRequests *decimal.Decimal
	if r.MonthlyPutBlockRequests != nil {
		putSnapshotBlockRequests = decimalPtr(decimal.NewFromInt(*r.MonthlyPutBlockRequests))
	}

	var fastSnapshotRestoreHours *decimal.Decimal
	if r.MonthlyPutBlockRequests != nil {
		fastSnapshotRestoreHours = decimalPtr(decimal.NewFromInt(*r.FastSnapshotRestoreHours))
	}

	costComponents := []*schema.CostComponent{
		ebsSnapshotCostComponent(region, gbVal),
		{
			Name:            "Fast snapshot restore",
			Unit:            "DSU-hours",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: fastSnapshotRestoreHours,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(region),
				Service:       strPtr("AmazonEC2"),
				ProductFamily: strPtr("Fast Snapshot Restore"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: strPtr("/EBS:FastSnapshotRestore$/")},
				},
			},
			UsageBased: true,
		},
		{
			Name:            "ListChangedBlocks & ListSnapshotBlocks API requests",
			Unit:            "1k requests",
			UnitMultiplier:  decimal.NewFromInt(1000),
			MonthlyQuantity: listBlockRequests,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(region),
				Service:       strPtr("AmazonEC2"),
				ProductFamily: strPtr("EBS direct API Requests"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: strPtr("/EBS:directAPI.snapshot.List$/")},
				},
			},
			UsageBased: true,
		},
		{
			Name:            "GetSnapshotBlock API requests",
			Unit:            "1k SnapshotAPIUnits",
			UnitMultiplier:  decimal.NewFromInt(1000),
			MonthlyQuantity: getSnapshotBlockRequests,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(region),
				Service:       strPtr("AmazonEC2"),
				ProductFamily: strPtr("EBS direct API Requests"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: strPtr("/EBS:directAPI.snapshot.Get$/")},
				},
			},
			UsageBased: true,
		},
		{
			Name:            "PutSnapshotBlock API requests",
			Unit:            "1k SnapshotAPIUnits",
			UnitMultiplier:  decimal.NewFromInt(1000),
			MonthlyQuantity: putSnapshotBlockRequests,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(region),
				Service:       strPtr("AmazonEC2"),
				ProductFamily: strPtr("EBS direct API Requests"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: strPtr("/EBS:directAPI.snapshot.Put$/")},
				},
			},
			UsageBased: true,
		}}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents, UsageSchema: r.UsageSchema(),
	}
}

func ebsSnapshotCostComponent(region string, gbVal decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "EBS snapshot storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: &gbVal,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(region),
			Service:       strPtr("AmazonEC2"),
			ProductFamily: strPtr("Storage Snapshot"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/EBS:SnapshotUsage$/")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/ebs_snapshot_copy.go
# RESOURCE: aws_ebs_snapshot_copy
# SIZE: 992 bytes | LINES: 35
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type EBSSnapshotCopy struct {
	Address string
	Region  string
	SizeGB  *float64
}

func (r *EBSSnapshotCopy) CoreType() string {
	return "EBSSnapshotCopy"
}

func (r *EBSSnapshotCopy) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *EBSSnapshotCopy) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *EBSSnapshotCopy) BuildResource() *schema.Resource {
	region := r.Region

	gbVal := decimal.NewFromInt(int64(defaultVolumeSize))

	if r.SizeGB != nil {
		gbVal = decimal.NewFromFloat(*r.SizeGB)
	}

	costComponents := []*schema.CostComponent{
		ebsSnapshotCostComponent(region, gbVal),
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/ebs_volume.go
# RESOURCE: aws_ebs_volume
# SIZE: 5736 bytes | LINES: 163
################################################################################
package aws

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

var defaultVolumeSize = int64(8)

type EBSVolume struct {
	// "required" args that can't really be missing.
	Address    string
	Region     string
	Type       string
	IOPS       int64
	Throughput int64

	// "optional" args that can be empty strings.
	Size *int64

	// "usage" args
	MonthlyStandardIORequests *int64 `infracost_usage:"monthly_standard_io_requests"`
}

func (a *EBSVolume) CoreType() string {
	return "EBSVolume"
}

func (a *EBSVolume) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_standard_io_requests", DefaultValue: 0, ValueType: schema.Int64},
	}
}

func (a *EBSVolume) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(a, u)
}

func (a *EBSVolume) BuildResource() *schema.Resource {
	if a.Type == "" {
		a.Type = "gp2"
	}

	costComponents := make([]*schema.CostComponent, 0)
	subResources := make([]*schema.Resource, 0)

	costComponents = append(costComponents, a.storageCostComponent())

	if strings.ToLower(a.Type) == "gp3" && a.Throughput > 125 {
		costComponents = append(costComponents, a.provisionedThroughputCostComponent())
	}

	if strings.ToLower(a.Type) == "io1" {
		costComponents = append(costComponents, a.provisionedIOPSCostComponent("EBS:VolumeP-IOPS.piops", a.IOPS))
	} else if strings.ToLower(a.Type) == "io2" {
		costComponents = append(costComponents, a.provisionedIOPSCostComponent("EBS:VolumeP-IOPS.io2$", a.IOPS))
	} else if strings.ToLower(a.Type) == "gp3" && a.IOPS > 3000 {
		costComponents = append(costComponents, a.provisionedIOPSCostComponent("VolumeP-IOPS.gp3", a.IOPS-3000))
	}

	if strings.ToLower(a.Type) == "standard" {
		costComponents = append(costComponents, a.ioRequestsCostComponent())
	}

	return &schema.Resource{
		Name:           a.Address,
		UsageSchema:    a.UsageSchema(),
		CostComponents: costComponents,
		SubResources:   subResources,
	}
}

func (a *EBSVolume) storageCostComponent() *schema.CostComponent {
	size := defaultVolumeSize
	if a.Size != nil {
		size = *a.Size
	}

	var name string
	switch strings.ToLower(a.Type) {
	case "standard":
		name = "Storage (magnetic)"
	case "io1":
		name = "Storage (provisioned IOPS SSD, io1)"
	case "io2":
		name = "Storage (provisioned IOPS SSD, io2)"
	case "st1":
		name = "Storage (throughput optimized HDD, st1)"
	case "sc1":
		name = "Storage (cold HDD, sc1)"
	case "gp3":
		name = "Storage (general purpose SSD, gp3)"
	case "gp2":
		name = "Storage (general purpose SSD, gp2)"
	default:
		name = "Storage (unknown)"
	}

	return &schema.CostComponent{
		Name:            name,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(size)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(a.Region),
			Service:       strPtr("AmazonEC2"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "volumeApiName", ValueRegex: strPtr(fmt.Sprintf("/%s/i", a.Type))},
			},
		},
	}
}

func (a *EBSVolume) provisionedIOPSCostComponent(usageType string, iops int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Provisioned IOPS",
		Unit:            "IOPS",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(iops)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(a.Region),
			Service:       strPtr("AmazonEC2"),
			ProductFamily: strPtr("System Operation"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "volumeApiName", ValueRegex: strPtr(fmt.Sprintf("/%s/i", a.Type))},
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", usageType))},
			},
		},
	}
}

func (a *EBSVolume) ioRequestsCostComponent() *schema.CostComponent {
	var qty *decimal.Decimal
	if a.MonthlyStandardIORequests != nil {
		qty = decimalPtr(decimal.NewFromInt(*a.MonthlyStandardIORequests))
	}

	return &schema.CostComponent{
		Name:            "I/O requests",
		Unit:            "1M request",
		UnitMultiplier:  decimal.NewFromInt(1000000),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(a.Region),
			Service:       strPtr("AmazonEC2"),
			ProductFamily: strPtr("System Operation"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "volumeApiName", ValueRegex: strPtr(fmt.Sprintf("/%s/i", a.Type))},
				{Key: "usagetype", ValueRegex: strPtr("/EBS:VolumeIOUsage/i")},
			},
		},
		UsageBased: true,
	}
}

func (a *EBSVolume) provisionedThroughputCostComponent() *schema.CostComponent {
	qty := decimal.NewFromInt(a.Throughput - 125)
	qty = qty.Div(decimal.NewFromInt(1024))

	return &schema.CostComponent{
		Name:            "Provisioned throughput",
		Unit:            "Mbps",
		UnitMultiplier:  decimal.NewFromFloat(1.0 / 1024.0),
		MonthlyQuantity: decimalPtr(qty),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(a.Region),
			Service:       strPtr("AmazonEC2"),
			ProductFamily: strPtr("Provisioned Throughput"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "volumeApiName", ValueRegex: strPtr(fmt.Sprintf("/%s/i", a.Type))},
				{Key: "usagetype", ValueRegex: strPtr("/VolumeP-Throughput.gp3/")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			Unit: strPtr("GiBps-mo"),
		},
	}
}

################################################################################
# FILE: internal/resources/aws/ec2_client_vpn_endpoint.go
# RESOURCE: aws_ec2_client_vpn_endpoint
# SIZE: 1232 bytes | LINES: 41
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type EC2ClientVPNEndpoint struct {
	Address string
	Region  string
}

func (r *EC2ClientVPNEndpoint) CoreType() string {
	return "EC2ClientVPNEndpoint"
}

func (r *EC2ClientVPNEndpoint) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *EC2ClientVPNEndpoint) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *EC2ClientVPNEndpoint) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:           "Connection",
				Unit:           "hours",
				UnitMultiplier: decimal.NewFromInt(1),
				HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName: strPtr("aws"),
					Region:     strPtr(r.Region),
					Service:    strPtr("AmazonVPC"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/ClientVPN-ConnectionHours/")},
					},
				},
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/ec2_client_vpn_network_association.go
# RESOURCE: aws_ec2_client_vpn_network_association
# SIZE: 1300 bytes | LINES: 41
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type EC2ClientVPNNetworkAssociation struct {
	Address string
	Region  string
}

func (r *EC2ClientVPNNetworkAssociation) CoreType() string {
	return "EC2ClientVPNNetworkAssociation"
}

func (r *EC2ClientVPNNetworkAssociation) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *EC2ClientVPNNetworkAssociation) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *EC2ClientVPNNetworkAssociation) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:           "Endpoint association",
				Unit:           "hours",
				UnitMultiplier: decimal.NewFromInt(1),
				HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName: strPtr("aws"),
					Region:     strPtr(r.Region),
					Service:    strPtr("AmazonVPC"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/ClientVPN-EndpointHours/")},
					},
				},
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/ec2_host.go
# RESOURCE: aws_ec2_host
# SIZE: 4574 bytes | LINES: 118
################################################################################
package aws

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// EC2Host defines an AWS EC2 dedicated host. It supports multiple instance families & allows
// you to run workloads on a physical server dedicated for your use. You can use on-demand or
// reservation pricing.
//
// See more resource information here: https://aws.amazon.com/ec2/dedicated-hosts/
//
// See the pricing information here: https://aws.amazon.com/ec2/dedicated-hosts/pricing/
type EC2Host struct {
	Address                       string
	Region                        string
	InstanceType                  string
	InstanceFamily                string
	ReservedInstanceTerm          *string `infracost_usage:"reserved_instance_term"`
	ReservedInstancePaymentOption *string `infracost_usage:"reserved_instance_payment_option"`
}

func (r *EC2Host) CoreType() string {
	return "EC2Host"
}

func (r *EC2Host) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "reserved_instance_term", DefaultValue: "", ValueType: schema.String},
		{Key: "reserved_instance_payment_option", DefaultValue: "", ValueType: schema.String},
	}
}

func (r *EC2Host) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *EC2Host) BuildResource() *schema.Resource {
	purchaseOptionLabel := "on-demand"
	priceFilter := &schema.PriceFilter{
		PurchaseOption: strPtr("on_demand"),
	}

	var err error
	if r.ReservedInstanceTerm != nil {
		resolver := &ec2HostReservationResolver{
			term:          strVal(r.ReservedInstanceTerm),
			paymentOption: strVal(r.ReservedInstancePaymentOption),
		}

		priceFilter, err = resolver.PriceFilter()

		if err != nil {
			logging.Logger.Warn().Msg(err.Error())
		}

		purchaseOptionLabel = "reserved"
	}

	instanceFamily := r.InstanceFamily

	if r.InstanceType != "" {
		split := strings.Split(r.InstanceType, ".")
		if len(split) > 0 {
			instanceFamily = split[0]
		}
	}

	hostPurchaseType := "HostUsage"

	if purchaseOptionLabel == "reserved" {
		hostPurchaseType = "ReservedHostUsage"
	}

	hostAttributeFilters := []*schema.AttributeFilter{
		{Key: "usagetype", ValueRegex: regexPtr(fmt.Sprintf("%s:%s$", hostPurchaseType, instanceFamily))},
	}

	costComponents := []*schema.CostComponent{
		{
			Name:           fmt.Sprintf("EC2 Dedicated Host (%s, %s)", purchaseOptionLabel, instanceFamily),
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: &schema.ProductFilter{
				VendorName:       strPtr("aws"),
				Region:           strPtr(r.Region),
				Service:          strPtr("AmazonEC2"),
				ProductFamily:    strPtr("Dedicated Host"),
				AttributeFilters: hostAttributeFilters,
			},
			PriceFilter: priceFilter,
		},
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

type ec2HostReservationResolver struct {
	term          string
	paymentOption string
}

// PriceFilter implementation for ec2HostReservationResolver
// Allowed values for ReservedInstanceTerm: ["1_year", "3_year"]
// Allowed values for ReservedInstancePaymentOption: ["all_upfront", "partial_upfront", "no_upfront"]
func (r ec2HostReservationResolver) PriceFilter() (*schema.PriceFilter, error) {
	purchaseOptionLabel := "reserved"
	def := &schema.PriceFilter{
		PurchaseOption: strPtr(purchaseOptionLabel),
	}
	termLength := reservedTermsMapping[r.term]
	purchaseOption := reservedHostPaymentOptionMapping[r.paymentOption]
	validTerms := sliceOfKeysFromMap(reservedTermsMapping)
	if !stringInSlice(validTerms, r.term) {
		return def, fmt.Errorf("Invalid reserved_instance_term, ignoring reserved options. Expected: %s. Got: %s", strings.Join(validTerms, ", "), r.term)
	}
	validOptions := sliceOfKeysFromMap(reservedPaymentOptionMapping)

	if !stringInSlice(validOptions, r.paymentOption) {
		return def, fmt.Errorf("Invalid reserved_instance_payment_option, ignoring reserved options. Expected: %s. Got: %s", strings.Join(validOptions, ", "), r.paymentOption)
	}
	return &schema.PriceFilter{
		PurchaseOption:     strPtr(purchaseOptionLabel),
		StartUsageAmount:   strPtr("0"),
		TermLength:         strPtr(termLength),
		TermPurchaseOption: strPtr(purchaseOption),
	}, nil
}

################################################################################
# FILE: internal/resources/aws/ec2_traffic_mirror_session.go
# RESOURCE: aws_ec2_traffic_mirror_session
# SIZE: 1239 bytes | LINES: 41
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type EC2TrafficMirrorSession struct {
	Address string
	Region  string
}

func (r *EC2TrafficMirrorSession) CoreType() string {
	return "EC2TrafficMirrorSession"
}

func (r *EC2TrafficMirrorSession) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *EC2TrafficMirrorSession) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *EC2TrafficMirrorSession) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:           "Traffic mirror",
				Unit:           "hours",
				UnitMultiplier: decimal.NewFromInt(1),
				HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName: strPtr("aws"),
					Region:     strPtr(r.Region),
					Service:    strPtr("AmazonVPC"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/ENI-Mirror/")},
					},
				},
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/ec2_transit_gateway_peering_attachment.go
# RESOURCE: aws_ec2_transit_gateway_peering_attachment
# SIZE: 1032 bytes | LINES: 31
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type EC2TransitGatewayPeeringAttachment struct {
	Address              string
	Region               string
	TransitGatewayRegion string
}

func (r *EC2TransitGatewayPeeringAttachment) CoreType() string {
	return "EC2TransitGatewayPeeringAttachment"
}

func (r *EC2TransitGatewayPeeringAttachment) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *EC2TransitGatewayPeeringAttachment) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *EC2TransitGatewayPeeringAttachment) BuildResource() *schema.Resource {
	region := r.Region
	if r.TransitGatewayRegion != "" {
		region = r.TransitGatewayRegion
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			transitGatewayAttachmentCostComponent(region, "TransitGatewayPeering"),
		}, UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/ec2_transit_gateway_vpc_attachment.go
# RESOURCE: aws_ec2_transit_gateway_vpc_attachment
# SIZE: 2863 bytes | LINES: 77
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type Ec2TransitGatewayVpcAttachment struct {
	Address                string
	Region                 string
	VPCRegion              string
	TransitGatewayRegion   string
	MonthlyDataProcessedGB *float64 `infracost_usage:"monthly_data_processed_gb"`
}

func (r *Ec2TransitGatewayVpcAttachment) CoreType() string {
	return "Ec2TransitGatewayVpcAttachment"
}

func (r *Ec2TransitGatewayVpcAttachment) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_data_processed_gb", ValueType: schema.Float64, DefaultValue: 0}}
}

func (r *Ec2TransitGatewayVpcAttachment) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *Ec2TransitGatewayVpcAttachment) BuildResource() *schema.Resource {
	region := r.Region

	if r.VPCRegion != "" {
		region = r.VPCRegion
	}

	if r.TransitGatewayRegion != "" {
		region = r.TransitGatewayRegion
	}

	var gbDataProcessed *decimal.Decimal

	if r.MonthlyDataProcessedGB != nil {
		gbDataProcessed = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataProcessedGB))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			transitGatewayAttachmentCostComponent(region, "TransitGatewayVPC"),
			transitGatewayDataProcessingCostComponent(region, "TransitGatewayVPC", gbDataProcessed),
		}, UsageSchema: r.UsageSchema(),
	}
}

func transitGatewayAttachmentCostComponent(region string, operation string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Transit gateway attachment",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(region),
			Service:    strPtr("AmazonVPC"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/TransitGateway-Hours/")},
				{Key: "operation", Value: strPtr(operation)},
			},
		},
	}
}

func transitGatewayDataProcessingCostComponent(region string, operation string, gbDataProcessed *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Data processed",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: gbDataProcessed,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(region),
			Service:    strPtr("AmazonVPC"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/TransitGateway-Bytes/")},
				{Key: "operation", Value: strPtr(operation)},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/ecr_repository.go
# RESOURCE: aws_ecr_repository
# SIZE: 1565 bytes | LINES: 51
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type ECRRepository struct {
	Address   string
	Region    string
	StorageGB *float64 `infracost_usage:"storage_gb"`
}

func (r *ECRRepository) CoreType() string {
	return "ECRRepository"
}

func (r *ECRRepository) UsageSchema() []*schema.UsageItem {
	return ECRRepositoryUsageSchema
}

var ECRRepositoryUsageSchema = []*schema.UsageItem{
	{Key: "storage_gb", ValueType: schema.Float64, DefaultValue: 0},
}

func (r *ECRRepository) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ECRRepository) BuildResource() *schema.Resource {
	var storageSize *decimal.Decimal
	if r.StorageGB != nil {
		storageSize = decimalPtr(decimal.NewFromFloat(*r.StorageGB))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Storage",
				Unit:            "GB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: storageSize,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AmazonECR"),
					ProductFamily: strPtr("EC2 Container Registry"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", Value: strPtr("TimedStorage-ByteHrs")},
					},
				},
				UsageBased: true,
			},
		},
		UsageSchema: ECRRepositoryUsageSchema,
	}
}

################################################################################
# FILE: internal/resources/aws/ecs_service.go
# RESOURCE: aws_ecs_service
# SIZE: 3023 bytes | LINES: 89
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type ECSService struct {
	Address                        string
	LaunchType                     string
	Region                         string
	DesiredCount                   int64
	MemoryGB                       float64
	VCPU                           float64
	InferenceAcceleratorDeviceType string
}

func (r *ECSService) CoreType() string {
	return "ECSService"
}

func (r *ECSService) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *ECSService) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ECSService) BuildResource() *schema.Resource {
	if r.LaunchType != "FARGATE" {
		return &schema.Resource{
			Name:        r.Address,
			IsSkipped:   true,
			NoPrice:     true,
			UsageSchema: r.UsageSchema(),
		}
	}

	costComponents := []*schema.CostComponent{
		{
			Name:           "Per GB per hour",
			Unit:           "GB",
			UnitMultiplier: schema.HourToMonthUnitMultiplier,
			HourlyQuantity: decimalPtr(decimal.NewFromFloat(r.MemoryGB * float64(r.DesiredCount))),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonECS"),
				ProductFamily: strPtr("Compute"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: strPtr("/Fargate-GB-Hours/")},
				},
			},
		},
		{
			Name:           "Per vCPU per hour",
			Unit:           "CPU",
			UnitMultiplier: schema.HourToMonthUnitMultiplier,
			HourlyQuantity: decimalPtr(decimal.NewFromFloat(r.VCPU * float64(r.DesiredCount))),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonECS"),
				ProductFamily: strPtr("Compute"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: strPtr("/Fargate-vCPU-Hours:perCPU/")},
				},
			},
		},
	}

	if r.InferenceAcceleratorDeviceType != "" {
		costComponents = append(costComponents, &schema.CostComponent{
			Name:           fmt.Sprintf("Inference accelerator (%s)", r.InferenceAcceleratorDeviceType),
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(r.DesiredCount)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonEI"),
				ProductFamily: strPtr("Elastic Inference"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", r.InferenceAcceleratorDeviceType))},
				},
			},
		})
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/efs_file_system.go
# RESOURCE: aws_efs_file_system
# SIZE: 6289 bytes | LINES: 141
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type EFSFileSystem struct {
	Address                        string
	Region                         string
	HasLifecyclePolicy             bool
	AvailabilityZoneName           string
	ProvisionedThroughputInMBps    float64
	InfrequentAccessStorageGB      *float64 `infracost_usage:"infrequent_access_storage_gb"`
	StorageGB                      *float64 `infracost_usage:"storage_gb"`
	MonthlyInfrequentAccessReadGB  *float64 `infracost_usage:"monthly_infrequent_access_read_gb"`
	MonthlyInfrequentAccessWriteGB *float64 `infracost_usage:"monthly_infrequent_access_write_gb"`
}

func (r *EFSFileSystem) CoreType() string {
	return "EFSFileSystem"
}

func (r *EFSFileSystem) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "infrequent_access_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "storage_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_infrequent_access_read_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_infrequent_access_write_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *EFSFileSystem) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *EFSFileSystem) BuildResource() *schema.Resource {
	costComponents := make([]*schema.CostComponent, 0)

	var storageGB *decimal.Decimal
	if r.StorageGB != nil {
		storageGB = decimalPtr(decimal.NewFromFloat(*r.StorageGB))
	}

	if r.AvailabilityZoneName != "" {
		costComponents = append(costComponents, r.storageCostComponent("Storage (one zone)", "-TimedStorage-Z-ByteHrs", storageGB))
	} else {
		costComponents = append(costComponents, r.storageCostComponent("Storage (standard)", "-TimedStorage-ByteHrs", storageGB))
	}

	if r.ProvisionedThroughputInMBps > 0 {
		provisionedThroughput := r.calculateProvisionedThroughput(storageGB, decimal.NewFromFloat(r.ProvisionedThroughputInMBps))
		costComponents = append(costComponents, r.provisionedThroughputCostComponent(provisionedThroughput))
	}

	if r.HasLifecyclePolicy {
		var infrequentAccessStorageGB *decimal.Decimal
		if r.InfrequentAccessStorageGB != nil {
			infrequentAccessStorageGB = decimalPtr(decimal.NewFromFloat(*r.InfrequentAccessStorageGB))
		}

		if r.AvailabilityZoneName != "" {
			costComponents = append(costComponents, r.storageCostComponent("Storage (one zone, infrequent access)", "IATimedStorage-Z-ByteHrs", infrequentAccessStorageGB))
		} else {
			costComponents = append(costComponents, r.storageCostComponent("Storage (standard, infrequent access)", "-IATimedStorage-ByteHrs", infrequentAccessStorageGB))
		}

		var infrequentAccessReadGB *decimal.Decimal
		if r.MonthlyInfrequentAccessReadGB != nil {
			infrequentAccessReadGB = decimalPtr(decimal.NewFromFloat(*r.MonthlyInfrequentAccessReadGB))
		}

		var infrequentAccessWriteGB *decimal.Decimal
		if r.MonthlyInfrequentAccessWriteGB != nil {
			infrequentAccessWriteGB = decimalPtr(decimal.NewFromFloat(*r.MonthlyInfrequentAccessWriteGB))
		}

		costComponents = append(costComponents, r.requestsCostComponent("Read requests (infrequent access)", "Read", infrequentAccessReadGB))
		costComponents = append(costComponents, r.requestsCostComponent("Write requests (infrequent access)", "Write", infrequentAccessWriteGB))
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *EFSFileSystem) calculateProvisionedThroughput(storageGB *decimal.Decimal, throughput decimal.Decimal) *decimal.Decimal {
	if storageGB == nil {
		storageGB = &decimal.Zero
	}

	defaultThroughput := storageGB.Mul(decimal.NewFromInt(730).Div(decimal.NewFromInt(20).Mul(decimal.NewFromInt(1))))
	totalProvisionedThroughput := throughput.Mul(decimal.NewFromInt(730))
	totalBillableProvisionedThroughput := totalProvisionedThroughput.Sub(defaultThroughput).Div(decimal.NewFromInt(730))

	if totalBillableProvisionedThroughput.IsPositive() {
		return &totalBillableProvisionedThroughput
	}

	return &decimal.Zero
}

func (r *EFSFileSystem) storageCostComponent(name, usagetype string, storageGB *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: storageGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonEFS"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", usagetype))},
			},
		},
		UsageBased: true,
	}
}

func (r *EFSFileSystem) provisionedThroughputCostComponent(provisionedThroughputMiBps *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Provisioned throughput",
		Unit:            "MBps",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: provisionedThroughputMiBps,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonEFS"),
			ProductFamily: strPtr("Provisioned Throughput"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/ProvisionedTP-MiBpsHrs/")},
			},
		},
		UsageBased: true,
	}
}

func (r *EFSFileSystem) requestsCostComponent(name, accessType string, requestsGB *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: requestsGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonEFS"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "accessType", Value: strPtr(accessType)},
				{Key: "storageClass", Value: strPtr("Infrequent Access")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/eip.go
# RESOURCE: aws_eip
# SIZE: 1638 bytes | LINES: 56
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type EIP struct {
	Address   string
	Region    string
	Allocated bool
}

func (r *EIP) CoreType() string {
	return "EIP"
}

func (r *EIP) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *EIP) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *EIP) BuildResource() *schema.Resource {
	// The EIP is free if allocated. AWS does this to encourage efficient use of Elastic IPs
	// and discourage users from leaving unused EIPs lying around in their AWS account.
	if r.Allocated {
		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:           "IP address (if unused)",
				Unit:           "hours",
				UnitMultiplier: decimal.NewFromInt(1),
				HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AmazonEC2"),
					ProductFamily: strPtr("IP Address"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/ElasticIP:IdleAddress/")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					StartUsageAmount: strPtr("1"),
				},
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/eks_cluster.go
# RESOURCE: aws_eks_cluster
# SIZE: 2692 bytes | LINES: 78
################################################################################
package aws

import (
	"time"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

var (
	eksSupportMap = map[string]time.Time{
		"1.29": time.Date(2025, time.March, 23, 0, 0, 0, 0, time.UTC),
		"1.28": time.Date(2024, time.November, 26, 0, 0, 0, 0, time.UTC),
		"1.27": time.Date(2024, time.July, 24, 0, 0, 0, 0, time.UTC),
		"1.26": time.Date(2024, time.June, 11, 0, 0, 0, 0, time.UTC),
		"1.25": time.Date(2024, time.May, 1, 0, 0, 0, 0, time.UTC),
		"1.24": time.Date(2024, time.January, 31, 0, 0, 0, 0, time.UTC),
		"1.23": time.Date(2023, time.October, 11, 0, 0, 0, 0, time.UTC),
	}
)

type EKSCluster struct {
	Address string
	Version string
	Region  string
}

func (r *EKSCluster) CoreType() string {
	return "EKSCluster"
}

func (r *EKSCluster) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *EKSCluster) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *EKSCluster) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: []*schema.CostComponent{r.clusterHoursCostComponent()},
		UsageSchema:    r.UsageSchema(),
	}
}

// clusterHoursCostComponent returns the management cost of the EKS cluster. This
// can include extended support cost if the version is not supported by AWS
// anymore. In this case we set a custom price of 0.6$ per hour. This is a
// placeholder until AWS provides the price. and we can look it up in the Pricing
// API.
func (r *EKSCluster) clusterHoursCostComponent() *schema.CostComponent {
	baseCost := &schema.CostComponent{
		Name:           "EKS cluster",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonEKS"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/AmazonEKS-Hours:perCluster/")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
	}

	if r.Version == "" {
		return baseCost
	}

	supportDate := eksSupportMap[r.Version]
	if supportDate.IsZero() {
		return baseCost
	}

	if !supportDate.Before(time.Now()) {
		return baseCost
	}

	baseCost.Name = "EKS cluster (extended support)"
	// @TODO: Add price when AWS provides it
	baseCost.SetCustomPrice(decimalPtr(decimal.NewFromFloat(0.6)))

	return baseCost

}

################################################################################
# FILE: internal/resources/aws/eks_fargate_profile.go
# RESOURCE: aws_eks_fargate_profile
# SIZE: 2312 bytes | LINES: 69
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type EKSFargateProfile struct {
	Address string
	Region  string
}

func (r *EKSFargateProfile) CoreType() string {
	return "EKSFargateProfile"
}

func (r *EKSFargateProfile) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *EKSFargateProfile) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *EKSFargateProfile) BuildResource() *schema.Resource {
	costComponents := make([]*schema.CostComponent, 0)
	costComponents = append(costComponents, r.memoryCostComponent())
	costComponents = append(costComponents, r.vcpuCostComponent())

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *EKSFargateProfile) memoryCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Per GB per hour",
		Unit:           "GB",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonEKS"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/Fargate-GB-Hours/")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
	}
}

func (r *EKSFargateProfile) vcpuCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Per vCPU per hour",
		Unit:           "CPU",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonEKS"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/Fargate-vCPU-Hours:perCPU/")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
	}
}

################################################################################
# FILE: internal/resources/aws/eks_node_group.go
# RESOURCE: aws_eks_node_group
# SIZE: 6114 bytes | LINES: 152
################################################################################
package aws

import (
	"context"
	"math"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage/aws"
)

type EKSNodeGroup struct {
	// "required" args that can't really be missing.
	Address     string
	Region      string
	Name        string
	ClusterName string

	InstanceType   string
	PurchaseOption string
	DiskSize       float64

	// "optional" args, that may be empty depending on the resource config
	RootBlockDevice *EBSVolume
	LaunchTemplate  *LaunchTemplate

	// "usage" args
	InstanceCount                 *int64  `infracost_usage:"instances"`
	OperatingSystem               *string `infracost_usage:"operating_system"`
	ReservedInstanceType          *string `infracost_usage:"reserved_instance_type"`
	ReservedInstanceTerm          *string `infracost_usage:"reserved_instance_term"`
	ReservedInstancePaymentOption *string `infracost_usage:"reserved_instance_payment_option"`
	MonthlyCPUCreditHours         *int64  `infracost_usage:"monthly_cpu_credit_hrs"`
	VCPUCount                     *int64  `infracost_usage:"vcpu_count"`
}

func (a *EKSNodeGroup) CoreType() string {
	return "EKSNodeGroup"
}

func (a *EKSNodeGroup) UsageSchema() []*schema.UsageItem {
	return EKSNodeGroupUsageSchema
}

var EKSNodeGroupUsageSchema = append([]*schema.UsageItem{
	{Key: "instances", DefaultValue: 0, ValueType: schema.Int64},
}, InstanceUsageSchema...)

func (a *EKSNodeGroup) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(a, u)

	// The usage keys for Launch Template are specified on the EKS Node Groupresource
	if a.LaunchTemplate != nil {
		resources.PopulateArgsWithUsage(a.LaunchTemplate, u)
	}
}

// getUsageSchemaWithDefaultInstanceCount is a temporary hack to make --sync-usage-file use the node group's "desired_size"
// as the default value for the "instances" usage param.  Without this, --sync-usage-file sets instances=0 causing the
// costs for the node group to be $0.  This can be removed when --sync-usage-file creates the usage file with usgage keys
// commented out by default.
func (a *EKSNodeGroup) getUsageSchemaWithDefaultInstanceCount() []*schema.UsageItem {
	if a.InstanceCount == nil || *a.InstanceCount == 0 {
		return EKSNodeGroupUsageSchema
	}

	usageSchema := make([]*schema.UsageItem, 0, len(EKSNodeGroupUsageSchema))
	for _, u := range EKSNodeGroupUsageSchema {
		if u.Key == "instances" {
			usageSchema = append(usageSchema, &schema.UsageItem{Key: "instances", DefaultValue: intVal(a.InstanceCount), ValueType: schema.Int64})
		} else {
			usageSchema = append(usageSchema, u)
		}
	}
	return usageSchema
}

func (a *EKSNodeGroup) BuildResource() *schema.Resource {
	r := &schema.Resource{
		Name:        a.Address,
		UsageSchema: a.getUsageSchemaWithDefaultInstanceCount(),
	}

	var estimateInstanceQualities schema.EstimateFunc

	// The EKS Node Group resource either has the instance attributes inline or a reference to a Launch Template.
	// If it has a reference to a Launch Template we create generic resources for that and add add it as a subresource
	// of the EKS Node Group resource.
	if a.LaunchTemplate != nil {
		lt := a.LaunchTemplate.BuildResource()
		// If the Launch Template returns nil it is not supported so the Autoscaling Group should also return nil
		if lt == nil {
			return nil
		}
		r.SubResources = append(r.SubResources, lt)
		estimateInstanceQualities = lt.EstimateUsage
	} else {
		instance := &Instance{
			Region:                        a.Region,
			Tenancy:                       "Shared",
			InstanceType:                  a.InstanceType,
			PurchaseOption:                a.PurchaseOption,
			OperatingSystem:               a.OperatingSystem,
			ReservedInstanceType:          a.ReservedInstanceType,
			ReservedInstanceTerm:          a.ReservedInstanceTerm,
			ReservedInstancePaymentOption: a.ReservedInstancePaymentOption,
			MonthlyCPUCreditHours:         a.MonthlyCPUCreditHours,
			VCPUCount:                     a.VCPUCount,
		}

		instance.RootBlockDevice = &EBSVolume{
			Address: "root_block_device",
			Region:  a.Region,
			Type:    "gp2",
			Size:    intPtr(int64(a.DiskSize)),
		}

		instanceResource := instance.BuildResource()
		r.CostComponents = append(r.CostComponents, instanceResource.CostComponents...)

		// For EKS Node Groups we show the root block device cost component into the top level of the resource
		for _, subResource := range instanceResource.SubResources {
			if subResource.Name == "root_block_device" {
				r.CostComponents = append(r.CostComponents, subResource.CostComponents...)
			} else {
				r.SubResources = append(r.SubResources, subResource)
			}
		}
		estimateInstanceQualities = instanceResource.EstimateUsage

		qty := int64(0)
		if a.InstanceCount != nil {
			qty = *a.InstanceCount
		}
		schema.MultiplyQuantities(r, decimal.NewFromInt(qty))
	}

	estimate := func(ctx context.Context, u map[string]interface{}) error {
		err := estimateInstanceQualities(ctx, u)
		if err != nil {
			return err
		}

		// By default (no LaunchTemplate), instances use Amazon Linux 2 AMI."
		// c.f. https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html
		if _, ok := u["operating_system"]; !ok {
			u["operating_system"] = "linux"
		}

		if a.ClusterName != "" && a.Name != "" {
			// Sum the counts from the EKS Node Group's Autoscaling Groups
			asgNames, err := aws.EKSGetNodeGroupAutoscalingGroups(ctx, a.Region, a.ClusterName, a.Name)
			if err != nil {
				return err
			}
			count := float64(0.0)

			if len(asgNames) > 0 {
				for _, asgName := range asgNames {
					asgCount, err := aws.AutoscalingGetInstanceCount(ctx, a.Region, asgName)
					if err != nil {
						return err
					}
					count += asgCount
				}
			}

			if count > 0 {
				u["instances"] = int64(math.Round(count))
			}
		}
		return nil
	}
	r.EstimateUsage = estimate

	return r
}

################################################################################
# FILE: internal/resources/aws/elastic_beanstalk_environment.go
# RESOURCE: aws_elastic_beanstalk_environment
# SIZE: 3888 bytes | LINES: 98
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
)

// ElasticBeanstalkEnvironment struct represents AWS Elastic Beanstalk environments.
//
// Resource information: https://aws.amazon.com/elasticbeanstalk/
// Pricing information: https://aws.amazon.com/elasticbeanstalk/pricing/
type ElasticBeanstalkEnvironment struct {
	Address string
	Region  string
	Name    string

	LoadBalancerType string

	RootBlockDevice     *EBSVolume
	CloudwatchLogGroup  *CloudwatchLogGroup
	LoadBalancer        *LB
	ElasticLoadBalancer *ELB
	DBInstance          *DBInstance
	LaunchConfiguration *LaunchConfiguration
}

func (r *ElasticBeanstalkEnvironment) CoreType() string {
	return "ElasticBeanstalkEnvironment"
}

// UsageSchema defines a list which represents the usage schema of ElasticBeanstalkEnvironment.
// Usage costs for Elastic Beanstalk come from sub resources as it is a wrapper for other AWS services.
func (r *ElasticBeanstalkEnvironment) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{
			Key:          "cloudwatch",
			DefaultValue: &usage.ResourceUsage{Name: "cloudwatch", Items: CloudwatchLogGroupUsageSchema},
			ValueType:    schema.SubResourceUsage,
		},
		{
			Key:          "lb",
			DefaultValue: &usage.ResourceUsage{Name: "lb", Items: LBUsageSchema},
			ValueType:    schema.SubResourceUsage,
		},
		{
			Key:          "elb",
			DefaultValue: &usage.ResourceUsage{Name: "elb", Items: ELBUsageSchema},
			ValueType:    schema.SubResourceUsage,
		},
		{
			Key:          "db",
			DefaultValue: &usage.ResourceUsage{Name: "db", Items: DBInstanceUsageSchema},
			ValueType:    schema.SubResourceUsage,
		},
		{
			Key:          "ec2",
			DefaultValue: &usage.ResourceUsage{Name: "ec2", Items: LaunchConfigurationUsageSchema},
			ValueType:    schema.SubResourceUsage,
		},
	}
}

// PopulateUsage parses the u schema.UsageData into the ElasticBeanstalkEnvironment.
// It uses the `infracost_usage` struct tags to populate data into the ElasticBeanstalkEnvironment.
func (r *ElasticBeanstalkEnvironment) PopulateUsage(u *schema.UsageData) {
	if u == nil {
		return
	}

	if r.ElasticLoadBalancer != nil {
		resources.PopulateArgsWithUsage(r.ElasticLoadBalancer, schema.NewUsageData("elb", u.Get("elb").Map()))
	}

	if r.LoadBalancer != nil {
		resources.PopulateArgsWithUsage(r.LoadBalancer, schema.NewUsageData("lb", u.Get("lb").Map()))
	}

	if r.DBInstance != nil {
		resources.PopulateArgsWithUsage(r.DBInstance, schema.NewUsageData("db", u.Get("db").Map()))
	}

	if r.CloudwatchLogGroup != nil {
		resources.PopulateArgsWithUsage(r.CloudwatchLogGroup, schema.NewUsageData("cloudwatch", u.Get("cloudwatch").Map()))
	}

	resources.PopulateArgsWithUsage(r.LaunchConfiguration, schema.NewUsageData("ec2", u.Get("ec2").Map()))
}

// BuildResource builds a schema.Resource from a valid ElasticBeanstalkEnvironment struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *ElasticBeanstalkEnvironment) BuildResource() *schema.Resource {
	a := &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
	}

	a.SubResources = append(a.SubResources, r.LaunchConfiguration.BuildResource())

	if r.DBInstance != nil {
		a.SubResources = append(a.SubResources, r.DBInstance.BuildResource())
	}

	if r.CloudwatchLogGroup != nil {
		a.SubResources = append(a.SubResources, r.CloudwatchLogGroup.BuildResource())
	}

	if r.LoadBalancerType == "classic" {
		a.SubResources = append(a.SubResources, r.ElasticLoadBalancer.BuildResource())
	} else {
		a.SubResources = append(a.SubResources, r.LoadBalancer.BuildResource())
	}

	return a

}

################################################################################
# FILE: internal/resources/aws/elasticache_cluster.go
# RESOURCE: aws_elasticache_cluster
# SIZE: 7272 bytes | LINES: 172
################################################################################
package aws

import (
	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type ElastiCacheCluster struct {
	Address                       string
	Region                        string
	HasReplicationGroup           bool
	NodeType                      string
	Engine                        string
	CacheNodes                    int64
	SnapshotRetentionLimit        int64
	SnapshotStorageSizeGB         *float64 `infracost_usage:"snapshot_storage_size_gb"`
	ReservedInstanceTerm          *string  `infracost_usage:"reserved_instance_term"`
	ReservedInstancePaymentOption *string  `infracost_usage:"reserved_instance_payment_option"`
}

func (r *ElastiCacheCluster) CoreType() string {
	return "ElastiCacheCluster"
}

func (r *ElastiCacheCluster) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "snapshot_storage_size_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "reserved_instance_term", DefaultValue: "", ValueType: schema.String},
		{Key: "reserved_instance_payment_option", DefaultValue: "", ValueType: schema.String},
	}
}

func (r *ElastiCacheCluster) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ElastiCacheCluster) BuildResource() *schema.Resource {
	if r.HasReplicationGroup {
		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	costComponents := []*schema.CostComponent{
		r.elastiCacheCostComponent(false),
	}

	if strings.ToLower(r.Engine) == "redis" && r.SnapshotRetentionLimit > 1 {
		costComponents = append(costComponents, r.backupStorageCostComponent())
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
	}
}

func (r *ElastiCacheCluster) elastiCacheCostComponent(autoscaling bool) *schema.CostComponent {
	purchaseOptionLabel := "on-demand"
	priceFilter := &schema.PriceFilter{
		PurchaseOption: strPtr("on_demand"),
	}
	if r.ReservedInstanceTerm != nil {
		resolver := &elasticacheReservationResolver{
			term:          strVal(r.ReservedInstanceTerm),
			paymentOption: strVal(r.ReservedInstancePaymentOption),
			cacheNodeType: r.NodeType,
		}
		reservedFilter, err := resolver.PriceFilter()
		if err != nil {
			logging.Logger.Warn().Msg(err.Error())
		} else {
			priceFilter = reservedFilter
		}
		purchaseOptionLabel = "reserved"
	}

	nameParams := []string{purchaseOptionLabel, r.NodeType}
	if autoscaling {
		nameParams = append(nameParams, "autoscaling")
	}

	return &schema.CostComponent{
		Name:           fmt.Sprintf("ElastiCache (%s)", strings.Join(nameParams, ", ")),
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(r.CacheNodes)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonElastiCache"),
			ProductFamily: strPtr("Cache Instance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "instanceType", Value: strPtr(r.NodeType)},
				{Key: "locationType", Value: strPtr("AWS Region")},
				{Key: "cacheEngine", Value: strPtr(cases.Title(language.English).String(r.Engine))},
			},
		},
		PriceFilter: priceFilter,
		UsageBased:  autoscaling,
	}
}

func (r *ElastiCacheCluster) backupStorageCostComponent() *schema.CostComponent {
	var monthlyBackupStorageGB *decimal.Decimal

	backupRetention := r.SnapshotRetentionLimit - 1

	if r.SnapshotStorageSizeGB != nil {
		snapshotSize := decimal.NewFromFloat(*r.SnapshotStorageSizeGB)
		monthlyBackupStorageGB = decimalPtr(snapshotSize.Mul(decimal.NewFromInt(backupRetention)))
	}

	return &schema.CostComponent{
		Name:            "Backup storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: monthlyBackupStorageGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonElastiCache"),
			ProductFamily: strPtr("Storage Snapshot"),
		},
		UsageBased: true,
	}
}

type elasticacheReservationResolver struct {
	term          string
	paymentOption string
	cacheNodeType string
}

func (r elasticacheReservationResolver) isElasticacheReservedNodeLegacyOffering() bool {
	for k := range elasticacheReservedNodeCacheLegacyOfferings {
		if k == r.paymentOption {
			return true
		}
	}
	return false
}

// PriceFilter implementation for elasticacheReservationResolver
// Allowed values for ReservedInstanceTerm: ["1_year", "3_year"]
// Allowed values for ReservedInstancePaymentOption: ["all_upfront", "partial_upfront", "no_upfront"] for non legacy reservation nodes
// Allowed values for ReservedInstancePaymentOption: ["heavy_utilization", "medium_utilization", "light_utilization"] for legacy reservation nodes
// Legacy reservation nodes: "t2", "m3", "m4", "r3", "r4". (See elasticacheReservedNodeLegacyTypes in util.go)
// Corner Case: In the case of legacy reservation cache nodes unfortunately, for a specified node type, the allowed ReservedInstancePaymentOption may differ in different regions.
//
//	Because of this, in the case of a legacy reservation, a warning is raised to the user.
func (r elasticacheReservationResolver) PriceFilter() (*schema.PriceFilter, error) {
	purchaseOptionLabel := "reserved"
	def := &schema.PriceFilter{
		PurchaseOption: strPtr(purchaseOptionLabel),
	}
	termLength := reservedTermsMapping[r.term]
	var purchaseOption string
	if r.isElasticacheReservedNodeLegacyOffering() {
		purchaseOption = elasticacheReservedNodeCacheLegacyOfferings[r.paymentOption]
	} else {
		purchaseOption = reservedPaymentOptionMapping[r.paymentOption]
	}
	validTerms := sliceOfKeysFromMap(reservedTermsMapping)
	if !stringInSlice(validTerms, r.term) {
		return def, fmt.Errorf("Invalid reserved_instance_term, ignoring reserved options. Expected: %s. Got: %s", strings.Join(validTerms, ", "), r.term)
	}
	validOptions := append(sliceOfKeysFromMap(reservedPaymentOptionMapping), sliceOfKeysFromMap(elasticacheReservedNodeCacheLegacyOfferings)...)

	if !stringInSlice(validOptions, r.paymentOption) {
		return def, fmt.Errorf("Invalid reserved_instance_payment_option, ignoring reserved options. Expected: %s. Got: %s", strings.Join(validOptions, ", "), r.paymentOption)
	}
	nodeType := strings.Split(r.cacheNodeType, ".")[1] // Get node type from cache node type. cache.m3.large -> m3
	if stringInSlice(elasticacheReservedNodeLegacyTypes, nodeType) {
		logging.Logger.Warn().Msgf("No products found is possible for legacy nodes %s if provided payment option is not supported by the region.", strings.Join(elasticacheReservedNodeLegacyTypes, ", "))
	}
	return &schema.PriceFilter{
		PurchaseOption:     strPtr(purchaseOptionLabel),
		StartUsageAmount:   strPtr("0"),
		TermLength:         strPtr(termLength),
		TermPurchaseOption: strPtr(purchaseOption),
	}, nil
}

################################################################################
# FILE: internal/resources/aws/elasticache_replication_group.go
# RESOURCE: aws_elasticache_replication_group
# SIZE: 3253 bytes | LINES: 86
################################################################################
package aws

import (
	"strings"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type ElastiCacheReplicationGroup struct {
	Address                       string
	Region                        string
	NodeType                      string
	Engine                        string
	CacheClusters                 int64
	ClusterNodeGroups             int64
	ClusterReplicasPerNodeGroup   int64
	SnapshotRetentionLimit        int64
	SnapshotStorageSizeGB         *float64 `infracost_usage:"snapshot_storage_size_gb"`
	ReservedInstanceTerm          *string  `infracost_usage:"reserved_instance_term"`
	ReservedInstancePaymentOption *string  `infracost_usage:"reserved_instance_payment_option"`

	AppAutoscalingTarget []*AppAutoscalingTarget
}

func (r *ElastiCacheReplicationGroup) CoreType() string {
	return "ElastiCacheReplicationGroup"
}

func (r *ElastiCacheReplicationGroup) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "snapshot_storage_size_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "reserved_instance_term", DefaultValue: "", ValueType: schema.String},
		{Key: "reserved_instance_payment_option", DefaultValue: "", ValueType: schema.String},
	}
}

func (r *ElastiCacheReplicationGroup) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ElastiCacheReplicationGroup) BuildResource() *schema.Resource {
	engine := r.Engine
	if engine == "" {
		engine = "redis"
	}

	var autoscaling bool
	nodeGroups := r.ClusterNodeGroups
	replicasPerNodeGroup := r.ClusterReplicasPerNodeGroup
	for _, target := range r.AppAutoscalingTarget {
		switch target.ScalableDimension {
		case "elasticache:replication-group:NodeGroups":
			autoscaling = true
			if target.Capacity != nil {
				nodeGroups = *target.Capacity
			} else {
				nodeGroups = target.MinCapacity
			}
		case "elasticache:replication-group:Replicas":
			autoscaling = true
			if target.Capacity != nil {
				replicasPerNodeGroup = *target.Capacity
			} else {
				replicasPerNodeGroup = target.MinCapacity
			}
		}
	}

	cacheNodes := r.CacheClusters
	if nodeGroups > 0 {
		// CacheClusters is mutually exclusive with ClusterNodeGroups/ClusterReplicasPerNodeGroup
		cacheNodes = (nodeGroups * replicasPerNodeGroup) + nodeGroups
	}

	cluster := &ElastiCacheCluster{
		Region:                        r.Region,
		NodeType:                      r.NodeType,
		Engine:                        engine,
		CacheNodes:                    cacheNodes,
		SnapshotRetentionLimit:        r.SnapshotRetentionLimit,
		SnapshotStorageSizeGB:         r.SnapshotStorageSizeGB,
		ReservedInstanceTerm:          r.ReservedInstanceTerm,
		ReservedInstancePaymentOption: r.ReservedInstancePaymentOption,
	}

	costComponents := []*schema.CostComponent{
		cluster.elastiCacheCostComponent(autoscaling),
	}

	if strings.ToLower(engine) == "redis" && r.SnapshotRetentionLimit > 1 {
		costComponents = append(costComponents, cluster.backupStorageCostComponent())
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/elb.go
# RESOURCE: aws_elb
# SIZE: 2397 bytes | LINES: 73
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type ELB struct {
	Address                string
	Region                 string
	MonthlyDataProcessedGB *float64 `infracost_usage:"monthly_data_processed_gb"`
}

var ELBUsageSchema = []*schema.UsageItem{
	{Key: "monthly_data_processed_gb", ValueType: schema.Float64, DefaultValue: 0},
}

func (r *ELB) CoreType() string {
	return "ELB"
}

func (r *ELB) UsageSchema() []*schema.UsageItem {
	return ELBUsageSchema
}

func (r *ELB) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ELB) BuildResource() *schema.Resource {
	var dataProcessed *decimal.Decimal
	if r.MonthlyDataProcessedGB != nil {
		dataProcessed = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataProcessedGB))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			r.lbCostComponent(),
			r.dataProcessedCostComponent(dataProcessed),
		},
		UsageSchema: r.UsageSchema(),
	}
}

func (r *ELB) lbCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Classic load balancer",
		Unit:           "hours",
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		UnitMultiplier: decimal.NewFromInt(1),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSELB"),
			ProductFamily: strPtr("Load Balancer"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "locationType", Value: strPtr("AWS Region")},
				{Key: "usagetype", ValueRegex: strPtr("/LoadBalancerUsage/")},
			},
		},
	}
}

func (r *ELB) dataProcessedCostComponent(dataProcessed *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Data processed",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: dataProcessed,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSELB"),
			ProductFamily: strPtr("Load Balancer"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/DataProcessing-Bytes/")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/fsx_openzfs_file_system.go
# RESOURCE: aws_fsx_openzfs_file_system
# SIZE: 5589 bytes | LINES: 153
################################################################################
package aws

import (
	"fmt"
	"math"
	"strings"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type FSxOpenZFSFileSystem struct {
	Address                   string
	StorageType               string
	ThroughputCapacity        int64
	ProvisionedIOPS           int64
	ProvisionedIOPSMode       string
	StorageCapacityGB         int64
	Region                    string
	DeploymentType            string
	DataCompression           string
	CompressionSavingsPercent *float64 `infracost_usage:"compression_savings_percent"`
	BackupStorageGB           *float64 `infracost_usage:"backup_storage_gb"`
}

func (r *FSxOpenZFSFileSystem) CoreType() string {
	return "FSxOpenZFSFileSystem"
}

func (r *FSxOpenZFSFileSystem) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "backup_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *FSxOpenZFSFileSystem) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *FSxOpenZFSFileSystem) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			r.throughputCapacityCostComponent(),
			r.provisionedIOPSCapacityCostComponent(),
			r.storageCapacityCostComponent(),
			r.backupGBCostComponent(),
		},
		UsageSchema: r.UsageSchema(),
	}
}

func (r *FSxOpenZFSFileSystem) throughputCapacityCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Throughput capacity",
		Unit:            "MBps",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(r.ThroughputCapacity)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonFSx"),
			ProductFamily: strPtr("Provisioned Throughput"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "deploymentOption", Value: strPtr("Single-AZ")},
				{Key: "fileSystemType", Value: strPtr("OpenZFS")},
			},
		},
	}
}

func (r *FSxOpenZFSFileSystem) provisionedIOPSCapacityCostComponent() *schema.CostComponent {
	var provisionedIOPS = decimalPtr(decimal.NewFromInt(0))
	if r.ProvisionedIOPSMode == "USER_PROVISIONED" {
		provisionedIOPS = decimalPtr(decimal.NewFromFloat(math.Max(0, float64(r.ProvisionedIOPS-(3*r.StorageCapacityGB)))))
	}
	return &schema.CostComponent{
		Name:            "Provisioned IOPS",
		Unit:            "IOPS",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: provisionedIOPS,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonFSx"),
			ProductFamily: strPtr("Provisioned IOPS"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "deploymentOption", Value: strPtr("Single-AZ")},
				{Key: "fileSystemType", Value: strPtr("OpenZFS")},
			},
		},
	}
}

func (r *FSxOpenZFSFileSystem) storageCapacityCostComponent() *schema.CostComponent {
	var storageCapacity *decimal.Decimal
	var compressionEnabled = ""
	var compressionSavingsPercent float64
	if r.DataCompression != "" && r.DataCompression != "NONE" {
		if r.CompressionSavingsPercent != nil {
			compressionSavingsPercent = *r.CompressionSavingsPercent
		} else {
			compressionSavingsPercent = 50
		}
		compressionEnabled = fmt.Sprintf(" (%s compression, %.0f%%)", r.DataCompression, compressionSavingsPercent)
		storageCapacity = decimalPtr(decimal.NewFromFloat(math.Ceil(float64(r.StorageCapacityGB) * (1 - compressionSavingsPercent/100))))
	} else {
		storageCapacity = decimalPtr(decimal.NewFromInt(r.StorageCapacityGB))
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("SSD storage%s", compressionEnabled),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: storageCapacity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonFSx"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "deploymentOption", Value: strPtr("Single-AZ")},
				{Key: "fileSystemType", Value: strPtr("OpenZFS")},
				{Key: "storageType", Value: strPtr("SSD")},
			},
		},
	}
}

func (r *FSxOpenZFSFileSystem) backupGBCostComponent() *schema.CostComponent {
	var backupStorage *decimal.Decimal
	if r.BackupStorageGB != nil {
		backupStorage = decimalPtr(decimal.NewFromFloat(*r.BackupStorageGB))
	}

	filters := []*schema.AttributeFilter{
		{Key: "usagetype", ValueRegex: strPtr("/BackupUsage/")},
		{Key: "fileSystemType", Value: strPtr("OpenZFS")},
	}
	if strings.Contains(strings.ToLower(r.DeploymentType), "multi") {
		filters = append(filters, &schema.AttributeFilter{
			Key:   "deploymentOption",
			Value: strPtr("Multi-AZ"),
		})
	} else {
		filters = append(filters, &schema.AttributeFilter{
			Key:   "deploymentOption",
			Value: strPtr("N/A"),
		})
	}

	return &schema.CostComponent{
		Name:            "Backup storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: backupStorage,
		ProductFilter: &schema.ProductFilter{
			VendorName:       strPtr("aws"),
			Region:           strPtr(r.Region),
			Service:          strPtr("AmazonFSx"),
			ProductFamily:    strPtr("Storage"),
			AttributeFilters: filters,
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/fsx_windows_file_system.go
# RESOURCE: aws_fsx_windows_file_system
# SIZE: 4024 bytes | LINES: 116
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type FSxWindowsFileSystem struct {
	Address            string
	StorageType        string
	ThroughputCapacity int64
	StorageCapacityGB  int64
	Region             string
	DeploymentType     string
	BackupStorageGB    *float64 `infracost_usage:"backup_storage_gb"`
}

func (r *FSxWindowsFileSystem) CoreType() string {
	return "FSxWindowsFileSystem"
}

func (r *FSxWindowsFileSystem) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "backup_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *FSxWindowsFileSystem) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *FSxWindowsFileSystem) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			r.throughputCapacityCostComponent(),
			r.storageCapacityCostComponent(),
			r.backupGBCostComponent(),
		},
		UsageSchema: r.UsageSchema(),
	}
}

func (r *FSxWindowsFileSystem) deploymentOptionValue() string {
	if strings.Contains(strings.ToLower(r.DeploymentType), "multi_az") {
		return "Multi-AZ"
	}

	return "Single-AZ"
}

func (r *FSxWindowsFileSystem) storageTypeValue() string {
	if strings.ToLower(r.StorageType) == "hdd" {
		return "HDD"
	}

	return "SSD"
}

func (r *FSxWindowsFileSystem) throughputCapacityCostComponent() *schema.CostComponent {
	deploymentOption := r.deploymentOptionValue()

	return &schema.CostComponent{
		Name:            "Throughput capacity",
		Unit:            "MBps",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(r.ThroughputCapacity)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonFSx"),
			ProductFamily: strPtr("Provisioned Throughput"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "deploymentOption", Value: strPtr(deploymentOption)},
				{Key: "fileSystemType", Value: strPtr("Windows")},
			},
		},
	}
}

func (r *FSxWindowsFileSystem) storageCapacityCostComponent() *schema.CostComponent {
	deploymentOption := r.deploymentOptionValue()
	storageType := r.storageTypeValue()

	return &schema.CostComponent{
		Name:            fmt.Sprintf("%v storage", storageType),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(r.StorageCapacityGB)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonFSx"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "deploymentOption", Value: strPtr(deploymentOption)},
				{Key: "fileSystemType", Value: strPtr("Windows")},
				{Key: "storageType", Value: strPtr(storageType)},
			},
		},
	}
}

func (r *FSxWindowsFileSystem) backupGBCostComponent() *schema.CostComponent {
	deploymentOption := r.deploymentOptionValue()

	var backupStorage *decimal.Decimal
	if r.BackupStorageGB != nil {
		backupStorage = decimalPtr(decimal.NewFromFloat(*r.BackupStorageGB))
	}

	return &schema.CostComponent{
		Name:            "Backup storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: backupStorage,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonFSx"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "deploymentOption", Value: strPtr(deploymentOption)},
				{Key: "usagetype", ValueRegex: strPtr("/BackupUsage/")},
				{Key: "fileSystemType", Value: strPtr("Windows")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/global_accelerator.go
# RESOURCE: aws_global_accelerator
# SIZE: 1726 bytes | LINES: 45
################################################################################
package aws

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// GlobalAccelerator struct represents AWS Global Accelerator service
//
// Resource information: https://aws.amazon.com/global-accelerator
// Pricing information: https://aws.amazon.com/global-accelerator/pricing/
type GlobalAccelerator struct {
	Address string
}

func (r *GlobalAccelerator) CoreType() string {
	return "FSxOpenZFSFileSystem"
}

func (r *GlobalAccelerator) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *GlobalAccelerator) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *GlobalAccelerator) BuildResource() *schema.Resource {
	var costComponents []*schema.CostComponent
	costComponent := &schema.CostComponent{
		Name:           "Fixed fee",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Service:    strPtr("AWSGlobalAccelerator"),
		},
	}
	// AWS Global Accelerator has a fixed fee of 0.025$ per hour.
	// This price unfortunately is not mapped actually in AWS Pricing API
	// More: AWS_DEFAULT_REGION=us-east-1 aws pricing get-products --service-code AWSGlobalAccelerator | jq -r '.PriceList[] | fromjson | .product'
	costComponent.SetCustomPrice(decimalPtr(decimal.NewFromFloat(0.025)))
	costComponents = append(costComponents, costComponent)
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/global_accelerator_endpoint_group.go
# RESOURCE: aws_global_accelerator_endpoint_group
# SIZE: 9588 bytes | LINES: 240
################################################################################
package aws

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
)

// GlobalacceleratorEndpointGroup struct represents a Global Accelerator endpoint group
//
// Resource information: https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups.html
// Pricing information: https://aws.amazon.com/it/global-accelerator/pricing/
type GlobalacceleratorEndpointGroup struct {
	Address string
	Region  string

	MonthlyInboundDataTransferGB  *globalAcceleratorRegionDataTransferUsage `infracost_usage:"monthly_inbound_data_transfer_gb"`
	MonthlyOutboundDataTransferGB *globalAcceleratorRegionDataTransferUsage `infracost_usage:"monthly_outbound_data_transfer_gb"`
}

var globalAcceleratorRegionDataTransferUsageSchema = []*schema.UsageItem{
	{Key: "us", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "europe", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "south_africa", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "south_america", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "south_korea", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "australia", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "asia_pacific", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "india", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "middle_east", DefaultValue: 0, ValueType: schema.Float64},
}
var regionCodeMapping = map[string]string{
	"us-gov-west-1":   "US",
	"us-gov-east-1":   "US",
	"us-east-1":       "NA",
	"us-east-2":       "NA",
	"us-west-1":       "NA",
	"us-west-2":       "NA",
	"us-west-2-lax-1": "NA",
	"ca-central-1":    "NA",
	"ca-west-1":       "NA",
	"mx-central-1":    "NA",
	"cn-north-1":      "AP",
	"cn-northwest-1":  "AP",
	"eu-central-1":    "EU",
	"eu-west-1":       "EU",
	"eu-west-2":       "EU",
	"eu-south-1":      "EU",
	"eu-west-3":       "EU",
	"eu-north-1":      "EU",
	"il-central-1":    "EU",
	"ap-east-1":       "AP",
	"ap-east-2":       "AP",
	"ap-northeast-1":  "AP",
	"ap-northeast-2":  "AP",
	"ap-northeast-3":  "AP",
	"ap-southeast-1":  "AP",
	"ap-southeast-2":  "AP",
	"ap-southeast-3":  "AP",
	"ap-southeast-4":  "AP",
	"ap-southeast-5":  "AP",
	"ap-southeast-6":  "AP",
	"ap-southeast-7":  "AP",
	"ap-south-1":      "AP",
	"ap-south-2":      "AP",
	"me-central-1":    "ME",
	"me-south-1":      "ME",
	"sa-east-1":       "SA",
	"af-south-1":      "ZA",
}

type globalAcceleratorRegionDataTransferUsage struct {
	US           *float64 `infracost_usage:"us"`
	Europe       *float64 `infracost_usage:"europe"`
	SouthAfrica  *float64 `infracost_usage:"south_africa"`
	SouthAmerica *float64 `infracost_usage:"south_america"`
	SouthKorea   *float64 `infracost_usage:"south_korea"`
	Australia    *float64 `infracost_usage:"australia"`
	AsiaPacific  *float64 `infracost_usage:"asia_pacific"`
	MiddleEast   *float64 `infracost_usage:"middle_east"`
	India        *float64 `infracost_usage:"india"`
}

type globalAcceleratorRegionData struct {
	awsGroupedName                string
	codeRegion                    string
	monthlyInboundDataTransferGB  *float64
	monthlyOutboundDataTransferGB *float64
}

func (g *globalAcceleratorRegionData) HasUsage() bool {
	return g.monthlyInboundDataTransferGB != nil || g.monthlyOutboundDataTransferGB != nil
}

func (r *GlobalacceleratorEndpointGroup) CoreType() string {
	return "GlobalacceleratorEndpointGroup"
}

func (r *GlobalacceleratorEndpointGroup) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{
			Key:          "monthly_inbound_data_transfer_gb",
			DefaultValue: &usage.ResourceUsage{Name: "monthly_inbound_data_transfer_gb", Items: globalAcceleratorRegionDataTransferUsageSchema},
			ValueType:    schema.SubResourceUsage,
		},
		{
			Key:          "monthly_outbound_data_transfer_gb",
			DefaultValue: &usage.ResourceUsage{Name: "monthly_outbound_data_transfer_gb", Items: globalAcceleratorRegionDataTransferUsageSchema},
			ValueType:    schema.SubResourceUsage,
		},
	}
}

func (r *GlobalacceleratorEndpointGroup) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *GlobalacceleratorEndpointGroup) BuildResource() *schema.Resource {

	if r.MonthlyInboundDataTransferGB == nil {
		r.MonthlyInboundDataTransferGB = &globalAcceleratorRegionDataTransferUsage{}
	}
	if r.MonthlyOutboundDataTransferGB == nil {
		r.MonthlyOutboundDataTransferGB = &globalAcceleratorRegionDataTransferUsage{}
	}

	subResources := r.buildSubresources()

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: []*schema.CostComponent{},
		SubResources:   subResources,
	}
}

func (r *GlobalacceleratorEndpointGroup) buildSubresources() []*schema.Resource {
	var (
		totalInbound  float64 = 0
		totalOutbound float64 = 0
	)
	regionsData := []*globalAcceleratorRegionData{
		{
			awsGroupedName:                "US, Mexico, Canada",
			codeRegion:                    "NA",
			monthlyInboundDataTransferGB:  r.MonthlyInboundDataTransferGB.US,
			monthlyOutboundDataTransferGB: r.MonthlyOutboundDataTransferGB.US,
		},
		{
			awsGroupedName:                "Europe",
			codeRegion:                    "EU",
			monthlyInboundDataTransferGB:  r.MonthlyInboundDataTransferGB.Europe,
			monthlyOutboundDataTransferGB: r.MonthlyOutboundDataTransferGB.Europe,
		},
		{
			awsGroupedName:                "South Africa, Kenya",
			codeRegion:                    "ZA",
			monthlyInboundDataTransferGB:  r.MonthlyInboundDataTransferGB.SouthAfrica,
			monthlyOutboundDataTransferGB: r.MonthlyOutboundDataTransferGB.SouthAfrica,
		},
		{
			awsGroupedName:                "South America",
			codeRegion:                    "SA",
			monthlyInboundDataTransferGB:  r.MonthlyInboundDataTransferGB.SouthAmerica,
			monthlyOutboundDataTransferGB: r.MonthlyOutboundDataTransferGB.SouthAmerica,
		},
		{
			awsGroupedName:                "South Korea",
			codeRegion:                    "KR",
			monthlyInboundDataTransferGB:  r.MonthlyInboundDataTransferGB.SouthKorea,
			monthlyOutboundDataTransferGB: r.MonthlyOutboundDataTransferGB.SouthKorea,
		},
		{
			awsGroupedName:                "Middle East",
			codeRegion:                    "ME",
			monthlyInboundDataTransferGB:  r.MonthlyInboundDataTransferGB.MiddleEast,
			monthlyOutboundDataTransferGB: r.MonthlyOutboundDataTransferGB.MiddleEast,
		},
		{
			awsGroupedName:                "Australia, New Zealand",
			codeRegion:                    "AU",
			monthlyInboundDataTransferGB:  r.MonthlyInboundDataTransferGB.Australia,
			monthlyOutboundDataTransferGB: r.MonthlyOutboundDataTransferGB.Australia,
		},
		{
			awsGroupedName:                "Asia Pacific",
			codeRegion:                    "AP",
			monthlyInboundDataTransferGB:  r.MonthlyInboundDataTransferGB.AsiaPacific,
			monthlyOutboundDataTransferGB: r.MonthlyOutboundDataTransferGB.AsiaPacific,
		},
		{
			awsGroupedName:                "India, Indonesia, Philippines, Thailand",
			codeRegion:                    "IN",
			monthlyInboundDataTransferGB:  r.MonthlyInboundDataTransferGB.India,
			monthlyOutboundDataTransferGB: r.MonthlyOutboundDataTransferGB.India,
		},
	}
	trafficDirection := "In"

	for _, data := range regionsData {
		if !data.HasUsage() {
			continue
		}
		totalInbound += floatVal(data.monthlyInboundDataTransferGB)
		totalOutbound += floatVal(data.monthlyOutboundDataTransferGB)
	}
	if totalInbound < totalOutbound {
		trafficDirection = "Out"
	}

	subresources := []*schema.Resource{}

	for _, data := range regionsData {
		if !data.HasUsage() {
			continue
		}

		subresources = append(subresources, r.buildRegionSubresource(data, trafficDirection))
	}

	return subresources
}

func (r *GlobalacceleratorEndpointGroup) buildRegionSubresource(regionData *globalAcceleratorRegionData, trafficDirection string) *schema.Resource {
	from := regionCodeMapping[r.Region]
	to := regionData.codeRegion
	quantity := regionData.monthlyInboundDataTransferGB
	if trafficDirection == "Out" {
		quantity = regionData.monthlyOutboundDataTransferGB
	}

	// Even if there are multiple price record entries the price for -Bytes-Internet and -Bytes-AWS for the same regions are equal
	// So one of these two can be fixed to avoid multiple prices found
	usageType := fmt.Sprintf("%s-%s-%s-Bytes-Internet", strings.ToUpper(from), strings.ToUpper(to), strings.ToUpper(trafficDirection))
	resource := &schema.Resource{
		Name: regionData.awsGroupedName,
		CostComponents: []*schema.CostComponent{
			{
				Name:            fmt.Sprintf("%sbound DT-premium fee", trafficDirection),
				Unit:            "GB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: decimalPtr(decimal.NewFromFloat(floatVal(quantity))),
				ProductFilter: &schema.ProductFilter{
					VendorName: strPtr("aws"),
					Service:    strPtr("AWSGlobalAccelerator"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "trafficDirection", Value: strPtr(trafficDirection)},
						{Key: "fromLocation", Value: strPtr(from)},
						{Key: "toLocation", Value: strPtr(to)},
						{Key: "operation", Value: strPtr("Dominant")},
						{Key: "usagetype", Value: strPtr(usageType)},
					},
				},
				UsageBased: true,
			},
		},
	}

	return resource
}

################################################################################
# FILE: internal/resources/aws/glue_catalog_database.go
# RESOURCE: aws_glue_catalog_database
# SIZE: 3960 bytes | LINES: 105
################################################################################
package aws

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// GlueCatalogDatabase struct represents a serverless AWS Glue catalog. A Glue catalog is a database designed to store
// raw data fetched from Glue crawlers before the data is cleaned and transformed by a Glue job.
//
// GlueCatalogDatabase is just one resource of the wider AWS Glue service, which provides a number of different serverless services
// to build a robust data analytics pipeline.
//
// Resource information: https://aws.amazon.com/glue/
// Pricing information: https://aws.amazon.com/glue/pricing/
type GlueCatalogDatabase struct {
	Address string
	Region  string

	MonthlyObjects  *float64 `infracost_usage:"monthly_objects"`
	MonthlyRequests *float64 `infracost_usage:"monthly_requests"`
}

func (r *GlueCatalogDatabase) CoreType() string {
	return "GlueCatalogDatabase"
}

func (r *GlueCatalogDatabase) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_objects", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_requests", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the GlueCatalogDatabase.
// It uses the `infracost_usage` struct tags to populate data into the GlueCatalogDatabase.
func (r *GlueCatalogDatabase) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid GlueCatalogDatabase struct. GlueCatalogDatabase has the following
// schema.CostComponents associated with it:
//
//  1. Storage - charged for every 100,000 objects stored above 1M, per month.
//  2. MonthlyAdditionalRequests - charged per million requests above 1M in a month.
//
// This method is called after the resource is initialised by an IaC provider. See providers folder for more information.
func (r *GlueCatalogDatabase) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			r.storageObjectsCostComponent(),
			r.requestsCostComponent(),
		},
	}
}

func (r *GlueCatalogDatabase) storageObjectsCostComponent() *schema.CostComponent {
	var quantity *decimal.Decimal
	var limit float64 = 100000

	if r.MonthlyObjects != nil {
		objects := *r.MonthlyObjects

		if objects < limit {
			objects = 0
		}

		quantity = decimalPtr(decimal.NewFromFloat(objects))
	}

	return &schema.CostComponent{
		Name:            "Storage",
		Unit:            "100k objects",
		UnitMultiplier:  decimal.NewFromFloat(limit),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    vendorName,
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSGlue"),
			ProductFamily: strPtr("AWS Glue"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "group", ValueRegex: strPtr("/^data catalog storage$/i")},
			},
		},
		UsageBased: true,
	}
}

func (r *GlueCatalogDatabase) requestsCostComponent() *schema.CostComponent {
	var quantity *decimal.Decimal
	var limit float64 = 1000000
	if r.MonthlyRequests != nil {
		requests := *r.MonthlyRequests

		if requests < limit {
			requests = 0
		}

		quantity = decimalPtr(decimal.NewFromFloat(requests))
	}

	return &schema.CostComponent{
		Name:            "Requests",
		Unit:            "1M requests",
		UnitMultiplier:  decimal.NewFromFloat(limit),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    vendorName,
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSGlue"),
			ProductFamily: strPtr("AWS Glue"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "group", ValueRegex: strPtr("/^data catalog requests$/i")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/glue_crawler.go
# RESOURCE: aws_glue_crawler
# SIZE: 2508 bytes | LINES: 66
################################################################################
package aws

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// GlueCrawler struct represents a serverless AWS Glue crawler. A Glue crawler crawls defined data sources and sends them
// into a Glue data catalog, ready for a Glue job to transform and merge into a main dataset/lake.
//
// GlueCrawler is just one resource of the wider AWS Glue service, which provides a number of different serverless services
// to build a robust data analytics pipeline.
//
// Resource information: https://aws.amazon.com/glue/
// Pricing information: https://aws.amazon.com/glue/pricing/
type GlueCrawler struct {
	Address string
	Region  string

	MonthlyHours *float64 `infracost_usage:"monthly_hours"`
}

func (r *GlueCrawler) CoreType() string {
	return "GlueCrawler"
}

func (r *GlueCrawler) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_hours", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the GlueCrawler.
// It uses the `infracost_usage` struct tags to populate data into the GlueCrawler.
func (r *GlueCrawler) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid GlueCrawler struct. GlueCrawler has just one schema.CostComponent
// associated with it:
//
//  1. Hours - GlueCrawler is charged per hour that the crawler is run.
//
// This method is called after the resource is initialised by an IaC provider. See providers folder for more information.
func (r *GlueCrawler) BuildResource() *schema.Resource {
	var quantity *decimal.Decimal
	if r.MonthlyHours != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyHours))
	}

	return &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Duration",
				Unit:            "hours",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: quantity,
				ProductFilter: &schema.ProductFilter{
					VendorName:    vendorName,
					Region:        strPtr(r.Region),
					Service:       strPtr("AWSGlue"),
					ProductFamily: strPtr("AWS Glue"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "operation", ValueRegex: strPtr("/^crawlerrun$/i")},
					},
				},
				UsageBased: true,
			},
		},
	}
}

################################################################################
# FILE: internal/resources/aws/glue_job.go
# RESOURCE: aws_glue_job
# SIZE: 2795 bytes | LINES: 78
################################################################################
package aws

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// GlueJob struct represents a serverless AWS Glue job. A Glue job is designed to clean, transform and merge data
// into a data lake so that it is easy to analyze.
//
// GlueJob is just one resource of the wider AWS Glue service, which provides a number of different serverless services
// to build a robust data analytics pipeline.
//
// Resource information: https://aws.amazon.com/glue/
// Pricing information: https://aws.amazon.com/glue/pricing/
type GlueJob struct {
	Address string
	Region  string
	DPUs    float64

	MonthlyHours *float64 `infracost_usage:"monthly_hours"`
}

func (r *GlueJob) CoreType() string {
	return "GlueJob"
}

func (r *GlueJob) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_hours", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the GlueJob.
// It uses the `infracost_usage` struct tags to populate data into the GlueJob.
func (r *GlueJob) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid GlueJob struct. GlueJob has just one schema.CostComponent
// associated with it:
//
//  1. DPU hours - GlueJob is charged per hour that the job is run. Users are charged based on the number of DPU
//     units they use in that time.
//
// This method is called after the resource is initialised by an IaC provider. See providers folder for more information.
func (r *GlueJob) BuildResource() *schema.Resource {
	var quantity *decimal.Decimal
	if r.MonthlyHours != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyHours * r.DPUs))
	}

	suffix := "DPUs"
	if r.DPUs == 1 {
		suffix = "DPU"
	}

	unit := fmt.Sprintf("hours (%d %s)", int(r.DPUs), suffix)

	if r.DPUs > 0 && r.DPUs < 1 {
		unit = fmt.Sprintf("hours (%.4f %s)", r.DPUs, suffix)
	}

	return &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Duration",
				Unit:            unit,
				UnitMultiplier:  decimal.NewFromFloat(r.DPUs),
				MonthlyQuantity: quantity,
				ProductFilter: &schema.ProductFilter{
					VendorName:    vendorName,
					Region:        strPtr(r.Region),
					Service:       strPtr("AWSGlue"),
					ProductFamily: strPtr("AWS Glue"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "group", Value: strPtr("ETL Job run")},
						{Key: "operation", ValueRegex: strPtr("/^jobrun$/i")},
					},
				},
				UsageBased: true,
			},
		},
	}
}

################################################################################
# FILE: internal/resources/aws/grafana_workspace.go
# RESOURCE: aws_grafana_workspace
# SIZE: 3786 bytes | LINES: 101
################################################################################
package aws

import (
	"strings"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/shopspring/decimal"
)

type GrafanaWorkspace struct {
	Address                      string
	Region                       string
	License                      string
	EditorsAdministratorLicenses *int64 `infracost_usage:"editors_administrator_licenses"`
	ViewerLicenses               *int64 `infracost_usage:"viewer_licenses"`
}

func (r *GrafanaWorkspace) CoreType() string {
	return "GrafanaWorkspace"
}

func (r *GrafanaWorkspace) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "editors_administrator_licenses", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "viewer_licenses", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *GrafanaWorkspace) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *GrafanaWorkspace) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	var editorLicenses *decimal.Decimal
	if r.EditorsAdministratorLicenses != nil && *r.EditorsAdministratorLicenses > 0 {
		editorLicenses = decimalPtr(decimal.NewFromInt(*r.EditorsAdministratorLicenses))
	} else if r.EditorsAdministratorLicenses == nil {
		editorLicenses = decimalPtr(decimal.NewFromInt(1))
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Editor/administrator licenses",
		Unit:            "users",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: editorLicenses,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonGrafana"),
			ProductFamily: strPtr("User Fees"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("Grafana:EditorUser$")},
			},
		},
	})

	var viewerLicenses *decimal.Decimal
	if r.ViewerLicenses != nil && *r.ViewerLicenses > 0 {
		viewerLicenses = decimalPtr(decimal.NewFromInt(*r.ViewerLicenses))
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Viewer licenses",
		Unit:            "users",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: viewerLicenses,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonGrafana"),
			ProductFamily: strPtr("User Fees"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("Grafana:ViewerUser$")},
			},
		},
		UsageBased: true,
	})

	if strings.EqualFold(r.License, "ENTERPRISE") {
		var enterprisePluginsQty decimal.Decimal
		if editorLicenses != nil {
			enterprisePluginsQty = enterprisePluginsQty.Add(*editorLicenses)
		}
		if viewerLicenses != nil {
			enterprisePluginsQty = enterprisePluginsQty.Add(*viewerLicenses)
		}

		if enterprisePluginsQty.GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, &schema.CostComponent{
				Name:            "Enterprise plugins licenses",
				Unit:            "users",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: &enterprisePluginsQty,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AmazonGrafana"),
					ProductFamily: strPtr("User Fees"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: regexPtr("Grafana:EnterprisePluginsUser$")},
					},
				},
			})
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/instance.go
# RESOURCE: aws_instance
# SIZE: 12874 bytes | LINES: 329
################################################################################
package aws

import (
	"context"
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage/aws"
)

var defaultEC2InstanceMetricCount = 7
var burstableInstanceTypePrefixes = []string{"t2", "t3", "t3a", "t4g"}

type Instance struct {
	// "required" args that can't really be missing.
	Address          string
	Region           string
	Tenancy          string
	PurchaseOption   string
	AMI              string
	InstanceType     string
	EBSOptimized     bool
	EnableMonitoring bool
	CPUCredits       string
	HasHost          bool

	// "optional" args, that may be empty depending on the resource config
	ElasticInferenceAcceleratorType *string
	RootBlockDevice                 *EBSVolume
	EBSBlockDevices                 []*EBSVolume

	// "usage" args
	OperatingSystem               *string  `infracost_usage:"operating_system"`
	ReservedInstanceType          *string  `infracost_usage:"reserved_instance_type"`
	ReservedInstanceTerm          *string  `infracost_usage:"reserved_instance_term"`
	ReservedInstancePaymentOption *string  `infracost_usage:"reserved_instance_payment_option"`
	MonthlyCPUCreditHours         *int64   `infracost_usage:"monthly_cpu_credit_hrs"`
	VCPUCount                     *int64   `infracost_usage:"vcpu_count"`
	MonthlyHours                  *float64 `infracost_usage:"monthly_hrs"`
}

func (a *Instance) CoreType() string {
	return "Instance"
}

func (a *Instance) UsageSchema() []*schema.UsageItem {
	return InstanceUsageSchema
}

var InstanceUsageSchema = []*schema.UsageItem{
	{Key: "operating_system", DefaultValue: "linux", ValueType: schema.String},
	{Key: "reserved_instance_type", DefaultValue: "", ValueType: schema.String},
	{Key: "reserved_instance_term", DefaultValue: "", ValueType: schema.String},
	{Key: "reserved_instance_payment_option", DefaultValue: "", ValueType: schema.String},
	{Key: "monthly_cpu_credit_hrs", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "vcpu_count", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_hrs", DefaultValue: 730, ValueType: schema.Float64},
}

func (a *Instance) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(a, u)
}

func (a *Instance) BuildResource() *schema.Resource {
	if strings.ToLower(a.Tenancy) == "host" {
		if a.HasHost {
			a.Tenancy = "Host"
		} else {
			logging.Logger.Warn().Msgf("Skipping resource %s. Infracost currently does not support host tenancy for AWS EC2 instances without Host ID set up", a.Address)
			return nil
		}
	} else if strings.ToLower(a.Tenancy) == "dedicated" {
		a.Tenancy = "Dedicated"
	} else {
		a.Tenancy = "Shared"
	}

	if a.CPUCredits == "" && (strings.HasPrefix(a.InstanceType, "t3.") || strings.HasPrefix(a.InstanceType, "t4g.")) {
		a.CPUCredits = "unlimited"
	}

	if a.OperatingSystem == nil {
		a.OperatingSystem = strPtr("linux")
	}

	if a.PurchaseOption == "" {
		a.PurchaseOption = "on_demand"
	}

	costComponents := make([]*schema.CostComponent, 0)
	subResources := make([]*schema.Resource, 0)

	if a.RootBlockDevice != nil {
		subResources = append(subResources, a.RootBlockDevice.BuildResource())
	}

	for _, ebs := range a.EBSBlockDevices {
		subResources = append(subResources, ebs.BuildResource())
	}

	if !a.HasHost {
		costComponents = append(costComponents, a.computeCostComponent())
	}

	if a.EBSOptimized {
		costComponents = append(costComponents, a.ebsOptimizedCostComponent())
	}

	if a.EnableMonitoring {
		costComponents = append(costComponents, a.detailedMonitoringCostComponent())
	}

	if a.ElasticInferenceAcceleratorType != nil {
		costComponents = append(costComponents, a.elasticInferenceAcceleratorCostComponent())
	}

	if a.CPUCredits == "unlimited" {
		if instanceFamily := getBurstableInstanceFamily(burstableInstanceTypePrefixes, a.InstanceType); instanceFamily != "" {
			costComponents = append(costComponents, a.cpuCreditCostComponent(instanceFamily))
		}
	}

	estimate := func(ctx context.Context, values map[string]interface{}) error {
		if a.AMI != "" {
			platform, err := aws.EC2DescribeOS(ctx, a.Region, a.AMI)
			if err != nil {
				return err
			}
			if platform != "" {
				values["operating_system"] = platform
			}
		}
		return nil
	}

	return &schema.Resource{
		Name:           a.Address,
		UsageSchema:    a.UsageSchema(),
		CostComponents: costComponents,
		SubResources:   subResources,
		EstimateUsage:  estimate,
	}
}

func (a *Instance) computeCostComponent() *schema.CostComponent {
	purchaseOptionLabel := map[string]string{
		"on_demand": "on-demand",
		"spot":      "spot",
	}[a.PurchaseOption]

	osLabel := "Linux/UNIX"
	osFilterVal := "Linux"

	switch strVal(a.OperatingSystem) {
	case "windows":
		osLabel = "Windows"
		osFilterVal = "Windows"
	case "rhel":
		osLabel = "RHEL"
		osFilterVal = "RHEL"
	case "suse":
		osLabel = "SUSE"
		osFilterVal = "SUSE"
	default:
		if strVal(a.OperatingSystem) != "linux" {
			logging.Logger.Warn().Msgf("Unrecognized operating system %s, defaulting to Linux/UNIX", strVal(a.OperatingSystem))
		}
	}

	priceFilter := &schema.PriceFilter{
		PurchaseOption: strPtr(a.PurchaseOption),
	}

	if a.ReservedInstanceType != nil {
		resolver := &ec2ReservationResolver{
			term:              strVal(a.ReservedInstanceTerm),
			paymentOption:     strVal(a.ReservedInstancePaymentOption),
			termOfferingClass: strVal(a.ReservedInstanceType),
		}
		reservedFilter, err := resolver.PriceFilter()
		if err != nil {
			logging.Logger.Warn().Msg(err.Error())
		} else {
			priceFilter = reservedFilter
		}
		purchaseOptionLabel = "reserved"
	}

	qty := decimal.NewFromFloat(730)
	if a.MonthlyHours != nil {
		qty = decimal.NewFromFloat(*a.MonthlyHours)
	}

	// metal instances have a different ProductFamily in AWS pricing data
	productFamily := "Compute Instance"
	if strings.Contains(strings.ToLower(a.InstanceType), "metal") {
		productFamily = "Compute Instance (bare metal)"
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Instance usage (%s, %s, %s)", osLabel, purchaseOptionLabel, a.InstanceType),
		Unit:            "hours",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(qty),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(a.Region),
			Service:       strPtr("AmazonEC2"),
			ProductFamily: strPtr(productFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "instanceType", Value: strPtr(a.InstanceType)},
				{Key: "tenancy", Value: strPtr(a.Tenancy)},
				{Key: "operatingSystem", Value: strPtr(osFilterVal)},
				{Key: "preInstalledSw", Value: strPtr("NA")},
				{Key: "licenseModel", Value: strPtr("No License required")},
				{Key: "capacitystatus", Value: strPtr("Used")},
			},
		},
		PriceFilter: priceFilter,
	}
}

func (a *Instance) ebsOptimizedCostComponent() *schema.CostComponent {
	/**
	 * EBS Optimized instances are billed hourly whenever the attached instance is live.
	 *
	 * From the EBS-opimized instance docs:
	 *    > For Current Generation Instance types, EBS-optimization is enabled by default
	 *    > at no additional cost. For Previous Generation Instances types, EBS-optimization
	 *    > prices are on the Previous Generation Pricing Page.
	 *    >
	 *    > The hourly price for EBS-optimized instances is in addition to the hourly usage fee
	 *    > for supported instance types.
	 */
	qty := decimal.NewFromFloat(730)
	if a.MonthlyHours != nil {
		qty = decimal.NewFromFloat(*a.MonthlyHours)
	}

	return &schema.CostComponent{
		Name:                 "EBS-optimized usage",
		Unit:                 "hours",
		UnitMultiplier:       decimal.NewFromInt(1),
		MonthlyQuantity:      decimalPtr(qty),
		IgnoreIfMissingPrice: true,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(a.Region),
			Service:       strPtr("AmazonEC2"),
			ProductFamily: strPtr("Compute Instance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "instanceType", Value: strPtr(a.InstanceType)},
				{Key: "usagetype", ValueRegex: strPtr("/EBSOptimized/")},
			},
		},
	}
}

func (a *Instance) detailedMonitoringCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:                 "EC2 detailed monitoring",
		Unit:                 "metrics",
		UnitMultiplier:       decimal.NewFromInt(1),
		MonthlyQuantity:      decimalPtr(decimal.NewFromInt(int64(defaultEC2InstanceMetricCount))),
		IgnoreIfMissingPrice: true,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(a.Region),
			Service:       strPtr("AmazonCloudWatch"),
			ProductFamily: strPtr("Metric"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "group", Value: strPtr("Metric")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("0"),
		},
	}
}

func (a *Instance) elasticInferenceAcceleratorCostComponent() *schema.CostComponent {
	/**
	 * Elastic inference accelerators are billed hourly whenever the attached instance is live.
	 *
	 * From the elastic inference accelerator  docs:
	 *    > With Amazon Elastic Inference, you pay only for the accelerator hours you use.
	 *    > There are no upfront costs or minimum fees.
	 */
	qty := decimal.NewFromFloat(730)
	if a.MonthlyHours != nil {
		qty = decimal.NewFromFloat(*a.MonthlyHours)
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Inference accelerator (%s)", strVal(a.ElasticInferenceAcceleratorType)),
		Unit:            "hours",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(qty),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(a.Region),
			Service:       strPtr("AmazonEI"),
			ProductFamily: strPtr("Elastic Inference"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", strVal(a.ElasticInferenceAcceleratorType)))},
			},
		},
	}
}

func (a *Instance) cpuCreditCostComponent(instanceFamily string) *schema.CostComponent {
	qty := decimal.Zero
	if a.MonthlyCPUCreditHours != nil && a.VCPUCount != nil {
		qty = decimal.NewFromInt(*a.MonthlyCPUCreditHours).Mul(decimal.NewFromInt(*a.VCPUCount))
	}

	return &schema.CostComponent{
		Name:            "CPU credits",
		Unit:            "vCPU-hours",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(qty),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(a.Region),
			Service:       strPtr("AmazonEC2"),
			ProductFamily: strPtr("CPU Credits"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "operatingSystem", Value: strPtr("Linux")},
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/CPUCredits:%s$/", instanceFamily))},
			},
		},
	}
}

type ec2ReservationResolver struct {
	term              string
	paymentOption     string
	termOfferingClass string
}

// PriceFilter implementation for ec2ReservationResolver
// Allowed values for ReservedInstanceTerm: ["1_year", "3_year"]
// Allowed values for ReservedInstancePaymentOption: ["all_upfront", "partial_upfront", "no_upfront"]
// Allowed values for ReservedTermOfferingClass: ["standard", "convertible"]
func (r ec2ReservationResolver) PriceFilter() (*schema.PriceFilter, error) {
	termLength := reservedTermsMapping[r.term]
	purchaseOption := reservedPaymentOptionMapping[r.paymentOption]
	validTypes := []string{"convertible", "standard"}
	if !stringInSlice(validTypes, r.termOfferingClass) {
		return nil, fmt.Errorf("Invalid reserved_instance_type, ignoring reserved options. Expected: convertible, standard. Got: %s", r.termOfferingClass)
	}
	validTerms := sliceOfKeysFromMap(reservedTermsMapping)
	if !stringInSlice(validTerms, r.term) {
		return nil, fmt.Errorf("Invalid reserved_instance_term, ignoring reserved options. Expected: %s. Got: %s", strings.Join(validTerms, ", "), r.term)
	}
	validOptions := sliceOfKeysFromMap(reservedPaymentOptionMapping)
	if !stringInSlice(validOptions, r.paymentOption) {
		return nil, fmt.Errorf("Invalid reserved_instance_payment_option, ignoring reserved options. Expected: %s. Got: %s", strings.Join(validOptions, ", "), r.paymentOption)
	}
	return &schema.PriceFilter{
		StartUsageAmount:   strPtr("0"),
		TermOfferingClass:  strPtr(r.termOfferingClass),
		TermLength:         strPtr(termLength),
		TermPurchaseOption: strPtr(purchaseOption),
	}, nil
}

################################################################################
# FILE: internal/resources/aws/kinesis_firehose_delivery_stream.go
# RESOURCE: aws_kinesis_firehose_delivery_stream
# SIZE: 5472 bytes | LINES: 139
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/usage"
)

type KinesisFirehoseDeliveryStream struct {
	Address                     string
	Region                      string
	DataFormatConversionEnabled bool
	VPCDeliveryEnabled          bool
	VPCDeliveryAZs              int64
	MonthlyDataIngestedGB       *float64 `infracost_usage:"monthly_data_ingested_gb"`
}

func (r *KinesisFirehoseDeliveryStream) CoreType() string {
	return "KinesisFirehoseDeliveryStream"
}

func (r *KinesisFirehoseDeliveryStream) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_data_ingested_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *KinesisFirehoseDeliveryStream) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *KinesisFirehoseDeliveryStream) BuildResource() *schema.Resource {
	costComponents := make([]*schema.CostComponent, 0)

	if r.MonthlyDataIngestedGB != nil {
		tierLimits := []int{512_000, 1_536_000}

		result := usage.CalculateTierBuckets(decimal.NewFromFloat(*r.MonthlyDataIngestedGB), tierLimits)

		if result[0].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, r.dataIngestedCostComponent("first 500TB", "0", "512000", &result[0]))
		}
		if result[1].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, r.dataIngestedCostComponent("next 1.5PB", "512000", "2048000", &result[1]))
		}
		if result[2].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, r.dataIngestedCostComponent("next 3PB", "2048000", "Inf", &result[2]))
		}
	} else {
		costComponents = append(costComponents, r.dataIngestedCostComponent("first 500TB", "0", "512000", nil))
	}

	if r.DataFormatConversionEnabled {
		costComponents = append(costComponents, r.formatConversionCostComponent())
	}

	if r.VPCDeliveryEnabled {
		costComponents = append(costComponents, r.vpcDataCostComponent())
		costComponents = append(costComponents, r.vpcDeliveryCostComponent())
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *KinesisFirehoseDeliveryStream) dataIngestedCostComponent(tier, startUsageAmount, endUsageAmount string, quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Data ingested (%s)", tier),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesisFirehose"),
			ProductFamily: strPtr("Kinesis Firehose"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "group", Value: strPtr("Event-by-Event Processing")},
				{Key: "sourcetype", Value: strPtr("")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(startUsageAmount),
			EndUsageAmount:   strPtr(endUsageAmount),
		},
		UsageBased: true,
	}
}

func (r *KinesisFirehoseDeliveryStream) formatConversionCostComponent() *schema.CostComponent {
	var monthlyDataIngestedGB *decimal.Decimal
	if r.MonthlyDataIngestedGB != nil {
		monthlyDataIngestedGB = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataIngestedGB))
	}

	return &schema.CostComponent{
		Name:            "Format conversion",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: monthlyDataIngestedGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesisFirehose"),
			ProductFamily: strPtr("Kinesis Firehose"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "operation", Value: strPtr("DataFormatConversion")},
			},
		},
	}
}

func (r *KinesisFirehoseDeliveryStream) vpcDataCostComponent() *schema.CostComponent {
	var monthlyDataIngestedGB *decimal.Decimal
	if r.MonthlyDataIngestedGB != nil {
		monthlyDataIngestedGB = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataIngestedGB))
	}

	return &schema.CostComponent{
		Name:            "VPC data",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: monthlyDataIngestedGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesisFirehose"),
			ProductFamily: strPtr("Kinesis Firehose"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "operation", Value: strPtr("VpcBandwidth")},
			},
		},
	}
}

func (r *KinesisFirehoseDeliveryStream) vpcDeliveryCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "VPC AZ delivery",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(r.VPCDeliveryAZs)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesisFirehose"),
			ProductFamily: strPtr("Kinesis Firehose"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "operation", Value: strPtr("RunVpcInstance")},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/aws/kinesis_stream.go
# RESOURCE: aws_kinesis_stream
# SIZE: 16154 bytes | LINES: 373
################################################################################
package aws

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// KinesisStream struct represents Kinesis Data Streams a fully managed, serverless streaming data service
//
// Resource information: https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/kinesis_stream
// Pricing information: https://aws.amazon.com/kinesis/data-streams/pricing/
type KinesisStream struct {
	Address    string
	Region     string
	StreamMode string
	ShardCount int64

	// Usage fields
	// On demand
	MonthlyOnDemandDataIngestedGB      *float64 `infracost_usage:"monthly_on_demand_data_in_gb"`
	MonthlyOnDemandDataRetrievalGB     *float64 `infracost_usage:"monthly_on_demand_data_out_gb"`
	MonthlyOnDemandEFODataRetrievalGB  *float64 `infracost_usage:"monthly_on_demand_efo_data_out_gb"`
	MonthlyOnDemandExtendedRetentionGb *float64 `infracost_usage:"monthly_on_demand_extended_retention_gb"`
	MonthlyOnDemandLongTermRetentionGb *float64 `infracost_usage:"monthly_on_demand_long_term_retention_gb"`
	// Provisioned
	MonthlyProvisionedPutUnits            *float64 `infracost_usage:"monthly_provisioned_put_units"`
	MonthlyProvisionedExtendedRetentionGb *float64 `infracost_usage:"monthly_provisioned_extended_retention_gb"`
	MonthlyProvisionedLongTermRetentionGb *float64 `infracost_usage:"monthly_provisioned_long_term_retention_gb"`
	MonthlyProvisionedLongTermRetrievalGb *float64 `infracost_usage:"monthly_provisioned_long_term_retrieval_gb"`
	MonthlyProvisionedEFODataRetrievalGB  *float64 `infracost_usage:"monthly_provisioned_efo_data_out_gb"`
	MonthlyProvisionedEFOConsumerHours    *float64 `infracost_usage:"monthly_provisioned_efo_consumer_hours"`
}

// CoreType returns the name of this resource type
func (r *KinesisStream) CoreType() string {
	return "KinesisStream"
}

// UsageSchema defines a list which represents the usage schema of KinesisStream.
func (r *KinesisStream) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_on_demand_data_in_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_on_demand_data_out_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_on_demand_efo_data_out_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_on_demand_extended_retention_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_on_demand_long_term_retention_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_provisioned_put_units", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_provisioned_extended_retention_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_provisioned_long_term_retention_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_provisioned_long_term_retrieval_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_provisioned_efo_data_out_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_provisioned_efo_consumer_hours", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the KinesisStream.
// It uses the `infracost_usage` struct tags to populate data into the KinesisStream.
func (r *KinesisStream) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// Set some vars that come from the pricing api
var (
	onDemandStreamName    string = "ON_DEMAND"
	provisionedStreamName string = "PROVISIONED"
)

// BuildResource builds a schema.Resource from a valid KinesisStream struct.
// This method is called after the resource is initialized by an IaC provider.
// See providers folder for more information.
func (r *KinesisStream) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}
	// Depending on the stream mode, we will have different cost components
	if r.StreamMode == onDemandStreamName {
		costComponents = append(costComponents, r.onDemandStreamCostComponent())
		costComponents = append(costComponents, r.onDemandDataIngestedCostComponent())
		costComponents = append(costComponents, r.onDemandDataRetrievalCostComponent())
		costComponents = append(costComponents, r.onDemandEfoDataRetrievalCostComponent())
		costComponents = append(costComponents, r.onDemandExtendedRetentionCostComponent())
		costComponents = append(costComponents, r.onDemandLongTermRetentionCostComponent())
	}
	if r.StreamMode == provisionedStreamName {
		costComponents = append(costComponents, r.provisionedStreamCostComponent())
		costComponents = append(costComponents, r.provisionedStreamPutUnitsCostComponent())
		costComponents = append(costComponents, r.provisionedExtendedRetentionCostComponent())
		costComponents = append(costComponents, r.provisionedLongTermRetentionCostComponent())
		costComponents = append(costComponents, r.provisionedLongTermRetrievalCostComponent())
		costComponents = append(costComponents, r.provisionedEfoDataRetrievalCostComponent())
		costComponents = append(costComponents, r.provisionedEfoConsumersCostComponent())
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *KinesisStream) onDemandStreamCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           onDemandStreamName,
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesis"),
			ProductFamily: strPtr("Kinesis Streams"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(^|-)OnDemand-StreamHour")},
				{Key: "operation", Value: strPtr("OnDemandStreamHr")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
	}
}

func (r *KinesisStream) onDemandDataIngestedCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Data ingested",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyOnDemandDataIngestedGB),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesis"),
			ProductFamily: strPtr("Kinesis Streams"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(^|-)OnDemand-BilledIncomingBytes")},
				{Key: "operation", Value: strPtr("OnDemandDataIngested")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *KinesisStream) onDemandDataRetrievalCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Data retrieval",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyOnDemandDataRetrievalGB),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesis"),
			ProductFamily: strPtr("Kinesis Streams"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(^|-)OnDemand-BilledOutgoingBytes")},
				{Key: "operation", Value: strPtr("OnDemandDataRetrieval")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *KinesisStream) onDemandEfoDataRetrievalCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Enhanced Fan Out (EFO) Data retrieval",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyOnDemandEFODataRetrievalGB),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesis"),
			ProductFamily: strPtr("Kinesis Streams"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(^|-)OnDemand-BilledOutgoingEFOBytes")},
				{Key: "operation", Value: strPtr("OnDemandEFODataRetrieval")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *KinesisStream) onDemandExtendedRetentionCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Extended retention (24H to 7D)",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyOnDemandExtendedRetentionGb),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesis"),
			ProductFamily: strPtr("Kinesis Streams"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(^|-)OnDemand-ExtendedRetention-ByteHrs")},
				{Key: "operation", Value: strPtr("OnDemandExtendedRetentionByteHrs")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *KinesisStream) onDemandLongTermRetentionCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Long term retention (7D+)",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyOnDemandLongTermRetentionGb),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesis"),
			ProductFamily: strPtr("Kinesis Streams"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(^|-)OnDemand-LongTermRetention-ByteHrs")},
				{Key: "operation", Value: strPtr("OnDemandLongTermRetentionByteHrs")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *KinesisStream) provisionedStreamCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           provisionedStreamName,
		Unit:           "hours",
		HourlyQuantity: decimalPtr(decimal.NewFromInt(r.ShardCount)),
		UnitMultiplier: decimal.NewFromInt(1),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesis"),
			ProductFamily: strPtr("Kinesis Streams"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(^|-)Storage-ShardHour")},
				{Key: "operation", Value: strPtr("shardHourStorage")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
	}
}

func (r *KinesisStream) provisionedStreamPutUnitsCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Put request unit",
		Unit:            "units",
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyProvisionedPutUnits),
		UnitMultiplier:  decimal.NewFromInt(1),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesis"),
			ProductFamily: strPtr("Kinesis Streams"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(^|-)PutRequestPayloadUnits")},
				{Key: "operation", Value: strPtr("PutRequest")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *KinesisStream) provisionedExtendedRetentionCostComponent() *schema.CostComponent {
	return &schema.CostComponent{

		Name:            "Extended retention (24H to 7D)",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyProvisionedExtendedRetentionGb),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesis"),
			ProductFamily: strPtr("Kinesis Streams"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(^|-)Extended-ShardHour")},
				{Key: "operation", Value: strPtr("shardHourStorage")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *KinesisStream) provisionedLongTermRetentionCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Long term retention (7D+)",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyProvisionedLongTermRetentionGb),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesis"),
			ProductFamily: strPtr("Kinesis Streams"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(^|-)LongTermRetention-ByteHrs")},
				{Key: "operation", Value: strPtr("LongTermRetentionByteHrs")},
			},
		},
		UsageBased: true,
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
	}
}

func (r *KinesisStream) provisionedLongTermRetrievalCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Extended retention retrieval (7D+)",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyProvisionedLongTermRetrievalGb),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesis"),
			ProductFamily: strPtr("Kinesis Streams"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(^|-)LongTermRetention-ReadBytes")},
				{Key: "operation", Value: strPtr("LongTermRetentionDataRetrieval")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *KinesisStream) provisionedEfoDataRetrievalCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Enhanced Fan Out (EFO) Data retrieval",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyProvisionedEFODataRetrievalGB),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesis"),
			ProductFamily: strPtr("Kinesis Streams"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(^|-)ReadBytes")},
				{Key: "operation", Value: strPtr("EnhancedFanoutDataRetrieval")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *KinesisStream) provisionedEfoConsumersCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Enhanced Fan Out (EFO)",
		Unit:            "consumer-shard hour",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyProvisionedEFOConsumerHours),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesis"),
			ProductFamily: strPtr("Kinesis Streams"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("(^|-)EnhancedFanoutHour")},
				{Key: "operation", Value: strPtr("ConsumerHour")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/kinesisanalytics_application.go
# RESOURCE: aws_kinesisanalytics_application
# SIZE: 1930 bytes | LINES: 51
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type KinesisAnalyticsApplication struct {
	Address                string
	Region                 string
	KinesisProcessingUnits *int64 `infracost_usage:"kinesis_processing_units"`
}

func (r *KinesisAnalyticsApplication) CoreType() string {
	return "KinesisAnalyticsApplication"
}

func (r *KinesisAnalyticsApplication) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "kinesis_processing_units", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *KinesisAnalyticsApplication) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *KinesisAnalyticsApplication) BuildResource() *schema.Resource {
	var kinesisProcessingUnits *decimal.Decimal
	if r.KinesisProcessingUnits != nil {
		kinesisProcessingUnits = decimalPtr(decimal.NewFromInt(*r.KinesisProcessingUnits))
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: []*schema.CostComponent{r.processingStreamCostComponent(kinesisProcessingUnits)},
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *KinesisAnalyticsApplication) processingStreamCostComponent(kinesisProcessingUnits *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Processing (stream)",
		Unit:           "KPU",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: kinesisProcessingUnits,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesisAnalytics"),
			ProductFamily: strPtr("Kinesis Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/KPU-Hour-Java/i")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/kinesisanalyticsv2_application.go
# RESOURCE: aws_kinesisanalyticsv2_application
# SIZE: 4460 bytes | LINES: 109
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"strings"

	"github.com/shopspring/decimal"
)

type KinesisAnalyticsV2Application struct {
	Address                    string
	Region                     string
	RuntimeEnvironment         string
	KinesisProcessingUnits     *int64   `infracost_usage:"kinesis_processing_units"`
	DurableApplicationBackupGB *float64 `infracost_usage:"durable_application_backup_gb"`
}

func (r *KinesisAnalyticsV2Application) CoreType() string {
	return "KinesisAnalyticsV2Application"
}

func (r *KinesisAnalyticsV2Application) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "kinesis_processing_units", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "durable_application_backup_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *KinesisAnalyticsV2Application) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *KinesisAnalyticsV2Application) BuildResource() *schema.Resource {
	costComponents := make([]*schema.CostComponent, 0)

	var kinesisProcessingUnits *decimal.Decimal
	if r.KinesisProcessingUnits != nil {
		kinesisProcessingUnits = decimalPtr(decimal.NewFromInt(*r.KinesisProcessingUnits))
	}

	var durableApplicationBackupGB *decimal.Decimal
	if r.DurableApplicationBackupGB != nil {
		durableApplicationBackupGB = decimalPtr(decimal.NewFromFloat(*r.DurableApplicationBackupGB))
	}

	v1App := &KinesisAnalyticsApplication{
		Region:                 r.Region,
		KinesisProcessingUnits: r.KinesisProcessingUnits,
	}

	costComponents = append(costComponents, v1App.processingStreamCostComponent(kinesisProcessingUnits))

	if strings.HasPrefix(strings.ToLower(r.RuntimeEnvironment), "flink") {
		costComponents = append(costComponents, r.processingOrchestrationCostComponent())
		costComponents = append(costComponents, r.runningStorageCostComponent(kinesisProcessingUnits))
		costComponents = append(costComponents, r.backupCostComponent(durableApplicationBackupGB))
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *KinesisAnalyticsV2Application) processingOrchestrationCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Processing (orchestration)",
		Unit:           "KPU",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesisAnalytics"),
			ProductFamily: strPtr("Kinesis Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/KPU-Hour-Java/i")},
			},
		},
	}
}

func (r *KinesisAnalyticsV2Application) runningStorageCostComponent(kinesisProcessingUnits *decimal.Decimal) *schema.CostComponent {
	var quantity *decimal.Decimal
	if kinesisProcessingUnits != nil {
		quantity = decimalPtr(kinesisProcessingUnits.Mul(decimal.NewFromInt(50)))
	}

	return &schema.CostComponent{
		Name:            "Running storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesisAnalytics"),
			ProductFamily: strPtr("Kinesis Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/RunningApplicationStorage$/i")},
			},
		},
		UsageBased: true,
	}
}

func (r *KinesisAnalyticsV2Application) backupCostComponent(durableApplicationBackupGB *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Backup",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: durableApplicationBackupGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonKinesisAnalytics"),
			ProductFamily: strPtr("Kinesis Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/DurableApplicationBackups/i")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/kinesisanalyticsv2_application_snapshot.go
# RESOURCE: aws_kinesisanalyticsv2_application_snapshot
# SIZE: 1483 bytes | LINES: 37
################################################################################
package aws

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type KinesisAnalyticsV2ApplicationSnapshot struct {
	Address                    string
	Region                     string
	DurableApplicationBackupGB *float64 `infracost_usage:"durable_application_backup_gb"`
}

func (r *KinesisAnalyticsV2ApplicationSnapshot) CoreType() string {
	return "KinesisAnalyticsV2ApplicationSnapshot"
}

func (r *KinesisAnalyticsV2ApplicationSnapshot) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "durable_application_backup_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *KinesisAnalyticsV2ApplicationSnapshot) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *KinesisAnalyticsV2ApplicationSnapshot) BuildResource() *schema.Resource {
	var durableApplicationBackupGB *decimal.Decimal
	if r.DurableApplicationBackupGB != nil {
		durableApplicationBackupGB = decimalPtr(decimal.NewFromFloat(*r.DurableApplicationBackupGB))
	}

	v2App := &KinesisAnalyticsV2Application{
		Region:                     r.Region,
		DurableApplicationBackupGB: r.DurableApplicationBackupGB,
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: []*schema.CostComponent{v2App.backupCostComponent(durableApplicationBackupGB)},
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/kms_external_key.go
# RESOURCE: aws_kms_external_key
# SIZE: 781 bytes | LINES: 28
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type KMSExternalKey struct {
	Address string
	Region  string
}

func (r *KMSExternalKey) CoreType() string {
	return "KMSExternalKey"
}

func (r *KMSExternalKey) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *KMSExternalKey) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *KMSExternalKey) BuildResource() *schema.Resource {
	kmsKey := &KMSKey{
		Region: r.Region,
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: []*schema.CostComponent{kmsKey.customerMasterKeyCostComponent()},
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/kms_key.go
# RESOURCE: aws_kms_key
# SIZE: 2813 bytes | LINES: 86
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type KMSKey struct {
	Address               string
	Region                string
	CustomerMasterKeySpec string
}

func (r *KMSKey) CoreType() string {
	return "KMSKey"
}

func (r *KMSKey) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *KMSKey) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *KMSKey) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.customerMasterKeyCostComponent(),
	}

	costComponents = append(costComponents, r.requestsCostComponents()...)

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *KMSKey) customerMasterKeyCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Customer master key",
		Unit:            "months",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("awskms"),
			ProductFamily: strPtr("Encryption Key"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/KMS-Keys/")},
			},
		},
	}
}

func (r *KMSKey) requestsCostComponents() []*schema.CostComponent {
	switch r.CustomerMasterKeySpec {
	case "RSA_2048":
		return []*schema.CostComponent{
			r.requestsCostComponent("Requests (RSA 2048)", "/KMS-Requests-Asymmetric-RSA_2048/"),
		}
	case
		"RSA_3072",
		"RSA_4096",
		"ECC_NIST_P256",
		"ECC_NIST_P384",
		"ECC_NIST_P521",
		"ECC_SECG_P256K1":
		return []*schema.CostComponent{
			r.requestsCostComponent("Requests (asymmetric)", "/KMS-Requests-Asymmetric$/"),
		}
	}

	return []*schema.CostComponent{
		r.requestsCostComponent("Requests", "/KMS-Requests$/"),
		r.requestsCostComponent("ECC GenerateDataKeyPair requests", "/KMS-Requests-GenerateDatakeyPair-ECC/"),
		r.requestsCostComponent("RSA GenerateDataKeyPair requests", "/KMS-Requests-GenerateDatakeyPair-ECC/"),
	}
}

func (r *KMSKey) requestsCostComponent(name string, usagetype string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           name,
		Unit:           "10k requests",
		UnitMultiplier: decimal.NewFromInt(10000),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(r.Region),
			Service:    strPtr("awskms"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(usagetype)},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/aws/lambda_function.go
# RESOURCE: aws_lambda_function
# SIZE: 7258 bytes | LINES: 181
################################################################################
package aws

import (
	"context"
	"math"
	"strconv"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
	"github.com/infracost/infracost/internal/usage/aws"

	"github.com/shopspring/decimal"
)

type LambdaFunction struct {
	Address      string
	Region       string
	Name         string
	MemorySize   int64
	Architecture string
	StorageSize  int64

	RequestDurationMS *int64 `infracost_usage:"request_duration_ms"`
	MonthlyRequests   *int64 `infracost_usage:"monthly_requests"`
}

func (a *LambdaFunction) CoreType() string {
	return "LambdaFunction"
}

func (a *LambdaFunction) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "request_duration_ms", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_requests", DefaultValue: 0, ValueType: schema.Int64},
	}
}

func (a *LambdaFunction) UsageEstimationParams() []schema.UsageParam {
	return []schema.UsageParam{
		{Key: "memory_size_gb", Value: decimal.NewFromInt(a.MemorySize).Div(decimal.NewFromInt(1024)).String()},
	}
}

func (a *LambdaFunction) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(a, u)
}

func (a *LambdaFunction) BuildResource() *schema.Resource {
	memorySize := decimal.NewFromInt(a.MemorySize)
	storageSize := decimal.NewFromInt(a.StorageSize)
	requestType := "AWS-Lambda-Requests"
	durationType := "AWS-Lambda-Duration"
	storageType := "AWS-Lambda-Storage-Duration"

	averageRequestDuration := decimal.NewFromInt(1)
	if a.RequestDurationMS != nil {
		averageRequestDuration = decimal.NewFromInt(*a.RequestDurationMS)
	}

	if a.Architecture == "arm64" {
		requestType = "AWS-Lambda-Requests-ARM"
		durationType = "AWS-Lambda-Duration-ARM"
		storageType = "AWS-Lambda-Storage-Duration-ARM"
	}

	var monthlyRequests *decimal.Decimal
	var gbSeconds *decimal.Decimal
	var storageGBSeconds *decimal.Decimal
	var costComponents []*schema.CostComponent

	if a.MonthlyRequests != nil {
		monthlyRequests = decimalPtr(decimal.NewFromInt(*a.MonthlyRequests))
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Requests",
		Unit:            "1M requests",
		UnitMultiplier:  decimal.NewFromInt(1000000),
		MonthlyQuantity: monthlyRequests,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(a.Region),
			Service:       strPtr("AWSLambda"),
			ProductFamily: strPtr("Serverless"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "group", Value: strPtr(requestType)},
				{Key: "usagetype", ValueRegex: strPtr("/Request/")},
				{Key: "groupDescription", ValueRegex: regexPtr("^(?!.*China free tier).*$")},
			},
		},
		UsageBased: true,
	},
	)

	// Defaults to x86 tiers
	gbRequestTiers := []int{6000000000, 9000000000}
	displayNameList := []string{"Duration (first 6B)", "Duration (next 9B)", "Duration (over 15B)"}

	if a.Architecture == "arm64" {
		gbRequestTiers = []int{7500000000, 11250000000}
		displayNameList = []string{"Duration (first 7.5B)", "Duration (next 11.25B)", "Duration (over 18.75B)"}
	}

	if isAWSChina(a.Region) {
		gbRequestTiers = []int{}
		displayNameList = []string{"Duration"}
	}

	if a.MonthlyRequests != nil {
		monthlyRequests = decimalPtr(decimal.NewFromInt(*a.MonthlyRequests))
		gbSeconds = decimalPtr(calculateGBSeconds(memorySize, averageRequestDuration, *monthlyRequests))
		storageGBSeconds = decimalPtr(calculateStorageGBSeconds(storageSize, *gbSeconds))

		gbSecondQuantities := usage.CalculateTierBuckets(*gbSeconds, gbRequestTiers)

		costComponents = append(costComponents, a.storageCostComponent(storageGBSeconds, storageType))

		usageTier := 0
		for i := 0; i < len(gbSecondQuantities); i++ {
			// Always add the first one
			if i == 0 || gbSecondQuantities[i].GreaterThan(decimal.NewFromInt(0)) {
				costComponents = append(costComponents, a.durationCostComponent(displayNameList[i], strconv.Itoa(usageTier), &gbSecondQuantities[i], durationType))
				if i < len(gbRequestTiers) {
					usageTier += gbRequestTiers[i]
				}
			}
		}
	} else {
		costComponents = append(costComponents, a.storageCostComponent(nil, storageType))
		costComponents = append(costComponents, a.durationCostComponent(displayNameList[0], "0", gbSeconds, durationType))
	}

	estimate := func(ctx context.Context, values map[string]interface{}) error {
		inv, err := aws.LambdaGetInvocations(ctx, a.Region, a.Name)
		if err != nil {
			return err
		}
		values["monthly_requests"] = int64(math.Round(inv))
		dur, err := aws.LambdaGetDurationAvg(ctx, a.Region, a.Name)
		if err != nil {
			return err
		}
		values["request_duration_ms"] = int64(math.Round(dur))
		return nil
	}

	return &schema.Resource{
		Name:           a.Address,
		UsageSchema:    a.UsageSchema(),
		CostComponents: costComponents,
		EstimateUsage:  estimate,
	}
}

func calculateGBSeconds(memorySize decimal.Decimal, averageRequestDuration decimal.Decimal, monthlyRequests decimal.Decimal) decimal.Decimal {
	gb := memorySize.Div(decimal.NewFromInt(1024))
	seconds := averageRequestDuration.Ceil().Div(decimal.NewFromInt(1000)) // Round up to closest 1ms and convert to seconds
	return monthlyRequests.Mul(gb).Mul(seconds)
}

func calculateStorageGBSeconds(storageSize decimal.Decimal, gbSeconds decimal.Decimal) decimal.Decimal {
	storage := storageSize.Sub(decimal.NewFromInt(512)).Div(decimal.NewFromInt(1024))
	return storage.Mul(gbSeconds)
}

func (a *LambdaFunction) durationCostComponent(displayName string, usageTier string, quantity *decimal.Decimal, durationType string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            displayName,
		Unit:            "GB-seconds",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(a.Region),
			Service:       strPtr("AWSLambda"),
			ProductFamily: strPtr("Serverless"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "group", Value: strPtr(durationType)},
				{Key: "usagetype", ValueRegex: strPtr("/GB-Second/")},
				{Key: "groupDescription", ValueRegex: regexPtr("^(?!.*China free tier).*$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(usageTier),
		},
		UsageBased: true,
	}
}

func (a *LambdaFunction) storageCostComponent(quantity *decimal.Decimal, storageType string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Ephemeral storage",
		Unit:            "GB-seconds",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(a.Region),
			Service:       strPtr("AWSLambda"),
			ProductFamily: strPtr("Serverless"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "group", Value: strPtr(storageType)},
				{Key: "usagetype", ValueRegex: strPtr("/GB-Second/")},
				{Key: "groupDescription", ValueRegex: regexPtr("^(?!.*China free tier).*$")},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/aws/lambda_provisioned_concurrency_config.go
# RESOURCE: aws_lambda_provisioned_concurrency_config
# SIZE: 5125 bytes | LINES: 125
################################################################################
package aws

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// LambdaProvisionedConcurrencyConfig initializes a requested number of execution environments so that
// they are prepared to respond immediately to your functions invocations. Configuring provisioned
// concurrency incurs charges to your AWS Account.
//
// Resource information: https://docs.aws.amazon.com/lambda/latest/dg/lambda-concurrency.html
// Pricing information: https://aws.amazon.com/lambda/pricing/#Provisioned_Concurrency_Pricing
type LambdaProvisionedConcurrencyConfig struct {
	Address                         string
	Region                          string
	Name                            string
	ProvisionedConcurrentExecutions int64

	MonthlyDurationHours *int64  `infracost_usage:"monthly_duration_hrs"`
	MonthlyRequests      *int64  `infracost_usage:"monthly_requests"`
	RequestDurationMS    *int64  `infracost_usage:"request_duration_ms"`
	Architecture         *string `infracost_usage:"architecture"`
	MemoryMB             *int64  `infracost_usage:"memory_mb"`
}

func (r *LambdaProvisionedConcurrencyConfig) CoreType() string {
	return "LambdaProvisionedConcurrencyConfig"
}

func (r *LambdaProvisionedConcurrencyConfig) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "memory_mb", ValueType: schema.Int64, DefaultValue: 512},
		{Key: "architecture", ValueType: schema.String, DefaultValue: "x86_64"},
		{Key: "monthly_duration_hrs", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "request_duration_ms", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *LambdaProvisionedConcurrencyConfig) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *LambdaProvisionedConcurrencyConfig) BuildResource() *schema.Resource {
	monthlyDurationHours := decimal.NewFromInt(0)
	memorySize := decimal.NewFromInt(512)
	monthlyRequests := decimal.NewFromInt(0)

	concurrentExecutions := decimal.NewFromInt(r.ProvisionedConcurrentExecutions)

	if r.MonthlyRequests != nil {
		monthlyRequests = decimal.NewFromInt(*r.MonthlyRequests)
	}

	if r.MonthlyDurationHours != nil {
		monthlyDurationHours = decimal.NewFromInt(*r.MonthlyDurationHours)
	}

	averageRequestDuration := decimal.NewFromInt(1)
	if r.RequestDurationMS != nil {
		averageRequestDuration = decimal.NewFromInt(*r.RequestDurationMS)
	}

	if r.MemoryMB != nil {
		memorySize = decimal.NewFromInt(*r.MemoryMB)
	}

	totalSeconds := monthlyDurationHours.Mul(decimal.NewFromInt(3600))
	totalConcurrencyConfigured := concurrentExecutions.Mul(memorySize.Div(decimal.NewFromInt(1024)))
	totalConcurrency := totalConcurrencyConfigured.Mul(totalSeconds)

	concurrencyType := "AWS-Lambda-Provisioned-Concurrency"
	durationType := "AWS-Lambda-Duration-Provisioned"
	requestType := "AWS-Lambda-Requests"

	if strVal(r.Architecture) == "arm64" {
		concurrencyType = "AWS-Lambda-Provisioned-Concurrency-ARM"
		durationType = "AWS-Lambda-Duration-Provisioned-ARM"
		requestType = "AWS-Lambda-Requests-ARM"
	}

	provisionDuration := calculateGBSeconds(memorySize, averageRequestDuration, monthlyRequests)

	costComponents := []*schema.CostComponent{
		{
			Name:            "Requests",
			Unit:            "1M requests",
			UnitMultiplier:  decimal.NewFromInt(1000000),
			MonthlyQuantity: decimalPtr(monthlyRequests),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AWSLambda"),
				ProductFamily: strPtr("Serverless"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "group", Value: strPtr(requestType)},
					{Key: "usagetype", ValueRegex: strPtr("/Request/")},
				},
			},
			UsageBased: true,
		},
		{
			Name:            "Provisioned Concurrency",
			Unit:            "GB-seconds",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: &totalConcurrency,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AWSLambda"),
				ProductFamily: strPtr("Serverless"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "group", Value: strPtr(concurrencyType)},
				},
			},
			UsageBased: true,
		},
		{
			Name:            "Duration",
			Unit:            "GB-seconds",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: &provisionDuration,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AWSLambda"),
				ProductFamily: strPtr("Serverless"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "group", Value: strPtr(durationType)},
				},
			},
			UsageBased: true,
		},
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

################################################################################
# FILE: internal/resources/aws/launch_configuration.go
# RESOURCE: aws_launch_configuration
# SIZE: 3593 bytes | LINES: 86
################################################################################
package aws

import (
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type LaunchConfiguration struct {
	// "required" args that can't really be missing.
	Address          string
	Region           string
	Tenancy          string
	PurchaseOption   string
	AMI              string
	InstanceType     string
	EBSOptimized     bool
	EnableMonitoring bool
	CPUCredits       string

	// "optional" args, that may be empty depending on the resource config
	ElasticInferenceAcceleratorType *string
	RootBlockDevice                 *EBSVolume
	EBSBlockDevices                 []*EBSVolume

	// "usage" args
	// These are populated from the Autoscaling Group resource
	InstanceCount                 *int64  `infracost_usage:"instances"`
	OperatingSystem               *string `infracost_usage:"operating_system"`
	ReservedInstanceType          *string `infracost_usage:"reserved_instance_type"`
	ReservedInstanceTerm          *string `infracost_usage:"reserved_instance_term"`
	ReservedInstancePaymentOption *string `infracost_usage:"reserved_instance_payment_option"`
	MonthlyCPUCreditHours         *int64  `infracost_usage:"monthly_cpu_credit_hrs"`
	VCPUCount                     *int64  `infracost_usage:"vcpu_count"`
}

var LaunchConfigurationUsageSchema = InstanceUsageSchema

func (r *LaunchConfiguration) CoreType() string {
	return "LaunchConfiguration"
}

func (r *LaunchConfiguration) UsageSchema() []*schema.UsageItem {
	return LaunchConfigurationUsageSchema
}

func (r *LaunchConfiguration) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *LaunchConfiguration) BuildResource() *schema.Resource {
	if strings.ToLower(r.Tenancy) == "host" {
		logging.Logger.Warn().Msgf("Skipping resource %s. Infracost currently does not support host tenancy for AWS Launch Configurations", r.Address)
		return nil
	} else if strings.ToLower(r.Tenancy) == "dedicated" {
		r.Tenancy = "Dedicated"
	} else {
		r.Tenancy = "Shared"
	}

	instance := &Instance{
		Region:                          r.Region,
		Tenancy:                         r.Tenancy,
		PurchaseOption:                  r.PurchaseOption,
		AMI:                             r.AMI,
		InstanceType:                    r.InstanceType,
		EBSOptimized:                    r.EBSOptimized,
		EnableMonitoring:                r.EnableMonitoring,
		CPUCredits:                      r.CPUCredits,
		ElasticInferenceAcceleratorType: r.ElasticInferenceAcceleratorType,
		OperatingSystem:                 r.OperatingSystem,
		RootBlockDevice:                 r.RootBlockDevice,
		EBSBlockDevices:                 r.EBSBlockDevices,
		ReservedInstanceType:            r.ReservedInstanceType,
		ReservedInstanceTerm:            r.ReservedInstanceTerm,
		ReservedInstancePaymentOption:   r.ReservedInstancePaymentOption,
		MonthlyCPUCreditHours:           r.MonthlyCPUCreditHours,
		VCPUCount:                       r.VCPUCount,
	}
	instanceResource := instance.BuildResource()

	res := &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: instanceResource.CostComponents,
		SubResources:   instanceResource.SubResources,
		EstimateUsage:  instanceResource.EstimateUsage,
	}

	qty := int64(1)
	if r.InstanceCount != nil {
		qty = *r.InstanceCount
	}
	schema.MultiplyQuantities(res, decimal.NewFromInt(qty))

	return res
}

################################################################################
# FILE: internal/resources/aws/launch_template.go
# RESOURCE: aws_launch_template
# SIZE: 5331 bytes | LINES: 118
################################################################################
package aws

import (
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type LaunchTemplate struct {
	// "required" args that can't really be missing.
	Address                          string
	Region                           string
	AMI                              string
	OnDemandBaseCount                int64
	OnDemandPercentageAboveBaseCount int64
	Tenancy                          string
	InstanceType                     string
	EBSOptimized                     bool
	EnableMonitoring                 bool
	CPUCredits                       string

	// "optional" args, that may be empty depending on the resource config
	ElasticInferenceAcceleratorType *string
	RootBlockDevice                 *EBSVolume
	EBSBlockDevices                 []*EBSVolume

	// "usage" args
	// These are populated from the Autoscaling Group/EKS Node Group resource
	InstanceCount                 *int64  `infracost_usage:"instances"`
	OperatingSystem               *string `infracost_usage:"operating_system"`
	ReservedInstanceType          *string `infracost_usage:"reserved_instance_type"`
	ReservedInstanceTerm          *string `infracost_usage:"reserved_instance_term"`
	ReservedInstancePaymentOption *string `infracost_usage:"reserved_instance_payment_option"`
	MonthlyCPUCreditHours         *int64  `infracost_usage:"monthly_cpu_credit_hrs"`
	VCPUCount                     *int64  `infracost_usage:"vcpu_count"`
}

var LaunchTemplateUsageSchema = InstanceUsageSchema

func (r *LaunchTemplate) CoreType() string {
	return "LaunchTemplate"
}

func (r *LaunchTemplate) UsageSchema() []*schema.UsageItem {
	return LaunchTemplateUsageSchema
}

func (r *LaunchTemplate) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *LaunchTemplate) BuildResource() *schema.Resource {
	if strings.ToLower(r.Tenancy) == "host" {
		logging.Logger.Warn().Msgf("Skipping resource %s. Infracost currently does not support host tenancy for AWS Launch Templates", r.Address)
		return nil
	} else if strings.ToLower(r.Tenancy) == "dedicated" {
		r.Tenancy = "Dedicated"
	} else {
		r.Tenancy = "Shared"
	}

	costComponents := make([]*schema.CostComponent, 0)

	instance := &Instance{
		Region:                          r.Region,
		Tenancy:                         r.Tenancy,
		AMI:                             r.AMI,
		InstanceType:                    r.InstanceType,
		EBSOptimized:                    r.EBSOptimized,
		EnableMonitoring:                r.EnableMonitoring,
		CPUCredits:                      r.CPUCredits,
		ElasticInferenceAcceleratorType: r.ElasticInferenceAcceleratorType,
		OperatingSystem:                 r.OperatingSystem,
		RootBlockDevice:                 r.RootBlockDevice,
		EBSBlockDevices:                 r.EBSBlockDevices,
		ReservedInstanceType:            r.ReservedInstanceType,
		ReservedInstanceTerm:            r.ReservedInstanceTerm,
		ReservedInstancePaymentOption:   r.ReservedInstancePaymentOption,
		MonthlyCPUCreditHours:           r.MonthlyCPUCreditHours,
		VCPUCount:                       r.VCPUCount,
	}
	instanceResource := instance.BuildResource()

	// Skip the Instance usage cost component since we will prepend these later with the correct purchase options and counts
	for _, costComponent := range instanceResource.CostComponents {
		if !strings.HasPrefix(costComponent.Name, "Instance usage") {
			costComponents = append(costComponents, costComponent)
		}
	}

	res := &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
		SubResources:   instanceResource.SubResources,
		EstimateUsage:  instanceResource.EstimateUsage,
	}

	instanceCount := int64(1)
	if r.InstanceCount != nil {
		instanceCount = *r.InstanceCount
	}

	schema.MultiplyQuantities(res, decimal.NewFromInt(instanceCount))

	onDemandCount, spotCount := r.calculateOnDemandAndSpotInstanceCounts()

	if spotCount > 0 {
		instance.PurchaseOption = "spot"
		c := instance.computeCostComponent()
		c.MonthlyQuantity = decimalPtr(c.MonthlyQuantity.Mul(decimal.NewFromInt(spotCount)))
		res.CostComponents = append([]*schema.CostComponent{c}, res.CostComponents...)
	}

	if onDemandCount > 0 {
		instance.PurchaseOption = "on_demand"
		c := instance.computeCostComponent()
		c.MonthlyQuantity = decimalPtr(c.MonthlyQuantity.Mul(decimal.NewFromInt(onDemandCount)))
		res.CostComponents = append([]*schema.CostComponent{c}, res.CostComponents...)
	}

	return res
}

func (r *LaunchTemplate) calculateOnDemandAndSpotInstanceCounts() (int64, int64) {
	instanceCount := int64(1)
	if r.InstanceCount != nil {
		instanceCount = *r.InstanceCount
	}

	onDemandInstanceCount := r.OnDemandBaseCount
	remainingCount := instanceCount - onDemandInstanceCount
	percMultiplier := decimal.NewFromInt(r.OnDemandPercentageAboveBaseCount).Div(decimal.NewFromInt(100))
	onDemandInstanceCount += decimal.NewFromInt(remainingCount).Mul(percMultiplier).Ceil().IntPart()
	spotInstanceCount := instanceCount - onDemandInstanceCount

	return onDemandInstanceCount, spotInstanceCount
}

################################################################################
# FILE: internal/resources/aws/lb.go
# RESOURCE: aws_lb
# SIZE: 5336 bytes | LINES: 144
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"strings"

	"github.com/shopspring/decimal"
)

type LB struct {
	Address           string
	LoadBalancerType  string
	Region            string
	RuleEvaluations   *int64   `infracost_usage:"rule_evaluations"`
	NewConnections    *int64   `infracost_usage:"new_connections"`
	ActiveConnections *int64   `infracost_usage:"active_connections"`
	ProcessedBytesGB  *float64 `infracost_usage:"processed_bytes_gb"`
}

var LBUsageSchema = []*schema.UsageItem{
	{Key: "rule_evaluations", ValueType: schema.Int64, DefaultValue: 0},
	{Key: "new_connections", ValueType: schema.Int64, DefaultValue: 0},
	{Key: "active_connections", ValueType: schema.Int64, DefaultValue: 0},
	{Key: "processed_bytes_gb", ValueType: schema.Float64, DefaultValue: 0},
}

func (r *LB) CoreType() string {
	return "LB"
}

func (r *LB) UsageSchema() []*schema.UsageItem {
	return LBUsageSchema
}

func (r *LB) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *LB) BuildResource() *schema.Resource {
	var maxLCU *decimal.Decimal

	var newConnectionsLCU *decimal.Decimal
	if r.NewConnections != nil {
		newConnections := decimal.NewFromInt(*r.NewConnections)
		newConnectionsLCU = decimalPtr(newConnections.Div(decimal.NewFromInt(100)))
		maxLCU = newConnectionsLCU
	}

	var activeConnectionsLCU *decimal.Decimal
	if r.ActiveConnections != nil {
		activeConnections := decimal.NewFromInt(*r.ActiveConnections)
		activeConnectionsLCU = decimalPtr(activeConnections.Div(decimal.NewFromInt(3000)))

		if maxLCU == nil {
			maxLCU = activeConnectionsLCU
		} else {
			maxLCU = decimalPtr(decimal.Max(*maxLCU, *activeConnectionsLCU))
		}
	}

	var processedBytesLCU *decimal.Decimal
	if r.ProcessedBytesGB != nil {
		processedBytes := decimal.NewFromFloat(*r.ProcessedBytesGB)
		processedBytesLCU = decimalPtr(processedBytes.Div(decimal.NewFromInt(1)))

		if maxLCU == nil {
			maxLCU = processedBytesLCU
		} else {
			maxLCU = decimalPtr(decimal.Max(*maxLCU, *processedBytesLCU))
		}
	}

	var costComponents []*schema.CostComponent

	if strings.ToLower(r.LoadBalancerType) == "application" {
		var ruleEvaluationsLCU decimal.Decimal
		if r.RuleEvaluations != nil && maxLCU != nil {
			ruleEvaluations := decimal.NewFromInt(*r.RuleEvaluations)
			ruleEvaluationsLCU = ruleEvaluations.Div(decimal.NewFromInt(1000))

			if maxLCU == nil {
				maxLCU = &ruleEvaluationsLCU
			} else {
				maxLCU = decimalPtr(decimal.Max(*maxLCU, ruleEvaluationsLCU))
			}
		}

		costComponents = r.applicationLBCostComponents(maxLCU)
	} else {
		costComponents = r.networkLBCostComponents(maxLCU)
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *LB) applicationLBCostComponents(maxLCU *decimal.Decimal) []*schema.CostComponent {
	productFamily := "Load Balancer-Application"

	return []*schema.CostComponent{
		{
			Name:           "Application load balancer",
			Unit:           "hours",
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			UnitMultiplier: decimal.NewFromInt(1),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AWSELB"),
				ProductFamily: strPtr("Load Balancer-Application"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "locationType", Value: strPtr("AWS Region")},
					{Key: "usagetype", ValueRegex: regexPtr("^([A-Z]{3}\\d-|Global-|EU-)?LoadBalancerUsage$")},
				},
			},
		},
		r.capacityUnitsCostComponent(productFamily, maxLCU),
	}
}

func (r *LB) networkLBCostComponents(maxLCU *decimal.Decimal) []*schema.CostComponent {
	productFamily := "Load Balancer-Network"

	return []*schema.CostComponent{
		{
			Name:           "Network load balancer",
			Unit:           "hours",
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			UnitMultiplier: decimal.NewFromInt(1),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AWSELB"),
				ProductFamily: strPtr("Load Balancer-Network"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "locationType", Value: strPtr("AWS Region")},
					{Key: "usagetype", ValueRegex: strPtr("/LoadBalancerUsage/")},
				},
			},
		},
		r.capacityUnitsCostComponent(productFamily, maxLCU),
	}
}

func (r *LB) capacityUnitsCostComponent(productFamily string, maxLCU *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Load balancer capacity units",
		Unit:            "LCU",
		UnitMultiplier:  schema.HourToMonthUnitMultiplier,
		MonthlyQuantity: maxLCU,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSELB"),
			ProductFamily: strPtr(productFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "locationType", Value: strPtr("AWS Region")},
				{Key: "usagetype", ValueRegex: strPtr("/^([A-Z]{3}\\d-|Global-|EU-)?LCUUsage/")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/lightsail_instance.go
# RESOURCE: aws_lightsail_instance
# SIZE: 2098 bytes | LINES: 68
################################################################################
package aws

import (
	"fmt"
	"strings"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type LightsailInstance struct {
	Address  string
	Region   string
	BundleID string
}

func (r *LightsailInstance) CoreType() string {
	return "LightsailInstance"
}

func (r *LightsailInstance) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *LightsailInstance) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *LightsailInstance) BuildResource() *schema.Resource {
	bundlePrefixMappings := map[string]string{
		"nano":    "0.5GB",
		"micro":   "1GB",
		"small":   "2GB",
		"medium":  "4GB",
		"large":   "8GB",
		"xlarge":  "16GB",
		"2xlarge": "32GB",
		"4xlarge": "64GB",
	}

	operatingSystemSuffix := ""
	operatingSystemLabel := "Linux/UNIX"

	if strings.Contains(strings.ToLower(r.BundleID), "_win_") {
		operatingSystemSuffix = "_win"
		operatingSystemLabel = "Windows"
	}

	bundlePrefix := strings.Split(strings.ToLower(r.BundleID), "_")[0]

	memory, ok := bundlePrefixMappings[bundlePrefix]
	if !ok {
		// this will end up showing a 'product not found' warning
		memory = bundlePrefix
	}

	usagetypeRegex := fmt.Sprintf("-BundleUsage:%s%s$", memory, operatingSystemSuffix)

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:           fmt.Sprintf("Virtual server (%s)", operatingSystemLabel),
				Unit:           "hours",
				UnitMultiplier: decimal.NewFromInt(1),
				HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AmazonLightsail"),
					ProductFamily: strPtr("Lightsail Instance"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: regexPtr(usagetypeRegex)},
					},
				},
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/mq_broker.go
# RESOURCE: aws_mq_broker
# SIZE: 3793 bytes | LINES: 111
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type MQBroker struct {
	Address          string
	StorageType      string
	DeploymentMode   string
	Region           string
	EngineType       string
	HostInstanceType string
	StorageSizeGb    *float64 `infracost_usage:"storage_size_gb"`
}

func (r *MQBroker) CoreType() string {
	return "MQBroker"
}

func (r *MQBroker) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "storage_size_gb", ValueType: schema.Float64, DefaultValue: 0}}
}

func (r *MQBroker) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *MQBroker) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			r.instanceUsageCostComponent(),
			r.storageCostComponent(),
		},
		UsageSchema: r.UsageSchema(),
	}
}

func (r *MQBroker) isMultiAZ() bool {
	if strings.ToLower(r.DeploymentMode) == "active_standby_multi_az" || strings.ToLower(r.DeploymentMode) == "cluster_multi_az" {
		return true
	}

	return false
}

func (r *MQBroker) instanceUsageCostComponent() *schema.CostComponent {
	deploymentOption := "Single-AZ"
	if r.isMultiAZ() {
		deploymentOption = "Multi-AZ"
	}

	deploymentMode := strings.ToLower(r.DeploymentMode)
	if deploymentMode == "" {
		deploymentMode = "single_instance"
	}

	return &schema.CostComponent{
		Name:           fmt.Sprintf("Instance usage (%s, %s, %s)", r.EngineType, r.HostInstanceType, strings.ToLower(deploymentMode)),
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonMQ"),
			ProductFamily: strPtr("Broker Instances"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr(r.HostInstanceType)},
				{Key: "brokerEngine", ValueRegex: regexPtr(r.EngineType)},
				{Key: "deploymentOption", ValueRegex: regexPtr(deploymentOption)},
				{Key: "operation", ValueRegex: regexPtr("CreateBroker")},
			},
		},
	}
}

func (r *MQBroker) storageCostComponent() *schema.CostComponent {
	instanceCount := int64(1)
	if strings.ToLower(r.EngineType) == "rabbitmq" && r.isMultiAZ() {
		instanceCount = int64(3)
	}

	storageType := strings.ToLower(r.StorageType)
	if storageType == "" {
		if strings.ToLower(r.EngineType) == "rabbitmq" {
			storageType = "ebs"
		} else {
			storageType = "efs"
		}
	}

	usageType := "TimedStorage-ByteHrs"
	if strings.ToLower(r.EngineType) == "rabbitmq" {
		usageType = "TimedStorage-RabbitMQ-ByteHrs"
	} else if strings.ToLower(storageType) == "ebs" {
		usageType = "TimedStorage-EBS-ByteHrs"
	}

	var storageSizeGB *decimal.Decimal
	if r.StorageSizeGb != nil {
		storageSizeGB = decimalPtr(decimal.NewFromFloat(*r.StorageSizeGb).Mul(decimal.NewFromInt(instanceCount)))
	}

	costComponent := &schema.CostComponent{
		Name:            fmt.Sprintf("Storage (%s, %s)", r.EngineType, strings.ToUpper(storageType)),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: storageSizeGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonMQ"),
			ProductFamily: strPtr("Broker Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", usageType))},
			},
		},
		UsageBased: true,
	}
	return costComponent
}

################################################################################
# FILE: internal/resources/aws/msk_cluster.go
# RESOURCE: aws_msk_cluster
# SIZE: 2623 bytes | LINES: 77
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type MSKCluster struct {
	Address                 string
	Region                  string
	BrokerNodes             int64
	BrokerNodeInstanceType  string
	BrokerNodeEBSVolumeSize int64

	// "optional" args, that may be empty depending on the resource config
	AppAutoscalingTarget []*AppAutoscalingTarget
}

func (r *MSKCluster) CoreType() string {
	return "MSKCluster"
}

func (r *MSKCluster) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *MSKCluster) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *MSKCluster) BuildResource() *schema.Resource {
	ebsVolumeSize := r.BrokerNodeEBSVolumeSize
	ebsAutoscaleSuffix := ""

	for _, target := range r.AppAutoscalingTarget {
		if target.ScalableDimension == "kafka:broker-storage:VolumeSize" {
			ebsAutoscaleSuffix = " (autoscaling)"
			if target.Capacity != nil {
				ebsVolumeSize = *target.Capacity
			} else {
				ebsVolumeSize = target.MinCapacity
			}
		}
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:           fmt.Sprintf("Instance (%s)", r.BrokerNodeInstanceType),
				Unit:           "hours",
				UnitMultiplier: decimal.NewFromInt(1),
				HourlyQuantity: decimalPtr(decimal.NewFromInt(r.BrokerNodes)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AmazonMSK"),
					ProductFamily: strPtr("Managed Streaming for Apache Kafka (MSK)"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", r.BrokerNodeInstanceType))},
						{Key: "locationType", Value: strPtr("AWS Region")},
					},
				},
			},
			{
				Name:            "Storage" + ebsAutoscaleSuffix,
				Unit:            "GB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: decimalPtr(decimal.NewFromInt(ebsVolumeSize * r.BrokerNodes)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AmazonMSK"),
					ProductFamily: strPtr("Managed Streaming for Apache Kafka (MSK)"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "storageFamily", Value: strPtr("GP2")},
					},
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/mwaa_environment.go
# RESOURCE: aws_mwaa_environment
# SIZE: 3879 bytes | LINES: 97
################################################################################
package aws

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type MWAAEnvironment struct {
	// These fields are required since they are pulled directly from the IAC configuration (e.g. the terraform plan)
	Address string
	Region  string
	Size    string // Should be Small, Medium, or Large

	// If there is a parameter than needs to be read from infracost-usage.yml you define it like this:
	AdditionalWorkers    *float64 `infracost_usage:"additional_workers"`
	AdditionalSchedulers *float64 `infracost_usage:"additional_schedulers"`
	MetaDatabaseGB       *float64 `infracost_usage:"meta_database_gb"`
}

// If the resource requires a usage parameter
func (a *MWAAEnvironment) CoreType() string {
	return "MWAAEnvironment"
}

func (a *MWAAEnvironment) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "additional_workers", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "additional_schedulers", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "meta_database_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	}
}

// If the resource requires a usage parameter
func (a *MWAAEnvironment) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(a, u)
}

func (a *MWAAEnvironment) BuildResource() *schema.Resource {
	var workerQuantity, schedulerQuantity, metaDatabaseGB *decimal.Decimal
	if a.AdditionalWorkers != nil {
		workerQuantity = decimalPtr(decimal.NewFromFloat(*a.AdditionalWorkers))
	}
	if a.AdditionalSchedulers != nil {
		schedulerQuantity = decimalPtr(decimal.NewFromFloat(*a.AdditionalSchedulers))
	}
	if a.MetaDatabaseGB != nil {
		metaDatabaseGB = decimalPtr(decimal.NewFromFloat(*a.MetaDatabaseGB))
	}

	costComponents := []*schema.CostComponent{
		a.newInstanceCostComponent("Environment", a.Size, decimalPtr(decimal.NewFromInt(1))),
		a.newInstanceCostComponent("Worker", a.Size, workerQuantity),
		a.newInstanceCostComponent("Scheduler", a.Size, schedulerQuantity),
		a.newStorageCostComponent(metaDatabaseGB),
	}

	return &schema.Resource{
		Name:           a.Address,
		UsageSchema:    a.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (a *MWAAEnvironment) newInstanceCostComponent(instanceType, size string, quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           fmt.Sprintf("%s (%s)", instanceType, size),
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(a.Region),
			Service:    strPtr("AmazonMWAA"),
			AttributeFilters: []*schema.AttributeFilter{
				// Note the use of start/end anchors and case-insensitive match with ValueRegex
				{Key: "size", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", a.Size))},
				{Key: "type", Value: strPtr(instanceType)},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
	}
}

func (a *MWAAEnvironment) newStorageCostComponent(quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Meta database",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(a.Region),
			Service:    strPtr("AmazonMWAA"),
			AttributeFilters: []*schema.AttributeFilter{
				// Note the use of start/end anchors and case-insensitive match with ValueRegex
				{Key: "usagetype", ValueRegex: strPtr("/Airflow-StandardDatabaseStorage$/")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/nat_gateway.go
# RESOURCE: aws_nat_gateway
# SIZE: 2088 bytes | LINES: 65
################################################################################
package aws

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type NATGateway struct {
	Address string
	Region  string

	MonthlyDataProcessedGB *float64 `infracost_usage:"monthly_data_processed_gb"`
}

func (a *NATGateway) CoreType() string {
	return "NATGateway"
}

func (a *NATGateway) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_data_processed_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	}
}

func (a *NATGateway) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(a, u)
}

func (a *NATGateway) BuildResource() *schema.Resource {
	var gbDataProcessed *decimal.Decimal
	if a.MonthlyDataProcessedGB != nil {
		gbDataProcessed = decimalPtr(decimal.NewFromFloat(*a.MonthlyDataProcessedGB))
	}

	return &schema.Resource{
		Name:        a.Address,
		UsageSchema: a.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			{
				Name:           "NAT gateway",
				Unit:           "hours",
				UnitMultiplier: decimal.NewFromInt(1),
				HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(a.Region),
					Service:       strPtr("AmazonEC2"),
					ProductFamily: strPtr("NAT Gateway"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/NatGateway-Hours/")},
					},
				},
			},
			{
				Name:            "Data processed",
				Unit:            "GB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: gbDataProcessed,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(a.Region),
					Service:       strPtr("AmazonEC2"),
					ProductFamily: strPtr("NAT Gateway"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/NatGateway-Bytes/")},
					},
				},
				UsageBased: true,
			},
		},
	}
}

################################################################################
# FILE: internal/resources/aws/neptune_cluster.go
# RESOURCE: aws_neptune_cluster
# SIZE: 3854 bytes | LINES: 114
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type NeptuneCluster struct {
	Address               string
	Region                string
	BackupRetentionPeriod int64
	StorageGB             *float64 `infracost_usage:"storage_gb"`
	MonthlyIORequests     *int64   `infracost_usage:"monthly_io_requests"`
	BackupStorageGB       *float64 `infracost_usage:"backup_storage_gb"`
}

func (r *NeptuneCluster) CoreType() string {
	return "NeptuneCluster"
}

func (r *NeptuneCluster) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "storage_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_io_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "backup_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *NeptuneCluster) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *NeptuneCluster) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.storageCostComponent(),
		r.ioRequestsCostComponent(),
	}

	if r.BackupRetentionPeriod > 1 {
		costComponents = append(costComponents, r.backupStorageCostComponent())
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *NeptuneCluster) storageCostComponent() *schema.CostComponent {
	var storageGB *decimal.Decimal
	if r.StorageGB != nil {
		storageGB = decimalPtr(decimal.NewFromFloat(*r.StorageGB))
	}

	return &schema.CostComponent{
		Name:            "Storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: storageGB,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(r.Region),
			Service:    strPtr("AmazonNeptune"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("^([A-Z]{3}\\d-|Global-|EU-)?StorageUsage$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *NeptuneCluster) ioRequestsCostComponent() *schema.CostComponent {
	var monthlyIORequests *decimal.Decimal
	if r.MonthlyIORequests != nil {
		monthlyIORequests = decimalPtr(decimal.NewFromInt(*r.MonthlyIORequests))
	}

	return &schema.CostComponent{
		Name:            "I/O requests",
		Unit:            "1M request",
		UnitMultiplier:  decimal.NewFromInt(int64(1000000)),
		MonthlyQuantity: monthlyIORequests,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(r.Region),
			Service:    strPtr("AmazonNeptune"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s$/i", "StorageIOUsage"))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *NeptuneCluster) backupStorageCostComponent() *schema.CostComponent {
	var backupStorageGB *decimal.Decimal
	if r.BackupStorageGB != nil {
		backupStorageGB = decimalPtr(decimal.NewFromFloat(*r.BackupStorageGB))
	}

	return &schema.CostComponent{
		Name:            "Backup storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: backupStorageGB,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(r.Region),
			Service:    strPtr("AmazonNeptune"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/BackupUsage$/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/neptune_cluster_instance.go
# RESOURCE: aws_neptune_cluster_instance
# SIZE: 3307 bytes | LINES: 92
################################################################################
package aws

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type NeptuneClusterInstance struct {
	Address             string
	Region              string
	InstanceClass       string
	IOOptimized         bool
	Count               *int64
	MonthlyCPUCreditHrs *int64 `infracost_usage:"monthly_cpu_credit_hrs"`
}

func (r *NeptuneClusterInstance) CoreType() string {
	return "NeptuneClusterInstance"
}

func (r *NeptuneClusterInstance) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_cpu_credit_hrs", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *NeptuneClusterInstance) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *NeptuneClusterInstance) BuildResource() *schema.Resource {
	hourlyQuantity := 1
	if r.Count != nil {
		hourlyQuantity = int(*r.Count)
	}

	var monthlyCPUCreditHrs *decimal.Decimal
	if r.MonthlyCPUCreditHrs != nil {
		monthlyCPUCreditHrs = decimalPtr(decimal.NewFromInt(*r.MonthlyCPUCreditHrs))
	}

	costComponents := []*schema.CostComponent{
		r.dbInstanceCostComponent(hourlyQuantity),
	}

	if instanceFamily := getBurstableInstanceFamily([]string{"db.t3", "db.t4g"}, r.InstanceClass); instanceFamily != "" {
		costComponents = append(costComponents, r.cpuCreditsCostComponent(monthlyCPUCreditHrs, instanceFamily))
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *NeptuneClusterInstance) dbInstanceCostComponent(quantity int) *schema.CostComponent {
	usageTypePrefix := "InstanceUsage:"
	if r.IOOptimized {
		usageTypePrefix = "InstanceUsageIOOptimized:"
	}

	return &schema.CostComponent{
		Name:           fmt.Sprintf("Database instance (on-demand, %s)", r.InstanceClass),
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(int64(quantity))),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(r.Region),
			Service:    strPtr("AmazonNeptune"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "instanceType", Value: strPtr(strings.ToLower(r.InstanceClass))},
				{Key: "usagetype", ValueRegex: regexPtr(fmt.Sprintf("%s%s$", usageTypePrefix, strings.ToLower(r.InstanceClass)))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
	}
}

func (r *NeptuneClusterInstance) cpuCreditsCostComponent(quantity *decimal.Decimal, instanceFamily string) *schema.CostComponent {
	return &schema.CostComponent{

		Name:           "CPU credits",
		Unit:           "vCPU-hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(r.Region),
			Service:    strPtr("AmazonNeptune"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("CPUCredits:" + instanceFamily + "$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/neptune_cluster_snapshot.go
# RESOURCE: aws_neptune_cluster_snapshot
# SIZE: 1379 bytes | LINES: 41
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type NeptuneClusterSnapshot struct {
	Address               string
	Region                string
	BackupRetentionPeriod *int64   // This can be unknown since it's retrieved from the Neptune cluster
	BackupStorageGB       *float64 `infracost_usage:"backup_storage_gb"`
}

func (r *NeptuneClusterSnapshot) CoreType() string {
	return "NeptuneClusterSnapshot"
}

func (r *NeptuneClusterSnapshot) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "backup_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *NeptuneClusterSnapshot) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *NeptuneClusterSnapshot) BuildResource() *schema.Resource {
	if r.BackupRetentionPeriod != nil && *r.BackupRetentionPeriod < 2 {
		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	cluster := &NeptuneCluster{
		Region:          r.Region,
		BackupStorageGB: r.BackupStorageGB,
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: []*schema.CostComponent{cluster.backupStorageCostComponent()},
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/networkfirewall_firewall.go
# RESOURCE: aws_networkfirewall_firewall
# SIZE: 3113 bytes | LINES: 78
################################################################################
package aws

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// NetworkfirewallFirewall struct represents an AWS Network Firewall Firewall resource.
//
// Resource information: https://aws.amazon.com/network-firewall/
// Pricing information: https://aws.amazon.com/network-firewall/pricing/
type NetworkfirewallFirewall struct {
	Address string
	Region  string

	MonthlyDataProcessedGB *float64 `infracost_usage:"monthly_data_processed_gb"`
}

// NetworkfirewallFirewallUsageSchema defines a list which represents the usage schema of NetworkfirewallFirewall.
func (r *NetworkfirewallFirewall) CoreType() string {
	return "NetworkfirewallFirewall"
}

func (r *NetworkfirewallFirewall) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_data_processed_gb", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the NetworkfirewallFirewall.
// It uses the `infracost_usage` struct tags to populate data into the NetworkfirewallFirewall.
func (r *NetworkfirewallFirewall) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid NetworkfirewallFirewall struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *NetworkfirewallFirewall) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.endpointCostComponent(),
		r.dataProcessedCostComponent(),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *NetworkfirewallFirewall) endpointCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Network Firewall Endpoint",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSNetworkFirewall"),
			ProductFamily: strPtr("AWS Firewall"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("^[A-Z0-9]*-Endpoint-Hour$")},
			},
		},
	}
}

func (r *NetworkfirewallFirewall) dataProcessedCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Data Processed",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyDataProcessedGB),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSNetworkFirewall"),
			ProductFamily: strPtr("AWS Firewall"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("^[A-Z0-9]*-Traffic-GB-Processed$")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/rds_cluster.go
# RESOURCE: aws_rds_cluster
# SIZE: 10076 bytes | LINES: 228
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"strings"

	"github.com/shopspring/decimal"
)

type RDSCluster struct {
	Address                   string
	Region                    string
	EngineMode                string
	Engine                    string
	IOOptimized               bool
	BackupRetentionPeriod     int64
	WriteRequestsPerSec       *int64   `infracost_usage:"write_requests_per_sec"`
	ReadRequestsPerSec        *int64   `infracost_usage:"read_requests_per_sec"`
	ChangeRecordsPerStatement *float64 `infracost_usage:"change_records_per_statement"`
	StorageGB                 *float64 `infracost_usage:"storage_gb"`
	AverageStatementsPerHr    *int64   `infracost_usage:"average_statements_per_hr"`
	BacktrackWindowHrs        *int64   `infracost_usage:"backtrack_window_hrs"`
	SnapshotExportSizeGB      *float64 `infracost_usage:"snapshot_export_size_gb"`
	CapacityUnitsPerHr        *float64 `infracost_usage:"capacity_units_per_hr"`
	BackupSnapshotSizeGB      *float64 `infracost_usage:"backup_snapshot_size_gb"`
}

func (r *RDSCluster) CoreType() string {
	return "RDSCluster"
}

func (r *RDSCluster) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "write_requests_per_sec", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "read_requests_per_sec", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "change_records_per_statement", ValueType: schema.Float64, DefaultValue: 0.0},
		{Key: "storage_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "average_statements_per_hr", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "backtrack_window_hrs", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "snapshot_export_size_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "capacity_units_per_hr", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "backup_snapshot_size_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *RDSCluster) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *RDSCluster) BuildResource() *schema.Resource {
	costComponents := make([]*schema.CostComponent, 0)

	databaseEngineMode := strings.ToLower(r.EngineMode)
	if databaseEngineMode == "" {
		databaseEngineMode = "provisioned"
	}

	databaseEngineStorageType := "Any"

	var databaseEngine string
	switch r.Engine {
	case "aurora", "aurora-mysql":
		databaseEngine = "Aurora MySQL"
		databaseEngineStorageType = "(Any|Aurora MySQL)"
	case "aurora-postgresql":
		databaseEngine = "Aurora PostgreSQL"
		databaseEngineStorageType = databaseEngine
	}

	var auroraCapacityUnits *decimal.Decimal
	if r.CapacityUnitsPerHr != nil {
		auroraCapacityUnits = decimalPtr(decimal.NewFromFloat(*r.CapacityUnitsPerHr))
	}

	if strings.ToLower(databaseEngineMode) == "serverless" {
		costComponents = append(costComponents, &schema.CostComponent{
			Name:           "Aurora serverless",
			Unit:           "ACU-hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: auroraCapacityUnits,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonRDS"),
				ProductFamily: strPtr("Serverless"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "databaseEngine", ValueRegex: regexPtr(databaseEngine)},
				},
			},
			UsageBased: true,
		})
	}

	costComponents = append(costComponents, r.auroraStorageCostComponents(databaseEngineStorageType)...)

	if r.BackupRetentionPeriod > 1 {
		var totalBackupStorageGB *decimal.Decimal

		if r.BackupSnapshotSizeGB != nil {
			totalBackupStorageGB = decimalPtr(r.calculateBackupStorage(decimal.NewFromFloat(*r.BackupSnapshotSizeGB), r.BackupRetentionPeriod))
		}

		costComponents = append(costComponents, r.auroraBackupStorageCostComponent(totalBackupStorageGB, databaseEngine))
	}

	if databaseEngineMode != "serverless" && !strings.Contains(r.Engine, "postgresql") {
		var totalBacktrackChangeRecords *decimal.Decimal

		if r.AverageStatementsPerHr != nil && r.ChangeRecordsPerStatement != nil && r.BacktrackWindowHrs != nil {
			averageStatements := decimal.NewFromInt(*r.AverageStatementsPerHr)
			backtrackChangeRecords := decimal.NewFromFloat(*r.ChangeRecordsPerStatement)
			backtrackWindowHours := decimal.NewFromInt(*r.BacktrackWindowHrs)

			totalBacktrackChangeRecords = decimalPtr(r.calculateBacktrack(averageStatements, backtrackChangeRecords, backtrackWindowHours))
		}

		costComponents = append(costComponents, r.auroraBacktrackCostComponent(totalBacktrackChangeRecords))
	}

	var snapshotExportSizeGB *decimal.Decimal
	if r.SnapshotExportSizeGB != nil {
		snapshotExportSizeGB = decimalPtr(decimal.NewFromFloat(*r.SnapshotExportSizeGB))
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Snapshot export",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: snapshotExportSizeGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Service:       strPtr("AmazonRDS"),
			Region:        strPtr(r.Region),
			ProductFamily: strPtr("System Operation"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "databaseEngine", ValueRegex: regexPtr(databaseEngine)},
				{Key: "usagetype", ValueRegex: regexPtr("Aurora:SnapshotExportToS3$")},
			},
		},
		UsageBased: true,
	})

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *RDSCluster) auroraStorageCostComponents(databaseEngineStorageType string) []*schema.CostComponent {
	var storageGB, writeRequestsPerSecond, readRequestsPerSecond, monthlyIORequests *decimal.Decimal

	if r.StorageGB != nil {
		storageGB = decimalPtr(decimal.NewFromFloat(*r.StorageGB))
	}

	if r != nil && r.WriteRequestsPerSec != nil && r.ReadRequestsPerSec != nil {
		writeRequestsPerSecond = decimalPtr(decimal.NewFromInt(*r.WriteRequestsPerSec))
		readRequestsPerSecond = decimalPtr(decimal.NewFromInt(*r.ReadRequestsPerSec))
		monthlyIORequests = decimalPtr(r.calculateIORequests(*readRequestsPerSecond, *writeRequestsPerSecond))
	}

	label := "Storage"
	usageType := "Aurora:StorageUsage$"
	if r.IOOptimized {
		label = "Storage (I/O-optimized)"
		usageType = "Aurora:IO-OptimizedStorageUsage$"
	}

	return []*schema.CostComponent{
		{
			Name:            label,
			Unit:            "GB",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: storageGB,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonRDS"),
				ProductFamily: strPtr("Database Storage"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "databaseEngine", ValueRegex: regexPtr(databaseEngineStorageType)},
					{Key: "usagetype", ValueRegex: regexPtr(usageType)},
				},
			},
			UsageBased: true,
		},
		{
			Name:            "I/O requests",
			Unit:            "1M requests",
			UnitMultiplier:  decimal.NewFromInt(1000000),
			MonthlyQuantity: monthlyIORequests,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonRDS"),
				ProductFamily: strPtr("System Operation"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "databaseEngine", ValueRegex: regexPtr(databaseEngineStorageType)},
					{Key: "usagetype", ValueRegex: regexPtr("Aurora:StorageIOUsage$")},
				},
			},
			UsageBased: true,
		},
	}
}

func (r *RDSCluster) auroraBackupStorageCostComponent(totalBackupStorageGB *decimal.Decimal, databaseEngine string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Backup storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: totalBackupStorageGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonRDS"),
			ProductFamily: strPtr("Storage Snapshot"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "databaseEngine", ValueRegex: regexPtr(databaseEngine)},
				{Key: "usagetype", ValueRegex: regexPtr("Aurora:BackupUsage$")},
			},
		},
		UsageBased: true,
	}
}

func (r *RDSCluster) auroraBacktrackCostComponent(backtrackChangeRecords *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:                 "Backtrack",
		Unit:                 "1M change-records",
		UnitMultiplier:       decimal.NewFromInt(1000000),
		MonthlyQuantity:      backtrackChangeRecords,
		IgnoreIfMissingPrice: true, // Backtrack is not available in all regions
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Service:       strPtr("AmazonRDS"),
			Region:        strPtr(r.Region),
			ProductFamily: strPtr("System Operation"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("Aurora:BacktrackUsage$")},
			},
		},
		UsageBased: true,
	}
}

func (r *RDSCluster) calculateIORequests(writeRequestPerSecond decimal.Decimal, readRequestsPerSecond decimal.Decimal) decimal.Decimal {
	ioPerSecond := writeRequestPerSecond.Add(readRequestsPerSecond)
	monthlyIO := ioPerSecond.Mul(decimal.NewFromInt(730)).Mul(decimal.NewFromInt(60)).Mul(decimal.NewFromInt(60))
	return monthlyIO
}

func (r *RDSCluster) calculateBackupStorage(snapShotStorageSize decimal.Decimal, numberOfBackups int64) decimal.Decimal {
	return snapShotStorageSize.Mul(decimal.NewFromInt(numberOfBackups)).Sub(snapShotStorageSize)
}

func (r *RDSCluster) calculateBacktrack(averageStatements decimal.Decimal, changeRecords decimal.Decimal, windowHours decimal.Decimal) decimal.Decimal {
	return averageStatements.Mul(decimal.NewFromInt(730)).Mul(changeRecords).Mul(windowHours)
}

################################################################################
# FILE: internal/resources/aws/rds_cluster_instance.go
# RESOURCE: aws_rds_cluster_instance
# SIZE: 7961 bytes | LINES: 186
################################################################################
package aws

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type RDSClusterInstance struct {
	Address                                      string
	Region                                       string
	InstanceClass                                string
	Engine                                       string
	Version                                      string
	IOOptimized                                  bool
	PerformanceInsightsEnabled                   bool
	PerformanceInsightsLongTermRetention         bool
	MonthlyCPUCreditHrs                          *int64   `infracost_usage:"monthly_cpu_credit_hrs"`
	VCPUCount                                    *int64   `infracost_usage:"vcpu_count"`
	MonthlyAdditionalPerformanceInsightsRequests *int64   `infracost_usage:"monthly_additional_performance_insights_requests"`
	ReservedInstanceTerm                         *string  `infracost_usage:"reserved_instance_term"`
	ReservedInstancePaymentOption                *string  `infracost_usage:"reserved_instance_payment_option"`
	CapacityUnitsPerHr                           *float64 `infracost_usage:"capacity_units_per_hr"`
}

func (r *RDSClusterInstance) CoreType() string {
	return "RDSClusterInstance"
}

func (r *RDSClusterInstance) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_cpu_credit_hrs", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "vcpu_count", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_additional_performance_insights_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "reserved_instance_term", DefaultValue: "", ValueType: schema.String},
		{Key: "reserved_instance_payment_option", DefaultValue: "", ValueType: schema.String},
		{Key: "capacity_units_per_hr", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *RDSClusterInstance) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *RDSClusterInstance) BuildResource() *schema.Resource {
	databaseEngine := r.databaseEngineValue()

	costComponents := []*schema.CostComponent{}
	isServerless := strings.EqualFold(r.InstanceClass, "db.serverless")
	if isServerless {
		costComponents = append(costComponents, r.auroraServerlessV2CostComponent(databaseEngine))
	} else {
		costComponents = append(costComponents, r.dbInstanceCostComponent(databaseEngine))
	}

	if instanceFamily := getBurstableInstanceFamily([]string{"db.t3", "db.t4g"}, r.InstanceClass); instanceFamily != "" {
		instanceCPUCreditHours := decimal.Zero
		if r.MonthlyCPUCreditHrs != nil {
			instanceCPUCreditHours = decimal.NewFromInt(*r.MonthlyCPUCreditHrs)
		}

		instanceVCPUCount := decimal.Zero
		if r.VCPUCount != nil {
			// VCPU count has been set explicitly
			instanceVCPUCount = decimal.NewFromInt(*r.VCPUCount)
		} else if count, ok := InstanceTypeToVCPU[strings.TrimPrefix(r.InstanceClass, "db.")]; ok {
			// We were able to lookup thing VCPU count
			instanceVCPUCount = decimal.NewFromInt(count)
		}

		if instanceCPUCreditHours.GreaterThan(decimal.NewFromInt(0)) {
			cpuCreditQuantity := instanceVCPUCount.Mul(instanceCPUCreditHours)
			costComponents = append(costComponents, r.cpuCreditsCostComponent(databaseEngine, instanceFamily, cpuCreditQuantity))
		}
	}
	if r.PerformanceInsightsEnabled {
		if r.PerformanceInsightsLongTermRetention {
			costComponents = append(costComponents, performanceInsightsLongTermRetentionCostComponent(r.Region, r.InstanceClass, databaseEngine, isServerless, r.CapacityUnitsPerHr))
		}

		if r.MonthlyAdditionalPerformanceInsightsRequests == nil || *r.MonthlyAdditionalPerformanceInsightsRequests > 0 {
			costComponents = append(costComponents,
				performanceInsightsAPIRequestCostComponent(r.Region, r.MonthlyAdditionalPerformanceInsightsRequests))
		}
	}

	extendedSupport := extendedSupportCostComponent(r.Version, r.Region, r.Engine, r.InstanceClass)
	if extendedSupport != nil {
		costComponents = append(costComponents, extendedSupport)
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *RDSClusterInstance) databaseEngineValue() string {
	if r.Engine == "aurora-postgresql" {
		return "Aurora PostgreSQL"
	}

	return "Aurora MySQL"
}

func (r *RDSClusterInstance) dbInstanceCostComponent(databaseEngine string) *schema.CostComponent {
	purchaseOptionLabel := "on-demand"
	priceFilter := &schema.PriceFilter{
		PurchaseOption: strPtr("on_demand"),
	}

	var err error
	if r.ReservedInstanceTerm != nil {
		resolver := &rdsReservationResolver{
			term:          strVal(r.ReservedInstanceTerm),
			paymentOption: strVal(r.ReservedInstancePaymentOption),
		}
		priceFilter, err = resolver.PriceFilter()
		if err != nil {
			logging.Logger.Warn().Msg(err.Error())
		}
		purchaseOptionLabel = "reserved"
	}

	// Example usage types for Aurora
	// InstanceUsage:db.t3.medium
	// InstanceUsageIOOptimized:db.t3.medium
	// EU-InstanceUsage:db.t3.medium
	// EU-InstanceUsageIOOptimized:db.t3.medium
	usageTypeFilter := "/InstanceUsage:/"
	if r.IOOptimized {
		usageTypeFilter = "/InstanceUsageIOOptimized:/"
	}

	return &schema.CostComponent{
		Name:           fmt.Sprintf("Database instance (%s, %s)", purchaseOptionLabel, r.InstanceClass),
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonRDS"),
			ProductFamily: strPtr("Database Instance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "instanceType", Value: strPtr(r.InstanceClass)},
				{Key: "databaseEngine", Value: strPtr(databaseEngine)},
				{Key: "usagetype", ValueRegex: strPtr(usageTypeFilter)},
			},
		},
		PriceFilter: priceFilter,
	}
}

func (r *RDSClusterInstance) auroraServerlessV2CostComponent(databaseEngine string) *schema.CostComponent {
	var auroraCapacityUnits *decimal.Decimal
	if r.CapacityUnitsPerHr != nil {
		auroraCapacityUnits = decimalPtr(decimal.NewFromFloat(*r.CapacityUnitsPerHr))
	}

	label := "Aurora serverless v2"
	usageType := "Aurora:ServerlessV2Usage$"
	if r.IOOptimized {
		label = "Aurora serverless v2 (I/O-optimized)"
		usageType = "Aurora:ServerlessV2IOOptimizedUsage$"
	}

	return &schema.CostComponent{
		Name:           label,
		Unit:           "ACU-hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: auroraCapacityUnits,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonRDS"),
			ProductFamily: strPtr("ServerlessV2"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "databaseEngine", Value: strPtr(databaseEngine)},
				{Key: "usagetype", ValueRegex: regexPtr(usageType)},
			},
		},
		UsageBased: true,
	}
}

func (r *RDSClusterInstance) cpuCreditsCostComponent(databaseEngine, instanceFamily string, vCPUCount decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "CPU credits",
		Unit:            "vCPU-hours",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: &vCPUCount,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonRDS"),
			ProductFamily: strPtr("CPU Credits"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "databaseEngine", Value: strPtr(databaseEngine)},
				{Key: "usagetype", ValueRegex: regexPtr("CPUCredits:" + instanceFamily + "$")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/redshift_cluster.go
# RESOURCE: aws_redshift_cluster
# SIZE: 7002 bytes | LINES: 168
################################################################################
package aws

import (
	"fmt"
	"strings"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/usage"
)

type RedshiftCluster struct {
	Address                      string
	Region                       string
	NodeType                     string
	Nodes                        *int64
	ManagedStorageGB             *float64 `infracost_usage:"managed_storage_gb"`
	ExcessConcurrencyScalingSecs *int64   `infracost_usage:"excess_concurrency_scaling_secs"`
	SpectrumDataScannedTB        *float64 `infracost_usage:"spectrum_data_scanned_tb"`
	BackupStorageGB              *float64 `infracost_usage:"backup_storage_gb"`
}

func (r *RedshiftCluster) CoreType() string {
	return "RedshiftCluster"
}

func (r *RedshiftCluster) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "managed_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "excess_concurrency_scaling_secs", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "spectrum_data_scanned_tb", ValueType: schema.Float64, DefaultValue: 0.0},
		{Key: "backup_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *RedshiftCluster) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *RedshiftCluster) BuildResource() *schema.Resource {
	numberOfNodes := int64(1)
	if r.Nodes != nil {
		numberOfNodes = *r.Nodes
	}

	costComponents := []*schema.CostComponent{
		{
			Name:           fmt.Sprintf("Cluster usage (%s, %s)", "on-demand", r.NodeType),
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(numberOfNodes)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonRedshift"),
				ProductFamily: strPtr("Compute Instance"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "instanceType", ValueRegex: strPtr(fmt.Sprintf("/%s/i", r.NodeType))},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("on_demand"),
			},
		},
	}

	if strings.HasPrefix(r.NodeType, "ra3") {
		var managedStorage *decimal.Decimal
		if r.ManagedStorageGB != nil {
			managedStorage = decimalPtr(decimal.NewFromFloat(*r.ManagedStorageGB))
		}

		costComponents = append(costComponents, r.managedStorageCostComponent(managedStorage))
	}

	if strings.HasPrefix(r.NodeType, "ra3") || strings.HasPrefix(r.NodeType, "ds2") || strings.HasPrefix(r.NodeType, "dc2") {
		var concurrencyScalingSeconds *decimal.Decimal
		if r.ExcessConcurrencyScalingSecs != nil {
			concurrencyScalingSeconds = decimalPtr(decimal.NewFromInt(*r.ExcessConcurrencyScalingSecs))
		}

		costComponents = append(costComponents, r.concurrencyScalingCostComponent(numberOfNodes, concurrencyScalingSeconds))
	}

	var tbScanned *decimal.Decimal
	if r.SpectrumDataScannedTB != nil {
		tbScanned = decimalPtr(decimal.NewFromFloat(*r.SpectrumDataScannedTB))
	}

	costComponents = append(costComponents, r.spectrumCostComponent(tbScanned))

	if r.BackupStorageGB != nil {
		storageSnapshotGB := decimal.NewFromFloat(*r.BackupStorageGB)
		storageSnapshotTiers := usage.CalculateTierBuckets(storageSnapshotGB, []int{51200, 512000})

		if storageSnapshotTiers[0].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, r.storageSnapshotCostComponent("Backup storage (first 50 TB)", "0", &storageSnapshotTiers[0]))
		}

		if storageSnapshotTiers[1].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, r.storageSnapshotCostComponent("Backup storage (next 450 TB)", "51200", &storageSnapshotTiers[1]))
		}

		if storageSnapshotTiers[2].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, r.storageSnapshotCostComponent("Backup storage (over 500 TB)", "512000", &storageSnapshotTiers[2]))
		}
	} else {
		costComponents = append(costComponents, r.storageSnapshotCostComponent("Backup storage (first 50 TB)", "0", nil))
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *RedshiftCluster) concurrencyScalingCostComponent(numberOfNodes int64, concurrencySeconds *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Concurrency scaling (%s)", r.NodeType),
		Unit:            "node-seconds",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: concurrencySeconds,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonRedshift"),
			ProductFamily: strPtr("Redshift Concurrency Scaling"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "instanceType", ValueRegex: strPtr(fmt.Sprintf("/%s/i", r.NodeType))},
				{Key: "concurrencyscalingfreeusage", Value: strPtr("No")},
			},
		},
		UsageBased: true,
	}
}

func (r *RedshiftCluster) spectrumCostComponent(tbScanned *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Spectrum",
		Unit:            "TB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: tbScanned,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonRedshift"),
			ProductFamily: strPtr("Redshift Data Scan"),
		},
		UsageBased: true,
	}
}

func (r *RedshiftCluster) storageSnapshotCostComponent(displayName string, startUsageAmount string, storageSnapshot *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            displayName,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: storageSnapshot,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonRedshift"),
			ProductFamily: strPtr("Storage Snapshot"),
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(startUsageAmount),
		},
		UsageBased: true,
	}
}

func (r *RedshiftCluster) managedStorageCostComponent(managedStorage *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Managed storage (%s)", r.NodeType),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: managedStorage,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonRedshift"),
			ProductFamily: strPtr("Redshift Managed Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "instanceType", ValueRegex: strPtr(fmt.Sprintf("/%s/i", r.NodeType))},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/remediater.go
# RESOURCE: aws_remediater
# SIZE: 376 bytes | LINES: 14
################################################################################
package aws

// type remediater struct {
// 	description string
// 	remediate   func() error
// }

// func (r remediater) Describe() string {
// 	return r.description
// }

// func (r remediater) Error() string {
// 	return fmt.Sprintf("Must %s to estimate usage", r.Describe())
// }

// func (r remediater) Remediate() error {
// 	return r.remediate()
// }

################################################################################
# FILE: internal/resources/aws/route53_health_check.go
# RESOURCE: aws_route53_health_check
# SIZE: 3215 bytes | LINES: 92
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type Route53HealthCheck struct {
	Address         string
	RequestInterval string
	MeasureLatency  bool
	Type            string
	EndpointType    *string `infracost_usage:"endpoint_type"`
}

func (r *Route53HealthCheck) CoreType() string {
	return "Route53HealthCheck"
}

func (r *Route53HealthCheck) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "endpoint_type", ValueType: schema.String, DefaultValue: "aws"},
	}
}

func (r *Route53HealthCheck) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *Route53HealthCheck) BuildResource() *schema.Resource {
	costComponents := make([]*schema.CostComponent, 0)

	endpointType := "aws"
	usageAmount := "50"
	if r.EndpointType != nil {
		endpointType = strings.Replace(*r.EndpointType, "_", "-", 1)
		if strings.ToLower(endpointType) == "non-aws" {
			usageAmount = "0"
		}
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Health check",
		Unit:            "months",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Service:       strPtr("AmazonRoute53"),
			ProductFamily: strPtr("DNS Health Check"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/Health-Check-%s/i", endpointType))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(usageAmount),
		},
	})

	healthCheckType := r.Type
	optionalHealthCheckCount := decimal.Zero

	if strings.HasPrefix(healthCheckType, "HTTPS") {
		optionalHealthCheckCount = optionalHealthCheckCount.Add(decimal.NewFromInt(1))
	}

	if r.RequestInterval == "10" {
		optionalHealthCheckCount = optionalHealthCheckCount.Add(decimal.NewFromInt(1))
	}

	if r.MeasureLatency {
		optionalHealthCheckCount = optionalHealthCheckCount.Add(decimal.NewFromInt(1))
	}

	if strings.HasSuffix(healthCheckType, "STR_MATCH") {
		optionalHealthCheckCount = optionalHealthCheckCount.Add(decimal.NewFromInt(1))
	}

	if optionalHealthCheckCount.GreaterThan(decimal.NewFromInt(0)) {
		costComponents = append(costComponents, &schema.CostComponent{
			Name:            "Optional features",
			Unit:            "months",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: decimalPtr(optionalHealthCheckCount),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Service:       strPtr("AmazonRoute53"),
				ProductFamily: strPtr("DNS Health Check"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/Health-Check-Option-%s/i", endpointType))},
				},
			},
			PriceFilter: &schema.PriceFilter{
				StartUsageAmount: strPtr("0"),
			},
		})
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/route53_record.go
# RESOURCE: aws_route53_record
# SIZE: 4699 bytes | LINES: 106
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/usage"
)

type Route53Record struct {
	Address                    string
	IsAlias                    bool
	MonthlyLatencyBasedQueries *int64 `infracost_usage:"monthly_latency_based_queries"`
	MonthlyGeoQueries          *int64 `infracost_usage:"monthly_geo_queries"`
	MonthlyStandardQueries     *int64 `infracost_usage:"monthly_standard_queries"`
}

func (r *Route53Record) CoreType() string {
	return "Route53Record"
}

func (r *Route53Record) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_latency_based_queries", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_geo_queries", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_standard_queries", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *Route53Record) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *Route53Record) BuildResource() *schema.Resource {
	if r.IsAlias {
		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	costComponents := []*schema.CostComponent{}
	limits := []int{1000000000}

	var numbOfStdQueries *decimal.Decimal
	if r.MonthlyStandardQueries != nil {
		numbOfStdQueries = decimalPtr(decimal.NewFromInt(*r.MonthlyStandardQueries))
		stdQueriesTiers := usage.CalculateTierBuckets(*numbOfStdQueries, limits)

		if stdQueriesTiers[0].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, queriesCostComponent("Standard queries (first 1B)", "DNS-Queries", "0", &stdQueriesTiers[0]))
		}

		if stdQueriesTiers[1].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, queriesCostComponent("Standard queries (over 1B)", "DNS-Queries", "1000000000", &stdQueriesTiers[1]))
		}
	} else {
		var unknown *decimal.Decimal

		costComponents = append(costComponents, queriesCostComponent("Standard queries (first 1B)", "DNS-Queries", "0", unknown))
	}

	var numbOfLBRQueries *decimal.Decimal
	if r.MonthlyLatencyBasedQueries != nil {
		numbOfLBRQueries = decimalPtr(decimal.NewFromInt(*r.MonthlyLatencyBasedQueries))
		lbrQueriesTiers := usage.CalculateTierBuckets(*numbOfLBRQueries, limits)

		if lbrQueriesTiers[0].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, queriesCostComponent("Latency based routing queries (first 1B)", "LBR-Queries", "0", &lbrQueriesTiers[0]))
		}

		if lbrQueriesTiers[1].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, queriesCostComponent("Latency based routing queries (over 1B)", "LBR-Queries", "1000000000", &lbrQueriesTiers[1]))
		}
	} else {
		var unknown *decimal.Decimal

		costComponents = append(costComponents, queriesCostComponent("Latency based routing queries (first 1B)", "LBR-Queries", "0", unknown))
	}

	var numbOfGeoQueries *decimal.Decimal
	if r.MonthlyGeoQueries != nil {
		numbOfGeoQueries = decimalPtr(decimal.NewFromInt(*r.MonthlyGeoQueries))
		geoQueriesTiers := usage.CalculateTierBuckets(*numbOfGeoQueries, limits)

		if geoQueriesTiers[0].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, queriesCostComponent("Geo DNS queries (first 1B)", "Geo-Queries", "0", &geoQueriesTiers[0]))
		}

		if geoQueriesTiers[1].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, queriesCostComponent("Geo DNS queries (over 1B)", "Geo-Queries", "1000000000", &geoQueriesTiers[1]))
		}
	} else {
		var unknown *decimal.Decimal

		costComponents = append(costComponents, queriesCostComponent("Geo DNS queries (first 1B)", "Geo-Queries", "0", unknown))
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func queriesCostComponent(displayName string, usageType string, usageTier string, quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            displayName,
		Unit:            "1M queries",
		UnitMultiplier:  decimal.NewFromInt(1000000),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Service:       strPtr("AmazonRoute53"),
			ProductFamily: strPtr("DNS Query"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", Value: &usageType},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(usageTier),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/route53_resolver_endpoint.go
# RESOURCE: aws_route53_resolver_endpoint
# SIZE: 3145 bytes | LINES: 85
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/infracost/infracost/internal/usage"

	"github.com/shopspring/decimal"
)

type Route53ResolverEndpoint struct {
	Address           string
	Region            string
	ResolverEndpoints int64
	MonthlyQueries    *int64 `infracost_usage:"monthly_queries"`
}

func (r *Route53ResolverEndpoint) CoreType() string {
	return "Route53ResolverEndpoint"
}

func (r *Route53ResolverEndpoint) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *Route53ResolverEndpoint) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *Route53ResolverEndpoint) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		{
			Name:           "Resolver endpoints",
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(r.ResolverEndpoints)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonRoute53"),
				ProductFamily: strPtr("DNS Query"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: strPtr("/ResolverNetworkInterface$/")},
				},
			},
		},
	}

	queryTierLimits := []int{1000000000}

	if r.MonthlyQueries != nil {
		monthlyQueries := decimal.NewFromInt(*r.MonthlyQueries)
		dnsQueriesTier := usage.CalculateTierBuckets(monthlyQueries, queryTierLimits)
		tierOne := dnsQueriesTier[0]
		tierTwo := dnsQueriesTier[1]

		if tierOne.GreaterThan(decimal.NewFromInt(0)) {
			costComponents = append(costComponents, r.queriesCostComponent("DNS queries (first 1B)", "0", &tierOne))
		}

		if tierTwo.GreaterThan(decimal.NewFromInt(0)) {
			costComponents = append(costComponents, r.queriesCostComponent("DNS queries (over 1B)", "1000000000", &tierTwo))
		}

	} else {
		var unknown *decimal.Decimal
		costComponents = append(costComponents, r.queriesCostComponent("DNS queries (first 1B)", "0", unknown))
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *Route53ResolverEndpoint) queriesCostComponent(displayName string, usageTier string, monthlyQueries *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            displayName,
		Unit:            "1M queries",
		UnitMultiplier:  decimal.NewFromInt(1000000),
		MonthlyQuantity: monthlyQueries,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonRoute53"),
			ProductFamily: strPtr("DNS Query"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/DNS-Queries/")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(usageTier),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/route53_zone.go
# RESOURCE: aws_route53_zone
# SIZE: 1244 bytes | LINES: 43
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type Route53Zone struct {
	Address string
}

func (r *Route53Zone) CoreType() string {
	return "Route53Zone"
}

func (r *Route53Zone) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *Route53Zone) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *Route53Zone) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Hosted zone",
				Unit:            "months",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Service:       strPtr("AmazonRoute53"),
					ProductFamily: strPtr("DNS Zone"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", Value: strPtr("HostedZone")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					StartUsageAmount: strPtr("0"),
				},
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/s3_bucket.go
# RESOURCE: aws_s3_bucket
# SIZE: 8371 bytes | LINES: 189
################################################################################
package aws

import (
	"context"
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
	"github.com/infracost/infracost/internal/usage/aws"
)

type S3Bucket struct {
	// "required" args that can't really be missing.
	Address           string
	Region            string
	Name              string
	ObjectTagsEnabled bool

	// "optional" args, that may be empty depending on the resource config
	LifecycleStorageClasses []string

	// "usage" args
	ObjectTags *int64 `infracost_usage:"object_tags"`

	// "derived" attributes, that are constructed from the other arguments
	storageClasses    []S3StorageClass
	allStorageClasses []S3StorageClass
}

func (a *S3Bucket) CoreType() string {
	return "S3Bucket"
}

func (a *S3Bucket) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "object_tags", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "standard", DefaultValue: &usage.ResourceUsage{Name: "standard", Items: S3StandardStorageClassUsageSchema}, ValueType: schema.SubResourceUsage},
		{Key: "intelligent_tiering", DefaultValue: &usage.ResourceUsage{Name: "intelligent_tiering", Items: S3IntelligentTieringStorageClassUsageSchema}, ValueType: schema.SubResourceUsage},
		{Key: "standard_infrequent_access", DefaultValue: &usage.ResourceUsage{Name: "standard_infrequent_access", Items: S3StandardInfrequentAccessStorageClassUsageSchema}, ValueType: schema.SubResourceUsage},
		{Key: "one_zone_infrequent_access", DefaultValue: &usage.ResourceUsage{Name: "one_zone_infrequent_access", Items: S3OneZoneInfrequentAccessStorageClassUsageSchema}, ValueType: schema.SubResourceUsage},
		{Key: "glacier_flexible_retrieval", DefaultValue: &usage.ResourceUsage{Name: "glacier_flexible_retrieval", Items: S3GlacierFlexibleRetrievalStorageClassUsageSchema}, ValueType: schema.SubResourceUsage},
		{Key: "glacier_deep_archive", DefaultValue: &usage.ResourceUsage{Name: "glacier_deep_archive", Items: S3GlacierDeepArchiveStorageClassUsageSchema}, ValueType: schema.SubResourceUsage},
	}
}

type S3StorageClass interface {
	UsageKey() string
	PopulateUsage(u *schema.UsageData)
	BuildResource() *schema.Resource
}

func (a *S3Bucket) AllStorageClasses() []S3StorageClass {
	if a.allStorageClasses == nil {
		a.allStorageClasses = []S3StorageClass{
			&S3StandardStorageClass{Region: a.Region},
			&S3IntelligentTieringStorageClass{Region: a.Region},
			&S3StandardInfrequentAccessStorageClass{Region: a.Region},
			&S3OneZoneInfrequentAccessStorageClass{Region: a.Region},
			&S3GlacierFlexibleRetrievalStorageClass{Region: a.Region},
			&S3GlacierDeepArchiveStorageClass{Region: a.Region},
		}
	}

	return a.allStorageClasses
}

func (a *S3Bucket) PopulateUsage(u *schema.UsageData) {
	// Add the storage classes based on what's based through in the usage
	// and any storage classes added in the lifecycle storage classes.
	for _, storageClass := range a.AllStorageClasses() {
		if stringInSlice(a.LifecycleStorageClasses, storageClass.UsageKey()) || (u != nil && !u.IsEmpty(storageClass.UsageKey())) {
			// Populate the storage class usage using the map in the usage data
			if u != nil {
				storageClass.PopulateUsage(&schema.UsageData{
					Address:    storageClass.UsageKey(),
					Attributes: u.Get(storageClass.UsageKey()).Map(),
				})
			}
			a.storageClasses = append(a.storageClasses, storageClass)
		}
	}

	resources.PopulateArgsWithUsage(a, u)
}

func (a *S3Bucket) BuildResource() *schema.Resource {
	costComponents := make([]*schema.CostComponent, 0)
	if a.ObjectTagsEnabled {
		costComponents = append(costComponents, a.objectTagsCostComponent())
	}

	subResources := make([]*schema.Resource, 0, len(a.storageClasses))
	for _, storageClass := range a.storageClasses {
		subResources = append(subResources, storageClass.BuildResource())
	}

	estimate := func(ctx context.Context, u map[string]interface{}) error {
		// https://docs.aws.amazon.com/AmazonS3/latest/userguide/metrics-dimensions.html

		storageMetricsMap := map[string]map[string]string{
			"standard": {
				"storage_gb": "StandardStorage",
			},
			"intelligent_tiering": {
				"frequent_access_storage_gb":     "IntelligentTieringFAStorage",
				"infrequent_access_storage_gb":   "IntelligentTieringIAStorage",
				"archive_access_storage_gb":      "IntelligentTieringAAStorage",
				"deep_archive_access_storage_gb": "IntelligentTieringDAAStorage",
			},
			"standard_infrequent_access": {
				"storage_gb": "StandardIAStorage",
			},
			"one_zone_infrequent_access": {
				"storage_gb": "OneZoneIAStorage",
			},
			"glacier_flexible_retrieval": {
				"storage_gb": "GlacierStorage",
			},
			"glacier_deep_archive": {
				"storage_gb": "DeepArchiveStorage",
			},
		}

		// We want to check all storage classes, not just the ones that have been added by the lifecycle policy or previous
		// usage data, so that any additional storage classes that have estimated data will be added when we reload the resources.
		for _, storageClass := range a.AllStorageClasses() {
			if _, ok := storageMetricsMap[storageClass.UsageKey()]; !ok {
				continue
			}

			storageClassUsage := make(map[string]interface{})
			if v, ok := u[storageClass.UsageKey()]; ok && v != nil {
				storageClassUsage = v.(map[string]interface{})
			}

			for usageKey, metric := range storageMetricsMap[storageClass.UsageKey()] {
				storageBytes, err := aws.S3GetBucketSizeBytes(ctx, a.Region, a.Name, metric)
				if err != nil {
					return err
				}

				// Always add usage for the Standard storage class, but skip others that have no data.
				if storageBytes > 0 || storageClass.UsageKey() == "standard" {
					storageClassUsage[usageKey] = storageBytes / 1000 / 1000 / 1000
				}
			}

			if len(storageClassUsage) > 0 {
				u[storageClass.UsageKey()] = storageClassUsage
			}
		}

		filter, err := aws.S3FindMetricsFilter(ctx, a.Region, a.Name)
		if err != nil || filter == "" {
			msg := "Unable to find matching metrics filter for S3 bucket, so unable to sync additional metrics"
			if err != nil {
				msg = fmt.Sprintf("%s: %s", msg, err)
			}
			logging.Logger.Debug().Msg(msg)
		} else {
			standardStorageClassUsage := u["standard"].(map[string]interface{})

			monthlyTier1Requests, err := aws.S3GetBucketRequests(ctx, a.Region, a.Name, filter, []string{"PutRequests", "PostRequests", "ListRequests"})
			if err != nil {
				return err
			}

			monthlyTier2Requests, err := aws.S3GetBucketRequests(ctx, a.Region, a.Name, filter, []string{"GetRequests", "HeadRequests", "SelectRequests"})
			if err != nil {
				return err
			}

			selectDataScannedBytes, err := aws.S3GetBucketDataBytes(ctx, a.Region, a.Name, filter, "SelectBytesScanned")
			if err != nil {
				return err
			}

			selectDataReturnedBytes, err := aws.S3GetBucketDataBytes(ctx, a.Region, a.Name, filter, "SelectBytesReturned")
			if err != nil {
				return err
			}

			standardStorageClassUsage["monthly_tier_1_requests"] = monthlyTier1Requests
			standardStorageClassUsage["monthly_tier_2_requests"] = monthlyTier2Requests
			standardStorageClassUsage["monthly_select_data_scanned_gb"] = selectDataScannedBytes / 1000 / 1000 / 1000
			standardStorageClassUsage["monthly_select_data_returned_gb"] = selectDataReturnedBytes / 1000 / 1000 / 1000
		}

		return nil
	}

	return &schema.Resource{
		Name:           a.Address,
		UsageSchema:    a.UsageSchema(),
		EstimateUsage:  estimate,
		CostComponents: costComponents,
		SubResources:   subResources,
	}
}

func (a *S3Bucket) objectTagsCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Object tagging",
		Unit:            "10k tags",
		UnitMultiplier:  decimal.NewFromInt(10000),
		MonthlyQuantity: intPtrToDecimalPtr(a.ObjectTags),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(a.Region),
			Service:    strPtr("AmazonS3"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/TagStorage-TagHrs/")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/s3_bucket_analytics_configuration.go
# RESOURCE: aws_s3_bucket_analytics_configuration
# SIZE: 1657 bytes | LINES: 49
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type S3BucketAnalyticsConfiguration struct {
	Address                 string
	Region                  string
	MonthlyMonitoredObjects *int64 `infracost_usage:"monthly_monitored_objects"`
}

func (r *S3BucketAnalyticsConfiguration) CoreType() string {
	return "S3BucketAnalyticsConfiguration"
}

func (r *S3BucketAnalyticsConfiguration) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_monitored_objects", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *S3BucketAnalyticsConfiguration) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *S3BucketAnalyticsConfiguration) BuildResource() *schema.Resource {
	var monitObj *decimal.Decimal
	if r.MonthlyMonitoredObjects != nil {
		monitObj = decimalPtr(decimal.NewFromInt(*r.MonthlyMonitoredObjects))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Objects monitored",
				Unit:            "1M objects",
				UnitMultiplier:  decimal.NewFromInt(1000000),
				MonthlyQuantity: monitObj,
				ProductFilter: &schema.ProductFilter{
					VendorName: strPtr("aws"),
					Region:     strPtr(r.Region),
					Service:    strPtr("AmazonS3"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/StorageAnalytics-ObjCount/")},
					},
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/s3_bucket_inventory.go
# RESOURCE: aws_s3_bucket_inventory
# SIZE: 1548 bytes | LINES: 47
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type S3BucketInventory struct {
	Address              string
	Region               string
	MonthlyListedObjects *int64 `infracost_usage:"monthly_listed_objects"`
}

func (r *S3BucketInventory) CoreType() string {
	return "S3BucketInventory"
}

func (r *S3BucketInventory) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_listed_objects", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *S3BucketInventory) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *S3BucketInventory) BuildResource() *schema.Resource {
	var listedObj *decimal.Decimal
	if r.MonthlyListedObjects != nil {
		listedObj = decimalPtr(decimal.NewFromInt(*r.MonthlyListedObjects))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Objects listed",
				Unit:            "1M objects",
				UnitMultiplier:  decimal.NewFromInt(1000000),
				MonthlyQuantity: listedObj,
				ProductFilter: &schema.ProductFilter{
					VendorName: strPtr("aws"),
					Region:     strPtr(r.Region),
					Service:    strPtr("AmazonS3"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/Inventory-ObjectsListed/")},
					},
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/s3_glacier_deep_archive_storage_class.go
# RESOURCE: aws_s3_glacier_deep_archive_storage_class
# SIZE: 3989 bytes | LINES: 59
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type S3GlacierDeepArchiveStorageClass struct {
	// "required" args that can't really be missing.
	Region string

	// "usage" args
	StorageGB                            *float64 `infracost_usage:"storage_gb"`
	MonthlyTier1Requests                 *int64   `infracost_usage:"monthly_tier_1_requests"`
	MonthlyTier2Requests                 *int64   `infracost_usage:"monthly_tier_2_requests"`
	MonthlyLifecycleTransitionRequests   *int64   `infracost_usage:"monthly_lifecycle_transition_requests"`
	MonthlyStandardDataRetrievalRequests *int64   `infracost_usage:"monthly_standard_data_retrieval_requests"`
	MonthlyStandardDataRetrievalGB       *float64 `infracost_usage:"monthly_standard_data_retrieval_gb"`
	MonthlyBulkDataRetrievalRequests     *int64   `infracost_usage:"monthly_bulk_data_retrieval_requests"`
	MonthlyBulkDataRetrievalGB           *float64 `infracost_usage:"monthly_bulk_data_retrieval_gb"`
	EarlyDeleteGB                        *float64 `infracost_usage:"early_delete_gb"`
}

var S3GlacierDeepArchiveStorageClassUsageSchema = []*schema.UsageItem{
	{Key: "storage_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_tier_1_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_tier_2_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_lifecycle_transition_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_standard_data_retrieval_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_standard_data_retrieval_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_bulk_data_retrieval_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_bulk_data_retrieval_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "early_delete_gb", DefaultValue: 0.0, ValueType: schema.Float64},
}

func (a *S3GlacierDeepArchiveStorageClass) CoreType() string {
	return "S3GlacierDeepArchiveStorageClass"
}

func (a *S3GlacierDeepArchiveStorageClass) UsageSchema() []*schema.UsageItem {
	return S3GlacierDeepArchiveStorageClassUsageSchema
}

func (a *S3GlacierDeepArchiveStorageClass) UsageKey() string {
	return "glacier_deep_archive"
}

func (a *S3GlacierDeepArchiveStorageClass) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(a, u)
}

func (a *S3GlacierDeepArchiveStorageClass) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        "Glacier deep archive",
		UsageSchema: a.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			s3StorageCostComponent("Storage", "AmazonS3GlacierDeepArchive", a.Region, "TimedStorage-GDA-ByteHrs", a.StorageGB),
			s3ApiOperationCostComponent("PUT, COPY, POST, LIST requests", "AmazonS3GlacierDeepArchive", a.Region, "Requests-GDA-Tier1", "PostObject", a.MonthlyTier1Requests),
			s3ApiCostComponent("GET, SELECT, and all other requests", "AmazonS3", a.Region, "Requests-GDA-Tier2", a.MonthlyTier2Requests),
			s3LifecycleTransitionsCostComponent(a.Region, "Requests-Tier3", "S3-GDATransition", a.MonthlyLifecycleTransitionRequests),
			s3ApiOperationCostComponent("Retrieval requests (standard)", "AmazonS3GlacierDeepArchive", a.Region, "Requests-GDA-Tier3", "", a.MonthlyStandardDataRetrievalRequests),
			s3DataCostComponent("Retrievals (standard)", "AmazonS3GlacierDeepArchive", a.Region, "Standard-Retrieval-Bytes", a.MonthlyStandardDataRetrievalGB),
			s3ApiCostComponent("Retrieval requests (bulk)", "AmazonS3GlacierDeepArchive", a.Region, "Requests-GDA-Tier5", a.MonthlyBulkDataRetrievalRequests),
			s3DataCostComponent("Retrievals (bulk)", "AmazonS3GlacierDeepArchive", a.Region, "Bulk-Retrieval-Bytes", a.MonthlyBulkDataRetrievalGB),
			s3DataCostComponent("Early delete (within 180 days)", "AmazonS3GlacierDeepArchive", a.Region, "EarlyDelete-GDA", a.EarlyDeleteGB),
		},
	}
}

################################################################################
# FILE: internal/resources/aws/s3_glacier_flexible_retrieval_storage_class.go
# RESOURCE: aws_s3_glacier_flexible_retrieval_storage_class
# SIZE: 6146 bytes | LINES: 77
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type S3GlacierFlexibleRetrievalStorageClass struct {
	// "required" args that can't really be missing.
	Region string

	// "usage" args
	StorageGB                             *float64 `infracost_usage:"storage_gb"`
	MonthlyTier1Requests                  *int64   `infracost_usage:"monthly_tier_1_requests"`
	MonthlyTier2Requests                  *int64   `infracost_usage:"monthly_tier_2_requests"`
	MonthlyLifecycleTransitionRequests    *int64   `infracost_usage:"monthly_lifecycle_transition_requests"`
	MonthlyStandardDataRetrievalRequests  *int64   `infracost_usage:"monthly_standard_data_retrieval_requests"`
	MonthlyStandardDataRetrievalGB        *float64 `infracost_usage:"monthly_standard_data_retrieval_gb"`
	MonthlyStandardSelectDataScannedGB    *float64 `infracost_usage:"monthly_standard_select_data_scanned_gb"`
	MonthlyStandardSelectDataReturnedGB   *float64 `infracost_usage:"monthly_standard_select_data_returned_gb"`
	MonthlyExpeditedDataRetrievalRequests *int64   `infracost_usage:"monthly_expedited_data_retrieval_requests"`
	MonthlyExpeditedDataRetrievalGB       *float64 `infracost_usage:"monthly_expedited_data_retrieval_gb"`
	MonthlyExpeditedSelectDataScannedGB   *float64 `infracost_usage:"monthly_expedited_select_data_scanned_gb"`
	MonthlyExpeditedSelectDataReturnedGB  *float64 `infracost_usage:"monthly_expedited_select_data_returned_gb"`
	MonthlyBulkSelectDataScannedGB        *float64 `infracost_usage:"monthly_bulk_select_data_scanned_gb"`
	MonthlyBulkSelectDataReturnedGB       *float64 `infracost_usage:"monthly_bulk_select_data_returned_gb"`
	EarlyDeleteGB                         *float64 `infracost_usage:"early_delete_gb"`
}

var S3GlacierFlexibleRetrievalStorageClassUsageSchema = []*schema.UsageItem{
	{Key: "storage_gb", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_tier_1_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_tier_2_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_lifecycle_transition_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_standard_data_retrieval_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_standard_data_retrieval_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_standard_select_data_scanned_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_standard_select_data_returned_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_expedited_data_retrieval_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_expedited_data_retrieval_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_expedited_select_data_scanned_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_expedited_select_data_returned_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_bulk_select_data_scanned_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_bulk_select_data_returned_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "early_delete_gb", DefaultValue: 0.0, ValueType: schema.Float64},
}

func (a *S3GlacierFlexibleRetrievalStorageClass) CoreType() string {
	return "S3GlacierFlexibleRetrievalStorageClass"
}

func (a *S3GlacierFlexibleRetrievalStorageClass) UsageSchema() []*schema.UsageItem {
	return S3GlacierFlexibleRetrievalStorageClassUsageSchema
}

func (a *S3GlacierFlexibleRetrievalStorageClass) UsageKey() string {
	return "glacier_flexible_retrieval"
}

func (a *S3GlacierFlexibleRetrievalStorageClass) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(a, u)
}

func (a *S3GlacierFlexibleRetrievalStorageClass) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        "Glacier flexible retrieval",
		UsageSchema: a.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			s3StorageCostComponent("Storage", "AmazonGlacier", a.Region, "TimedStorage-ByteHrs", a.StorageGB),
			s3ApiOperationCostComponent("PUT, COPY, POST, LIST requests", "AmazonS3", a.Region, "Requests-GLACIER-Tier1", "PostObject", a.MonthlyTier1Requests),
			s3ApiCostComponent("GET, SELECT, and all other requests", "AmazonS3", a.Region, "Requests-GLACIER-Tier2", a.MonthlyTier2Requests),
			s3LifecycleTransitionsCostComponent(a.Region, "Requests-Tier3", "S3-GlacierTransition", a.MonthlyLifecycleTransitionRequests),
			s3ApiCostComponent("Retrieval requests (standard)", "AmazonGlacier", a.Region, "Requests-Tier1", a.MonthlyStandardDataRetrievalRequests),
			s3DataCostComponent("Retrievals (standard)", "AmazonGlacier", a.Region, "Standard-Retrieval-Bytes", a.MonthlyStandardDataRetrievalGB),
			s3DataCostComponent("Select data scanned (standard)", "AmazonGlacier", a.Region, "Std-Select-Scanned-Bytes", a.MonthlyStandardSelectDataScannedGB),
			s3DataCostComponent("Select data returned (standard)", "AmazonGlacier", a.Region, "Std-Select-Returned-Bytes", a.MonthlyStandardSelectDataReturnedGB),
			s3ApiCostComponent("Retrieval requests (expedited)", "AmazonGlacier", a.Region, "Requests-Tier3", a.MonthlyExpeditedDataRetrievalRequests),
			s3DataCostComponent("Retrievals (expedited)", "AmazonGlacier", a.Region, "Expedited-Retrieval-Bytes", a.MonthlyExpeditedDataRetrievalGB),
			s3DataCostComponent("Select data scanned (expedited)", "AmazonGlacier", a.Region, "Exp-Select-Scanned-Bytes", a.MonthlyExpeditedSelectDataScannedGB),
			s3DataCostComponent("Select data returned (expedited)", "AmazonGlacier", a.Region, "Exp-Select-Returned-Bytes", a.MonthlyExpeditedSelectDataReturnedGB),
			s3DataCostComponent("Select data scanned (bulk)", "AmazonGlacier", a.Region, "Bulk-Select-Scanned-Bytes", a.MonthlyBulkSelectDataScannedGB),
			s3DataCostComponent("Select data returned (bulk)", "AmazonGlacier", a.Region, "Bulk-Select-Returned-Bytes", a.MonthlyBulkSelectDataReturnedGB),
			s3DataCostComponent("Early delete (within 90 days)", "AmazonGlacier", a.Region, "EarlyDelete-ByteHrs", a.EarlyDeleteGB),
		},
	}
}

################################################################################
# FILE: internal/resources/aws/s3_intelligent_tiering_storage_class.go
# RESOURCE: aws_s3_intelligent_tiering_storage_class
# SIZE: 4448 bytes | LINES: 65
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type S3IntelligentTieringStorageClass struct {
	// "required" args that can't really be missing.
	Region string

	// "usage" args
	FrequentAccessStorageGB            *float64 `infracost_usage:"frequent_access_storage_gb"`
	InfrequentAccessStorageGB          *float64 `infracost_usage:"infrequent_access_storage_gb"`
	ArchiveAccessStorageGB             *float64 `infracost_usage:"archive_access_storage_gb"`
	DeepArchiveAccessStorageGB         *float64 `infracost_usage:"deep_archive_access_storage_gb"`
	MonitoredObjects                   *int64   `infracost_usage:"monitored_objects"`
	MonthlyTier1Requests               *int64   `infracost_usage:"monthly_tier_1_requests"`
	MonthlyTier2Requests               *int64   `infracost_usage:"monthly_tier_2_requests"`
	MonthlyLifecycleTransitionRequests *int64   `infracost_usage:"monthly_lifecycle_transition_requests"`
	MonthlySelectDataScannedGB         *float64 `infracost_usage:"monthly_select_data_scanned_gb"`
	MonthlySelectDataReturnedGB        *float64 `infracost_usage:"monthly_select_data_returned_gb"`
	EarlyDeleteGB                      *float64 `infracost_usage:"early_delete_gb"`
}

var S3IntelligentTieringStorageClassUsageSchema = []*schema.UsageItem{
	{Key: "frequent_access_storage_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "infrequent_access_storage_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "archive_access_storage_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "deep_archive_access_storage_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monitored_objects", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_tier_1_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_tier_2_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_lifecycle_transition_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_select_data_scanned_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_select_data_returned_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "early_delete_gb", DefaultValue: 0.0, ValueType: schema.Float64},
}

func (a *S3IntelligentTieringStorageClass) CoreType() string {
	return "S3IntelligentTieringStorageClass"
}

func (a *S3IntelligentTieringStorageClass) UsageSchema() []*schema.UsageItem {
	return S3IntelligentTieringStorageClassUsageSchema
}

func (a *S3IntelligentTieringStorageClass) UsageKey() string {
	return "intelligent_tiering"
}

func (a *S3IntelligentTieringStorageClass) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(a, u)
}

func (a *S3IntelligentTieringStorageClass) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        "Intelligent tiering",
		UsageSchema: a.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			s3StorageCostComponent("Storage (frequent access)", "AmazonS3", a.Region, "TimedStorage-INT-FA-ByteHrs", a.FrequentAccessStorageGB),
			s3StorageCostComponent("Storage (infrequent access)", "AmazonS3", a.Region, "TimedStorage-INT-IA-ByteHrs", a.InfrequentAccessStorageGB),
			s3StorageVolumeTypeCostComponent("Storage (archive access)", "AmazonS3", a.Region, "TimedStorage-INT-AA-ByteHrs", "IntelligentTieringArchive", a.FrequentAccessStorageGB),
			s3StorageVolumeTypeCostComponent("Storage (deep archive access)", "AmazonS3", a.Region, "TimedStorage-INT-DAA-ByteHrs", "IntelligentTieringDeepArchive", a.InfrequentAccessStorageGB),
			s3MonitoringCostComponent(a.Region, a.MonitoredObjects),
			s3ApiCostComponent("PUT, COPY, POST, LIST requests", "AmazonS3", a.Region, "Requests-INT-Tier1", a.MonthlyTier1Requests),
			s3ApiCostComponent("GET, SELECT, and all other requests", "AmazonS3", a.Region, "Requests-INT-Tier2", a.MonthlyTier2Requests),
			s3LifecycleTransitionsCostComponent(a.Region, "Requests-Tier4", "", a.MonthlyLifecycleTransitionRequests),
			s3DataCostComponent("Select data scanned", "AmazonS3", a.Region, "Select-Scanned-INT-Bytes", a.MonthlySelectDataScannedGB),
			s3DataCostComponent("Select data returned", "AmazonS3", a.Region, "Select-Returned-INT-Bytes", a.MonthlySelectDataReturnedGB),
			s3DataCostComponent("Early delete (within 30 days)", "AmazonS3", a.Region, "EarlyDelete-INT", a.EarlyDeleteGB),
		},
	}
}

################################################################################
# FILE: internal/resources/aws/s3_one_zone_infrequent_access_storage_class.go
# RESOURCE: aws_s3_one_zone_infrequent_access_storage_class
# SIZE: 3186 bytes | LINES: 53
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type S3OneZoneInfrequentAccessStorageClass struct {
	// "required" args that can't really be missing.
	Region string

	// "usage" args
	StorageGB                          *float64 `infracost_usage:"storage_gb"`
	MonthlyTier1Requests               *int64   `infracost_usage:"monthly_tier_1_requests"`
	MonthlyTier2Requests               *int64   `infracost_usage:"monthly_tier_2_requests"`
	MonthlyLifecycleTransitionRequests *int64   `infracost_usage:"monthly_lifecycle_transition_requests"`
	MonthlyDataRetrievalGB             *float64 `infracost_usage:"monthly_data_retrieval_gb"`
	MonthlySelectDataScannedGB         *float64 `infracost_usage:"monthly_select_data_scanned_gb"`
	MonthlySelectDataReturnedGB        *float64 `infracost_usage:"monthly_select_data_returned_gb"`
}

var S3OneZoneInfrequentAccessStorageClassUsageSchema = []*schema.UsageItem{
	{Key: "storage_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_tier_1_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_tier_2_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_lifecycle_transition_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_data_retrieval_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_select_data_scanned_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_select_data_returned_gb", DefaultValue: 0.0, ValueType: schema.Float64},
}

func (a *S3OneZoneInfrequentAccessStorageClass) CoreType() string {
	return "S3OneZoneInfrequentAccessStorageClass"
}

func (a *S3OneZoneInfrequentAccessStorageClass) UsageSchema() []*schema.UsageItem {
	return S3OneZoneInfrequentAccessStorageClassUsageSchema
}

func (a *S3OneZoneInfrequentAccessStorageClass) UsageKey() string {
	return "one_zone_infrequent_access"
}

func (a *S3OneZoneInfrequentAccessStorageClass) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(a, u)
}

func (a *S3OneZoneInfrequentAccessStorageClass) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        "One zone - infrequent access",
		UsageSchema: a.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			s3StorageCostComponent("Storage", "AmazonS3", a.Region, "TimedStorage-ZIA-ByteHrs", a.StorageGB),
			s3ApiCostComponent("PUT, COPY, POST, LIST requests", "AmazonS3", a.Region, "Requests-ZIA-Tier1", a.MonthlyTier1Requests),
			s3ApiCostComponent("GET, SELECT, and all other requests", "AmazonS3", a.Region, "Requests-ZIA-Tier2", a.MonthlyTier2Requests),
			s3LifecycleTransitionsCostComponent(a.Region, "Requests-Tier4", "", a.MonthlyLifecycleTransitionRequests),
			s3DataCostComponent("Retrievals", "AmazonS3", a.Region, "Retrieval-ZIA", a.MonthlyDataRetrievalGB),
			s3DataCostComponent("Select data scanned", "AmazonS3", a.Region, "Select-Scanned-ZIA-Bytes", a.MonthlySelectDataScannedGB),
			s3DataCostComponent("Select data returned", "AmazonS3", a.Region, "Select-Returned-ZIA-Bytes", a.MonthlySelectDataReturnedGB),
		},
	}
}

################################################################################
# FILE: internal/resources/aws/s3_standard_infrequent_access_storage_class.go
# RESOURCE: aws_s3_standard_infrequent_access_storage_class
# SIZE: 3195 bytes | LINES: 53
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type S3StandardInfrequentAccessStorageClass struct {
	// "required" args that can't really be missing.
	Region string

	// "usage" args
	StorageGB                          *float64 `infracost_usage:"storage_gb"`
	MonthlyTier1Requests               *int64   `infracost_usage:"monthly_tier_1_requests"`
	MonthlyTier2Requests               *int64   `infracost_usage:"monthly_tier_2_requests"`
	MonthlyLifecycleTransitionRequests *int64   `infracost_usage:"monthly_lifecycle_transition_requests"`
	MonthlyDataRetrievalGB             *float64 `infracost_usage:"monthly_data_retrieval_gb"`
	MonthlySelectDataScannedGB         *float64 `infracost_usage:"monthly_select_data_scanned_gb"`
	MonthlySelectDataReturnedGB        *float64 `infracost_usage:"monthly_select_data_returned_gb"`
}

var S3StandardInfrequentAccessStorageClassUsageSchema = []*schema.UsageItem{
	{Key: "storage_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_tier_1_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_tier_2_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_lifecycle_transition_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_data_retrieval_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_select_data_scanned_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_select_data_returned_gb", DefaultValue: 0.0, ValueType: schema.Float64},
}

func (a *S3StandardInfrequentAccessStorageClass) CoreType() string {
	return "S3StandardInfrequentAccessStorageClass"
}

func (a *S3StandardInfrequentAccessStorageClass) UsageSchema() []*schema.UsageItem {
	return S3StandardInfrequentAccessStorageClassUsageSchema
}

func (a *S3StandardInfrequentAccessStorageClass) UsageKey() string {
	return "standard_infrequent_access"
}

func (a *S3StandardInfrequentAccessStorageClass) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(a, u)
}

func (a *S3StandardInfrequentAccessStorageClass) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        "Standard - infrequent access",
		UsageSchema: a.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			s3StorageCostComponent("Storage", "AmazonS3", a.Region, "TimedStorage-SIA-ByteHrs", a.StorageGB),
			s3ApiCostComponent("PUT, COPY, POST, LIST requests", "AmazonS3", a.Region, "Requests-SIA-Tier1", a.MonthlyTier1Requests),
			s3ApiCostComponent("GET, SELECT, and all other requests", "AmazonS3", a.Region, "Requests-SIA-Tier2", a.MonthlyTier2Requests),
			s3LifecycleTransitionsCostComponent(a.Region, "Requests-Tier4", "", a.MonthlyLifecycleTransitionRequests),
			s3DataCostComponent("Retrievals", "AmazonS3", a.Region, "Retrieval-SIA", a.MonthlyDataRetrievalGB),
			s3DataCostComponent("Select data scanned", "AmazonS3", a.Region, "Select-Scanned-SIA-Bytes", a.MonthlySelectDataScannedGB),
			s3DataCostComponent("Select data returned", "AmazonS3", a.Region, "Select-Returned-SIA-Bytes", a.MonthlySelectDataReturnedGB),
		},
	}
}

################################################################################
# FILE: internal/resources/aws/s3_standard_storage_class.go
# RESOURCE: aws_s3_standard_storage_class
# SIZE: 2450 bytes | LINES: 47
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type S3StandardStorageClass struct {
	// "required" args that can't really be missing.
	Region string

	// "usage" args
	StorageGB                   *float64 `infracost_usage:"storage_gb"`
	MonthlyTier1Requests        *int64   `infracost_usage:"monthly_tier_1_requests"`
	MonthlyTier2Requests        *int64   `infracost_usage:"monthly_tier_2_requests"`
	MonthlySelectDataScannedGB  *float64 `infracost_usage:"monthly_select_data_scanned_gb"`
	MonthlySelectDataReturnedGB *float64 `infracost_usage:"monthly_select_data_returned_gb"`
}

var S3StandardStorageClassUsageSchema = []*schema.UsageItem{
	{Key: "storage_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	{Key: "monthly_tier_1_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_tier_2_requests", DefaultValue: 0, ValueType: schema.Int64},
	{Key: "monthly_select_data_scanned_gb", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "monthly_select_data_returned_gb", DefaultValue: 0, ValueType: schema.Float64},
}

func (a *S3StandardStorageClass) CoreType() string {
	return "S3StandardStorageClass"
}

func (a *S3StandardStorageClass) UsageSchema() []*schema.UsageItem {
	return S3StandardStorageClassUsageSchema
}

func (a *S3StandardStorageClass) UsageKey() string {
	return "standard"
}

func (a *S3StandardStorageClass) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(a, u)
}

func (a *S3StandardStorageClass) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        "Standard",
		UsageSchema: a.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			s3StorageVolumeTypeCostComponent("Storage", "AmazonS3", a.Region, "TimedStorage-ByteHrs", "Standard", a.StorageGB),
			s3ApiCostComponent("PUT, COPY, POST, LIST requests", "AmazonS3", a.Region, "Requests-Tier1", a.MonthlyTier1Requests),
			s3ApiCostComponent("GET, SELECT, and all other requests", "AmazonS3", a.Region, "Requests-Tier2", a.MonthlyTier2Requests),
			s3DataGroupCostComponent("Select data scanned", "AmazonS3", a.Region, "Select-Scanned-Bytes", "S3-API-Select-Scanned", a.MonthlySelectDataScannedGB),
			s3DataGroupCostComponent("Select data returned", "AmazonS3", a.Region, "Select-Returned-Bytes", "S3-API-Select-Returned", a.MonthlySelectDataReturnedGB),
		},
	}
}

################################################################################
# FILE: internal/resources/aws/s3_storage_class_helpers.go
# RESOURCE: aws_s3_storage_class_helpers
# SIZE: 5433 bytes | LINES: 145
################################################################################
package aws

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/schema"
)

func s3StorageCostComponent(name string, service string, region string, usageType string, storageGB *float64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(storageGB),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(region),
			Service:    strPtr(service),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", usageType))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}
}

func s3StorageVolumeTypeCostComponent(name string, service string, region string, usageType string, volumeType string, storageGB *float64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(storageGB),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(region),
			Service:    strPtr(service),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", usageType))},
				{Key: "volumeType", ValueRegex: strPtr(fmt.Sprintf("/%s/i", volumeType))},
				{Key: "operation", Value: strPtr("")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}
}

func s3ApiCostComponent(name string, service string, region string, usageType string, requests *int64) *schema.CostComponent {
	return s3ApiOperationCostComponent(name, service, region, usageType, "", requests)
}

func s3ApiOperationCostComponent(name string, service string, region string, usageType string, operation string, requests *int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "1k requests",
		UnitMultiplier:  decimal.NewFromInt(1000),
		MonthlyQuantity: intPtrToDecimalPtr(requests),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(region),
			Service:    strPtr(service),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", usageType))},
				{Key: "operation", ValueRegex: strPtr(fmt.Sprintf("/%s/i", operation))},
			},
		},
		UsageBased: true,
	}
}

func s3DataCostComponent(name string, service string, region string, usageType string, dataGB *float64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(dataGB),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(region),
			Service:    strPtr(service),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", usageType))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}
}

func s3DataGroupCostComponent(name string, service string, region string, usageType string, group string, dataGB *float64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(dataGB),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(region),
			Service:    strPtr(service),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", usageType))},
				{Key: "group", ValueRegex: strPtr(fmt.Sprintf("/%s/i", group))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}
}

func s3LifecycleTransitionsCostComponent(region string, usageType string, operation string, requests *int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Lifecycle transition",
		Unit:            "1k requests",
		UnitMultiplier:  decimal.NewFromInt(1000),
		MonthlyQuantity: intPtrToDecimalPtr(requests),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(region),
			Service:    strPtr("AmazonS3"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s$/i", usageType))},
				{Key: "operation", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", operation))},
			},
		},
		UsageBased: true,
	}
}

func s3MonitoringCostComponent(region string, objects *int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Monitoring and automation",
		Unit:            "1k objects",
		UnitMultiplier:  decimal.NewFromInt(1000),
		MonthlyQuantity: intPtrToDecimalPtr(objects),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(region),
			Service:    strPtr("AmazonS3"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/Monitoring-Automation-INT/")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/search_domain.go
# RESOURCE: aws_search_domain
# SIZE: 10191 bytes | LINES: 262
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

// SearchDomain struct represents a managed search domain for both Amazon OpenSearch Service
// (formerly known as Amazon Elasticsearch Service) and AWS Elasticsearch Domain. These services
// provide fully managed search and analytics engines based on Elasticsearch and OpenSearch,
// respectively, allowing you to easily deploy, secure, and scale search solutions.
//
// Amazon OpenSearch Service and AWS Elasticsearch Domain offer a variety of instance types and
// configurations to accommodate different workloads, including dedicated master nodes, warm nodes,
// and EBS storage options. The pricing depends on the chosen instance types, instance counts,
// storage options, and additional features.
//
// For more information about Amazon OpenSearch Service and AWS Elasticsearch Domain functionality
// and pricing, refer to the following links:
//
// Amazon OpenSearch Service:
// Resource information: https://aws.amazon.com/opensearch-service/
// Pricing information: https://aws.amazon.com/opensearch-service/pricing/
//
// AWS Elasticsearch Domain:
// Resource information: https://aws.amazon.com/elasticsearch-service/
// Pricing information: https://aws.amazon.com/elasticsearch-service/pricing/
type SearchDomain struct {
	Address              string
	Region               string
	ClusterInstanceType  string
	ClusterInstanceCount *int64 // If this is nil it will default to 1

	EBSEnabled    bool
	EBSVolumeType string
	EBSVolumeSize *float64 // if this is nil it will default to 8
	EBSIOPS       *float64 // if this is nil it will default to 1
	EBSThroughput *float64 // if this is nil it will default to 0

	ClusterDedicatedMasterEnabled bool
	ClusterDedicatedMasterType    string
	ClusterDedicatedMasterCount   *int64 // if this is nil it will default to 3

	ClusterWarmEnabled bool
	ClusterWarmType    string
	ClusterWarmCount   *int64
}

func (r *SearchDomain) CoreType() string {
	return "SearchDomain"
}

func (r *SearchDomain) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *SearchDomain) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *SearchDomain) BuildResource() *schema.Resource {
	defaultClusterInstanceType := "m4.large.elasticsearch"

	instanceType := defaultClusterInstanceType
	if r.ClusterInstanceType != "" {
		instanceType = r.ClusterInstanceType
	}

	instanceCount := int64(1)
	if r.ClusterInstanceCount != nil {
		instanceCount = *r.ClusterInstanceCount
	}

	costComponents := []*schema.CostComponent{
		{
			Name:           fmt.Sprintf("Instance (on-demand, %s)", instanceType),
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(instanceCount)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonES"),
				ProductFamily: strPtr("Amazon OpenSearch Service Instance"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: strPtr("/ESInstance/")},
					{Key: "instanceType", Value: r.opensearchifyClusterInstanceType(instanceType)},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("on_demand"),
			},
		},
	}

	if r.EBSEnabled {
		gbVal := decimal.NewFromFloat(float64(defaultVolumeSize))
		if r.EBSVolumeSize != nil {
			gbVal = decimal.NewFromFloat(*r.EBSVolumeSize)
		}

		ebsType := "gp2"
		if r.EBSVolumeType != "" {
			ebsType = r.EBSVolumeType
		}

		ebsTypeMap := map[string]string{
			"gp3":      "GP3",
			"gp2":      "GP2",
			"io1":      "PIOPS-Storage",
			"standard": "Magnetic",
		}

		ebsFilter := "gp2"
		if val, ok := ebsTypeMap[ebsType]; ok {
			ebsFilter = val
		}

		costComponents = append(costComponents, &schema.CostComponent{
			Name:            fmt.Sprintf("Storage (%s)", ebsType),
			Unit:            "GB",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: &gbVal,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonES"),
				ProductFamily: strPtr("Amazon OpenSearch Service Volume"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: strPtr("/ES.+-Storage/")},
					{Key: "storageMedia", Value: strPtr(ebsFilter)},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("on_demand"),
			},
		})

		if strings.ToLower(ebsType) == "gp3" {
			paidThroughput := decimal.NewFromInt(0)
			if r.EBSThroughput != nil {
				throughput := decimal.NewFromFloat(*r.EBSThroughput)
				paidThroughput = r.calculateBillableThroughput(throughput, gbVal)
				paidThroughput = paidThroughput.Mul(decimal.NewFromInt(instanceCount))
			}

			costComponents = append(costComponents, &schema.CostComponent{
				Name:            fmt.Sprintf("Throughput (%s)", ebsType),
				Unit:            "Mbps",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: &paidThroughput,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AmazonES"),
					ProductFamily: strPtr("Amazon OpenSearch Service Volume"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "storageMedia", Value: strPtr("GP3-ThroughPut-Storage")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					PurchaseOption: strPtr("on_demand"),
				},
			})
		}

		if strings.ToLower(ebsType) == "io1" {
			iopsVal := decimal.NewFromInt(1)
			if r.EBSIOPS != nil {
				iopsVal = decimal.NewFromFloat(*r.EBSIOPS)

				if iopsVal.LessThan(decimal.NewFromInt(1)) {
					iopsVal = decimal.NewFromInt(1)
				}
			}

			costComponents = append(costComponents, &schema.CostComponent{
				Name:            fmt.Sprintf("Storage IOPS (%s)", ebsType),
				Unit:            "IOPS",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: &iopsVal,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AmazonES"),
					ProductFamily: strPtr("Amazon OpenSearch Service Volume"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/ES:PIOPS/")},
						{Key: "storageMedia", Value: strPtr("PIOPS")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					PurchaseOption: strPtr("on_demand"),
				},
			})
		}
	}

	if r.ClusterDedicatedMasterEnabled {
		dedicatedMasterType := defaultClusterInstanceType
		if r.ClusterDedicatedMasterType != "" {
			dedicatedMasterType = r.ClusterDedicatedMasterType
		}

		dedicatedMasterCount := int64(3)
		if r.ClusterDedicatedMasterCount != nil {
			dedicatedMasterCount = *r.ClusterDedicatedMasterCount
		}

		costComponents = append(costComponents, &schema.CostComponent{
			Name:           fmt.Sprintf("Dedicated master (on-demand, %s)", dedicatedMasterType),
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(dedicatedMasterCount)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonES"),
				ProductFamily: strPtr("Amazon OpenSearch Service Instance"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: strPtr("/ESInstance/")},
					{Key: "instanceType", Value: r.opensearchifyClusterInstanceType(dedicatedMasterType)},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("on_demand"),
			},
		})
	}

	if r.ClusterWarmEnabled && r.ClusterWarmType != "" {
		clusterWarmCount := int64(0)
		if r.ClusterWarmCount != nil {
			clusterWarmCount = *r.ClusterWarmCount
		}

		if clusterWarmCount > 0 {
			costComponents = append(costComponents, &schema.CostComponent{
				Name:           fmt.Sprintf("UltraWarm instance (on-demand, %s)", r.ClusterWarmType),
				Unit:           "hours",
				UnitMultiplier: decimal.NewFromInt(1),
				HourlyQuantity: decimalPtr(decimal.NewFromInt(clusterWarmCount)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AmazonES"),
					ProductFamily: strPtr("Amazon OpenSearch Service Instance"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "usagetype", ValueRegex: strPtr("/ESInstance/")},
						{Key: "instanceType", Value: r.opensearchifyClusterInstanceType(r.ClusterWarmType)},
					},
				},
				PriceFilter: &schema.PriceFilter{
					PurchaseOption: strPtr("on_demand"),
				},
			})
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *SearchDomain) opensearchifyClusterInstanceType(instanceType string) *string {
	s := strings.Replace(instanceType, ".elasticsearch", ".search", 1)
	return &s
}

// calculateBillableThroughput calculates billable throughput
// - 125 MiB/s free for volumes up to 170 GB
// - +250 MiB/s free for every 3 TB for volumes above 170 GB (storage is rounded up).
func (r *SearchDomain) calculateBillableThroughput(throughput decimal.Decimal, storage decimal.Decimal) decimal.Decimal {
	if storage.LessThanOrEqual(decimal.NewFromInt(170)) {
		if throughput.GreaterThan(decimal.NewFromInt(125)) {
			return throughput.Sub(decimal.NewFromInt(125))
		}

		return decimal.Zero
	}

	maxThroughput := decimal.NewFromInt(1000)

	incFactor := storage.Div(decimal.NewFromInt(3000)).RoundUp(0)
	freeThroughput := decimal.Min(maxThroughput, incFactor.Mul(decimal.NewFromInt(250)))

	if throughput.GreaterThan(freeThroughput) {
		return throughput.Sub(freeThroughput)
	}

	return decimal.Zero
}

################################################################################
# FILE: internal/resources/aws/secretsmanager_secret.go
# RESOURCE: aws_secretsmanager_secret
# SIZE: 1873 bytes | LINES: 59
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type SecretsManagerSecret struct {
	Address         string
	Region          string
	MonthlyRequests *int64 `infracost_usage:"monthly_requests"`
}

func (r *SecretsManagerSecret) CoreType() string {
	return "SecretsManagerSecret"
}

func (r *SecretsManagerSecret) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_requests", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *SecretsManagerSecret) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *SecretsManagerSecret) BuildResource() *schema.Resource {
	var monthlyRequests *decimal.Decimal
	if r.MonthlyRequests != nil {
		monthlyRequests = decimalPtr(decimal.NewFromInt(*r.MonthlyRequests))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Secret",
				Unit:            "months",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AWSSecretsManager"),
					ProductFamily: strPtr("Secret"),
				},
			},
			{
				Name:            "API requests",
				Unit:            "10k requests",
				UnitMultiplier:  decimal.NewFromInt(10000),
				MonthlyQuantity: monthlyRequests,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AWSSecretsManager"),
					ProductFamily: strPtr("API Request"),
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/sfn_state_machine.go
# RESOURCE: aws_sfn_state_machine
# SIZE: 5781 bytes | LINES: 140
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/usage"

	"strings"
)

type SFnStateMachine struct {
	Address            string
	Region             string
	Type               string
	MonthlyRequests    *int64 `infracost_usage:"monthly_requests"`
	WorkflowDurationMs *int64 `infracost_usage:"workflow_duration_ms"`
	MemoryMB           *int64 `infracost_usage:"memory_mb"`
	MonthlyTransitions *int64 `infracost_usage:"monthly_transitions"`
}

func (r *SFnStateMachine) CoreType() string {
	return "SFnStateMachine"
}

func (r *SFnStateMachine) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "workflow_duration_ms", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "memory_mb", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_transitions", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *SFnStateMachine) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *SFnStateMachine) BuildResource() *schema.Resource {
	costComponents := make([]*schema.CostComponent, 0)

	tier := r.Type
	if tier == "" {
		tier = "STANDARD"
	}

	if strings.ToLower(tier) == "standard" {
		var transitions *decimal.Decimal
		if r.MonthlyTransitions != nil {
			transitions = decimalPtr(decimal.NewFromInt(*r.MonthlyTransitions))
		}
		costComponents = append(costComponents, r.transistionsCostComponent(transitions))
	}

	if strings.ToLower(tier) == "express" {
		var requests *decimal.Decimal
		if r.MonthlyRequests != nil {
			requests = decimalPtr(decimal.NewFromInt(*r.MonthlyRequests))
		}
		costComponents = append(costComponents, r.requestsCostComponent(requests))

		if r.WorkflowDurationMs != nil && r.MonthlyRequests != nil && r.MemoryMB != nil {

			memoryRequest := decimalPtr(decimal.NewFromInt(*r.MemoryMB))
			duration := decimalPtr(decimal.NewFromInt(*r.WorkflowDurationMs))
			gbSeconds := decimalPtr(r.calculateGBSeconds(*memoryRequest, *duration, *requests))

			pushLimits := []int{3600000, 14400000}
			pushQuantities := usage.CalculateTierBuckets(*gbSeconds, pushLimits)

			costComponents = append(costComponents, r.durationCostComponent("Duration (first 1K)", "0", &pushQuantities[0]))
			if pushQuantities[1].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.durationCostComponent("Duration (next 4K)", "3600000", &pushQuantities[1]))
			}
			if pushQuantities[2].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.durationCostComponent("Duration (over 5K)", "18000000", &pushQuantities[2]))
			}
		} else {
			var unknown *decimal.Decimal
			costComponents = append(costComponents, r.durationCostComponent("Duration (first 1K)", "0", unknown))
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *SFnStateMachine) transistionsCostComponent(quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Transitions",
		Unit:            "1K transitions",
		UnitMultiplier:  decimal.NewFromInt(1000),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonStates"),
			ProductFamily: strPtr("AWS Step Functions"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/StateTransition/")},
			},
		},
		UsageBased: true,
	}
}

func (r *SFnStateMachine) requestsCostComponent(quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Requests",
		Unit:            "1M requests",
		UnitMultiplier:  decimal.NewFromInt(1000000),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonStates"),
			ProductFamily: strPtr("AWS Step Functions"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/StepFunctions-Request/")},
			},
		},
		UsageBased: true,
	}
}

func (r *SFnStateMachine) durationCostComponent(name string, startUsageAmt string, gbSeconds *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "GB-hours",
		UnitMultiplier:  decimal.NewFromInt(3600),
		MonthlyQuantity: gbSeconds,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("aws"),
			Region:     strPtr(r.Region),
			Service:    strPtr("AmazonStates"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/StepFunctions-GB-Second/")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(startUsageAmt),
		},
		UsageBased: true,
	}
}

func (r *SFnStateMachine) calculateGBSeconds(memorySize decimal.Decimal, averageRequestDuration decimal.Decimal, monthlyRequests decimal.Decimal) decimal.Decimal {

	if memorySize.LessThan(decimal.NewFromInt(64)) {
		memorySize = decimal.NewFromInt(64)
	}
	roundedMemory := memorySize.Div(decimal.NewFromInt(64)).Ceil().Mul(decimal.NewFromInt(64))

	roundedDuration := averageRequestDuration.Div(decimal.NewFromInt(100)).Ceil().Mul(decimal.NewFromInt(100))
	durationSeconds := monthlyRequests.Mul(roundedDuration).Mul(decimal.NewFromFloat(0.001))
	gbSeconds := durationSeconds.Mul(roundedMemory).Div(decimal.NewFromInt(1024))
	return gbSeconds
}

################################################################################
# FILE: internal/resources/aws/sns_topic.go
# RESOURCE: aws_sns_topic
# SIZE: 16302 bytes | LINES: 409
################################################################################
package aws

import (
	"fmt"
	"math"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

// SNSTopic struct represents an AWS SNS Topic operating in "Standard" mode.
//
// Resource information: https://docs.aws.amazon.com/sns/latest/dg/sns-create-topic.html
// Pricing information: https://aws.amazon.com/sns/pricing/#Standard_topics
type SNSTopic struct {
	Address                 string
	Region                  string
	RequestSizeKB           *float64 `infracost_usage:"request_size_kb"`
	MonthlyRequests         *int64   `infracost_usage:"monthly_requests"`
	HTTPSubscriptions       *int64   `infracost_usage:"http_subscriptions"`
	EmailSubscriptions      *int64   `infracost_usage:"email_subscriptions"`
	KinesisSubscriptions    *int64   `infracost_usage:"kinesis_subscriptions"`
	MobilePushSubscriptions *int64   `infracost_usage:"mobile_push_subscriptions"`
	MacOSSubscriptions      *int64   `infracost_usage:"macos_subscriptions"`
	SMSSubscriptions        *int64   `infracost_usage:"sms_subscriptions"`
	SMSNotificationPrice    *float64 `infracost_usage:"sms_notification_price"`
}

// SNSTopicUsageSchema defines a list which represents the usage schema of SNSTopic.
var SNSTopicUsageSchema = []*schema.UsageItem{
	{Key: "request_size_kb", ValueType: schema.Float64, DefaultValue: 0},
	{Key: "monthly_requests", ValueType: schema.Int64, DefaultValue: 0},
	{Key: "http_subscriptions", ValueType: schema.Int64, DefaultValue: 0},
	{Key: "email_subscriptions", ValueType: schema.Int64, DefaultValue: 0},
	{Key: "kinesis_subscriptions", ValueType: schema.Int64, DefaultValue: 0},
	{Key: "mobile_push_subscriptions", ValueType: schema.Int64, DefaultValue: 0},
	{Key: "macos_subscriptions", ValueType: schema.Int64, DefaultValue: 0},
	{Key: "sms_subscriptions", ValueType: schema.Int64, DefaultValue: 0},
	{Key: "sms_notification_price", ValueType: schema.Float64, DefaultValue: 0.0075},
}

// apiRequestsCostComponent returns a cost component for API request costs.
func (r *SNSTopic) apiRequestsCostComponent(requests *int64) *schema.CostComponent {
	var q *decimal.Decimal
	if requests != nil {
		if *requests > 1000000 {
			q = decimalPtr(decimal.NewFromInt(*requests - 1000000))
		} else {
			q = &decimal.Zero
		}
	}
	return &schema.CostComponent{
		Name:            "API requests (over 1M)",
		Unit:            "1M requests",
		UnitMultiplier:  decimal.NewFromInt(1000000),
		MonthlyQuantity: q,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonSNS"),
			ProductFamily: strPtr("API Request"),
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("1000000"),
		},
		UsageBased: true,
	}
}

// httpNotificationsCostComponent returns a cost component for HTTP notification costs.
func (r *SNSTopic) httpNotificationsCostComponent(subscriptions, requests *int64) *schema.CostComponent {
	return r.notificationsCostComponent(
		"HTTP/HTTPS notifications (over 100k)",
		"100k notifications",
		100000,
		"DeliveryAttempts-HTTP",
		100000,
		subscriptions,
		requests,
	)
}

// emailNotificationsCostComponent returns a cost component for Email notification costs.
func (r *SNSTopic) emailNotificationsCostComponent(subscriptions, requests *int64) *schema.CostComponent {
	return r.notificationsCostComponent(
		"Email/Email-JSON notifications (over 1k)",
		"100k notifications",
		100000,
		"DeliveryAttempts-SMTP",
		1000,
		subscriptions,
		requests,
	)
}

// kinesisNotificationsCostComponent returns a cost component for Kinesis notification costs.
func (r *SNSTopic) kinesisNotificationsCostComponent(subscriptions, requests *int64) *schema.CostComponent {
	return r.notificationsCostComponent(
		"Kinesis Firehose notifications",
		"1M notifications",
		1000000,
		"DeliveryAttempts-FIREHOSE",
		0,
		subscriptions,
		requests,
	)
}

// mobilePushNotificationsCostComponent returns a cost component for Mobile Push notification costs.
func (r *SNSTopic) mobilePushNotificationsCostComponent(subscriptions, requests *int64) *schema.CostComponent {
	return r.notificationsCostComponent(
		"Mobile Push notifications",
		"1M notifications",
		1000000,
		"DeliveryAttempts-APNS",
		0,
		subscriptions,
		requests,
	)
}

// macOSNotificationsCostComponent returns a cost component for MacOS notification costs.
func (r *SNSTopic) macOSNotificationsCostComponent(subscriptions, requests *int64) *schema.CostComponent {
	return r.notificationsCostComponent(
		"MacOS notifications",
		"1M notifications",
		1000000,
		"DeliveryAttempts-MACOS",
		0,
		subscriptions,
		requests,
	)
}

// smsNotificationsCostComponent returns a cost component for SMS notification costs.
func (r *SNSTopic) smsNotificationsCostComponent(subscriptions, requests *int64) *schema.CostComponent {
	var multiplier int64 = 100

	q := r.calculateQuantity(subscriptions, requests, multiplier)
	region := r.Region

	// Pricing is available only for these regions. Default usage price is the
	// same as for us-east-1, thus if region is not supported use us-east-1 in
	// attribute filter.
	availableRegions := []string{"us-east-1", "me-south-1", "eu-west-3"}
	if !stringInSlice(availableRegions, region) {
		region = availableRegions[0]
	}

	c := &schema.CostComponent{
		Name:            "SMS notifications (over 100)",
		Unit:            "100 notifications",
		UnitMultiplier:  decimal.NewFromInt(multiplier),
		MonthlyQuantity: q,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(region),
			Service:       strPtr("AmazonSNS"),
			ProductFamily: strPtr("Message Delivery"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("DeliveryAttempts-SMS$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(fmt.Sprintf("%d", 100)),
		},
		UsageBased: true,
	}

	if r.SMSNotificationPrice != nil {
		c.SetCustomPrice(decimalPtr(decimal.NewFromFloat(*r.SMSNotificationPrice)))
	}

	return c
}

func (r *SNSTopic) CoreType() string {
	return "SNSTopic"
}

func (r *SNSTopic) UsageSchema() []*schema.UsageItem {
	return SNSTopicUsageSchema
}

// PopulateUsage parses the u schema.UsageData into the SNSTopic.
// It uses the `infracost_usage` struct tags to populate data into the SNSTopic.
func (r *SNSTopic) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid SNSTopic struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *SNSTopic) BuildResource() *schema.Resource {
	var requests *int64

	requestSize := 64.0
	if r.RequestSizeKB != nil {
		requestSize = *r.RequestSizeKB
	}

	if r.MonthlyRequests != nil {
		requests = r.calculateRequests(requestSize, *r.MonthlyRequests)
	}

	components := []*schema.CostComponent{
		r.apiRequestsCostComponent(requests),
		r.httpNotificationsCostComponent(r.HTTPSubscriptions, requests),
		r.emailNotificationsCostComponent(r.EmailSubscriptions, requests),
		r.kinesisNotificationsCostComponent(r.KinesisSubscriptions, requests),
		r.mobilePushNotificationsCostComponent(r.MobilePushSubscriptions, requests),
		r.macOSNotificationsCostComponent(r.MacOSSubscriptions, requests),
		r.smsNotificationsCostComponent(r.SMSSubscriptions, requests),
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: components,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *SNSTopic) calculateRequests(requestSize float64, monthlyRequests int64) *int64 {
	i := int64(math.Ceil(requestSize/64.0)) * monthlyRequests
	return &i
}

func (r *SNSTopic) calculateQuantity(subscribers *int64, requests *int64, startUsageAmount int64) *decimal.Decimal {
	// Decide on whether quantity is >0, 0, or nil.
	// If both subscribers and requests are set, multiply them to get the total number of notifications.
	// If at least one of them is 0, set quantity to 0 so we don't show 'Monthly cost depends on usage...'
	// Otherwise, leave quantity nil so we show 'Monthly cost depends on usage...'
	var q *decimal.Decimal

	if subscribers != nil && requests != nil {
		totalNotifications := *subscribers * *requests
		if totalNotifications > startUsageAmount {
			q = decimalPtr(decimal.NewFromInt(totalNotifications - startUsageAmount))
		} else {
			q = &decimal.Zero // free tier
		}
	} else if (subscribers != nil && *subscribers == 0) || (requests != nil && *requests == 0) {
		q = &decimal.Zero
	}

	return q
}

// notificationsCostComponent returns a cost component corresponding to the supplied parameters.
func (r *SNSTopic) notificationsCostComponent(name, unit string, multiplier int64, usageType string, startUsageAmount int64, subscribers, requests *int64) *schema.CostComponent {
	q := r.calculateQuantity(subscribers, requests, startUsageAmount)

	return &schema.CostComponent{
		Name:            name,
		Unit:            unit,
		UnitMultiplier:  decimal.NewFromInt(multiplier),
		MonthlyQuantity: q,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonSNS"),
			ProductFamily: strPtr("Message Delivery"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr(fmt.Sprintf("%s$", usageType))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(fmt.Sprintf("%d", startUsageAmount)),
		},
		UsageBased: true,
	}
}

// SNSFIFOTopic struct represents an AWS SNS Topic operating in "FIFO" mode.
//
// Resource information: https://docs.aws.amazon.com/sns/latest/dg/fifo-example-use-case.html
// Pricing information: https://aws.amazon.com/sns/pricing/#FIFO_topics
type SNSFIFOTopic struct {
	Address         string
	Region          string
	Subscriptions   int64
	RequestSizeKB   *float64 `infracost_usage:"request_size_kb"`
	MonthlyRequests *int64   `infracost_usage:"monthly_requests"`
}

// SNSFIFOTopicUsageSchema defines a list which represents the usage schema of SNSFIFOTopic.
var SNSFIFOTopicUsageSchema = []*schema.UsageItem{
	{Key: "request_size_kb", ValueType: schema.Float64, DefaultValue: 1},
	{Key: "monthly_requests", ValueType: schema.Int64, DefaultValue: 0},
}

// This is an experiment to see if using an explicit structure to define the cost components
// can enable anything interesting (e.g. list what cost components could apply to a resource
// without having any IaAC)
// func (r *SNSFIFOTopic) CostComponents() []*schema.CostComponent {
//	return []*schema.CostComponent{
//		r.publishAPIRequestsCostComponent(nil),
//		r.publishAPIPayloadCostComponent(nil, nil),
//		r.notificationsCostComponent(0, nil),
//		r.notificationPayloadCostComponent(0, nil, nil),
//	}
// }

// publishAPIRequestsCostComponent returns a cost component for Publish API request costs.
func (r *SNSFIFOTopic) publishAPIRequestsCostComponent(requests *int64) *schema.CostComponent {
	var q *decimal.Decimal
	if requests != nil {
		q = decimalPtr(decimal.NewFromInt(*requests))
	}

	return &schema.CostComponent{
		Name:            "FIFO Publish API requests",
		Unit:            "1M requests",
		UnitMultiplier:  decimal.NewFromInt(1000000),
		MonthlyQuantity: q,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonSNS"),
			ProductFamily: strPtr(""),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("F-Request-Tier1$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}
}

// publishAPIPayloadCostComponent returns a cost component for Publish API payload costs.
func (r *SNSFIFOTopic) publishAPIPayloadCostComponent(requests *int64, requestSizeGB *float64) *schema.CostComponent {
	var q *decimal.Decimal
	if requests != nil && requestSizeGB != nil {
		q = decimalPtr(decimal.NewFromFloat(float64(*requests) * *requestSizeGB))
	}

	return &schema.CostComponent{
		Name:            "FIFO Publish API payload",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: q,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonSNS"),
			ProductFamily: strPtr(""),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("F-Ingress-Tier1$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}
}

// notificationsCostComponent returns a cost component for notification costs.
func (r *SNSFIFOTopic) notificationsCostComponent(subscriptions int64, requests *int64) *schema.CostComponent {
	var q *decimal.Decimal
	if subscriptions == 0 {
		q = &decimal.Zero
	} else if requests != nil {
		q = decimalPtr(decimal.NewFromInt(subscriptions * *requests))
	}

	return &schema.CostComponent{
		Name:            "FIFO notifications",
		Unit:            "1M notifications",
		UnitMultiplier:  decimal.NewFromInt(1000000),
		MonthlyQuantity: q,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonSNS"),
			ProductFamily: strPtr(""),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("F-DA-SQS$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}
}

// notificationPayloadCostComponent returns a cost component for notification payload costs.
func (r *SNSFIFOTopic) notificationPayloadCostComponent(subscriptions int64, requests *int64, requestSizeGB *float64) *schema.CostComponent {
	var q *decimal.Decimal
	if subscriptions == 0 {
		q = &decimal.Zero
	} else if requests != nil && requestSizeGB != nil {
		q = decimalPtr(decimal.NewFromFloat(float64(subscriptions**requests) * *requestSizeGB))
	}

	return &schema.CostComponent{
		Name:            "FIFO notification payload",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: q,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonSNS"),
			ProductFamily: strPtr(""),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: regexPtr("F-Egress-SQS$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}
}

func (r *SNSFIFOTopic) CoreType() string {
	return "SNSFIFOTopic"
}

func (r *SNSFIFOTopic) UsageSchema() []*schema.UsageItem {
	return SNSFIFOTopicUsageSchema
}

// PopulateUsage parses the u schema.UsageData into the SNSFIFOTopic.
// It uses the `infracost_usage` struct tags to populate data into the SNSFIFOTopic.
func (r *SNSFIFOTopic) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid SNSFIFOTopic struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *SNSFIFOTopic) BuildResource() *schema.Resource {
	var requestSizeGB *float64
	if r.RequestSizeKB != nil {
		requestSizeGB = floatPtr(*r.RequestSizeKB / 1000000.0)
	}

	components := []*schema.CostComponent{
		r.publishAPIRequestsCostComponent(r.MonthlyRequests),
		r.publishAPIPayloadCostComponent(r.MonthlyRequests, requestSizeGB),
		r.notificationsCostComponent(r.Subscriptions, r.MonthlyRequests),
		r.notificationPayloadCostComponent(r.Subscriptions, r.MonthlyRequests, requestSizeGB),
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: components,
		UsageSchema:    SNSTopicUsageSchema,
	}
}

################################################################################
# FILE: internal/resources/aws/sns_topic_subscription.go
# RESOURCE: aws_sns_topic_subscription
# SIZE: 2540 bytes | LINES: 77
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type SNSTopicSubscription struct {
	Address         string
	Protocol        string
	Region          string
	RequestSizeKB   *float64 `infracost_usage:"request_size_kb"`
	MonthlyRequests *int64   `infracost_usage:"monthly_requests"`
}

func (r *SNSTopicSubscription) CoreType() string {
	return "SNSTopicSubscription"
}

func (r *SNSTopicSubscription) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "request_size_kb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_requests", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *SNSTopicSubscription) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *SNSTopicSubscription) BuildResource() *schema.Resource {
	var endpointType string
	var freeTier string
	switch r.Protocol {
	case "http", "https":
		endpointType = "HTTP"
		freeTier = "100000"
	default:
		return &schema.Resource{
			Name:      r.Address,
			NoPrice:   true,
			IsSkipped: true,
		}
	}

	var requests *decimal.Decimal

	requestSize := decimal.NewFromInt(64)
	if r.RequestSizeKB != nil {
		requestSize = decimal.NewFromFloat(*r.RequestSizeKB)
	}

	if r.MonthlyRequests != nil {
		requests = decimalPtr(r.calculateRequests(requestSize, decimal.NewFromInt(*r.MonthlyRequests)))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            fmt.Sprintf("%s notifications", endpointType),
				Unit:            "1M notifications",
				UnitMultiplier:  decimal.NewFromInt(1000000),
				MonthlyQuantity: requests,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AmazonSNS"),
					ProductFamily: strPtr("Message Delivery"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "endpointType", ValueRegex: strPtr(fmt.Sprintf("/%s/i", endpointType))},
					},
				},
				PriceFilter: &schema.PriceFilter{
					StartUsageAmount: strPtr(freeTier),
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

func (r *SNSTopicSubscription) calculateRequests(requestSize decimal.Decimal, monthlyRequests decimal.Decimal) decimal.Decimal {
	return requestSize.Div(decimal.NewFromInt(64)).Ceil().Mul(monthlyRequests)
}

################################################################################
# FILE: internal/resources/aws/sqs_queue.go
# RESOURCE: aws_sqs_queue
# SIZE: 2236 bytes | LINES: 69
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type SQSQueue struct {
	Address         string
	Region          string
	FifoQueue       bool
	MonthlyRequests *float64 `infracost_usage:"monthly_requests"`
	RequestSizeKB   *int64   `infracost_usage:"request_size_kb"`
}

func (r *SQSQueue) CoreType() string {
	return "SQSQueue"
}

func (r *SQSQueue) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_requests", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "request_size_kb", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *SQSQueue) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *SQSQueue) BuildResource() *schema.Resource {
	var queueType string
	if r.FifoQueue {
		queueType = "FIFO (first-in, first-out)"
	} else {
		queueType = "Standard"
	}

	var requests *decimal.Decimal

	requestSize := decimal.NewFromInt(64)
	if r.RequestSizeKB != nil {
		requestSize = decimal.NewFromInt(*r.RequestSizeKB)
	}

	if r.MonthlyRequests != nil {
		requests = decimalPtr(r.calculateRequests(requestSize, decimal.NewFromFloat(*r.MonthlyRequests)))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Requests",
				Unit:            "1M requests",
				UnitMultiplier:  decimal.NewFromInt(1000000),
				MonthlyQuantity: requests,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("aws"),
					Region:        strPtr(r.Region),
					Service:       strPtr("AWSQueueService"),
					ProductFamily: strPtr("API Request"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "queueType", Value: strPtr(queueType)},
					},
				},
				PriceFilter: &schema.PriceFilter{
					StartUsageAmount: strPtr("0"),
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

func (r *SQSQueue) calculateRequests(requestSize decimal.Decimal, monthlyRequests decimal.Decimal) decimal.Decimal {
	return requestSize.Div(decimal.NewFromInt(64)).Ceil().Mul(monthlyRequests)
}

################################################################################
# FILE: internal/resources/aws/ssm_activation.go
# RESOURCE: aws_ssm_activation
# SIZE: 2117 bytes | LINES: 67
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"strings"

	"github.com/shopspring/decimal"
)

type SSMActivation struct {
	Address           string
	Region            string
	RegistrationLimit int64
	InstanceTier      *string `infracost_usage:"instance_tier"`
	Instances         *int64  `infracost_usage:"instances"`
}

func (r *SSMActivation) CoreType() string {
	return "SSMActivation"
}

func (r *SSMActivation) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "instance_tier", ValueType: schema.String, DefaultValue: "standard"},
		{Key: "instances", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *SSMActivation) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *SSMActivation) BuildResource() *schema.Resource {
	var instanceTier string
	if r.InstanceTier != nil {
		instanceTier = *r.InstanceTier
	} else if r.RegistrationLimit > 1000 {
		instanceTier = "Advanced"
	}

	var instanceCount *decimal.Decimal
	if r.Instances != nil {
		instanceCount = decimalPtr(decimal.NewFromInt(*r.Instances))
	}

	if strings.ToLower(instanceTier) == "advanced" {
		return &schema.Resource{
			Name: r.Address,
			CostComponents: []*schema.CostComponent{
				{
					Name:           "On-prem managed instances (advanced)",
					Unit:           "hours",
					UnitMultiplier: decimal.NewFromInt(1),
					HourlyQuantity: instanceCount,
					ProductFilter: &schema.ProductFilter{
						VendorName:    strPtr("aws"),
						Region:        strPtr(r.Region),
						Service:       strPtr("AWSSystemsManager"),
						ProductFamily: strPtr("AWS Systems Manager"),
						AttributeFilters: []*schema.AttributeFilter{
							{Key: "usagetype", ValueRegex: strPtr("/MI-AdvInstances-Hrs/")},
						},
					},
					UsageBased: true,
				},
			}, UsageSchema: r.UsageSchema(),
		}
	}

	return &schema.Resource{
		Name:        r.Address,
		NoPrice:     true,
		IsSkipped:   true,
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/ssm_parameter.go
# RESOURCE: aws_ssm_parameter
# SIZE: 4079 bytes | LINES: 111
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type SSMParameter struct {
	Address                string
	Tier                   string
	Region                 string
	ParameterStorageHrs    *int64  `infracost_usage:"parameter_storage_hrs"`
	APIThroughputLimit     *string `infracost_usage:"api_throughput_limit"`
	MonthlyAPIInteractions *int64  `infracost_usage:"monthly_api_interactions"`
}

func (r *SSMParameter) CoreType() string {
	return "SSMParameter"
}

func (r *SSMParameter) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "parameter_storage_hrs", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "api_throughput_limit", ValueType: schema.String, DefaultValue: "standard"},
		{Key: "monthly_api_interactions", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *SSMParameter) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *SSMParameter) BuildResource() *schema.Resource {
	costComponents := make([]*schema.CostComponent, 0)

	throughputLimit := ""

	if r.APIThroughputLimit != nil {
		throughputLimit = strings.ToLower(*r.APIThroughputLimit)

		if throughputLimit != "standard" && throughputLimit != "advanced" && throughputLimit != "higher" {
			logging.Logger.Warn().Msgf("Skipping resource %s. Unrecognized api_throughput_limit %s, expecting standard, advanced or higher", r.Address, *r.APIThroughputLimit)
			return nil
		}
	}

	if throughputLimit == "" {
		throughputLimit = r.tierValue()
	}

	if r.tierValue() != "standard" {
		costComponents = append(costComponents, r.parameterStorageCostComponent())
		costComponents = append(costComponents, r.apiThroughputCostComponent(throughputLimit))
	}

	if len(costComponents) == 0 {
		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *SSMParameter) tierValue() string {
	if r.Tier == "" {
		return "standard"
	}

	return strings.ToLower(r.Tier)
}

func (r *SSMParameter) parameterStorageCostComponent() *schema.CostComponent {
	parameterStorageHours := decimal.NewFromInt(730)
	if r.ParameterStorageHrs != nil {
		parameterStorageHours = decimal.NewFromInt(*r.ParameterStorageHrs)
	}

	return &schema.CostComponent{
		Name:            "Parameter storage (advanced)",
		Unit:            "hours",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: &parameterStorageHours,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSSystemsManager"),
			ProductFamily: strPtr("AWS Systems Manager"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/PS-Advanced-Param-Tier1/")},
			},
		},
		UsageBased: true,
	}
}

func (r *SSMParameter) apiThroughputCostComponent(throughputLimit string) *schema.CostComponent {
	var monthlyAPIInteractions *decimal.Decimal
	if r.MonthlyAPIInteractions != nil {
		monthlyAPIInteractions = decimalPtr(decimal.NewFromInt(*r.MonthlyAPIInteractions))
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("API interactions (%s)", throughputLimit),
		Unit:            "10k interactions",
		UnitMultiplier:  decimal.NewFromInt(10000),
		MonthlyQuantity: monthlyAPIInteractions,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AWSSystemsManager"),
			ProductFamily: strPtr("API Request"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/PS-Param-Processed-Tier2/")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/transfer_server.go
# RESOURCE: aws_transfer_server
# SIZE: 4626 bytes | LINES: 110
################################################################################
package aws

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// TransferServer defines a AWS Transfer Server resource from Transfer Family
// service. It supports multiple transfer protocols like FTP/FTPS/SFTP and
// each is billed hourly when enabled. It also bills the amount of data
// being downloaded/uploaded over those protocols.
//
// See more resource information here: https://aws.amazon.com/aws-transfer-family/.
//
// See the pricing information here: https://aws.amazon.com/aws-transfer-family/pricing/.
type TransferServer struct {
	Address   string
	Region    string
	Protocols []string

	// "usage" args
	MonthlyDataDownloadedGB *float64 `infracost_usage:"monthly_data_downloaded_gb"`
	MonthlyDataUploadedGB   *float64 `infracost_usage:"monthly_data_uploaded_gb"`
}

// TransferServerUsageSchema defines a list of usage items for TransferServer.
func (r *TransferServer) CoreType() string {
	return "TransferServer"
}

func (r *TransferServer) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_data_downloaded_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_data_uploaded_gb", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the TransferServer.
// It uses the `infracost_usage` struct tags to populate data into the TransferServer.
func (r *TransferServer) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid TransferServer struct.
// This method is called after the resource is initialised by an IaC provider.
func (r *TransferServer) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	for _, protocol := range r.Protocols {
		costComponents = append(costComponents, r.protocolEnabledCostComponent(protocol))
	}

	costComponents = append(costComponents, r.dataDownloadedCostComponent())
	costComponents = append(costComponents, r.dataUploadedCostComponent())

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *TransferServer) protocolEnabledCostComponent(protocol string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           fmt.Sprintf("%s protocol enabled", protocol),
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter:  r.buildProductFilter(protocol, "^[A-Z0-9]*-ProtocolHours$"),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
	}
}

func (r *TransferServer) dataDownloadedCostComponent() *schema.CostComponent {
	// The pricing is identical for all protocols and the traffic is combined
	transferProtocol := "FTP"

	return &schema.CostComponent{
		Name:            "Data downloaded",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyDataDownloadedGB),
		ProductFilter:   r.buildProductFilter(transferProtocol, "^[A-Z0-9]*-DownloadBytes$"),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *TransferServer) dataUploadedCostComponent() *schema.CostComponent {
	// The pricing is identical for all protocols and the traffic is combined
	transferProtocol := "FTP"

	return &schema.CostComponent{
		Name:            "Data uploaded",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyDataUploadedGB),
		ProductFilter:   r.buildProductFilter(transferProtocol, "^[A-Z0-9]*-UploadBytes$"),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *TransferServer) buildProductFilter(protocol, usageType string) *schema.ProductFilter {
	// The pricing for all storage types is identical, but for some protocols
	// EFS prices are missing in the pricing API.
	storageType := "S3"

	return &schema.ProductFilter{
		VendorName:    strPtr("aws"),
		Region:        strPtr(r.Region),
		Service:       strPtr("AWSTransfer"),
		ProductFamily: strPtr("AWS Transfer Family"),
		AttributeFilters: []*schema.AttributeFilter{
			{Key: "usagetype", ValueRegex: regexPtr(usageType)},
			{Key: "operation", ValueRegex: regexPtr(fmt.Sprintf("^%s:%s$", protocol, storageType))},
		},
	}
}

################################################################################
# FILE: internal/resources/aws/util.go
# RESOURCE: aws_util
# SIZE: 23626 bytes | LINES: 742
################################################################################
package aws

import (
	"fmt"
	"math"
	"reflect"
	"regexp"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/schema"
)

var (
	underscore = regexp.MustCompile(`_`)
	vendorName = strPtr("aws")
)

func strPtr(s string) *string {
	return &s
}

func strVal(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}

// nolint:deadcode,unused
func regexPtr(regex string) *string {
	return strPtr(fmt.Sprintf("/%s/i", regex))
}

func intPtr(i int64) *int64 {
	return &i
}

func floatPtr(i float64) *float64 {
	return &i
}

func intVal(i *int64) int64 {
	if i == nil {
		return 0
	}
	return *i
}

func floatVal(i *float64) float64 {
	if i == nil {
		return 0
	}
	return *i
}

func decimalPtr(d decimal.Decimal) *decimal.Decimal {
	return &d
}

func intPtrToDecimalPtr(i *int64) *decimal.Decimal {
	if i == nil {
		return nil
	}
	return decimalPtr(decimal.NewFromInt(*i))
}

func floatPtrToDecimalPtr(f *float64) *decimal.Decimal {
	if f == nil {
		return nil
	}
	return decimalPtr(decimal.NewFromFloat(*f))
}

func asGiB(i int64) int64 {
	if i == 0 {
		return 0
	}
	i /= (1024 * 1024 * 1024)
	if i == 0 {
		return 1
	}
	return i
}

func ceil64(f float64) int64 {
	return int64(math.Ceil(f))
}

func stringInSlice(slice []string, s string) bool {
	for _, b := range slice {
		if b == s {
			return true
		}
	}
	return false
}

func sliceOfKeysFromMap[K comparable, V any](m map[K]V) []K {
	keys := make([]K, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

// RegionMapping is a helpful conversion map that changes
// aws region name to the name commonly used in pricing filters.
var RegionMapping = map[string]string{
	"us-gov-west-1":   "AWS GovCloud (US-West)",
	"us-gov-east-1":   "AWS GovCloud (US-East)",
	"us-east-1":       "US East (N. Virginia)",
	"us-east-2":       "US East (Ohio)",
	"us-west-1":       "US West (N. California)",
	"us-west-2":       "US West (Oregon)",
	"us-west-2-lax-1": "US West (Los Angeles)",
	"ca-central-1":    "Canada (Central)",
	"ca-west-1":       "Canada West (Calgary)",
	"mx-central-1":    "Mexico (Central)",
	"cn-north-1":      "China (Beijing)",
	"cn-northwest-1":  "China (Ningxia)",
	"eu-central-1":    "EU (Frankfurt)",
	"eu-central-2":    "EU (Zurich)",
	"eu-west-1":       "EU (Ireland)",
	"eu-west-2":       "EU (London)",
	"eu-south-1":      "EU (Milan)",
	"eu-south-2":      "EU (Spain)",
	"eu-west-3":       "EU (Paris)",
	"eu-north-1":      "EU (Stockholm)",
	"il-central-1":    "Israel (Tel Aviv)",
	"ap-east-1":       "Asia Pacific (Hong Kong)",
	"ap-east-2":       "Asia Pacific (Taipei)",
	"ap-northeast-1":  "Asia Pacific (Tokyo)",
	"ap-northeast-2":  "Asia Pacific (Seoul)",
	"ap-northeast-3":  "Asia Pacific (Osaka)",
	"ap-southeast-1":  "Asia Pacific (Singapore)",
	"ap-southeast-2":  "Asia Pacific (Sydney)",
	"ap-southeast-3":  "Asia Pacific (Jakarta)",
	"ap-southeast-4":  "Asia Pacific (Melbourne)",
	"ap-southeast-5":  "Asia Pacific (Malaysia)",
	"ap-southeast-6":  "Asia Pacific (New Zealand)",
	"ap-southeast-7":  "Asia Pacific (Thailand)",
	"ap-south-1":      "Asia Pacific (Mumbai)",
	"ap-south-2":      "Asia Pacific (Hyderabad)",
	"me-central-1":    "Middle East (UAE)",
	"me-south-1":      "Middle East (Bahrain)",
	"sa-east-1":       "South America (Sao Paulo)",
	"af-south-1":      "Africa (Cape Town)",
}

// RegionCodeMapping helps to find region's abbreviated code for a more granular
// filtering when resources may have multiple products for the same region.
var RegionCodeMapping = map[string]string{
	"ap-southeast-1": "APS1",
}

// RegionsUsage is a reusable type that represents a usage cost map.
// This can be used in resources that define a usage parameter that's
// changed on a per-region basis. e.g.
//
// monthly_data_processed_gb:
//
//	us_gov_west_1: 188
//	us_east_1: 78
//
// can be handled by adding a usage cost property to your resource like so:
//
//	type MyResource struct {
//	   ...
//	   MonthlyDataProcessedGB *RegionsUsage `infracost_usage:"monthly_processed_gb"`
//	}
type RegionsUsage struct {
	USGovWest1   *float64 `infracost_usage:"us_gov_west_1"`
	USGovEast1   *float64 `infracost_usage:"us_gov_east_1"`
	USEast1      *float64 `infracost_usage:"us_east_1"`
	USEast2      *float64 `infracost_usage:"us_east_2"`
	USWest1      *float64 `infracost_usage:"us_west_1"`
	USWest2      *float64 `infracost_usage:"us_west_2"`
	USWest2Lax1  *float64 `infracost_usage:"us_west_2_lax_1"`
	CACentral1   *float64 `infracost_usage:"ca_central_1"`
	CAWest1      *float64 `infracost_usage:"ca_west_1"`
	CNNorth1     *float64 `infracost_usage:"cn_north_1"`
	CNNorthwest1 *float64 `infracost_usage:"cn_northwest_1"`
	EUCentral1   *float64 `infracost_usage:"eu_central_1"`
	EUCentral2   *float64 `infracost_usage:"eu_central_2"`
	EUWest1      *float64 `infracost_usage:"eu_west_1"`
	EUWest2      *float64 `infracost_usage:"eu_west_2"`
	EUSouth1     *float64 `infracost_usage:"eu_south_1"`
	EUSouth2     *float64 `infracost_usage:"eu_south_2"`
	EUWest3      *float64 `infracost_usage:"eu_west_3"`
	EUNorth1     *float64 `infracost_usage:"eu_north_1"`
	ILCentral1   *float64 `infracost_usage:"il_central_1"`
	APEast1      *float64 `infracost_usage:"ap_east_1"`
	APEast2      *float64 `infracost_usage:"ap_east_2"`
	APNortheast1 *float64 `infracost_usage:"ap_northeast_1"`
	APNortheast2 *float64 `infracost_usage:"ap_northeast_2"`
	APNortheast3 *float64 `infracost_usage:"ap_northeast_3"`
	APSoutheast1 *float64 `infracost_usage:"ap_southeast_1"`
	APSoutheast2 *float64 `infracost_usage:"ap_southeast_2"`
	APSoutheast3 *float64 `infracost_usage:"ap_southeast_3"`
	APSoutheast4 *float64 `infracost_usage:"ap_southeast_4"`
	APSoutheast5 *float64 `infracost_usage:"ap_southeast_5"`
	APSoutheast6 *float64 `infracost_usage:"ap_southeast_6"`
	APSoutheast7 *float64 `infracost_usage:"ap_southeast_7"`
	APSouth1     *float64 `infracost_usage:"ap_south_1"`
	APSouth2     *float64 `infracost_usage:"ap_south_2"`
	MECentral1   *float64 `infracost_usage:"me_central_1"`
	MESouth1     *float64 `infracost_usage:"me_south_1"`
	SAEast1      *float64 `infracost_usage:"sa_east_1"`
	AFSouth1     *float64 `infracost_usage:"af_south_1"`
}

// RegionUsage defines a hard definition in the regions map.
type RegionUsage struct {
	Key   string
	Value float64
}

// Values returns RegionUsage as a slice which can be iterated over
// to create cost components. The keys of the regions returned have
// their underscores replaced with hypens so they can be used in
// product filters and cost lookups.
func (r RegionsUsage) Values() []RegionUsage {
	s := reflect.ValueOf(r)
	t := reflect.TypeOf(r)

	var regions []RegionUsage
	for i := 0; i < s.NumField(); i++ {
		f := s.Field(i)

		if f.IsNil() {
			continue
		}

		regions = append(regions, RegionUsage{
			Key:   underscore.ReplaceAllString(t.Field(i).Tag.Get("infracost_usage"), "-"),
			Value: *f.Interface().(*float64),
		})
	}

	return regions
}

// RegionUsageSchema is the schema representation of the RegionsUsage type.
// This can be used as a schema.SubResourceUsage to define a structure that's
// commonly used with data transfer usage. e.g:
//
//	monthly_data_transfer_out_gb:
//		us_gov_west_1: 122
//		ca_central_1: 99
//
// See DirectoryServiceDirectory for an example usage.
var RegionUsageSchema = []*schema.UsageItem{
	{Key: "us_gov_west_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "us_gov_east_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "us_east_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "us_east_2", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "us_west_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "us_west_2", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "us_west_2_lax_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ca_central_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ca_west_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "mx_central_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "cn_north_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "cn_northwest_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "eu_central_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "eu_central_2", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "eu_west_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "eu_west_2", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "eu_south_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "eu_south_2", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "eu_west_3", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "eu_north_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "il_central_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ap_east_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ap_east_2", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ap_northeast_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ap_northeast_2", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ap_northeast_3", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ap_southeast_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ap_southeast_2", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ap_southeast_3", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ap_southeast_4", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ap_southeast_5", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ap_southeast_6", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ap_southeast_7", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ap_south_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "ap_south_2", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "me_central_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "me_south_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "sa_east_1", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "af_south_1", DefaultValue: 0, ValueType: schema.Float64},
}

func getBurstableInstanceFamily(matchPrefixes []string, instanceType string) string {
	for _, prefix := range matchPrefixes {
		if strings.HasPrefix(instanceType, prefix) {
			return prefix
		}
	}

	return ""
}

// this map was generated with:
// aws ec2 describe-instance-types | jq -r '[.InstanceTypes[] | "\"" + .InstanceType + "\": " + (.VCpuInfo.DefaultVCpus | tostring) + ","] | sort | .[]'
var InstanceTypeToVCPU = map[string]int64{
	"a1.2xlarge":       8,
	"a1.4xlarge":       16,
	"a1.large":         2,
	"a1.medium":        1,
	"a1.metal":         16,
	"a1.xlarge":        4,
	"c4.2xlarge":       8,
	"c4.4xlarge":       16,
	"c4.8xlarge":       36,
	"c4.large":         2,
	"c4.xlarge":        4,
	"c5.12xlarge":      48,
	"c5.18xlarge":      72,
	"c5.24xlarge":      96,
	"c5.2xlarge":       8,
	"c5.4xlarge":       16,
	"c5.9xlarge":       36,
	"c5.large":         2,
	"c5.metal":         96,
	"c5.xlarge":        4,
	"c5a.12xlarge":     48,
	"c5a.16xlarge":     64,
	"c5a.24xlarge":     96,
	"c5a.2xlarge":      8,
	"c5a.4xlarge":      16,
	"c5a.8xlarge":      32,
	"c5a.large":        2,
	"c5a.xlarge":       4,
	"c5ad.12xlarge":    48,
	"c5ad.16xlarge":    64,
	"c5ad.24xlarge":    96,
	"c5ad.2xlarge":     8,
	"c5ad.4xlarge":     16,
	"c5ad.8xlarge":     32,
	"c5ad.large":       2,
	"c5ad.xlarge":      4,
	"c5d.12xlarge":     48,
	"c5d.18xlarge":     72,
	"c5d.24xlarge":     96,
	"c5d.2xlarge":      8,
	"c5d.4xlarge":      16,
	"c5d.9xlarge":      36,
	"c5d.large":        2,
	"c5d.metal":        96,
	"c5d.xlarge":       4,
	"c5n.18xlarge":     72,
	"c5n.2xlarge":      8,
	"c5n.4xlarge":      16,
	"c5n.9xlarge":      36,
	"c5n.large":        2,
	"c5n.metal":        72,
	"c5n.xlarge":       4,
	"c6g.12xlarge":     48,
	"c6g.16xlarge":     64,
	"c6g.2xlarge":      8,
	"c6g.4xlarge":      16,
	"c6g.8xlarge":      32,
	"c6g.large":        2,
	"c6g.medium":       1,
	"c6g.metal":        64,
	"c6g.xlarge":       4,
	"c6gd.12xlarge":    48,
	"c6gd.16xlarge":    64,
	"c6gd.2xlarge":     8,
	"c6gd.4xlarge":     16,
	"c6gd.8xlarge":     32,
	"c6gd.large":       2,
	"c6gd.medium":      1,
	"c6gd.metal":       64,
	"c6gd.xlarge":      4,
	"c6gn.12xlarge":    48,
	"c6gn.16xlarge":    64,
	"c6gn.2xlarge":     8,
	"c6gn.4xlarge":     16,
	"c6gn.8xlarge":     32,
	"c6gn.large":       2,
	"c6gn.medium":      1,
	"c6gn.xlarge":      4,
	"c6i.12xlarge":     48,
	"c6i.16xlarge":     64,
	"c6i.24xlarge":     96,
	"c6i.2xlarge":      8,
	"c6i.32xlarge":     128,
	"c6i.4xlarge":      16,
	"c6i.8xlarge":      32,
	"c6i.large":        2,
	"c6i.metal":        128,
	"c6i.xlarge":       4,
	"d2.2xlarge":       8,
	"d2.4xlarge":       16,
	"d2.8xlarge":       36,
	"d2.xlarge":        4,
	"d3.2xlarge":       8,
	"d3.4xlarge":       16,
	"d3.8xlarge":       32,
	"d3.xlarge":        4,
	"g3.16xlarge":      64,
	"g3.4xlarge":       16,
	"g3.8xlarge":       32,
	"g3s.xlarge":       4,
	"g4ad.16xlarge":    64,
	"g4ad.2xlarge":     8,
	"g4ad.4xlarge":     16,
	"g4ad.8xlarge":     32,
	"g4ad.xlarge":      4,
	"g4dn.12xlarge":    48,
	"g4dn.16xlarge":    64,
	"g4dn.2xlarge":     8,
	"g4dn.4xlarge":     16,
	"g4dn.8xlarge":     32,
	"g4dn.metal":       96,
	"g4dn.xlarge":      4,
	"h1.16xlarge":      64,
	"h1.2xlarge":       8,
	"h1.4xlarge":       16,
	"h1.8xlarge":       32,
	"hpc6a.48xlarge":   96,
	"i2.2xlarge":       8,
	"i2.4xlarge":       16,
	"i2.8xlarge":       32,
	"i2.xlarge":        4,
	"i3.16xlarge":      64,
	"i3.2xlarge":       8,
	"i3.4xlarge":       16,
	"i3.8xlarge":       32,
	"i3.large":         2,
	"i3.metal":         72,
	"i3.xlarge":        4,
	"i3en.12xlarge":    48,
	"i3en.24xlarge":    96,
	"i3en.2xlarge":     8,
	"i3en.3xlarge":     12,
	"i3en.6xlarge":     24,
	"i3en.large":       2,
	"i3en.metal":       96,
	"i3en.xlarge":      4,
	"im4gn.16xlarge":   64,
	"im4gn.2xlarge":    8,
	"im4gn.4xlarge":    16,
	"im4gn.8xlarge":    32,
	"im4gn.large":      2,
	"im4gn.xlarge":     4,
	"inf1.24xlarge":    96,
	"inf1.2xlarge":     8,
	"inf1.6xlarge":     24,
	"inf1.xlarge":      4,
	"is4gen.2xlarge":   8,
	"is4gen.4xlarge":   16,
	"is4gen.8xlarge":   32,
	"is4gen.large":     2,
	"is4gen.medium":    1,
	"is4gen.xlarge":    4,
	"m4.10xlarge":      40,
	"m4.16xlarge":      64,
	"m4.2xlarge":       8,
	"m4.4xlarge":       16,
	"m4.large":         2,
	"m4.xlarge":        4,
	"m5.12xlarge":      48,
	"m5.16xlarge":      64,
	"m5.24xlarge":      96,
	"m5.2xlarge":       8,
	"m5.4xlarge":       16,
	"m5.8xlarge":       32,
	"m5.large":         2,
	"m5.metal":         96,
	"m5.xlarge":        4,
	"m5a.12xlarge":     48,
	"m5a.16xlarge":     64,
	"m5a.24xlarge":     96,
	"m5a.2xlarge":      8,
	"m5a.4xlarge":      16,
	"m5a.8xlarge":      32,
	"m5a.large":        2,
	"m5a.xlarge":       4,
	"m5ad.12xlarge":    48,
	"m5ad.16xlarge":    64,
	"m5ad.24xlarge":    96,
	"m5ad.2xlarge":     8,
	"m5ad.4xlarge":     16,
	"m5ad.8xlarge":     32,
	"m5ad.large":       2,
	"m5ad.xlarge":      4,
	"m5d.12xlarge":     48,
	"m5d.16xlarge":     64,
	"m5d.24xlarge":     96,
	"m5d.2xlarge":      8,
	"m5d.4xlarge":      16,
	"m5d.8xlarge":      32,
	"m5d.large":        2,
	"m5d.metal":        96,
	"m5d.xlarge":       4,
	"m5dn.12xlarge":    48,
	"m5dn.16xlarge":    64,
	"m5dn.24xlarge":    96,
	"m5dn.2xlarge":     8,
	"m5dn.4xlarge":     16,
	"m5dn.8xlarge":     32,
	"m5dn.large":       2,
	"m5dn.metal":       96,
	"m5dn.xlarge":      4,
	"m5n.12xlarge":     48,
	"m5n.16xlarge":     64,
	"m5n.24xlarge":     96,
	"m5n.2xlarge":      8,
	"m5n.4xlarge":      16,
	"m5n.8xlarge":      32,
	"m5n.large":        2,
	"m5n.metal":        96,
	"m5n.xlarge":       4,
	"m5zn.12xlarge":    48,
	"m5zn.2xlarge":     8,
	"m5zn.3xlarge":     12,
	"m5zn.6xlarge":     24,
	"m5zn.large":       2,
	"m5zn.metal":       48,
	"m5zn.xlarge":      4,
	"m6g.12xlarge":     48,
	"m6g.16xlarge":     64,
	"m6g.2xlarge":      8,
	"m6g.4xlarge":      16,
	"m6g.8xlarge":      32,
	"m6g.large":        2,
	"m6g.medium":       1,
	"m6g.metal":        64,
	"m6g.xlarge":       4,
	"m6gd.12xlarge":    48,
	"m6gd.16xlarge":    64,
	"m6gd.2xlarge":     8,
	"m6gd.4xlarge":     16,
	"m6gd.8xlarge":     32,
	"m6gd.large":       2,
	"m6gd.medium":      1,
	"m6gd.metal":       64,
	"m6gd.xlarge":      4,
	"m6i.12xlarge":     48,
	"m6i.16xlarge":     64,
	"m6i.24xlarge":     96,
	"m6i.2xlarge":      8,
	"m6i.32xlarge":     128,
	"m6i.4xlarge":      16,
	"m6i.8xlarge":      32,
	"m6i.large":        2,
	"m6i.metal":        128,
	"m6i.xlarge":       4,
	"mac1.metal":       12,
	"p2.16xlarge":      64,
	"p2.8xlarge":       32,
	"p2.xlarge":        4,
	"p3.16xlarge":      64,
	"p3.2xlarge":       8,
	"p3.8xlarge":       32,
	"p4d.24xlarge":     96,
	"r3.2xlarge":       8,
	"r3.4xlarge":       16,
	"r3.8xlarge":       32,
	"r3.large":         2,
	"r3.xlarge":        4,
	"r4.16xlarge":      64,
	"r4.2xlarge":       8,
	"r4.4xlarge":       16,
	"r4.8xlarge":       32,
	"r4.large":         2,
	"r4.xlarge":        4,
	"r5.12xlarge":      48,
	"r5.16xlarge":      64,
	"r5.24xlarge":      96,
	"r5.2xlarge":       8,
	"r5.4xlarge":       16,
	"r5.8xlarge":       32,
	"r5.large":         2,
	"r5.metal":         96,
	"r5.xlarge":        4,
	"r5a.12xlarge":     48,
	"r5a.16xlarge":     64,
	"r5a.24xlarge":     96,
	"r5a.2xlarge":      8,
	"r5a.4xlarge":      16,
	"r5a.8xlarge":      32,
	"r5a.large":        2,
	"r5a.xlarge":       4,
	"r5ad.12xlarge":    48,
	"r5ad.16xlarge":    64,
	"r5ad.24xlarge":    96,
	"r5ad.2xlarge":     8,
	"r5ad.4xlarge":     16,
	"r5ad.8xlarge":     32,
	"r5ad.large":       2,
	"r5ad.xlarge":      4,
	"r5b.12xlarge":     48,
	"r5b.16xlarge":     64,
	"r5b.24xlarge":     96,
	"r5b.2xlarge":      8,
	"r5b.4xlarge":      16,
	"r5b.8xlarge":      32,
	"r5b.large":        2,
	"r5b.metal":        96,
	"r5b.xlarge":       4,
	"r5d.12xlarge":     48,
	"r5d.16xlarge":     64,
	"r5d.24xlarge":     96,
	"r5d.2xlarge":      8,
	"r5d.4xlarge":      16,
	"r5d.8xlarge":      32,
	"r5d.large":        2,
	"r5d.metal":        96,
	"r5d.xlarge":       4,
	"r5dn.12xlarge":    48,
	"r5dn.16xlarge":    64,
	"r5dn.24xlarge":    96,
	"r5dn.2xlarge":     8,
	"r5dn.4xlarge":     16,
	"r5dn.8xlarge":     32,
	"r5dn.large":       2,
	"r5dn.metal":       96,
	"r5dn.xlarge":      4,
	"r5n.12xlarge":     48,
	"r5n.16xlarge":     64,
	"r5n.24xlarge":     96,
	"r5n.2xlarge":      8,
	"r5n.4xlarge":      16,
	"r5n.8xlarge":      32,
	"r5n.large":        2,
	"r5n.metal":        96,
	"r5n.xlarge":       4,
	"r6g.12xlarge":     48,
	"r6g.16xlarge":     64,
	"r6g.2xlarge":      8,
	"r6g.4xlarge":      16,
	"r6g.8xlarge":      32,
	"r6g.large":        2,
	"r6g.medium":       1,
	"r6g.metal":        64,
	"r6g.xlarge":       4,
	"r6gd.12xlarge":    48,
	"r6gd.16xlarge":    64,
	"r6gd.2xlarge":     8,
	"r6gd.4xlarge":     16,
	"r6gd.8xlarge":     32,
	"r6gd.large":       2,
	"r6gd.medium":      1,
	"r6gd.metal":       64,
	"r6gd.xlarge":      4,
	"r6i.12xlarge":     48,
	"r6i.16xlarge":     64,
	"r6i.24xlarge":     96,
	"r6i.2xlarge":      8,
	"r6i.32xlarge":     128,
	"r6i.4xlarge":      16,
	"r6i.8xlarge":      32,
	"r6i.large":        2,
	"r6i.metal":        128,
	"r6i.xlarge":       4,
	"t2.2xlarge":       8,
	"t2.large":         2,
	"t2.medium":        2,
	"t2.micro":         1,
	"t2.nano":          1,
	"t2.small":         1,
	"t2.xlarge":        4,
	"t3.2xlarge":       8,
	"t3.large":         2,
	"t3.medium":        2,
	"t3.micro":         2,
	"t3.nano":          2,
	"t3.small":         2,
	"t3.xlarge":        4,
	"t3a.2xlarge":      8,
	"t3a.large":        2,
	"t3a.medium":       2,
	"t3a.micro":        2,
	"t3a.nano":         2,
	"t3a.small":        2,
	"t3a.xlarge":       4,
	"t4g.2xlarge":      8,
	"t4g.large":        2,
	"t4g.medium":       2,
	"t4g.micro":        2,
	"t4g.nano":         2,
	"t4g.small":        2,
	"t4g.xlarge":       4,
	"u-6tb1.112xlarge": 448,
	"u-6tb1.56xlarge":  224,
	"x1.16xlarge":      64,
	"x1.32xlarge":      128,
	"x1e.16xlarge":     64,
	"x1e.2xlarge":      8,
	"x1e.32xlarge":     128,
	"x1e.4xlarge":      16,
	"x1e.8xlarge":      32,
	"x1e.xlarge":       4,
	"x2gd.12xlarge":    48,
	"x2gd.16xlarge":    64,
	"x2gd.2xlarge":     8,
	"x2gd.4xlarge":     16,
	"x2gd.8xlarge":     32,
	"x2gd.large":       2,
	"x2gd.medium":      1,
	"x2gd.metal":       64,
	"x2gd.xlarge":      4,
	"z1d.12xlarge":     48,
	"z1d.2xlarge":      8,
	"z1d.3xlarge":      12,
	"z1d.6xlarge":      24,
	"z1d.large":        2,
	"z1d.metal":        48,
	"z1d.xlarge":       4,
}

var reservedTermsMapping = map[string]string{
	"1_year": "1yr",
	"3_year": "3yr",
}

var reservedPaymentOptionMapping = map[string]string{
	"no_upfront":      "No Upfront",
	"partial_upfront": "Partial Upfront",
	"all_upfront":     "All Upfront",
}

// There's differences within the pricing API, the Values have no space.
var reservedHostPaymentOptionMapping = map[string]string{
	"no_upfront":      "NoUpfront",
	"partial_upfront": "PartialUpfront",
	"all_upfront":     "AllUpfront",
}

var elasticacheReservedNodeCacheLegacyOfferings = map[string]string{
	"heavy_utilization":  "Heavy Utilization",
	"medium_utilization": "Medium Utilization",
	"light_utilization":  "Light Utilization",
}

var elasticacheReservedNodeLegacyTypes = []string{"t2", "m3", "m4", "r3", "r4"}

type rdsReservationResolver struct {
	term          string
	paymentOption string
}

// PriceFilter implementation for rdsReservationResolver
// Allowed values for ReservedInstanceTerm: ["1_year", "3_year"]
// Allowed values for ReservedInstancePaymentOption: ["all_upfront", "partial_upfront", "no_upfront"]
// Corner case: When ReservedInstanceTerm is 3_year the only allowed ReservedInstancePaymentOption are ["all_upfront", "partial_upfront"]
func (r rdsReservationResolver) PriceFilter() (*schema.PriceFilter, error) {
	purchaseOptionLabel := "reserved"
	def := &schema.PriceFilter{
		PurchaseOption: strPtr(purchaseOptionLabel),
	}
	termLength := reservedTermsMapping[r.term]
	purchaseOption := reservedPaymentOptionMapping[r.paymentOption]
	validTerms := sliceOfKeysFromMap(reservedTermsMapping)
	if !stringInSlice(validTerms, r.term) {
		return def, fmt.Errorf("Invalid reserved_instance_term, ignoring reserved options. Expected: %s. Got: %s", strings.Join(validTerms, ", "), r.term)
	}
	validOptions := sliceOfKeysFromMap(reservedPaymentOptionMapping)
	if r.term == "3_year" {
		validOptions = []string{"partial_upfront", "all_upfront"}
	}
	if !stringInSlice(validOptions, r.paymentOption) {
		return def, fmt.Errorf("Invalid reserved_instance_payment_option, ignoring reserved options. Expected: %s. Got: %s", strings.Join(validOptions, ", "), r.paymentOption)
	}
	return &schema.PriceFilter{
		PurchaseOption:     strPtr(purchaseOptionLabel),
		StartUsageAmount:   strPtr("0"),
		TermLength:         strPtr(termLength),
		TermPurchaseOption: strPtr(purchaseOption),
	}, nil
}

func isAWSChina(region string) bool {
	return strings.HasPrefix(region, "cn-")
}

################################################################################
# FILE: internal/resources/aws/vpc_endpoint.go
# RESOURCE: aws_vpc_endpoint
# SIZE: 4910 bytes | LINES: 130
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/usage"
)

type VPCEndpoint struct {
	Address                string
	Region                 string
	Type                   string
	Interfaces             *int64
	MonthlyDataProcessedGb *float64 `infracost_usage:"monthly_data_processed_gb"`
}

func (r *VPCEndpoint) CoreType() string {
	return "VPCEndpoint"
}

func (r *VPCEndpoint) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_data_processed_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *VPCEndpoint) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *VPCEndpoint) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	vpcEndpointType := r.Type
	if vpcEndpointType == "" {
		vpcEndpointType = "Gateway"
	}

	vpcEndpointInterfaceCount := int64(1)
	if r.Interfaces != nil {
		vpcEndpointInterfaceCount = *r.Interfaces
	}

	if strings.ToLower(vpcEndpointType) == "gateway" {
		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	var dataProcessedGB *decimal.Decimal
	if r.MonthlyDataProcessedGb != nil {
		dataProcessedGB = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataProcessedGb))
	}

	var endpointHours, endpointBytes string

	if strings.ToLower(vpcEndpointType) == "interface" {
		endpointHours = "VpcEndpoint-Hours"
		endpointBytes = "VpcEndpoint-Bytes"
		if dataProcessedGB != nil {
			gbLimits := []int{1000000, 4000000}
			tiers := usage.CalculateTierBuckets(*dataProcessedGB, gbLimits)

			if tiers[0].GreaterThan(decimal.NewFromInt(0)) {
				costComponents = append(costComponents, r.dataProcessedCostComponent(endpointBytes, "Data processed (first 1PB)", "0", &tiers[0]))
			}
			if tiers[1].GreaterThan(decimal.NewFromInt(0)) {
				costComponents = append(costComponents, r.dataProcessedCostComponent(endpointBytes, "Data processed (next 4PB)", "1048576", &tiers[1]))
			}
			if tiers[2].GreaterThan(decimal.NewFromInt(0)) {
				costComponents = append(costComponents, r.dataProcessedCostComponent(endpointBytes, "Data processed (over 5PB)", "5242880", &tiers[2]))
			}
		} else {
			costComponents = append(costComponents, r.dataProcessedCostComponent(endpointBytes, "Data processed (first 1PB)", "0", dataProcessedGB))
		}
	} else if strings.ToLower(vpcEndpointType) == "gatewayloadbalancer" {
		endpointHours = "VpcEndpoint-GWLBE-Hours"
		endpointBytes = "VpcEndpoint-GWLBE-Bytes"
		costComponents = append(costComponents, &schema.CostComponent{
			Name:            "Data processed",
			Unit:            "GB",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: dataProcessedGB,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(r.Region),
				Service:       strPtr("AmazonVPC"),
				ProductFamily: strPtr("VpcEndpoint"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", endpointBytes))},
				},
			},
			UsageBased: true,
		})
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:           fmt.Sprintf("Endpoint (%s)", vpcEndpointType),
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(int64(vpcEndpointInterfaceCount))),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonVPC"),
			ProductFamily: strPtr("VpcEndpoint"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", endpointHours))},
			},
		},
	})

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *VPCEndpoint) dataProcessedCostComponent(endpointBytes string, displayName string, usageTier string, dataProcessedGB *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            displayName,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: dataProcessedGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("AmazonVPC"),
			ProductFamily: strPtr("VpcEndpoint"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr(fmt.Sprintf("/%s/i", endpointBytes))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(usageTier),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/vpn_connection.go
# RESOURCE: aws_vpn_connection
# SIZE: 1968 bytes | LINES: 54
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type VPNConnection struct {
	Address                string
	Region                 string
	TransitGatewayID       string
	MonthlyDataProcessedGB *float64 `infracost_usage:"monthly_data_processed_gb"`
}

func (r *VPNConnection) CoreType() string {
	return "VPNConnection"
}

func (r *VPNConnection) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_data_processed_gb", ValueType: schema.Float64, DefaultValue: 0}}
}

func (r *VPNConnection) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *VPNConnection) BuildResource() *schema.Resource {
	region := r.Region

	var gbDataProcessed *decimal.Decimal

	costComponents := []*schema.CostComponent{
		{
			Name:           "VPN connection",
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("aws"),
				Region:        strPtr(region),
				Service:       strPtr("AmazonVPC"),
				ProductFamily: strPtr("Cloud Connectivity"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "vpnType", ValueRegex: regexPtr("^VPN Standard")},
				},
			},
		},
	}

	if r.TransitGatewayID != "" {
		costComponents = append(costComponents, transitGatewayAttachmentCostComponent(region, "TransitGatewayVPN"))

		if r.MonthlyDataProcessedGB != nil {
			gbDataProcessed = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataProcessedGB))
		}

		costComponents = append(costComponents, transitGatewayDataProcessingCostComponent(region, "TransitGatewayVPN", gbDataProcessed))
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/aws/waf_web_acl.go
# RESOURCE: aws_waf_web_acl
# SIZE: 4485 bytes | LINES: 127
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type WAFWebACL struct {
	Address         string
	Region          string
	Rules           int64
	RuleGroups      int64
	RuleGroupRules  *int64 `infracost_usage:"rule_group_rules"`
	MonthlyRequests *int64 `infracost_usage:"monthly_requests"`
}

func (r *WAFWebACL) CoreType() string {
	return "WAFWebACL"
}

func (r *WAFWebACL) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "rule_group_rules", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_requests", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *WAFWebACL) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *WAFWebACL) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{r.webACLUsageCostComponent()}

	rules := r.Rules
	if r.RuleGroupRules != nil {
		rules += *r.RuleGroupRules
	}

	costComponents = append(costComponents, r.rulesCostComponent(rules))
	costComponents = append(costComponents, r.ruleGroupsCostComponent(r.RuleGroups))
	costComponents = append(costComponents, r.requestsCostComponent())

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *WAFWebACL) webACLUsageCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Web ACL usage",
		Unit:            "months",
		UnitMultiplier:  decimal.NewFromInt(int64(1)),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("awswaf"),
			ProductFamily: strPtr("Web Application Firewall"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/^[A-Z0-9]*-(?!ShieldProtected-)WebACL$/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
	}
}

func (r *WAFWebACL) rulesCostComponent(rules int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Rules",
		Unit:            "rules",
		UnitMultiplier:  decimal.NewFromInt(int64(1)),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(rules)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("awswaf"),
			ProductFamily: strPtr("Web Application Firewall"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/^[A-Z0-9]*-(?!ShieldProtected-)Rule$/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
	}
}

func (r *WAFWebACL) ruleGroupsCostComponent(ruleGroups int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Rule groups",
		Unit:            "groups",
		UnitMultiplier:  decimal.NewFromInt(int64(1)),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(ruleGroups)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("awswaf"),
			ProductFamily: strPtr("Web Application Firewall"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/^[A-Z0-9]*-(?!ShieldProtected-)Rule$/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *WAFWebACL) requestsCostComponent() *schema.CostComponent {
	var requests *decimal.Decimal
	if r.MonthlyRequests != nil {
		requests = decimalPtr(decimal.NewFromInt(*r.MonthlyRequests))
	}

	return &schema.CostComponent{
		Name:            "Requests",
		Unit:            "1M requests",
		UnitMultiplier:  decimal.NewFromInt(int64(1000000)),
		MonthlyQuantity: requests,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("awswaf"),
			ProductFamily: strPtr("Web Application Firewall"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/^[A-Z0-9]*-(?!ShieldProtected-)Request$/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/aws/wafv2_web_acl.go
# RESOURCE: aws_wafv2_web_acl
# SIZE: 5038 bytes | LINES: 140
################################################################################
package aws

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type WAFv2WebACL struct {
	Address               string
	Region                string
	Rules                 int64
	RuleGroups            int64
	ManagedRuleGroups     int64
	RuleGroupRules        *int64 `infracost_usage:"rule_group_rules"`
	ManagedRuleGroupRules *int64 `infracost_usage:"managed_rule_group_rules"`
	MonthlyRequests       *int64 `infracost_usage:"monthly_requests"`
}

func (r *WAFv2WebACL) CoreType() string {
	return "WAFv2WebACL"
}

func (r *WAFv2WebACL) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "managed_rule_group_rules", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "rule_group_rules", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *WAFv2WebACL) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *WAFv2WebACL) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{r.webACLUsageCostComponent()}

	rules := r.Rules
	if r.RuleGroupRules != nil {
		rules += *r.RuleGroupRules
	}
	if r.ManagedRuleGroupRules != nil {
		rules += *r.ManagedRuleGroupRules
	}

	if rules > 0 {
		costComponents = append(costComponents, r.rulesCostComponent(rules))
	}

	if r.RuleGroups > 0 {
		costComponents = append(costComponents, r.ruleGroupsCostComponent("Rule groups", r.RuleGroups))
	}

	if r.ManagedRuleGroups > 0 {
		costComponents = append(costComponents, r.ruleGroupsCostComponent("Managed rule groups", r.RuleGroups))
	}

	costComponents = append(costComponents, r.requestsCostComponent())

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *WAFv2WebACL) webACLUsageCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Web ACL usage",
		Unit:            "months",
		UnitMultiplier:  decimal.NewFromInt(int64(1)),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("awswaf"),
			ProductFamily: strPtr("Web Application Firewall"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/^[A-Z0-9]*-(?!ShieldProtected-)WebACLV2$/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
	}
}

func (r *WAFv2WebACL) rulesCostComponent(rules int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Rules",
		Unit:            "rules",
		UnitMultiplier:  decimal.NewFromInt(int64(1)),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(rules)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("awswaf"),
			ProductFamily: strPtr("Web Application Firewall"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/^[A-Z0-9]*-(?!ShieldProtected-)RuleV2$/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
	}
}

func (r *WAFv2WebACL) ruleGroupsCostComponent(name string, ruleGroups int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "groups",
		UnitMultiplier:  decimal.NewFromInt(int64(1)),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(ruleGroups)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("awswaf"),
			ProductFamily: strPtr("Web Application Firewall"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/^[A-Z0-9]*-(?!ShieldProtected-)RuleV2$/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

func (r *WAFv2WebACL) requestsCostComponent() *schema.CostComponent {
	var requests *decimal.Decimal
	if r.MonthlyRequests != nil {
		requests = decimalPtr(decimal.NewFromInt(*r.MonthlyRequests))
	}

	return &schema.CostComponent{
		Name:            "Requests",
		Unit:            "1M requests",
		UnitMultiplier:  decimal.NewFromInt(int64(1000000)),
		MonthlyQuantity: requests,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("aws"),
			Region:        strPtr(r.Region),
			Service:       strPtr("awswaf"),
			ProductFamily: strPtr("Web Application Firewall"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "usagetype", ValueRegex: strPtr("/^[A-Z0-9]*-(?!ShieldProtected-)RequestV2-Tier1$/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("on_demand"),
		},
		UsageBased: true,
	}
}

################################################################################
#                                                                              #
#                              AZURE RESOURCES                                  #
#                                                                              #
################################################################################

################################################################################
# FILE: internal/resources/azure/active_directory_domain_service.go
# RESOURCE: azure_active_directory_domain_service
# SIZE: 1912 bytes | LINES: 57
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type ActiveDirectoryDomainService struct {
	Address string
	Region  string
	SKU     string
}

func (r *ActiveDirectoryDomainService) CoreType() string {
	return "ActiveDirectoryDomainService"
}

func (r *ActiveDirectoryDomainService) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *ActiveDirectoryDomainService) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ActiveDirectoryDomainService) BuildResource() *schema.Resource {
	costComponents := activeDirectoryDomainServiceCostComponents("Active directory domain service", r.Region, r.SKU)

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func activeDirectoryDomainServiceCostComponents(name, region, sku string) []*schema.CostComponent {
	productType := "Standard"

	if sku != "" {
		productType = sku
	}

	costComponents := []*schema.CostComponent{
		{
			Name:           fmt.Sprintf("%s (%s)", name, productType),
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(region),
				Service:       strPtr("Microsoft Entra Domain Services"),
				ProductFamily: strPtr("Security"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "skuName", Value: strPtr(productType)},
					{Key: "meterName", Value: strPtr(fmt.Sprintf("%s User Forest", productType))},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
		},
	}
	return costComponents
}

################################################################################
# FILE: internal/resources/azure/active_directory_domain_service_replica_set.go
# RESOURCE: azure_active_directory_domain_service_replica_set
# SIZE: 1044 bytes | LINES: 28
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type ActiveDirectoryDomainServiceReplicaSet struct {
	Address            string
	Region             string
	DomainServiceIDSKU string
}

func (r *ActiveDirectoryDomainServiceReplicaSet) CoreType() string {
	return "ActiveDirectoryDomainServiceReplicaSet"
}

func (r *ActiveDirectoryDomainServiceReplicaSet) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *ActiveDirectoryDomainServiceReplicaSet) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ActiveDirectoryDomainServiceReplicaSet) BuildResource() *schema.Resource {
	region := r.Region

	costComponents := activeDirectoryDomainServiceCostComponents("Active directory domain service replica set", region, r.DomainServiceIDSKU)

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/api_management.go
# RESOURCE: azure_api_management
# SIZE: 4020 bytes | LINES: 115
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type APIManagement struct {
	Address                string
	Region                 string
	SKUName                string
	SelfHostedGatewayCount *int64 `infracost_usage:"self_hosted_gateway_count"`
	MonthlyAPICalls        *int64 `infracost_usage:"monthly_api_calls"`
}

func (r *APIManagement) CoreType() string {
	return "APIManagement"
}

func (r *APIManagement) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "self_hosted_gateway_count", ValueType: schema.Int64, DefaultValue: 0}, {Key: "monthly_api_calls", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *APIManagement) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *APIManagement) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}
	skuName := r.SKUName
	var tier string
	var capacity decimal.Decimal
	if s := strings.Split(skuName, "_"); len(s) == 2 {
		tier = strings.ToLower(s[0])
		capacity, _ = decimal.NewFromString(s[1])
	}

	if tier != "consumption" {
		costComponents = append(costComponents, r.apiManagementCostComponent(
			fmt.Sprintf("API management (%s)", tier),
			"units",
			tier,
			&capacity,
			false))

	} else {
		var apiCalls *decimal.Decimal
		if r.MonthlyAPICalls != nil {
			apiCalls = decimalPtr(decimal.NewFromInt(*r.MonthlyAPICalls))
		}

		if apiCalls != nil {
			apiCalls = decimalPtr(apiCalls.Div(decimal.NewFromInt(10000)))
			costComponents = append(costComponents, r.consumptionAPICostComponent(tier, apiCalls))
		} else {
			costComponents = append(costComponents, r.consumptionAPICostComponent(tier, apiCalls))
		}
	}

	if tier == "premium" {
		var selfHostedGateways *decimal.Decimal
		if r.SelfHostedGatewayCount != nil {
			selfHostedGateways = decimalPtr(decimal.NewFromInt(*r.SelfHostedGatewayCount))
		}
		costComponents = append(costComponents, r.apiManagementCostComponent(
			"Self hosted gateway",
			"gateways",
			"Gateway",
			selfHostedGateways,
			true,
		))
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *APIManagement) apiManagementCostComponent(name, unit, tier string, quantity *decimal.Decimal, usageBased bool) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           name,
		Unit:           unit,
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("API Management"),
			ProductFamily: strPtr("Developer Tools"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", tier))},
				{Key: "meterName", ValueRegex: strPtr(fmt.Sprintf("/^%s unit$/i", tier))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: usageBased,
	}
}

func (r *APIManagement) consumptionAPICostComponent(tier string, quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "API management (consumption)",
		Unit:            "1M calls",
		UnitMultiplier:  decimal.NewFromInt(100),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("API Management"),
			ProductFamily: strPtr("Developer Tools"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", tier))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("100"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/app_configuration.go
# RESOURCE: azure_app_configuration
# SIZE: 4721 bytes | LINES: 122
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// AppConfiguration struct represents an Azure App Configuration. App
// Configuration is a managed service that helps developers centralize their
// application configurations. It provides a service to store, manage, and access
// application configuration settings.
//
// Resource information: https://azure.microsoft.com/en-us/products/app-configuration/
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/app-configuration/
type AppConfiguration struct {
	Address  string
	Region   string
	SKU      string
	Replicas int64

	MonthlyAdditionalRequests *int64 `infracost_usage:"monthly_additional_requests"`
}

// CoreType returns the name of this resource type
func (r *AppConfiguration) CoreType() string {
	return "AppConfiguration"
}

// UsageSchema defines a list which represents the usage schema of AppConfiguration.
func (r *AppConfiguration) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_additional_requests", ValueType: schema.Int64, DefaultValue: 0},
	}
}

// PopulateUsage parses the u schema.UsageData into the AppConfiguration.
// It uses the `infracost_usage` struct tags to populate data into the AppConfiguration.
func (r *AppConfiguration) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid AppConfiguration struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
//
// BuildResource only returns cost components if the sku is not "free".
// "Standard" App Configuration instances are charged per instance and replica
// and per 10k requests over a daily 200k limit. However, we cannot compute the
// request count from the IaC code, so we rely on the user to provide the request
// count as a usage parameter. This usage parameter defines all total request
// made to the App Configuration instance and it's replicas in a month.
func (r *AppConfiguration) BuildResource() *schema.Resource {
	if strings.ToLower(r.SKU) == "free" {
		return &schema.Resource{
			Name:      r.Address,
			NoPrice:   true,
			IsSkipped: true,
		}
	}

	titledSku := cases.Title(language.English).String(r.SKU)
	components := []*schema.CostComponent{
		r.instanceCostComponent(titledSku),
		r.requestCostComponent(titledSku),
	}
	costComponents := components

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *AppConfiguration) requestCostComponent(titledSku string) *schema.CostComponent {
	var requestQuantity *decimal.Decimal
	if r.MonthlyAdditionalRequests != nil {
		requestQuantity = decimalPtr(decimal.NewFromInt(*r.MonthlyAdditionalRequests).Div(decimal.NewFromInt(10000)))
	}

	requestComponent := &schema.CostComponent{
		Name:            "Requests (over 200k/day per replica)",
		Unit:            "10k requests",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: requestQuantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("App Configuration"),
			ProductFamily: strPtr("Developer Tools"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr(titledSku + " Overage Operations")},
			},
		},
		UsageBased: true,
	}
	return requestComponent
}

func (r *AppConfiguration) instanceCostComponent(sku string) *schema.CostComponent {
	instanceCount := decimal.NewFromInt(1)
	if r.Replicas > 0 {

		instanceCount = instanceCount.Add(decimal.NewFromInt(r.Replicas))
	}
	name := "Instance"
	if r.Replicas > 0 {
		desc := "replica"
		if r.Replicas > 1 {
			desc = "replicas"
		}

		name = fmt.Sprintf("Instance (%d %s)", r.Replicas, desc)
	}

	return &schema.CostComponent{
		Name:            name,
		Unit:            "days",
		UnitMultiplier:  instanceCount,
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(30).Mul(instanceCount)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("App Configuration"),
			ProductFamily: strPtr("Developer Tools"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(sku)},
				{Key: "meterName", Value: strPtr(sku + " Instance")},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/azure/app_service_certificate_binding.go
# RESOURCE: azure_app_service_certificate_binding
# SIZE: 1864 bytes | LINES: 63
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type AppServiceCertificateBinding struct {
	Address  string
	Region   string
	SSLState string
}

func (r *AppServiceCertificateBinding) CoreType() string {
	return "AppServiceCertificateBinding"
}

func (r *AppServiceCertificateBinding) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *AppServiceCertificateBinding) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *AppServiceCertificateBinding) BuildResource() *schema.Resource {
	region := r.Region

	var sslType string

	sslState := strings.ToUpper(r.SSLState)

	if strings.HasPrefix(sslState, "IP") {
		sslType = "IP"
	} else {

		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	var instanceCount int64 = 1

	costComponents := []*schema.CostComponent{
		{
			Name:            "IP SSL certificate",
			Unit:            "months",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: decimalPtr(decimal.NewFromInt(instanceCount)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(region),
				Service:       strPtr("Azure App Service"),
				ProductFamily: strPtr("Compute"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "skuName", Value: strPtr(fmt.Sprintf("%s SSL", sslType))},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
		},
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/app_service_certificate_order.go
# RESOURCE: azure_app_service_certificate_order
# SIZE: 1791 bytes | LINES: 57
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type AppServiceCertificateOrder struct {
	Address     string
	ProductType string
}

func (r *AppServiceCertificateOrder) CoreType() string {
	return "AppServiceCertificateOrder"
}

func (r *AppServiceCertificateOrder) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *AppServiceCertificateOrder) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *AppServiceCertificateOrder) BuildResource() *schema.Resource {
	region := "Global"

	if strings.HasPrefix(region, "usgov") {
		region = "US Gov"
	}

	productType := "Standard"
	if r.ProductType != "" {
		productType = r.ProductType
	}
	productType = strings.ToLower(productType)

	costComponents := []*schema.CostComponent{
		{
			Name:           fmt.Sprintf("SSL certificate (%s)", productType),
			Unit:           "years",
			UnitMultiplier: decimal.NewFromInt(1),

			MonthlyQuantity: decimalPtr(decimal.NewFromInt(1).Div(decimal.NewFromInt(12))),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(region),
				Service:       strPtr("Azure App Service"),
				ProductFamily: strPtr("Compute"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "skuName", ValueRegex: strPtr(fmt.Sprintf("/%s SSL - 1 Year/i", productType))},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
		},
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/app_service_custom_hostname_binding.go
# RESOURCE: azure_app_service_custom_hostname_binding
# SIZE: 1868 bytes | LINES: 62
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type AppServiceCustomHostnameBinding struct {
	Address  string
	Region   string
	SSLState string
}

func (r *AppServiceCustomHostnameBinding) CoreType() string {
	return "AppServiceCustomHostnameBinding"
}

func (r *AppServiceCustomHostnameBinding) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *AppServiceCustomHostnameBinding) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *AppServiceCustomHostnameBinding) BuildResource() *schema.Resource {
	var sslType, sslState string

	sslState = strings.ToUpper(r.SSLState)

	if strings.HasPrefix(sslState, "IP") {
		sslType = "IP"
	} else {
		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	var instanceCount int64 = 1

	costComponents := []*schema.CostComponent{
		{
			Name:            "IP SSL certificate",
			Unit:            "months",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: decimalPtr(decimal.NewFromInt(instanceCount)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Azure App Service"),
				ProductFamily: strPtr("Compute"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "skuName", Value: strPtr(fmt.Sprintf("%s SSL", sslType))},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
		},
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/app_service_environment.go
# RESOURCE: azure_app_service_environment
# SIZE: 3193 bytes | LINES: 90
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type AppServiceEnvironment struct {
	Address         string
	Region          string
	PricingTier     string
	OperatingSystem *string `infracost_usage:"operating_system"`
}

func (r *AppServiceEnvironment) CoreType() string {
	return "AppServiceEnvironment"
}

func (r *AppServiceEnvironment) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "operating_system", ValueType: schema.String, DefaultValue: "linux"}}
}

func (r *AppServiceEnvironment) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *AppServiceEnvironment) BuildResource() *schema.Resource {
	tier := "I1"
	if r.PricingTier != "" {
		tier = r.PricingTier
	}

	stampFeeTiers := []string{"I1", "I2", "I3"}
	productName := "Isolated Plan"
	costComponents := make([]*schema.CostComponent, 0)
	os := "linux"
	if r.OperatingSystem != nil {
		os = strings.ToLower(*r.OperatingSystem)
	}
	if os == "linux" {
		productName += " - Linux"
	}
	if contains(stampFeeTiers, tier) == bool(true) {
		costComponents = append(costComponents, r.appIsolatedServicePlanCostComponentStampFee(productName))
	}
	costComponents = append(costComponents, r.appIsolatedServicePlanCostComponent(fmt.Sprintf("Instance usage (%s)", tier), productName, tier))

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}
func (r *AppServiceEnvironment) appIsolatedServicePlanCostComponentStampFee(productName string) *schema.CostComponent {
	return &schema.CostComponent{

		Name:           "Stamp fee",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure App Service"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Azure App Service " + productName)},
				{Key: "skuName", Value: strPtr("Stamp")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}
func (r *AppServiceEnvironment) appIsolatedServicePlanCostComponent(name, productName, tier string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           name,
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure App Service"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Azure App Service " + productName)},
				{Key: "skuName", Value: strPtr(tier)},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

################################################################################
# FILE: internal/resources/azure/app_service_plan.go
# RESOURCE: azure_app_service_plan
# SIZE: 4277 bytes | LINES: 136
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type AppServicePlan struct {
	Address     string
	SKUSize     string
	SKUCapacity int64
	Kind        string
	Region      string
	IsDevTest   bool
}

func (r *AppServicePlan) CoreType() string {
	return "AppServicePlan"
}

func (r *AppServicePlan) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *AppServicePlan) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *AppServicePlan) BuildResource() *schema.Resource {
	sku := ""
	os := "windows"
	var capacity int64 = 1
	if r.SKUCapacity > 0 {
		capacity = r.SKUCapacity
	}
	productName := "Standard Plan"

	if len(r.SKUSize) < 2 || strings.ToLower(r.SKUSize[:2]) == "ep" || strings.ToLower(r.SKUSize[:2]) == "y1" || strings.ToLower(r.SKUSize[:2]) == "ws" {
		return &schema.Resource{
			Name:        r.Address,
			IsSkipped:   true,
			NoPrice:     true,
			UsageSchema: r.UsageSchema(),
		}
	}

	var additionalAttributeFilters []*schema.AttributeFilter

	switch strings.ToLower(r.SKUSize[:1]) {
	case "s":
		sku = "S" + r.SKUSize[1:]
	case "b":
		sku = "B" + r.SKUSize[1:]
		productName = "Basic Plan"
	case "p", "i":
		sku, productName, additionalAttributeFilters = getVersionedAppServicePlanSKU(r.SKUSize, os)
	}

	switch strings.ToLower(r.SKUSize[:2]) {
	case "pc":
		sku = "PC" + r.SKUSize[2:]
		productName = "Premium Windows Container Plan"
	case "y1":
		sku = "Shared"
		productName = "Shared Plan"
	}

	if r.Kind != "" {
		os = strings.ToLower(r.Kind)
	}
	if os == "app" {
		os = "windows"
	}
	if os != "windows" && productName != "Premium Plan" && productName != "Isolated Plan" {
		productName += " - Linux"
	}

	purchaseOption := "Consumption"
	name := fmt.Sprintf("Instance usage (%s)", r.SKUSize)
	if r.IsDevTest && strings.Contains(os, "windows") && strings.ToLower(r.SKUSize[:2]) != "pc" {
		purchaseOption = "DevTestConsumption"
		name = fmt.Sprintf("Instance usage (dev/test, %s)", r.SKUSize)
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			servicePlanCostComponent(
				r.Region,
				name,
				productName,
				sku,
				capacity,
				purchaseOption,
				additionalAttributeFilters...,
			),
		},
		UsageSchema: r.UsageSchema(),
	}
}

func servicePlanCostComponent(region, name, productName, skuRefactor string, capacity int64, purchaseOption string, additionalAttributeFilters ...*schema.AttributeFilter) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           name,
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(capacity)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(region),
			Service:       strPtr("Azure App Service"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: append([]*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Azure App Service " + productName)},
				{Key: "skuName", ValueRegex: strPtr(fmt.Sprintf("/%s$/i", skuRefactor))},
			}, additionalAttributeFilters...),
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr(purchaseOption),
		},
	}
}

func getVersionedAppServicePlanSKU(skuName, os string) (string, string, []*schema.AttributeFilter) {
	tier := "Premium"
	if strings.ToLower(skuName[:1]) == "i" {
		tier = "Isolated"
	}

	version := strings.ToLower(skuName[2:])
	if version == "v1" {
		version = ""
	}

	formattedSku := strings.TrimSpace(skuName[:2] + " ?" + version)

	productVersion := version
	if len(version) > 0 && version[0] == 'm' {
		productVersion = version[1:]
	}
	productName := strings.ReplaceAll(tier+" "+productVersion+" Plan", "  ", " ")

	if productVersion == "v3" && os == "linux" {
		return formattedSku, productName, []*schema.AttributeFilter{
			{
				Key:        "armSkuName",
				ValueRegex: strPtr(fmt.Sprintf("/%s$/i", strings.ReplaceAll(formattedSku, " ", "_"))),
			},
		}
	}

	return formattedSku, productName, nil
}

################################################################################
# FILE: internal/resources/azure/application_gateway.go
# RESOURCE: azure_application_gateway
# SIZE: 8157 bytes | LINES: 196
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/usage"
)

type ApplicationGateway struct {
	Address                string
	SKUName                string
	SKUCapacity            int64
	AutoscalingMinCapacity *int64
	Region                 string
	MonthlyDataProcessedGB *float64 `infracost_usage:"monthly_data_processed_gb"`
	CapacityUnits          *int64   `infracost_usage:"capacity_units"`
}

func (r *ApplicationGateway) CoreType() string {
	return "ApplicationGateway"
}

func (r *ApplicationGateway) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_data_processed_gb", ValueType: schema.Float64, DefaultValue: 0}, {Key: "monthly_v2_capacity_units", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *ApplicationGateway) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ApplicationGateway) BuildResource() *schema.Resource {
	var sku, tier string
	costComponents := make([]*schema.CostComponent, 0)

	skuNameParts := strings.Split(r.SKUName, "_")
	if len(skuNameParts) > 1 {
		sku = strings.ToLower(skuNameParts[1])
	}

	if strings.ToLower(skuNameParts[0]) == "standard" {
		tier = "basic"
	} else {
		tier = "WAF"
	}

	capacityUnits := int64(1)
	if r.SKUCapacity > 0 {
		capacityUnits = r.SKUCapacity
	} else if r.CapacityUnits != nil {
		capacityUnits = *r.CapacityUnits
	} else if r.AutoscalingMinCapacity != nil {
		capacityUnits = *r.AutoscalingMinCapacity
	}

	if sku == "v2" {
		costComponents = append(costComponents, r.v2CostComponents(skuNameParts, capacityUnits)...)
	} else {
		costComponents = append(costComponents, r.v1CostComponents(tier, sku, capacityUnits)...)
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *ApplicationGateway) v1CostComponents(tier, sku string, capacityUnits int64) []*schema.CostComponent {
	costComponents := make([]*schema.CostComponent, 0)
	var monthlyDataProcessedGb *decimal.Decimal
	tierLimits := []int{10240, 30720}

	costComponents = append(costComponents, r.gatewayCostComponent(fmt.Sprintf("Gateway usage (%s, %s)", tier, sku), tier, sku, capacityUnits))

	if r.MonthlyDataProcessedGB != nil {
		monthlyDataProcessedGb = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataProcessedGB))
		result := usage.CalculateTierBuckets(*monthlyDataProcessedGb, tierLimits)

		if sku == "small" {
			if result[0].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.dataProcessingCostComponent("Data processing (0-10TB)", sku, "0", &result[0]))
			}
			if result[1].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.dataProcessingCostComponent("Data processing (10-40TB)", sku, "0", &result[1]))
			}
			if result[2].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.dataProcessingCostComponent("Data processing (over 40TB)", sku, "0", &result[2]))
			}
		}

		if sku == "medium" {
			if result[1].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.dataProcessingCostComponent("Data processing (10-40TB)", sku, "10240", &result[1]))
			}
			if result[2].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.dataProcessingCostComponent("Data processing (over 40TB)", sku, "10240", &result[2]))
			}
		}

		if sku == "large" {
			if result[2].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.dataProcessingCostComponent("Data processing (over 40TB)", sku, "40960", &result[2]))
			}
		}

	} else {
		var unknown *decimal.Decimal
		costComponents = append(costComponents, r.dataProcessingCostComponent("Data processing (0-10TB)", sku, "0", unknown))
	}

	return costComponents
}

func (r *ApplicationGateway) v2CostComponents(skuNameParts []string, capacityUnits int64) []*schema.CostComponent {
	costComponents := make([]*schema.CostComponent, 0)

	var tier string
	if len(skuNameParts) > 0 && strings.ToLower(skuNameParts[0]) == "standard" {
		tier = "basic v2"
		costComponents = append(costComponents, r.fixedForV2CostComponent(fmt.Sprintf("Gateway usage (%s)", tier), "standard v2"))
		costComponents = append(costComponents, r.capacityUnitsCostComponent("basic", "standard v2", capacityUnits))
	} else {
		tier = "WAF v2"
		costComponents = append(costComponents, r.fixedForV2CostComponent(fmt.Sprintf("Gateway usage (%s)", tier), tier))
		costComponents = append(costComponents, r.capacityUnitsCostComponent("WAF", tier, capacityUnits))
	}
	return costComponents
}

func (r *ApplicationGateway) gatewayCostComponent(name, tier, sku string, capacityUnits int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           name,
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(capacityUnits)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Application Gateway"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", ValueRegex: regexPtr(fmt.Sprintf("%s Application Gateway$", tier))},
				{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("%s Gateway$", sku))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}
func (r *ApplicationGateway) dataProcessingCostComponent(name, sku, startUsage string, qty *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Application Gateway"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("%s Data Processed", sku))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr(startUsage),
		},
		UsageBased: true,
	}
}
func (r *ApplicationGateway) capacityUnitsCostComponent(name, tier string, capacityUnits int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           fmt.Sprintf("V2 capacity units (%s)", name),
		Unit:           "CU",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(capacityUnits)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Application Gateway"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", ValueRegex: regexPtr(fmt.Sprintf("Application Gateway %s$", tier))},
				{Key: "meterName", ValueRegex: regexPtr("Capacity Units$")},
			},
		},

		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	}
}

func (r *ApplicationGateway) fixedForV2CostComponent(name, tier string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           name,
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Application Gateway"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", ValueRegex: regexPtr(fmt.Sprintf("Application Gateway %s$", tier))},
				{Key: "meterName", ValueRegex: regexPtr("Fixed Cost$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

################################################################################
# FILE: internal/resources/azure/application_insights.go
# RESOURCE: azure_application_insights
# SIZE: 2980 bytes | LINES: 75
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type ApplicationInsights struct {
	Address               string
	Region                string
	RetentionInDays       int64
	MonthlyDataIngestedGB *float64 `infracost_usage:"monthly_data_ingested_gb"`
}

func (r *ApplicationInsights) CoreType() string {
	return "ApplicationInsights"
}

func (r *ApplicationInsights) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_data_ingested_gb", ValueType: schema.Float64, DefaultValue: 0}}
}

func (r *ApplicationInsights) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ApplicationInsights) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	var dataIngested *decimal.Decimal
	if r.MonthlyDataIngestedGB != nil {
		dataIngested = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataIngestedGB))
	}
	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Data ingested",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: dataIngested,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Application Insights"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", "Enterprise Overage Data"))},
				{Key: "skuName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", "Enterprise"))},
			},
		},
		UsageBased: true,
	})

	var dataRetentionDays *decimal.Decimal
	if r.RetentionInDays != 0 {
		dataRetentionDays = decimalPtr(decimal.NewFromInt(r.RetentionInDays))

		if dataRetentionDays.GreaterThan(decimal.NewFromInt(90)) && dataIngested != nil {
			days := dataRetentionDays.Sub(decimal.NewFromInt(90)).Div(decimal.NewFromInt(30))
			qty := decimalPtr(dataIngested.Mul(days))
			costComponents = append(costComponents, &schema.CostComponent{
				Name:            fmt.Sprintf("Data retention (%s days)", dataRetentionDays.String()),
				Unit:            "GB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: qty,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("azure"),
					Region:        strPtr(r.Region),
					Service:       strPtr("Application Insights"),
					ProductFamily: strPtr("Management and Governance"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "meterName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", "Data Retention"))},
						{Key: "skuName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", "Enterprise"))},
					},
				},
			})
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/application_insights_standard_web_t.go
# RESOURCE: azure_application_insights_standard_web_t
# SIZE: 2635 bytes | LINES: 60
################################################################################
package azure

import (
	"fmt"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/shopspring/decimal"
)

// ApplicationInsightsStandardWebTest struct represents an Application Insights Standard WebTest.
//
// Resource information: https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/application_insights_standard_web_test
// Pricing information: https://azure.microsoft.com/en-in/pricing/details/monitor/
type ApplicationInsightsStandardWebTest struct {
	Address string
	Region  string

	Enabled   bool
	Frequency int64
}

// CoreType returns the name of this resource type
func (r *ApplicationInsightsStandardWebTest) CoreType() string {
	return "ApplicationInsightsStandardWebTest"
}

// UsageSchema defines a list which represents the usage schema of ApplicationInsightsStandardWebTest.
func (r *ApplicationInsightsStandardWebTest) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the ApplicationInsightsStandardWebTest.
// It uses the `infracost_usage` struct tags to populate data into the ApplicationInsightsStandardWebTest.
func (r *ApplicationInsightsStandardWebTest) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid ApplicationInsightsStandardWebTest struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *ApplicationInsightsStandardWebTest) BuildResource() *schema.Resource {
	var costComponents []*schema.CostComponent

	if r.Enabled {
		secondsPerMonth := int64(730 * 60 * 60) // 730 hours * 60 minutes * 60 seconds
		tests := secondsPerMonth / r.Frequency

		costComponents = append(costComponents, &schema.CostComponent{
			Name:            fmt.Sprintf("Standard web test (%d second frequency)", r.Frequency),
			Unit:            "tests",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: decimalPtr(decimal.NewFromInt(tests)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Azure Monitor"),
				ProductFamily: strPtr("Management and Governance"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "skuName", Value: strPtr("Standard Web Test")},
				},
			},
		})
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

################################################################################
# FILE: internal/resources/azure/application_insights_web_t.go
# RESOURCE: azure_application_insights_web_t
# SIZE: 1894 bytes | LINES: 59
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type ApplicationInsightsWebTest struct {
	Address string
	Region  string
	Kind    string
	Enabled bool
}

func (r *ApplicationInsightsWebTest) CoreType() string {
	return "ApplicationInsightsWebTest"
}

func (r *ApplicationInsightsWebTest) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *ApplicationInsightsWebTest) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ApplicationInsightsWebTest) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	if r.Kind != "" {
		if strings.ToLower(r.Kind) == "multistep" && r.Enabled {
			costComponents = append(costComponents, &schema.CostComponent{
				Name:            "Multi-step web test",
				Unit:            "test",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("azure"),
					Region:        strPtr(r.Region),
					Service:       strPtr("Application Insights"),
					ProductFamily: strPtr("Management and Governance"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "meterName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", "Multi-step Web Test"))},
						{Key: "skuName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", "Enterprise"))},
					},
				},
			})
		}
	}

	if len(costComponents) == 0 {
		return &schema.Resource{
			Name:        r.Address,
			IsSkipped:   true,
			NoPrice:     true,
			UsageSchema: r.UsageSchema(),
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}

}

################################################################################
# FILE: internal/resources/azure/automation_account.go
# RESOURCE: azure_automation_account
# SIZE: 3459 bytes | LINES: 81
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type AutomationAccount struct {
	Address                 string
	Region                  string
	MonthlyJobRunMins       *int64 `infracost_usage:"monthly_job_run_mins"`
	NonAzureConfigNodeCount *int64 `infracost_usage:"non_azure_config_node_count"`
	MonthlyWatcherHrs       *int64 `infracost_usage:"monthly_watcher_hrs"`
}

func (r *AutomationAccount) CoreType() string {
	return "AutomationAccount"
}

func (r *AutomationAccount) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_job_run_mins", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "non_azure_config_node_count", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_watcher_hrs", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *AutomationAccount) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *AutomationAccount) BuildResource() *schema.Resource {
	var monthlyJobRunMins, nonAzureConfigNodeCount *decimal.Decimal
	location := r.Region
	costComponents := make([]*schema.CostComponent, 0)

	if r.MonthlyJobRunMins != nil {
		monthlyJobRunMins = decimalPtr(decimal.NewFromInt(*r.MonthlyJobRunMins))
		if monthlyJobRunMins.IsPositive() {
			costComponents = append(costComponents, automationRunTimeCostComponent(location, "500", "Basic Runtime", "Basic", monthlyJobRunMins))
		}
	} else {
		costComponents = append(costComponents, automationRunTimeCostComponent(location, "500", "Basic Runtime", "Basic", monthlyJobRunMins))
	}

	if r.NonAzureConfigNodeCount != nil {
		nonAzureConfigNodeCount = decimalPtr(decimal.NewFromInt(*r.NonAzureConfigNodeCount))
		if nonAzureConfigNodeCount.IsPositive() {
			costComponents = append(costComponents, nonautomationDSCNodesCostComponent(location, "5", "Non-Azure Node", "Non-Azure", nonAzureConfigNodeCount))
		}
	} else {
		costComponents = append(costComponents, nonautomationDSCNodesCostComponent(location, "5", "Non-Azure Node", "Non-Azure", nonAzureConfigNodeCount))
	}

	costComponents = append(costComponents, r.watchersCostComponent("744", "Watcher", "Basic"))

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *AutomationAccount) watchersCostComponent(startUsage, meterName, skuName string) *schema.CostComponent {
	var monthlyQuantity *decimal.Decimal
	if r.MonthlyWatcherHrs != nil {
		monthlyQuantity = decimalPtr(decimal.NewFromInt(*r.MonthlyWatcherHrs))
	}

	return &schema.CostComponent{

		Name:            "Watchers",
		Unit:            "hours",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: monthlyQuantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Automation"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", meterName))},
				{Key: "skuName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", skuName))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr(startUsage),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/automation_dsc_configuration.go
# RESOURCE: azure_automation_dsc_configuration
# SIZE: 2511 bytes | LINES: 60
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type AutomationDSCConfiguration struct {
	Address                 string
	Region                  string
	NonAzureConfigNodeCount *int64 `infracost_usage:"non_azure_config_node_count"`
}

func (r *AutomationDSCConfiguration) CoreType() string {
	return "AutomationDSCConfiguration"
}

func (r *AutomationDSCConfiguration) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "non_azure_config_node_count", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *AutomationDSCConfiguration) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *AutomationDSCConfiguration) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: automationDSCNodesCostComponent(&r.Region, r.NonAzureConfigNodeCount),
		UsageSchema:    r.UsageSchema(),
	}
}

func automationDSCNodesCostComponent(location *string, nonAzureConfigNodeCount *int64) []*schema.CostComponent {
	var nonAzureConfigNodeCountDec *decimal.Decimal

	if nonAzureConfigNodeCount != nil {
		nonAzureConfigNodeCountDec = decimalPtr(decimal.NewFromInt(*nonAzureConfigNodeCount))
	}

	costComponents := make([]*schema.CostComponent, 0)
	costComponents = append(costComponents, nonautomationDSCNodesCostComponent(*location, "5", "Non-Azure Node", "Non-Azure", nonAzureConfigNodeCountDec))

	return costComponents
}

func nonautomationDSCNodesCostComponent(location, startUsage, meterName, skuName string, monthlyQuantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{

		Name:            "Non-azure config nodes",
		Unit:            "nodes",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: monthlyQuantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(location),
			Service:       strPtr("Automation"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", meterName))},
				{Key: "skuName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", skuName))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr(startUsage),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/automation_dsc_nodeconfiguration.go
# RESOURCE: azure_automation_dsc_nodeconfiguration
# SIZE: 997 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type AutomationDSCNodeConfiguration struct {
	Address string
	Region  string

	NonAzureConfigNodeCount *int64 `infracost_usage:"non_azure_config_node_count"`
}

func (r *AutomationDSCNodeConfiguration) CoreType() string {
	return "AutomationDSCNodeConfiguration"
}

func (r *AutomationDSCNodeConfiguration) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "non_azure_config_node_count", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *AutomationDSCNodeConfiguration) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *AutomationDSCNodeConfiguration) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: automationDSCNodesCostComponent(&r.Region, r.NonAzureConfigNodeCount),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/automation_job_schedule.go
# RESOURCE: azure_automation_job_schedule
# SIZE: 2219 bytes | LINES: 58
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type AutomationJobSchedule struct {
	Address           string
	Region            string
	MonthlyJobRunMins *int64 `infracost_usage:"monthly_job_run_mins"`
}

func (r *AutomationJobSchedule) CoreType() string {
	return "AutomationJobSchedule"
}

func (r *AutomationJobSchedule) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_job_run_mins", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *AutomationJobSchedule) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *AutomationJobSchedule) BuildResource() *schema.Resource {
	var monthlyJobRunMins *decimal.Decimal
	location := r.Region

	if r.MonthlyJobRunMins != nil {
		monthlyJobRunMins = decimalPtr(decimal.NewFromInt(*r.MonthlyJobRunMins))
	}

	costComponents := make([]*schema.CostComponent, 0)
	costComponents = append(costComponents, automationRunTimeCostComponent(location, "500", "Basic Runtime", "Basic", monthlyJobRunMins))

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func automationRunTimeCostComponent(location, startUsage, meterName, skuName string, monthlyQuantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{

		Name:            "Job run time",
		Unit:            "minutes",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: monthlyQuantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(location),
			Service:       strPtr("Automation"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", meterName))},
				{Key: "skuName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", skuName))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr(startUsage),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/backup_protected_vm.go
# RESOURCE: azure_backup_protected_vm
# SIZE: 6053 bytes | LINES: 150
################################################################################
package azure

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// BackupProtectedVM struct represents a backup for a given VM into a recovery services vault.
//
// Backup information: https://learn.microsoft.com/en-us/azure/backup/backup-overview
// Resource information: https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/backup_policy_vm
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/backup/
type BackupProtectedVM struct {
	Address     string
	Region      string
	StorageType string
	DiskSizeGB  float64

	// DiskUtilizationGB is an override that allows users to specify how much
	// data is actually stored on the VM and will be stored in the vault. By
	// default, we assume that the total VM storage capacity will be backed up.
	DiskUtilizationGB *float64 `infracost_usage:"disk_utilization_gb"`
	// AdditionalBackupRetentionGB allows user sto specify how much additional monthly data
	// is stored in the parent vault because of daily/monthly/yearly retention policies.
	// Azure Backup uses incremental backups, which means that after the initial full backup,
	// it only stores the changes made to the data since the last backup.
	//
	// In the future, it might be better to switch this to a percentage which can be used as daily churn of
	// data from the parent vault. We can then infer the data stored using azurerm_backup_policy_vm and the disk
	// utilization. However, attempts were done when initially writing this mapping, and it proved hard to match
	// up to the exact churn & estimated storage that the azure pricing calculator shows.
	AdditionalBackupRetentionGB *float64 `infracost_usage:"additional_backup_retention_gb"`
}

func (r *BackupProtectedVM) CoreType() string {
	return "BackupProtectedVM"
}

func (r *BackupProtectedVM) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "disk_utilization_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "additional_backup_retention_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

// PopulateUsage parses the u schema.UsageData into the BackupProtectedVM.
//
// This method is normally called from the parent RecoveryServicesVault.PopulateUsage method.
func (r *BackupProtectedVM) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid BackupProtectedVM struct.
//
// BackupProtectedVM is charged for the backup data stored for the protected VM:
//
// Firstly, the backup is charged a flat monthly fee for the size of the VM that it is backing up:
//
//	Instance < or = 50 GB 	$5 + storage consumed
//	Instance is > 50 GB but < or = 500 GB 	$10 + storage consumed
//	Instance is > 500 GB 	$10 for each 500 GB increment + storage consumed
//
// Then BackupProtectedVM is charged per GB of data stored in the parent recovery service vault. This
// depends on the amount of data stored within the vault and the type of storage that the vault uses, e.g. LRS vs GRS.
func (r *BackupProtectedVM) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			r.additionalCostForSizeOfVM(),
			r.storageCostsForVM(),
		},
	}
}

func (r *BackupProtectedVM) additionalCostForSizeOfVM() *schema.CostComponent {
	unit := "under 50 GB"
	quantity := decimal.NewFromInt(1)
	filter := &schema.AttributeFilter{
		Key:   "meterName",
		Value: strPtr("Azure Files Protected Instances"),
	}

	utilization := r.diskUtilization()
	if utilization > 50 {
		filter = &schema.AttributeFilter{
			Key:   "meterName",
			Value: strPtr("Azure VM Protected Instances"),
		}
		unit = "under 500 GB"

		if utilization > 500 {
			quantity = decimal.NewFromInt(int64(utilization) / 500)
			unit = "over 500 GB"
		}
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Instance backup (%s)", unit),
		Unit:            "month",
		UnitMultiplier:  quantity,
		MonthlyQuantity: &quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Backup"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Backup")},
				filter,
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}
}

func (r *BackupProtectedVM) storageCostsForVM() *schema.CostComponent {
	quantity := decimal.NewFromInt(r.totalBackupSize())
	dataStored := fmt.Sprintf("%s data stored", r.StorageType)

	return &schema.CostComponent{
		Name:            dataStored,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: &quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Backup"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Backup")},
				{Key: "skuName", Value: strPtr("Standard")},
				{Key: "meterName", ValueRegex: strPtr(fmt.Sprintf("/^%s/i", dataStored))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	}
}

func (r *BackupProtectedVM) totalBackupSize() int64 {
	return int64(r.diskUtilization() + r.additionalBackupRetention())
}

func (r *BackupProtectedVM) diskUtilization() float64 {
	if r.DiskUtilizationGB != nil {
		return *r.DiskUtilizationGB
	}

	return r.DiskSizeGB
}

func (r *BackupProtectedVM) additionalBackupRetention() float64 {
	if r.AdditionalBackupRetentionGB != nil {
		return *r.AdditionalBackupRetentionGB
	}

	return 0
}

################################################################################
# FILE: internal/resources/azure/bastion_host.go
# RESOURCE: azure_bastion_host
# SIZE: 4018 bytes | LINES: 111
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/usage"
)

type BastionHost struct {
	Address               string
	Region                string
	MonthlyOutboundDataGB *float64 `infracost_usage:"monthly_outbound_data_gb"`
}

func (r *BastionHost) CoreType() string {
	return "BastionHost"
}

func (r *BastionHost) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_outbound_data_gb", ValueType: schema.Float64, DefaultValue: 0}}
}

func (r *BastionHost) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *BastionHost) BuildResource() *schema.Resource {
	productType := "Basic"

	costComponents := []*schema.CostComponent{
		{
			Name:           "Bastion host",
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Azure Bastion"),
				ProductFamily: strPtr("Networking"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "skuName", Value: strPtr(productType)},
					{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Gateway", productType))},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
		},
	}

	costComponents = append(costComponents, r.outboundDataTransferComponents(productType)...)

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *BastionHost) outboundDataTransferComponents(productType string) []*schema.CostComponent {
	costComponents := make([]*schema.CostComponent, 0)
	name := "Outbound data transfer "

	type dataTier struct {
		name       string
		startUsage string
	}

	data := []dataTier{
		{name: fmt.Sprintf("%s%s", name, "(first 10TB)"), startUsage: "5"},
		{name: fmt.Sprintf("%s%s", name, "(next 40TB)"), startUsage: "10240"},
		{name: fmt.Sprintf("%s%s", name, "(next 100TB)"), startUsage: "51200"},
		{name: fmt.Sprintf("%s%s", name, "(next 350TB)"), startUsage: "153600"},
		{name: fmt.Sprintf("%s%s", name, "(over 500TB)"), startUsage: "512000"},
	}

	if r.MonthlyOutboundDataGB != nil {
		tierLimits := []int{10000, 50000, 150000, 500000}
		monthlyOutboundDataGb := decimal.NewFromFloat(*r.MonthlyOutboundDataGB)
		tiers := usage.CalculateTierBuckets(monthlyOutboundDataGb, tierLimits)
		for i, d := range data {
			if i < len(tiers) && tiers[i].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.outboundDataTransferSingleComponent(
					d.name,
					productType,
					d.startUsage,
					decimalPtr(tiers[i])))
			}
		}
	} else {
		costComponents = append(costComponents, r.outboundDataTransferSingleComponent(
			data[0].name,
			productType,
			data[0].startUsage,
			nil))
	}
	return costComponents
}

func (r *BastionHost) outboundDataTransferSingleComponent(name, productType, startUsage string, quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Bastion"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(productType)},
				{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Data Transfer Out", productType))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr(startUsage),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/cognitive_account_language.go
# RESOURCE: azure_cognitive_account_language
# SIZE: 27253 bytes | LINES: 538
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
	"github.com/shopspring/decimal"
)

var validLanguageCommitmentTierTextAnalyticsRecords = []int64{1_000_000, 3_000_000, 10_000_000}
var validLanguageCommitmentTierSummarizationRecords = []int64{3_000_000, 10_000_000}

// CognitiveAccountLanguage struct represents the Azure AI Language Service.
// This supports the pay-as-you pricing and the standard and connected container commitment tiers.
// This doesn't currently support the disconnected container commitment tier.
//
// The commitment tiers are implemented using a usage-based cost component for the commitment amount.
// Since multiple commitment tiers can be used at the same time, we use separate usage-based cost
// components for each commitment tier and overage, instead of using the same cost component as the
// pay-as-you-go pricing.
//
// Resource information: https://learn.microsoft.com/en-us/azure/ai-services/language-service/overview
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/cognitive-services/language-service/
type CognitiveAccountLanguage struct {
	Address string
	Region  string

	Sku string

	// Usage attributes

	MonthlyLanguageTextAnalyticsRecords *int64 `infracost_usage:"monthly_language_text_analytics_records"`
	MonthlyLanguageSummarizationRecords *int64 `infracost_usage:"monthly_language_summarization_records"`

	MonthlyLanguageConversationalLanguageUnderstandingRecords               *int64   `infracost_usage:"monthly_language_conversational_language_understanding_records"`
	MonthlyLanguageConversationalLanguageUnderstandingAdvancedTrainingHours *float64 `infracost_usage:"monthly_language_conversational_language_understanding_advanced_training_hours"`
	MonthlyLanguageCustomizedTextClassificationRecords                      *int64   `infracost_usage:"monthly_language_customized_text_classification_records"`
	MonthlyLanguageCustomizedSummarizationRecords                           *int64   `infracost_usage:"monthly_language_customized_summarization_records"`
	MonthlyLanguageCustomizedQuestionAnsweringRecords                       *int64   `infracost_usage:"monthly_language_customized_question_answering_records"`
	MonthlyLanguageCustomizedTrainingHours                                  *float64 `infracost_usage:"monthly_language_customized_training_hours"`
	MonthlyLanguageTextAnalyticsForHealthRecords                            *int64   `infracost_usage:"monthly_language_text_analytics_for_health_records"`

	// Commitment tiers
	MonthlyCommitmentLanguageTextAnalyticsRecords                          *int64 `infracost_usage:"monthly_commitment_language_text_analytics_records"`
	MonthlyCommitmentLanguageTextAnalyticsOverageRecords                   *int64 `infracost_usage:"monthly_commitment_language_text_analytics_overage_records"`
	MonthlyCommitmentLanguageSummarizationRecords                          *int64 `infracost_usage:"monthly_commitment_language_summarization_records"`
	MonthlyCommitmentLanguageSummarizationOverageRecords                   *int64 `infracost_usage:"monthly_commitment_language_summarization_overage_records"`
	MonthlyConnectedContainerCommitmentLanguageTextAnalyticsRecords        *int64 `infracost_usage:"monthly_connected_container_commitment_language_text_analytics_records"`
	MonthlyConnectedContainerCommitmentLanguageTextAnalyticsOverageRecords *int64 `infracost_usage:"monthly_connected_container_commitment_language_text_analytics_overage_records"`
	MonthlyConnectedContainerCommitmentLanguageSummarizationRecords        *int64 `infracost_usage:"monthly_connected_container_commitment_language_summarization_records"`
	MonthlyConnectedContainerCommitmentLanguageSummarizationOverageRecords *int64 `infracost_usage:"monthly_connected_container_commitment_language_summarization_overage_records"`
}

// // CoreType returns the name of this resource type
func (r *CognitiveAccountLanguage) CoreType() string {
	return "CognitiveAccountLanguage"
}

// UsageSchema defines a list which represents the usage schema of CognitiveAccountLanguage.
func (r *CognitiveAccountLanguage) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_language_text_analytics_records", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_language_summarization_records", DefaultValue: 0, ValueType: schema.Int64},

		{Key: "monthly_language_conversational_language_understanding_records", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_language_conversational_language_understanding_advanced_training_hours", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_language_customized_text_classification_records", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_language_customized_summarization_records", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_language_customized_question_answering_records", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_language_customized_training_hours", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_language_text_analytics_for_health_records", DefaultValue: 0, ValueType: schema.Int64},

		// Commitment tiers
		{Key: "monthly_commitment_language_text_analytics_records", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_commitment_language_text_analytics_overage_records", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_commitment_language_summarization_records", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_commitment_language_summarization_overage_records", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_connected_container_commitment_language_text_analytics_records", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_connected_container_commitment_language_text_analytics_overage_records", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_connected_container_commitment_language_summarization_records", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_connected_container_commitment_language_summarization_overage_records", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the CognitiveAccountLanguage.
// It uses the `infracost_usage` struct tags to populate data into the CognitiveAccountLanguage.
func (r *CognitiveAccountLanguage) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid CognitiveAccountLanguage struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *CognitiveAccountLanguage) BuildResource() *schema.Resource {
	// F0 is the free tier
	if strings.EqualFold(r.Sku, "f0") {
		return &schema.Resource{
			Name:      r.Address,
			NoPrice:   true,
			IsSkipped: true,
		}
	}

	// For some reason the SKU can either be S0 or S1 but they map to the same thing
	if !strings.EqualFold(r.Sku, "s0") && !strings.EqualFold(r.Sku, "s1") && !strings.EqualFold(r.Sku, "s") {
		logging.Logger.Warn().Msgf("Unsupported SKU %s for %s", r.Sku, r.Address)
		return nil
	}

	costComponents := make([]*schema.CostComponent, 0)

	if r.MonthlyCommitmentLanguageTextAnalyticsRecords != nil {
		costComponents = append(costComponents, r.commitmentTextAnalyticsCostComponents(standardCommitmentTier, *r.MonthlyCommitmentLanguageTextAnalyticsRecords, intPtrToDecimalPtr(r.MonthlyCommitmentLanguageTextAnalyticsOverageRecords))...)
	}
	if r.MonthlyConnectedContainerCommitmentLanguageTextAnalyticsRecords != nil {
		costComponents = append(costComponents, r.commitmentTextAnalyticsCostComponents(connectedContainerCommitmentTier, *r.MonthlyConnectedContainerCommitmentLanguageTextAnalyticsRecords, intPtrToDecimalPtr(r.MonthlyConnectedContainerCommitmentLanguageTextAnalyticsOverageRecords))...)
	}
	if (r.MonthlyCommitmentLanguageTextAnalyticsRecords == nil && r.MonthlyConnectedContainerCommitmentLanguageTextAnalyticsRecords == nil) || r.MonthlyLanguageTextAnalyticsRecords != nil {
		costComponents = append(costComponents, r.textAnalyticsCostComponents()...)
	}

	if r.MonthlyCommitmentLanguageSummarizationRecords != nil {
		costComponents = append(costComponents, r.commitmentSummarizationCostComponents(standardCommitmentTier, *r.MonthlyCommitmentLanguageSummarizationRecords, intPtrToDecimalPtr(r.MonthlyCommitmentLanguageSummarizationOverageRecords))...)
	}
	if r.MonthlyConnectedContainerCommitmentLanguageSummarizationRecords != nil {
		costComponents = append(costComponents, r.commitmentSummarizationCostComponents(connectedContainerCommitmentTier, *r.MonthlyConnectedContainerCommitmentLanguageSummarizationRecords, intPtrToDecimalPtr(r.MonthlyConnectedContainerCommitmentLanguageSummarizationOverageRecords))...)
	}
	if (r.MonthlyCommitmentLanguageSummarizationRecords == nil && r.MonthlyConnectedContainerCommitmentLanguageSummarizationRecords == nil) || r.MonthlyLanguageSummarizationRecords != nil {
		costComponents = append(costComponents, r.summarizationCostComponent())
	}

	costComponents = append(costComponents, r.conversationalLanguageUnderstandingCostComponent())
	costComponents = append(costComponents, r.conversationalLanguageUnderstandingAdvancedTrainingCostComponent())
	costComponents = append(costComponents, r.customizedTextClassificationCostComponent())
	costComponents = append(costComponents, r.customizedSummarizationCostComponent())
	costComponents = append(costComponents, r.customizedQuestionAnsweringCostComponents()...)
	costComponents = append(costComponents, r.customizedTrainingCostComponent())
	costComponents = append(costComponents, r.textAnalyticsForHealthCostComponents()...)

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *CognitiveAccountLanguage) textAnalyticsCostComponents() []*schema.CostComponent {
	var costComponents []*schema.CostComponent

	tierLimits := []int{500, 2_000, 7_500}
	tierData := []struct {
		suffix     string
		startUsage string
	}{
		{suffix: " (first 500K)", startUsage: "0"},
		{suffix: " (500K-2.5M)", startUsage: "500"},
		{suffix: " (2.5M-10M)", startUsage: "2500"},
		{suffix: " (over 10M)", startUsage: "10000"},
	}

	var qty *decimal.Decimal
	if r.MonthlyLanguageTextAnalyticsRecords != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyLanguageTextAnalyticsRecords).Div(decimal.NewFromInt(1_000)))
		tierQtys := usage.CalculateTierBuckets(*qty, tierLimits)

		for i, d := range tierData {
			if len(tierQtys) <= i {
				break
			}

			if tierQtys[i].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.textAnalyticsCostComponent(d.suffix, d.startUsage, decimalPtr(tierQtys[i])))
			}
		}
	} else {
		costComponents = append(costComponents, r.textAnalyticsCostComponent(tierData[1].suffix, tierData[1].startUsage, nil))
	}

	return costComponents
}

func (r *CognitiveAccountLanguage) textAnalyticsCostComponent(suffix string, startUsage string, qty *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Text analytics%s", suffix),
		Unit:            "1K records",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr("Cognitive Services"),
			ProductFamily: strPtr("AI + Machine Learning"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Language")},
				{Key: "skuName", Value: strPtr("Standard")},
				{Key: "meterName", Value: strPtr("Standard Text Records")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(startUsage),
		},
	}
}

func (r *CognitiveAccountLanguage) commitmentTextAnalyticsCostComponents(commitmentTierType int64, amount int64, overage *decimal.Decimal) []*schema.CostComponent {
	if !containsInt64(validLanguageCommitmentTierTextAnalyticsRecords, amount) {
		logging.Logger.Warn().Msgf("Invalid commitment tier %d for %s", amount, r.Address)
		return nil
	}

	desc := amountToDescription(amount)

	qty := decimal.NewFromInt(amount).Div(decimal.NewFromInt(1_000))

	skuName := "Commitment Tier Azure " + desc
	commitmentLabel := "commitment"
	if commitmentTierType == connectedContainerCommitmentTier {
		skuName = "Commitment Tier Connected " + desc
		commitmentLabel = "connected container commitment"
	}

	costComponents := []*schema.CostComponent{
		{
			Name: fmt.Sprintf("Text analytics (%s)", commitmentLabel),
			Unit: "1K records",
			// Use a monthly quantity of 1 and a unit multiplier so we show the
			// correct number of transactions in the qty field, and divide the price
			// by the number of transactions in the commitment tier
			UnitMultiplier:  decimal.NewFromInt(1).Div(qty),
			MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			UnitRounding:    int32Ptr(0),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Language")},
					{Key: "skuName", Value: strPtr(skuName)},
					{Key: "meterName", ValueRegex: regexPtr("Unit$")},
				},
			},
		},
	}

	if overage != nil {
		overageQty := decimalPtr(overage.Div(decimal.NewFromInt(1_000)))

		costComponents = append(costComponents, &schema.CostComponent{
			Name:            fmt.Sprintf("Text requests (%s overage)", commitmentLabel),
			Unit:            "1K records",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: overageQty,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Language")},
					{Key: "skuName", Value: strPtr(skuName)},
					{Key: "meterName", ValueRegex: regexPtr("Overage")},
				},
			},
		})
	}

	return costComponents
}

func (r *CognitiveAccountLanguage) summarizationCostComponent() *schema.CostComponent {
	var qty *decimal.Decimal
	if r.MonthlyLanguageSummarizationRecords != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyLanguageSummarizationRecords).Div(decimal.NewFromInt(1_000)))
	}

	return &schema.CostComponent{
		Name:            "Summarization",
		Unit:            "1K records",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr("Cognitive Services"),
			ProductFamily: strPtr("AI + Machine Learning"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Language")},
				{Key: "skuName", Value: strPtr("Standard")},
				{Key: "meterName", Value: strPtr("Standard Summarization Text Records")},
			},
		},
	}
}

func (r *CognitiveAccountLanguage) commitmentSummarizationCostComponents(commitmentTierType int64, amount int64, overage *decimal.Decimal) []*schema.CostComponent {
	if !containsInt64(validLanguageCommitmentTierSummarizationRecords, amount) {
		logging.Logger.Warn().Msgf("Invalid commitment tier %d for %s", amount, r.Address)
		return nil
	}

	desc := amountToDescription(amount)

	qty := decimal.NewFromInt(amount).Div(decimal.NewFromInt(1_000))

	skuName := "Commitment Tier Summarization Azure " + desc
	commitmentLabel := "commitment"
	if commitmentTierType == connectedContainerCommitmentTier {
		skuName = "Commitment Tier Summarization Connected " + desc
		commitmentLabel = "connected container commitment"
	}

	costComponents := []*schema.CostComponent{
		{
			Name: fmt.Sprintf("Summarization (%s)", commitmentLabel),
			Unit: "1K records",
			// Use a monthly quantity of 1 and a unit multiplier so we show the
			// correct number of transactions in the qty field, and divide the price
			// by the number of transactions in the commitment tier
			UnitMultiplier:  decimal.NewFromInt(1).Div(qty),
			MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			UnitRounding:    int32Ptr(0),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Language")},
					{Key: "skuName", Value: strPtr(skuName)},
					{Key: "meterName", ValueRegex: regexPtr("Unit$")},
				},
			},
		},
	}

	if overage != nil {
		overageQty := decimalPtr(overage.Div(decimal.NewFromInt(1_000)))

		costComponents = append(costComponents, &schema.CostComponent{
			Name:            fmt.Sprintf("Summarization (%s overage)", commitmentLabel),
			Unit:            "1K records",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: overageQty,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Language")},
					{Key: "skuName", Value: strPtr(skuName)},
					{Key: "meterName", ValueRegex: regexPtr("Overage")},
				},
			},
		})
	}

	return costComponents
}

func (r *CognitiveAccountLanguage) conversationalLanguageUnderstandingCostComponent() *schema.CostComponent {
	var qty *decimal.Decimal
	if r.MonthlyLanguageConversationalLanguageUnderstandingRecords != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyLanguageConversationalLanguageUnderstandingRecords).Div(decimal.NewFromInt(1_000)))
	}

	return &schema.CostComponent{
		Name:            "Conversational language understanding",
		Unit:            "1K records",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr("Cognitive Services"),
			ProductFamily: strPtr("AI + Machine Learning"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Language")},
				{Key: "skuName", Value: strPtr("Standard")},
				{Key: "meterName", Value: strPtr("Standard CLU Text Records")},
			},
		},
	}
}

func (r *CognitiveAccountLanguage) conversationalLanguageUnderstandingAdvancedTrainingCostComponent() *schema.CostComponent {
	var qty *decimal.Decimal
	if r.MonthlyLanguageConversationalLanguageUnderstandingAdvancedTrainingHours != nil {
		qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyLanguageConversationalLanguageUnderstandingAdvancedTrainingHours))
	}

	return &schema.CostComponent{
		Name:            "Conversational language understanding advanced training",
		Unit:            "hour",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr("Cognitive Services"),
			ProductFamily: strPtr("AI + Machine Learning"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Language")},
				{Key: "skuName", Value: strPtr("Standard")},
				{Key: "meterName", Value: strPtr("Standard CLU Advanced Training Unit")},
			},
		},
	}
}

func (r *CognitiveAccountLanguage) customizedTextClassificationCostComponent() *schema.CostComponent {
	var qty *decimal.Decimal
	if r.MonthlyLanguageCustomizedTextClassificationRecords != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyLanguageCustomizedTextClassificationRecords).Div(decimal.NewFromInt(1_000)))
	}

	return &schema.CostComponent{
		Name:            "Customized text classification",
		Unit:            "1K records",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr("Cognitive Services"),
			ProductFamily: strPtr("AI + Machine Learning"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Language")},
				{Key: "skuName", Value: strPtr("Standard")},
				{Key: "meterName", Value: strPtr("Standard Custom Text Records")},
			},
		},
	}
}

func (r *CognitiveAccountLanguage) customizedSummarizationCostComponent() *schema.CostComponent {
	var qty *decimal.Decimal
	if r.MonthlyLanguageCustomizedSummarizationRecords != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyLanguageCustomizedSummarizationRecords).Div(decimal.NewFromInt(1_000)))
	}

	return &schema.CostComponent{
		Name:            "Customized summarization",
		Unit:            "1K records",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr("Cognitive Services"),
			ProductFamily: strPtr("AI + Machine Learning"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Language")},
				{Key: "skuName", Value: strPtr("Standard")},
				{Key: "meterName", Value: strPtr("Standard Custom Summarization Text Records")},
			},
		},
	}
}

func (r *CognitiveAccountLanguage) customizedQuestionAnsweringCostComponents() []*schema.CostComponent {
	var costComponents []*schema.CostComponent

	tierLimits := []int{2_500}
	tierData := []struct {
		suffix     string
		startUsage string
	}{
		{suffix: " (first 2.5M)", startUsage: "0"},
		{suffix: " (over 2.5M)", startUsage: "2500"},
	}

	var qty *decimal.Decimal
	if r.MonthlyLanguageCustomizedQuestionAnsweringRecords != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyLanguageCustomizedQuestionAnsweringRecords).Div(decimal.NewFromInt(1_000)))
		tierQtys := usage.CalculateTierBuckets(*qty, tierLimits)

		for i, d := range tierData {
			if len(tierQtys) <= i {
				break
			}

			if tierQtys[i].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.customizedQuestionAnsweringCostComponent(d.suffix, d.startUsage, decimalPtr(tierQtys[i])))
			}
		}
	} else {
		costComponents = append(costComponents, r.customizedQuestionAnsweringCostComponent(tierData[1].suffix, tierData[1].startUsage, nil))
	}

	return costComponents
}

func (r *CognitiveAccountLanguage) customizedQuestionAnsweringCostComponent(suffix string, startUsage string, qty *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Customized question answering%s", suffix),
		Unit:            "1K records",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr("Cognitive Services"),
			ProductFamily: strPtr("AI + Machine Learning"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Language")},
				{Key: "skuName", Value: strPtr("Standard")},
				{Key: "meterName", Value: strPtr("Standard QA Text Records")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(startUsage),
		},
	}
}

func (r *CognitiveAccountLanguage) customizedTrainingCostComponent() *schema.CostComponent {
	var qty *decimal.Decimal
	if r.MonthlyLanguageCustomizedTrainingHours != nil {
		qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyLanguageCustomizedTrainingHours))
	}

	return &schema.CostComponent{
		Name:            "Customized training",
		Unit:            "hour",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr("Cognitive Services"),
			ProductFamily: strPtr("AI + Machine Learning"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Language")},
				{Key: "skuName", Value: strPtr("Standard")},
				{Key: "meterName", Value: strPtr("Standard Custom Training Unit")},
			},
		},
	}
}

func (r *CognitiveAccountLanguage) textAnalyticsForHealthCostComponents() []*schema.CostComponent {
	var costComponents []*schema.CostComponent

	tierLimits := []int{5, 495, 2_000, 7_500}
	tierData := []struct {
		suffix     string
		startUsage string
	}{
		{suffix: " (first 5K)", startUsage: "0"},
		{suffix: " (5K-500K)", startUsage: "5"},
		{suffix: " (500K-2.5M)", startUsage: "500"},
		{suffix: " (2.5M-10M)", startUsage: "2500"},
		{suffix: " (over 10M)", startUsage: "10000"},
	}

	var qty *decimal.Decimal
	if r.MonthlyLanguageTextAnalyticsForHealthRecords != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyLanguageTextAnalyticsForHealthRecords).Div(decimal.NewFromInt(1_000)))
		tierQtys := usage.CalculateTierBuckets(*qty, tierLimits)

		for i, d := range tierData {
			// Skip the first tier since it's free
			if i == 0 {
				continue
			}

			if len(tierQtys) <= i {
				break
			}

			if tierQtys[i].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.textAnalyticsForHealthCostComponent(d.suffix, d.startUsage, decimalPtr(tierQtys[i])))
			}
		}
	} else {
		costComponents = append(costComponents, r.textAnalyticsForHealthCostComponent(tierData[1].suffix, tierData[1].startUsage, nil))
	}

	return costComponents
}

func (r *CognitiveAccountLanguage) textAnalyticsForHealthCostComponent(suffix string, startUsage string, qty *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Text analytics for health%s", suffix),
		Unit:            "1K records",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr("Cognitive Services"),
			ProductFamily: strPtr("AI + Machine Learning"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Language")},
				{Key: "skuName", Value: strPtr("Standard")},
				{Key: "meterName", Value: strPtr("Standard Health Text Records")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(startUsage),
		},
	}
}

################################################################################
# FILE: internal/resources/azure/cognitive_account_luis.go
# RESOURCE: azure_cognitive_account_luis
# SIZE: 11119 bytes | LINES: 233
################################################################################
package azure

import (
	"strings"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/shopspring/decimal"
)

var validLUISCommitmentTierRequests = []int64{1_000_000, 5_000_000, 25_000_000}

// CognitiveAccountLUIS struct represents the Azure LUIS AI resource.
// This supports the pay-as-you pricing and the standard and connected container commitment tiers.
// This doesn't currently support the disconnected container commitment tier.
//
// The commitment tiers are implemented using a usage-based cost component for the commitment amount.
// Since multiple commitment tiers can be used at the same time, we use separate usage-based cost
// components for each commitment tier and overage, instead of using the same cost component as the
// pay-as-you-go pricing.
//
// Resource information: https://learn.microsoft.com/en-us/azure/ai-services/luis/what-is-luis
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/cognitive-services/language-understanding-intelligent-services/
type CognitiveAccountLUIS struct {
	Address string
	Region  string

	Sku string

	// Usage attributes

	MonthlyLUISTextRequests                                    *int64 `infracost_usage:"monthly_luis_text_requests"`
	MonthlyLUISSpeechRequests                                  *int64 `infracost_usage:"monthly_luis_speech_requests"`
	MonthlyCommitmentLUISTextRequests                          *int64 `infracost_usage:"monthly_commitment_luis_text_requests"`
	MonthlyCommitmentLUISTextOverageRequests                   *int64 `infracost_usage:"monthly_commitment_luis_text_overage_requests"`
	MonthlyConnectedContainerCommitmentLUISTextRequests        *int64 `infracost_usage:"monthly_connected_container_commitment_luis_text_requests"`
	MonthlyConnectedContainerCommitmentLUISTextOverageRequests *int64 `infracost_usage:"monthly_connected_container_commitment_luis_text_overage_requests"`
}

// // CoreType returns the name of this resource type
func (r *CognitiveAccountLUIS) CoreType() string {
	return "CognitiveAccountLUIS"
}

// UsageSchema defines a list which represents the usage schema of CognitiveAccountLUIS.
func (r *CognitiveAccountLUIS) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_luis_text_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_luis_speech_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_commitment_luis_text_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_commitment_luis_text_overage_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_connected_container_commitment_luis_text_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_connected_container_commitment_luis_text_overage_requests", ValueType: schema.Int64, DefaultValue: 0},
	}
}

// PopulateUsage parses the u schema.UsageData into the CognitiveAccountLUIS.
// It uses the `infracost_usage` struct tags to populate data into the CognitiveAccountLUIS.
func (r *CognitiveAccountLUIS) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid CognitiveAccountLUIS struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *CognitiveAccountLUIS) BuildResource() *schema.Resource {
	// F0 is the free tier
	if strings.EqualFold(r.Sku, "f0") {
		return &schema.Resource{
			Name:      r.Address,
			NoPrice:   true,
			IsSkipped: true,
		}
	}

	// For some reason the SKU can either be S0 or S1 but they map to the same thing
	if !strings.EqualFold(r.Sku, "s0") && !strings.EqualFold(r.Sku, "s1") && !strings.EqualFold(r.Sku, "s") {
		logging.Logger.Warn().Msgf("Unsupported SKU %s for %s", r.Sku, r.Address)
		return nil
	}

	costComponents := make([]*schema.CostComponent, 0)

	if r.MonthlyCommitmentLUISTextRequests != nil {
		costComponents = append(costComponents, r.commitmentTextRequestsCostComponents()...)
	}

	if r.MonthlyConnectedContainerCommitmentLUISTextRequests != nil {
		costComponents = append(costComponents, r.connectedContainerCommitmentTextRequestsCostComponents()...)
	}

	if (r.MonthlyCommitmentLUISTextRequests == nil && r.MonthlyConnectedContainerCommitmentLUISTextRequests == nil) || r.MonthlyLUISTextRequests != nil {
		costComponents = append(costComponents, r.textRequestsCostComponent())
	}

	costComponents = append(costComponents, r.speechRequestsCostComponent())

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *CognitiveAccountLUIS) textRequestsCostComponent() *schema.CostComponent {
	var qty *decimal.Decimal
	if r.MonthlyLUISTextRequests != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyLUISTextRequests).Div(decimal.NewFromInt(1_000)))
	}

	return &schema.CostComponent{
		Name:            "Text requests",
		Unit:            "1K transactions",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr("Cognitive Services"),
			ProductFamily: strPtr("AI + Machine Learning"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Language Understanding")},
				{Key: "skuName", Value: strPtr("S1")},
				{Key: "meterName", Value: strPtr("S1 Transactions")},
			},
		},
	}
}

func (r *CognitiveAccountLUIS) commitmentTextRequestsCostComponents() []*schema.CostComponent {
	amount := *r.MonthlyCommitmentLUISTextRequests
	if !containsInt64(validLUISCommitmentTierRequests, amount) {
		logging.Logger.Warn().Msgf("Invalid commitment tier %d for %s", amount, r.Address)
		return nil
	}

	desc := amountToDescription(amount)
	skuName := "Commitment Tier Azure" + " " + desc

	costComponents := []*schema.CostComponent{
		{
			Name: "Text requests (commitment)",
			Unit: "1M transactions",
			// Use a monthly quantity of 1 and a unit multiplier so we show the
			// correct number of transactions in the qty field, and divide the price
			// by the number of transactions in the commitment tier
			UnitMultiplier:  decimal.NewFromInt(1).Div(decimal.NewFromInt(amount)),
			MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Language Understanding")},
					{Key: "skuName", Value: strPtr(skuName)},
					{Key: "meterName", ValueRegex: regexPtr("Unit$")},
				},
			},
		},
	}

	if r.MonthlyCommitmentLUISTextOverageRequests != nil {
		overageQty := decimalPtr(decimal.NewFromInt(*r.MonthlyCommitmentLUISTextOverageRequests).Div(decimal.NewFromInt(1_000)))

		costComponents = append(costComponents, &schema.CostComponent{
			Name:            "Text requests (commitment overage)",
			Unit:            "1K transactions",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: overageQty,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Language Understanding")},
					{Key: "skuName", Value: strPtr(skuName)},
					{Key: "meterName", ValueRegex: regexPtr("Overage")},
				},
			},
		})
	}

	return costComponents
}

func (r *CognitiveAccountLUIS) connectedContainerCommitmentTextRequestsCostComponents() []*schema.CostComponent {
	amount := *r.MonthlyConnectedContainerCommitmentLUISTextRequests
	if !containsInt64(validLUISCommitmentTierRequests, amount) {
		logging.Logger.Warn().Msgf("Invalid commitment tier %d for %s", amount, r.Address)
		return nil
	}

	desc := amountToDescription(amount)
	skuName := "Commitment Tier Azure" + " " + desc

	qty := decimal.NewFromInt(amount).Div(decimal.NewFromInt(1_000_000))

	costComponents := []*schema.CostComponent{
		{
			Name: "Text requests (connected container commitment)",
			Unit: "1M transactions",
			// Use a monthly quantity of 1 and a unit multiplier so we show the
			// correct number of transactions in the qty field, and divide the price
			// by the number of transactions in the commitment tier
			UnitMultiplier:  decimal.NewFromInt(1).Div(qty),
			MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Language Understanding")},
					{Key: "skuName", Value: strPtr(skuName)},
					{Key: "meterName", ValueRegex: strPtr("Unit$")},
				},
			},
		},
	}

	if r.MonthlyConnectedContainerCommitmentLUISTextOverageRequests != nil {
		overageQty := decimalPtr(decimal.NewFromInt(*r.MonthlyConnectedContainerCommitmentLUISTextOverageRequests).Div(decimal.NewFromInt(1_000)))

		costComponents = append(costComponents, &schema.CostComponent{
			Name:            "Text requests (connected container commitment overage)",
			Unit:            "1K transactions",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: overageQty,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Language Understanding")},
					{Key: "skuName", Value: strPtr(skuName)},
					{Key: "meterName", ValueRegex: regexPtr("Overage")},
				},
			},
		})
	}

	return costComponents
}

func (r *CognitiveAccountLUIS) speechRequestsCostComponent() *schema.CostComponent {
	var qty *decimal.Decimal
	if r.MonthlyLUISSpeechRequests != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyLUISSpeechRequests).Div(decimal.NewFromInt(1_000)))
	}

	c := &schema.CostComponent{
		Name:            "Speech requests",
		Unit:            "1K transactions",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
	}

	// The Azure Retail API doesn't have prices for this
	if strings.HasPrefix(r.Region, "usgov") {
		c.SetCustomPrice(decimalPtr(decimal.NewFromFloat(6.875)))
	} else {
		c.SetCustomPrice(decimalPtr(decimal.NewFromFloat(5.5)))
	}

	return c
}

################################################################################
# FILE: internal/resources/azure/cognitive_account_speech.go
# RESOURCE: azure_cognitive_account_speech
# SIZE: 26880 bytes | LINES: 388
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

var validSpeechCommitmentTierHrs = []int64{2_000, 10_000, 50_000}
var validSpeechCommitmentTierChars = []int64{80_000_000, 400_000_000, 2_000_000_000}

const (
	standardCommitmentTier           = iota
	connectedContainerCommitmentTier = iota
)

// CognitiveAccountSpeech struct represents the Azure Speech AI resource.
// This supports the pay-as-you pricing and the standard and connected container commitment tiers.
// This doesn't currently support the disconnected container commitment tier.
//
// The commitment tiers are implemented using a usage-based cost component for the commitment amount.
// Since multiple commitment tiers can be used at the same time, we use separate usage-based cost
// components for each commitment tier and overage, instead of using the same cost component as the
// pay-as-you-go pricing.
//
// Resource information:https://azure.microsoft.com/en-us/products/ai-services/ai-speech
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/cognitive-services/speech-services/
type CognitiveAccountSpeech struct {
	Address string
	Region  string

	Sku string

	// Usage attributes

	// Speech to text
	MonthlySpeechToTextStandardHrs                                   *float64 `infracost_usage:"monthly_speech_to_text_standard_hrs"`
	MonthlySpeechToTextBatchHrs                                      *float64 `infracost_usage:"monthly_speech_to_text_standard_batch_hrs"`
	MonthlySpeechToTextCustomModelHrs                                *float64 `infracost_usage:"monthly_speech_to_text_custom_hrs"`
	MonthlySpeechToTextCustomModelBatchHrs                           *float64 `infracost_usage:"monthly_speech_to_text_custom_batch_hrs"`
	MonthlySpeechToTextCustomEndpointHrs                             *float64 `infracost_usage:"monthly_speech_to_text_custom_endpoint_hrs"`
	MonthlySpeechToTextConversationTranscriptionMultiChannelAudioHrs *float64 `infracost_usage:"monthly_speech_to_text_conversation_transcription_multi_channel_audio_hrs"`
	MonthlySpeechToTextCustomTrainingHrs                             *float64 `infracost_usage:"monthly_speech_to_text_custom_training_hrs"`
	MonthlySpeechToTextEnhancedAddOnsHrs                             *float64 `infracost_usage:"monthly_speech_to_text_enhanced_add_ons_hrs"`

	// Text to speech
	MonthlyTextToSpeechNeuralChars             *int64   `infracost_usage:"monthly_text_to_speech_neural_chars"`
	MonthlyTextToSpeechCustomNeuralTrainingHrs *float64 `infracost_usage:"monthly_text_to_speech_custom_neural_training_hrs"`
	MonthlyTextToSpeechCustomNeuralChars       *int64   `infracost_usage:"monthly_text_to_speech_custom_neural_chars"`
	MonthlyTextToSpeechCustomNeuralEndpointHrs *float64 `infracost_usage:"monthly_text_to_speech_custom_neural_endpoint_hrs"`
	MonthlyTextToSpeechLongAudioChars          *int64   `infracost_usage:"monthly_text_to_speech_long_audio_chars"`
	MonthlyTextToSpeechPersonalVoiceProfiles   *int64   `infracost_usage:"monthly_text_to_speech_personal_voice_profiles"`
	MonthlyTextToSpeechPersonalVoiceChars      *int64   `infracost_usage:"monthly_text_to_speech_personal_voice_chars"`

	// Speech translation
	MonthlySpeechTranslationHrs *float64 `infracost_usage:"monthly_speech_translation_hrs"`

	// Speaker recognition
	MonthlySpeakerVerificationTransactions   *int64 `infracost_usage:"monthly_speaker_verification_transactions"`
	MonthlySpeakerIdentificationTransactions *int64 `infracost_usage:"monthly_speaker_identification_transactions"`

	// Voice storage
	MonthlyVoiceProfiles *int64 `infracost_usage:"monthly_voice_profiles"`

	// Standard commitment tier
	MonthlyCommitmentSpeechToTextHrs                      *int64   `infracost_usage:"monthly_commitment_speech_to_text_standard_hrs"`
	MonthlyCommitmentSpeechToTextOverageHrs               *float64 `infracost_usage:"monthly_commitment_speech_to_text_standard_overage_hrs"`
	MonthlyCommitmentSpeechToTextCustomModelHrs           *int64   `infracost_usage:"monthly_commitment_speech_to_text_custom_hrs"`
	MonthlyCommitmentSpeechToTextCustomModelOverageHrs    *float64 `infracost_usage:"monthly_commitment_speech_to_text_custom_overage_hrs"`
	MonthlyCommitmentSpeechToTextEnhancedAddOnsHrs        *int64   `infracost_usage:"monthly_commitment_speech_to_text_enhanced_add_ons_hrs"`
	MonthlyCommitmentSpeechToTextEnhancedAddOnsOverageHrs *float64 `infracost_usage:"monthly_commitment_speech_to_text_enhanced_add_ons_overage_hrs"`
	MonthlyCommitmentTextToSpeechNeuralCommitmentChars    *int64   `infracost_usage:"monthly_commitment_text_to_speech_neural_commitment_chars"`
	MonthlyCommitmentTextToSpeechNeuralOverageChars       *int64   `infracost_usage:"monthly_commitment_text_to_speech_neural_overage_chars"`

	// Connected container
	MonthlyConnectedContainerCommitmentSpeechToTextHrs                      *int64   `infracost_usage:"monthly_connected_container_commitment_speech_to_text_standard_hrs"`
	MonthlyConnectedContainerCommitmentSpeechToTextOverageHrs               *float64 `infracost_usage:"monthly_connected_container_commitment_speech_to_text_standard_overage_hrs"`
	MonthlyConnectedContainerCommitmentSpeechToTextCustomModelHrs           *int64   `infracost_usage:"monthly_connected_container_commitment_speech_to_text_custom_hrs"`
	MonthlyConnectedContainerCommitmentSpeechToTextCustomModelOverageHrs    *float64 `infracost_usage:"monthly_connected_container_commitment_speech_to_text_custom_overage_hrs"`
	MonthlyConnectedContainerCommitmentSpeechToTextEnhancedAddOnsHrs        *int64   `infracost_usage:"monthly_connected_container_commitment_speech_to_text_enhanced_add_ons_hrs"`
	MonthlyConnectedContainerCommitmentSpeechToTextEnhancedAddOnsOverageHrs *float64 `infracost_usage:"monthly_connected_container_commitment_speech_to_text_enhanced_add_ons_overage_hrs"`
	MonthlyConnectedContainerCommitmentTextToSpeechNeuralCommitmentChars    *int64   `infracost_usage:"monthly_connected_container_commitment_text_to_speech_neural_commitment_chars"`
	MonthlyConnectedContainerCommitmentTextToSpeechNeuralOverageChars       *int64   `infracost_usage:"monthly_connected_container_commitment_text_to_speech_neural_overage_chars"`
}

// // CoreType returns the name of this resource type
func (r *CognitiveAccountSpeech) CoreType() string {
	return "CognitiveAccountSpeech"
}

// UsageSchema defines a list which represents the usage schema of CognitiveAccountSpeech.
func (r *CognitiveAccountSpeech) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		// Speech to text
		{Key: "monthly_speech_to_text_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_speech_to_text_custom_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_speech_to_text_batch_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_speech_to_text_custom_batch_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_speech_to_text_custom_endpoint_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_speech_to_text_conversation_transcription_multi_channel_audio_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_speech_to_text_custom_training_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_speech_to_text_enhanced_add_ons_hrs", ValueType: schema.Float64, DefaultValue: 0},
		// Text to speech
		{Key: "monthly_text_to_speech_neural_chars", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_text_to_speech_custom_neural_training_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_text_to_speech_custom_neural_chars", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_text_to_speech_custom_neural_endpoint_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_text_to_speech_long_audio_chars", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_text_to_speech_personal_voice_profiles", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_text_to_speech_personal_voice_chars", ValueType: schema.Int64, DefaultValue: 0},
		// Speech translation
		{Key: "monthly_speech_translation_hrs", ValueType: schema.Float64, DefaultValue: 0},
		// Speaker recognition
		{Key: "monthly_speaker_verification_transactions", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_speaker_identification_transactions", ValueType: schema.Int64, DefaultValue: 0},
		// Voice storage
		{Key: "monthly_voice_profiles", ValueType: schema.Int64, DefaultValue: 0},

		// Standard commitment tier
		{Key: "monthly_commitment_speech_to_text_standard_hrs", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_commitment_speech_to_text_standard_overage_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_commitment_speech_to_text_custom_hrs", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_commitment_speech_to_text_custom_overage_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_commitment_speech_to_text_enhanced_add_ons_hrs", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_commitment_speech_to_text_enhanced_add_ons_overage_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_commitment_text_to_speech_neural_commitment_chars", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_commitment_text_to_speech_neural_overage_chars", ValueType: schema.Int64, DefaultValue: 0},

		// Connected container
		{Key: "monthly_connected_container_commitment_speech_to_text_standard_hrs", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_connected_container_commitment_speech_to_text_standard_overage_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_connected_container_commitment_speech_to_text_custom_hrs", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_connected_container_commitment_speech_to_text_custom_overage_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_connected_container_commitment_speech_to_text_enhanced_add_ons_hrs", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_connected_container_commitment_speech_to_text_enhanced_add_ons_overage_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_connected_container_commitment_text_to_speech_neural_commitment_chars", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_connected_container_commitment_text_to_speech_neural_overage_chars", ValueType: schema.Int64, DefaultValue: 0},
	}
}

// PopulateUsage parses the u schema.UsageData into the CognitiveAccountSpeech.
// It uses the `infracost_usage` struct tags to populate data into the CognitiveAccountSpeech.
func (r *CognitiveAccountSpeech) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid CognitiveAccountSpeech struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *CognitiveAccountSpeech) BuildResource() *schema.Resource {
	// F0 is the free tier
	if strings.EqualFold(r.Sku, "f0") {
		return &schema.Resource{
			Name:      r.Address,
			NoPrice:   true,
			IsSkipped: true,
		}
	}

	// For some reason the SKU can either be S0 or S1 but they map to the same thing
	if !strings.EqualFold(r.Sku, "s0") && !strings.EqualFold(r.Sku, "s1") && !strings.EqualFold(r.Sku, "s") {
		logging.Logger.Warn().Msgf("Unsupported SKU %s for %s", r.Sku, r.Address)
		return nil
	}

	costComponents := r.costComponents()

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *CognitiveAccountSpeech) costComponents() []*schema.CostComponent {
	costComponents := make([]*schema.CostComponent, 0)

	// Speech to text
	if r.MonthlyCommitmentSpeechToTextHrs != nil {
		costComponents = append(costComponents, r.commitmentTierHourlyCostComponents("Speech to text", standardCommitmentTier, "Commitment Tier Speech to Text Azure", *r.MonthlyCommitmentSpeechToTextHrs, floatPtrToDecimalPtr(r.MonthlyCommitmentSpeechToTextOverageHrs))...)
	}
	if r.MonthlyConnectedContainerCommitmentSpeechToTextHrs != nil {
		costComponents = append(costComponents, r.commitmentTierHourlyCostComponents("Speech to text", connectedContainerCommitmentTier, "Commitment Tier Speech to Text Connected", *r.MonthlyConnectedContainerCommitmentSpeechToTextHrs, floatPtrToDecimalPtr(r.MonthlyConnectedContainerCommitmentSpeechToTextOverageHrs))...)
	}
	if (r.MonthlyCommitmentSpeechToTextHrs == nil && r.MonthlyConnectedContainerCommitmentSpeechToTextHrs == nil) || r.MonthlySpeechToTextStandardHrs != nil {
		costComponents = append(costComponents, r.s0HourlyCostComponent("Speech to text", "S1 Speech To Text", r.MonthlySpeechToTextStandardHrs))
	}

	costComponents = append(costComponents,
		r.s0HourlyCostComponent("Speech to text batch", "S1 Speech to Text Batch", r.MonthlySpeechToTextBatchHrs),
	)

	if r.MonthlyCommitmentSpeechToTextCustomModelHrs != nil {
		costComponents = append(costComponents, r.commitmentTierHourlyCostComponents("Speech to text custom model", standardCommitmentTier, "Commitment Tier Custom Speech to Text Azure", *r.MonthlyCommitmentSpeechToTextCustomModelHrs, floatPtrToDecimalPtr(r.MonthlyCommitmentSpeechToTextCustomModelOverageHrs))...)
	}
	if r.MonthlyConnectedContainerCommitmentSpeechToTextCustomModelHrs != nil {
		costComponents = append(costComponents, r.commitmentTierHourlyCostComponents("Speech to text custom model", connectedContainerCommitmentTier, "Commitment Tier Custom Speech to Text Connected", *r.MonthlyConnectedContainerCommitmentSpeechToTextCustomModelHrs, floatPtrToDecimalPtr(r.MonthlyConnectedContainerCommitmentSpeechToTextCustomModelOverageHrs))...)
	}
	if (r.MonthlyCommitmentSpeechToTextCustomModelHrs == nil && r.MonthlyConnectedContainerCommitmentSpeechToTextCustomModelHrs == nil) || r.MonthlySpeechToTextCustomModelHrs != nil {
		costComponents = append(costComponents, r.s0HourlyCostComponent("Speech to text custom model", "S1 Custom Speech To Text", r.MonthlySpeechToTextCustomModelHrs))
	}

	costComponents = append(costComponents, []*schema.CostComponent{
		r.s0HourlyCostComponent("Speech to text custom model batch", "S1 Custom Speech to Text Batch", r.MonthlySpeechToTextCustomModelBatchHrs),
		r.s0CostComponent("Speech to text custom endpoint hosting", "S1 Custom Speech Model Hosting Unit", floatPtrToDecimalPtr(r.MonthlySpeechToTextCustomEndpointHrs), "hours", 1, &schema.PriceFilter{Unit: strPtr("1/Hour")}), // This uses a different unit, so we don't want to filter the price by '1 Hour'
		r.s0HourlyCostComponent("Speech to text custom training", "S1 Custom Speech Training", r.MonthlySpeechToTextCustomTrainingHrs),
	}...)

	if r.MonthlyCommitmentSpeechToTextEnhancedAddOnsHrs != nil {
		costComponents = append(costComponents, r.commitmentTierHourlyCostComponents("Speech to text enhanced add-ons", standardCommitmentTier, "Commitment Tier STT AddOn Azure", *r.MonthlyCommitmentSpeechToTextEnhancedAddOnsHrs, floatPtrToDecimalPtr(r.MonthlyCommitmentSpeechToTextEnhancedAddOnsOverageHrs))...)
	}
	if r.MonthlyConnectedContainerCommitmentSpeechToTextEnhancedAddOnsHrs != nil {
		costComponents = append(costComponents, r.commitmentTierHourlyCostComponents("Speech to text enhanced add-ons", connectedContainerCommitmentTier, "Commitment Tier STT AddOn Connected", *r.MonthlyConnectedContainerCommitmentSpeechToTextEnhancedAddOnsHrs, floatPtrToDecimalPtr(r.MonthlyConnectedContainerCommitmentSpeechToTextEnhancedAddOnsOverageHrs))...)
	}
	if (r.MonthlyCommitmentSpeechToTextEnhancedAddOnsHrs == nil && r.MonthlyConnectedContainerCommitmentSpeechToTextEnhancedAddOnsHrs == nil) || r.MonthlySpeechToTextEnhancedAddOnsHrs != nil {
		costComponents = append(costComponents, r.s0HourlyCostComponent("Speech to text enhanced add-ons", "S1 Speech to Text Enhanced Feature Audio", r.MonthlySpeechToTextEnhancedAddOnsHrs))
	}

	costComponents = append(costComponents,
		r.s0HourlyCostComponent("Speech to text conversation transcription multi-channel audio", "S1 Conversation Transcription Multichannel Audio", r.MonthlySpeechToTextConversationTranscriptionMultiChannelAudioHrs),
	)

	// Text to speech
	if r.MonthlyCommitmentTextToSpeechNeuralCommitmentChars != nil {
		if !containsInt64(validSpeechCommitmentTierChars, *r.MonthlyCommitmentTextToSpeechNeuralCommitmentChars) {
			logging.Logger.Warn().Msgf("Invalid commitment tier amount %d for %s", *r.MonthlyCommitmentTextToSpeechNeuralCommitmentChars, r.Address)
		} else {
			costComponents = append(costComponents, r.commitmentTierCostComponents("Text to speech neural", standardCommitmentTier, "Commitment Tier Neural Text to Speech Azure", *r.MonthlyCommitmentTextToSpeechNeuralCommitmentChars, intPtrToDecimalPtr(r.MonthlyCommitmentTextToSpeechNeuralOverageChars), "1M chars", 1_000_000)...)
		}
	}
	if r.MonthlyConnectedContainerCommitmentTextToSpeechNeuralCommitmentChars != nil {
		if !containsInt64(validSpeechCommitmentTierChars, *r.MonthlyConnectedContainerCommitmentTextToSpeechNeuralCommitmentChars) {
			logging.Logger.Warn().Msgf("Invalid commitment tier amount %d for %s", *r.MonthlyConnectedContainerCommitmentTextToSpeechNeuralCommitmentChars, r.Address)
		} else {
			costComponents = append(costComponents, r.commitmentTierCostComponents("Text to speech neural", connectedContainerCommitmentTier, "Commit Tier Neural TTS Connected", *r.MonthlyConnectedContainerCommitmentTextToSpeechNeuralCommitmentChars, intPtrToDecimalPtr(r.MonthlyConnectedContainerCommitmentTextToSpeechNeuralOverageChars), "1M chars", 1_000_000)...)
		}
	}
	if (r.MonthlyCommitmentTextToSpeechNeuralCommitmentChars == nil && r.MonthlyConnectedContainerCommitmentTextToSpeechNeuralCommitmentChars == nil) || r.MonthlyTextToSpeechNeuralChars != nil {
		costComponents = append(costComponents, r.s0CostComponent("Text to speech neural", "S1 Neural Text To Speech Characters", intPtrToDecimalPtr(r.MonthlyTextToSpeechNeuralChars), "1M chars", 1_000_000, nil))
	}

	costComponents = append(costComponents, []*schema.CostComponent{
		r.s0HourlyCostComponent("Text to speech custom neural training", "S1 Custom Neural Training", r.MonthlyTextToSpeechCustomNeuralTrainingHrs),
		r.s0CostComponent("Text to speech custom neural", "S1 Custom Neural Realtime Characters", intPtrToDecimalPtr(r.MonthlyTextToSpeechCustomNeuralChars), "1M chars", 1_000_000, nil),
		r.s0CostComponent("Text to speech custom neural endpoint hosting", "S1 Custom Neural Voice Model Hosting Unit", floatPtrToDecimalPtr(r.MonthlyTextToSpeechCustomNeuralEndpointHrs), "hours", 1, &schema.PriceFilter{Unit: strPtr("1/Hour")}), // This uses a different unit, so we don't want to filter the price by '1 Hour'
		r.s0CostComponent("Text to speech long audio", "S1 Neural Long Audio Characters", intPtrToDecimalPtr(r.MonthlyTextToSpeechLongAudioChars), "1M chars", 1_000_000, nil),
	}...)

	costComponents = append(costComponents, r.personalVoiceCostComponents()...)

	// Speech translation

	costComponents = append(costComponents,
		r.s0HourlyCostComponent("Speech translation", "S1 Speech Translation", r.MonthlySpeechTranslationHrs),
	)

	// Speaker recognition
	costComponents = append(costComponents, []*schema.CostComponent{
		r.s0CostComponent("Speaker verification", "S1 Speaker Verification Transactions", intPtrToDecimalPtr(r.MonthlySpeakerVerificationTransactions), "1K transactions", 1_000, nil),
		r.s0CostComponent("Speaker identification", "S1 Speaker Identification Transactions", intPtrToDecimalPtr(r.MonthlySpeakerIdentificationTransactions), "1K transactions", 1_000, nil),
	}...)

	// Voice profiles
	costComponents = append(costComponents,
		r.s0CostComponent("Voice profiles", "S1 Voice Storage", intPtrToDecimalPtr(r.MonthlyVoiceProfiles), "1K profiles", 1_000, nil),
	)

	return costComponents
}

func (r *CognitiveAccountSpeech) s0CostComponent(name string, meterName string, qty *decimal.Decimal, unit string, qtyDiv int64, priceFilter *schema.PriceFilter) *schema.CostComponent {
	if qty != nil {
		qty = decimalPtr(qty.Div(decimal.NewFromInt(qtyDiv)))
	}

	return &schema.CostComponent{
		Name:            name,
		Unit:            unit,
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr("Cognitive Services"),
			ProductFamily: strPtr("AI + Machine Learning"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Speech")},
				{Key: "skuName", Value: strPtr("S1")},
				{Key: "meterName", Value: strPtr(meterName)},
			},
		},
		PriceFilter: priceFilter,
	}
}

func (r *CognitiveAccountSpeech) s0HourlyCostComponent(name string, meterName string, hours *float64) *schema.CostComponent {
	var qty *decimal.Decimal
	if hours != nil {
		qty = decimalPtr(decimal.NewFromFloat(*hours))
	}

	return r.s0CostComponent(name, meterName, qty, "hours", 1, &schema.PriceFilter{Unit: strPtr("1 Hour")})
}

func (r *CognitiveAccountSpeech) personalVoiceCostComponents() []*schema.CostComponent {
	var profilesQty *decimal.Decimal
	if r.MonthlyTextToSpeechPersonalVoiceProfiles != nil {
		profilesQty = decimalPtr(decimal.NewFromInt(*r.MonthlyTextToSpeechPersonalVoiceProfiles).Div(decimal.NewFromInt(1_000)))
	}

	var charsQty *decimal.Decimal
	if r.MonthlyTextToSpeechPersonalVoiceChars != nil {
		charsQty = decimalPtr(decimal.NewFromInt(*r.MonthlyTextToSpeechPersonalVoiceChars).Div(decimal.NewFromInt(1_000_000)))
	}

	return []*schema.CostComponent{
		{
			Name:            "Text to speech personal voice profiles",
			Unit:            "1K profiles",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: profilesQty,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Speech")},
					{Key: "skuName", Value: strPtr("Text to Speech - Personal Voice")},
					{Key: "meterName", Value: strPtr("Text to Speech - Personal Voice Voice Storage")},
				},
			},
		},
		{
			Name:            "Text to speech personal voice characters",
			Unit:            "1M chars",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: charsQty,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Speech")},
					{Key: "skuName", Value: strPtr("Text to Speech - Personal Voice")},
					{Key: "meterName", Value: strPtr("Text to Speech - Personal Voice Characters")},
				},
			},
		},
	}
}

func (r *CognitiveAccountSpeech) commitmentTierCostComponents(namePrefix string, commitmentTierType int, skuNamePrefix string, commitedAmount int64, overage *decimal.Decimal, unit string, qtyDiv int64) []*schema.CostComponent {
	desc := amountToDescription(commitedAmount)

	skuName := skuNamePrefix + " " + desc

	// Convert the amount to the correct unit
	// If the amount is 2_000, the qty divider is 1_000, so the qty should be 2
	// so we show the correct qty based on the units
	qty := decimal.NewFromInt(commitedAmount).Div(decimal.NewFromInt(qtyDiv))

	suffix := " (commitment)"
	if commitmentTierType == connectedContainerCommitmentTier {
		suffix = " (connected container commitment)"
	}

	costComponents := []*schema.CostComponent{
		{
			Name: fmt.Sprintf("%s%s", namePrefix, suffix),
			Unit: unit,
			// Use a monthly quantity of 1 and a unit multiplier so we show the
			// correct number of hours/chars in the qty field, and divide the price
			// by the number of hours/chars in the commitment tier
			UnitMultiplier:  decimal.NewFromInt(1).Div(qty),
			MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Speech")},
					{Key: "skuName", Value: strPtr(skuName)},
					{Key: "meterName", ValueRegex: regexPtr("Unit$")},
				},
			},
		},
	}

	if overage != nil && overage.GreaterThan(decimal.Zero) {
		overageQty := decimalPtr(overage.Div(decimal.NewFromInt(qtyDiv)))

		suffix := " (overage)"
		if commitmentTierType == connectedContainerCommitmentTier {
			suffix = " (connected container overage)"
		}

		costComponents = append(costComponents, &schema.CostComponent{
			Name:            fmt.Sprintf("%s%s", namePrefix, suffix),
			Unit:            unit,
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: overageQty,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Speech")},
					{Key: "skuName", Value: strPtr(skuName)},
					{Key: "meterName", ValueRegex: regexPtr("Overage")},
				},
			},
		})
	}

	return costComponents
}

func (r *CognitiveAccountSpeech) commitmentTierHourlyCostComponents(namePrefix string, commitmentTierType int, skuNamePrefix string, amount int64, overage *decimal.Decimal) []*schema.CostComponent {
	if !containsInt64(validSpeechCommitmentTierHrs, amount) {
		logging.Logger.Warn().Msgf("Invalid commitment tier amount %d for %s", amount, r.Address)
		return []*schema.CostComponent{}
	}

	return r.commitmentTierCostComponents(namePrefix, commitmentTierType, skuNamePrefix, amount, overage, "hours", 1)
}

// amountToDescription converts an amount to a human readable description.
// Such as 20K or 2000M.
func amountToDescription(amount int64) string {
	if amount < 1000 {
		return fmt.Sprintf("%d", amount)
	}

	if amount < 1000000 {
		return fmt.Sprintf("%dK", amount/1_000)
	}

	return fmt.Sprintf("%dM", amount/1_000_000)
}

################################################################################
# FILE: internal/resources/azure/cognitive_deployment.go
# RESOURCE: azure_cognitive_deployment
# SIZE: 49073 bytes | LINES: 1163
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/shopspring/decimal"
)

type languageModel struct {
	model            string
	version          string
	isDefaultVersion bool

	inputSKUGlobal  string
	outputSKUGlobal string

	inputSKURegional  string
	outputSKURegional string

	batchInputSKUGlobal  string
	batchOutputSKUGlobal string

	inputSKUDataZone  string
	outputSKUDataZone string

	cachedInputSKUGlobal   string
	cachedInputSKURegional string
	cachedInputSKUDataZone string

	batchInputSKUDataZone  string
	batchOutputSKUDataZone string

	audioInputSKUGlobal  string
	audioOutputSKUGlobal string

	audioInputSKURegional  string
	audioOutputSKURegional string

	audioInputSKUDataZone  string
	audioOutputSKUDataZone string
}

type sku struct {
	input       string
	output      string
	cachedInput string

	audioInput  string
	audioOutput string
}

func (l languageModel) skuName(skuName string) sku {
	switch strings.ToLower(skuName) {
	case "standard":
		return sku{
			input:       l.inputSKURegional,
			output:      l.outputSKURegional,
			cachedInput: l.cachedInputSKURegional,

			audioInput:  l.audioInputSKURegional,
			audioOutput: l.audioOutputSKURegional,
		}
	case "globalstandard":
		return sku{
			input:       l.inputSKUGlobal,
			output:      l.outputSKUGlobal,
			cachedInput: l.cachedInputSKUGlobal,

			audioInput:  l.audioInputSKUGlobal,
			audioOutput: l.audioOutputSKUGlobal,
		}
	case "data_zone_standard":
		return sku{
			input:       l.inputSKUDataZone,
			output:      l.outputSKUDataZone,
			cachedInput: l.cachedInputSKUDataZone,

			audioInput:  l.audioInputSKUDataZone,
			audioOutput: l.audioOutputSKUDataZone,
		}
	case "data_zone_batch":
		return sku{
			input:       l.batchInputSKUDataZone,
			output:      l.batchOutputSKUDataZone,
			cachedInput: l.cachedInputSKUDataZone,

			audioInput:  l.audioInputSKUDataZone,
			audioOutput: l.audioOutputSKUDataZone,
		}
	case "global_batch":
		return sku{
			input:       l.batchInputSKUGlobal,
			output:      l.batchOutputSKUGlobal,
			cachedInput: l.cachedInputSKUGlobal,

			audioInput:  l.audioInputSKUGlobal,
			audioOutput: l.audioOutputSKUGlobal,
		}

	}

	return sku{
		input:       l.inputSKUGlobal,
		output:      l.outputSKUGlobal,
		cachedInput: l.cachedInputSKUGlobal,

		audioInput:  l.audioInputSKUGlobal,
		audioOutput: l.audioOutputSKUGlobal,
	}
}

var (
	languageModelSKUs = map[string]map[string]languageModel{
		"gpt-4.5-preview": {
			"2025-02-27": {
				model:            "gpt-4.5-preview",
				version:          "2025-02-27",
				isDefaultVersion: true,

				inputSKUDataZone:  "gpt 4.5 0227 Inp DZone",
				outputSKUDataZone: "gpt 4.5 0227 Outp DZone",

				batchInputSKUDataZone:  "gpt 4.5 0227 Batch Inp DZone",
				batchOutputSKUDataZone: "gpt 4.5 0227 Batch Outp DZone",

				inputSKUGlobal:  "gpt 4.5 0227 Inp glbl",
				outputSKUGlobal: "gpt 4.5 0227 Outp glbl",

				batchInputSKUGlobal:  "gpt 4.5 0227 Batch Inp glbl",
				batchOutputSKUGlobal: "gpt 4.5 0227 Batch Outp glbl",

				inputSKURegional:  "gpt 4.5 0227 Inp regnl",
				outputSKURegional: "gpt 4.5 0227 Outp regnl",

				cachedInputSKUGlobal:   "gpt 4.5 0227 cached Inp glbl",
				cachedInputSKURegional: "gpt 4.5 0227 cached Inp regnl",
				cachedInputSKUDataZone: "gpt 4.5 0227 cached Inp DZone",
			},
		},
		"gpt-35-turbo": {
			"0301": {
				model:            "gpt-35-turbo",
				version:          "0301",
				isDefaultVersion: false,

				inputSKUGlobal:  "gpt-35-turbo4K-Inp-glbl",
				outputSKUGlobal: "gpt-35-turbo4K-Outp-glbl",

				inputSKURegional:  "gpt-35-turbo-4k-Input-regional",
				outputSKURegional: "gpt-35-turbo-4k-Output-regional",
			},
			"0613": {
				model:            "gpt-35-turbo",
				version:          "0613",
				isDefaultVersion: false,

				inputSKUGlobal:  "gpt-35-turbo4K-Inp-glbl",
				outputSKUGlobal: "gpt-35-turbo4K-Outp-glbl",

				inputSKURegional:  "gpt-35-turbo-4k-Input-regional",
				outputSKURegional: "gpt-35-turbo-4k-Output-regional",
			},
			"1106": {
				model:            "gpt-35-turbo",
				version:          "1106",
				isDefaultVersion: false,

				inputSKUGlobal:  "gpt-35-turbo4K-Inp-glbl",
				outputSKUGlobal: "gpt-35-turbo4K-Outp-glbl",

				inputSKURegional:  "gpt-35-turbo-4k-Input-regional",
				outputSKURegional: "gpt-35-turbo-4k-Output-regional",
			},
			"0125": {
				model:            "gpt-35-turbo",
				version:          "0125",
				isDefaultVersion: true,

				inputSKUGlobal:  "gpt-35-turbo4K-Inp-glbl",
				outputSKUGlobal: "gpt-35-turbo4K-Outp-glbl",

				inputSKURegional:  "gpt-35-turbo-4k-Input-regional",
				outputSKURegional: "gpt-35-turbo-4k-Output-regional",
			},
		},

		"gpt-35-turbo-16k": {
			"0613": {
				model:            "gpt-35-turbo-16k",
				version:          "0613",
				isDefaultVersion: true,

				inputSKUGlobal:  "gpt-35-turbo16K-Inp-glbl",
				outputSKUGlobal: "gpt-35-turbo16K-Outp-glbl",

				inputSKURegional:  "gpt-35-turbo-16k-Input-regional",
				outputSKURegional: "gpt-35-turbo-16k-Output-regional",

				batchInputSKUGlobal:  "gpt-35-turbo16K-Batch-Inp-glbl",
				batchOutputSKUGlobal: "gpt-35-turbo16K-Batch-Outp-glbl",
			},
		},

		"gpt-4": {
			"0125-Preview": {
				model:            "gpt-4",
				version:          "0125-Preview",
				isDefaultVersion: false,

				inputSKUGlobal:  "gpt-4-8K-Inp-glbl",
				outputSKUGlobal: "gpt-4-8K-Outp-glbl",

				inputSKURegional:  "gpt-4-8K-Input-regional",
				outputSKURegional: "gpt-4-8K-Output-regional",

				batchInputSKUGlobal:  "gpt-4-8K-Batch-Inp-glbl",
				batchOutputSKUGlobal: "gpt-4-8K-Batch-Outp-glbl",
			},
			"1106-Preview": {
				model:            "gpt-4",
				version:          "1106-Preview",
				isDefaultVersion: false,

				inputSKUGlobal:  "gpt-4-8K-Inp-glbl",
				outputSKUGlobal: "gpt-4-8K-Outp-glbl",

				inputSKURegional:  "gpt-4-8K-Input-regional",
				outputSKURegional: "gpt-4-8K-Output-regional",

				batchInputSKUGlobal:  "gpt-4-8K-Batch-Inp-glbl",
				batchOutputSKUGlobal: "gpt-4-8K-Batch-Outp-glbl",
			},
			"0613": {
				model:            "gpt-4",
				version:          "0613",
				isDefaultVersion: true,

				inputSKUGlobal:  "gpt-4-8K-Inp-glbl",
				outputSKUGlobal: "gpt-4-8K-Outp-glbl",

				inputSKURegional:  "gpt-4-8K-Input-regional",
				outputSKURegional: "gpt-4-8K-Output-regional",

				batchInputSKUGlobal:  "gpt-4-8K-Batch-Inp-glbl",
				batchOutputSKUGlobal: "gpt-4-8K-Batch-Outp-glbl",
			},
			"turbo-2024-04-09": {
				model:            "gpt-4",
				version:          "turbo-2024-04-09",
				isDefaultVersion: false,

				inputSKUGlobal:  "gpt-4-turbo128K Inp-glbl",
				outputSKUGlobal: "gpt-4-turbo128K Outp-glbl",

				inputSKURegional:  "gpt-4-turbo-128K Input-regional",
				outputSKURegional: "gpt-4-turbo-128K Output-regional",

				batchInputSKUGlobal:  "gpt-4-Turbo-Batch-128K Inp-glbl",
				batchOutputSKUGlobal: "gpt-4-Turbo-Batch-128K Outp-glbl",
			},
		},

		"gpt-4-32k": {
			"0613": {
				model:            "gpt-4-32k",
				version:          "0613",
				isDefaultVersion: true,

				inputSKUGlobal:  "gpt-4-32K-Inp-glbl",
				outputSKUGlobal: "gpt-4-32K-Outp-glbl",

				inputSKURegional:  "gpt-4-32K-Input-regional",
				outputSKURegional: "gpt-4-32K-Output-regional",
			},
		},

		"gpt-4o": {
			"2024-05-13": {
				model:            "gpt-4o",
				version:          "2024-05-13",
				isDefaultVersion: true,

				inputSKUGlobal:  "gpt 4o 0513 Input global",
				outputSKUGlobal: "gpt 4o 0513 Output global",

				inputSKURegional:  "gpt 4o 0513 Input regional",
				outputSKURegional: "gpt 4o 0513 Output regional",

				inputSKUDataZone:  "gpt 4o 0513 Input Data Zone",
				outputSKUDataZone: "gpt 4o 0513 Output Data Zone",

				batchInputSKUGlobal:  "gpt 4o 0513 Batch Inp glbl",
				batchOutputSKUGlobal: "gpt 4o 0513 Batch Outp glbl",

				batchInputSKUDataZone:  "gpt 4o 0513 Batch Inp Data Zone",
				batchOutputSKUDataZone: "gpt 4o 0513 Batch Outp Data Zone",
			},
			"2024-08-06": {
				model:            "gpt-4o",
				version:          "2024-08-06",
				isDefaultVersion: false,

				inputSKUGlobal:  "gpt-4o-0806-Inp-glbl",
				outputSKUGlobal: "gpt-4o-0806-Outp-glbl",

				cachedInputSKUGlobal: "gpt 4o 0806 cached Inp glbl",

				inputSKURegional:  "gpt-4o-0806-Inp-regnl",
				outputSKURegional: "gpt-4o-0806-Outp-regnl",

				cachedInputSKURegional: "gpt 4o 0806 cached Inp regnl",

				inputSKUDataZone:  "gpt 4o 0806 Inp Data Zone",
				outputSKUDataZone: "gpt 4o 0806 Outp Data Zone",

				cachedInputSKUDataZone: "gpt 4o 0806 cached Inp Data Zone",

				batchInputSKUGlobal:  "gpt-4o-0806-Batch-Inp-glbl",
				batchOutputSKUGlobal: "gpt-4o-0806-Batch-Outp-glbl",

				batchInputSKUDataZone:  "gpt 4o 0806 Batch Inp Data Zone",
				batchOutputSKUDataZone: "gpt 4o 0806 Batch Outp Data Zone",
			},
			"2024-11-20": {
				model:            "gpt-4o",
				version:          "2024-11-20",
				isDefaultVersion: false,

				inputSKUGlobal:  "gpt 4o 1120 Inp glbl",
				outputSKUGlobal: "gpt 4o 1120 Outp glbl",

				cachedInputSKUGlobal: "gpt 4o 1120 cached Inp glbl",

				inputSKURegional:  "gpt 4o 1120 Inp regnl",
				outputSKURegional: "gpt 4o 1120 Outp regnl",

				cachedInputSKURegional: "gpt 4o 1120 cached Inp regnl",

				inputSKUDataZone:  "gpt 4o 1120 Inp Data Zone",
				outputSKUDataZone: "gpt 4o 1120 Outp Data Zone",

				cachedInputSKUDataZone: "gpt 4o 1120 cached Inp Data Zone",

				batchInputSKUGlobal:  "gpt 4o 1120 Batch Inp glbl",
				batchOutputSKUGlobal: "gpt 4o 1120 Batch Outp glbl",

				batchInputSKUDataZone:  "gpt 4o 1120 Batch Inp Data Zone",
				batchOutputSKUDataZone: "gpt 4o 1120 Batch Outp Data Zone",
			},
		},

		"gpt-4o-mini": {
			"2024-07-18": {
				model:            "gpt-4o-mini",
				version:          "2024-07-18",
				isDefaultVersion: true,

				inputSKUGlobal:  "gpt-4o-mini-0718-Inp-glbl",
				outputSKUGlobal: "gpt-4o-mini-0718-Outp-glbl",

				cachedInputSKUGlobal: "gpt 4o mini 0718 cached Inp glbl",

				inputSKURegional:  "gpt-4o-mini-0718-Inp-regnl",
				outputSKURegional: "gpt-4o-mini-0718-Outp-regnl",

				cachedInputSKURegional: "gpt 4o mini 0718 cached Inp regnl",

				inputSKUDataZone:  "gpt 4o mini 0718 Inp Data Zone",
				outputSKUDataZone: "gpt 4o mini 0718 Outp Data Zone",

				cachedInputSKUDataZone: "gpt 4o mini 0718 cached Inp Data Zone",

				batchInputSKUGlobal:  "gpt-4o-mini-0718-Batch-Inp-glbl",
				batchOutputSKUGlobal: "gpt-4o-mini-0718-Batch-Outp-glbl",

				batchInputSKUDataZone:  "gpt 4o mini 0718 Batch Inp Data Zone",
				batchOutputSKUDataZone: "gpt 4o mini0718 BatchOutp DataZone",
			},
		},

		"gpt-4o-audio-preview": {
			"2024-12-17": {
				model:            "gpt-4o-audio-preview",
				version:          "2024-12-17",
				isDefaultVersion: false,

				inputSKUGlobal:  "gpt-4o-aud-1217-txt Inp glbl",
				outputSKUGlobal: "gpt-4o-aud-1217-txt Outp glbl",

				inputSKURegional:  "gpt-4o-aud-1217-txt Inp regnl",
				outputSKURegional: "gpt-4o-aud-1217-txt Outp regnl",

				inputSKUDataZone:  "gpt-4o-aud-1217-txt Inp DZone",
				outputSKUDataZone: "gpt-4o-aud-1217-txt Outp DZone",

				audioInputSKUGlobal:  "gpt-4o-aud-1217 Inp glbl",
				audioOutputSKUGlobal: "gpt-4o-aud-1217 Outp glbl",

				audioInputSKURegional:  "gpt-4o-aud-1217 Inp regnl",
				audioOutputSKURegional: "gpt-4o-aud-1217 Outp regnl",

				audioInputSKUDataZone:  "gpt-4o-aud-1217 Inp DZone",
				audioOutputSKUDataZone: "gpt-4o-aud-1217 Outp DZone",
			},
		},

		"gpt-4o-mini-audio-preview": {
			"2024-12-17": {
				model:            "gpt-4o-mini-audio-preview",
				version:          "2024-12-17",
				isDefaultVersion: false,

				inputSKUGlobal:  "gpt4omini-aud1217-txt Inp glbl",
				outputSKUGlobal: "gpt4omini-aud1217-txt Outp glbl",

				inputSKURegional:  "gpt4omini-aud1217-txt Inp regnl",
				outputSKURegional: "gpt4omini-aud1217-txt Outp regnl",

				inputSKUDataZone:  "gpt4omini-aud1217-txt Inp DZone",
				outputSKUDataZone: "gpt4omini-aud1217-txt Outp DZone",

				audioInputSKUGlobal:  "gpt4omini-aud1217 Inp glbl",
				audioOutputSKUGlobal: "gpt4omini-aud1217 Outp glbl",

				audioInputSKURegional:  "gpt4omini-aud1217 Inp regnl",
				audioOutputSKURegional: "gpt4omini-aud1217 Outp regnl",

				audioInputSKUDataZone:  "gpt4omini-aud1217 Inp DZone",
				audioOutputSKUDataZone: "gpt4omini-aud1217 Outp DZone",
			},
		},

		"gpt-4o-realtime-preview": {
			"2024-12-17": {
				model:            "gpt-4o-realtime-preview",
				version:          "2024-12-17",
				isDefaultVersion: false,

				inputSKUGlobal:  "gpt-4o-rt-txt-1217 Inp glbl",
				outputSKUGlobal: "gpt-4o-rt-txt-1217 Outp glbl",

				cachedInputSKUGlobal: "gpt-4o-rt-txt-1217 cchd Inp glbl",

				inputSKURegional:  "gpt-4o-rt-txt-1217 Inp regnl",
				outputSKURegional: "gpt-4o-rt-txt-1217 Outp regnl",

				cachedInputSKURegional: "gpt-4o-rt-txt-1217 cchd Inp rgnl",

				inputSKUDataZone:  "gpt-4o-rt-txt-1217 Inp DZone",
				outputSKUDataZone: "gpt-4o-rt-txt-1217 Outp DZone",

				cachedInputSKUDataZone: "gpt-4o-rt-txt-1217 cchd Inp DZn",

				audioInputSKUGlobal:  "gpt-4o-rt-aud-1217 Inp glbl",
				audioOutputSKUGlobal: "gpt-4o-rt-aud-1217 Outp glbl",

				audioInputSKURegional:  "gpt-4o-rt-aud-1217 Inp regnl",
				audioOutputSKURegional: "gpt-4o-rt-aud-1217 Outp regnl",

				audioInputSKUDataZone:  "gpt-4o-rt-aud-1217 Inp DZone",
				audioOutputSKUDataZone: "gpt-4o-rt-aud-1217 Outp DZone",
			},
			"2024-10-01": {
				model:            "gpt-4o-realtime-preview",
				version:          "2024-10-01",
				isDefaultVersion: false,

				inputSKUGlobal:  "gpt4o realtime prvw text inp glbl",
				outputSKUGlobal: "gpt4o realtime prvw text outp glbl",

				cachedInputSKUGlobal: "gpt4o realtime cached text inp glbl",

				inputSKURegional:  "gpt4o realtime prvw text inp regn",
				outputSKURegional: "gpt4o realtime prvw text outp regn",

				inputSKUDataZone:  "gpt4o realtimePrvwTxtInp DataZone",
				outputSKUDataZone: "gpt4o realtimePrvwTxtOutp DataZone",

				audioInputSKUGlobal:  "gpt4o realtimePrvw audio inp glbl",
				audioOutputSKUGlobal: "gpt4o realtimePrvw audio outp glbl",

				audioInputSKURegional:  "gpt4o realtimePrvw audio inp regn",
				audioOutputSKURegional: "gpt4o realtimePrvw audio outp regn",

				audioInputSKUDataZone:  "gpt4o realtimePrvwAudInp DataZone",
				audioOutputSKUDataZone: "gpt4o realtimePrvwAudOutp DataZone",
			},
		},

		"gpt-4o-mini-realtime-preview": {
			"2024-12-17": {
				model:            "gpt-4o-mini-realtime-preview",
				version:          "2024-12-17",
				isDefaultVersion: false,

				inputSKUGlobal:  "gpt4omini-rt-txt1217 Inp glbl",
				outputSKUGlobal: "gpt4omini-rt-txt1217 Outp glbl",

				cachedInputSKUGlobal: "gpt4omini-rt-txt1217 cchd Inp glbl",

				inputSKURegional:  "gpt4omini-rt-txt1217 Inp regnl",
				outputSKURegional: "gpt4omini-rt-txt1217 Outp regnl",

				cachedInputSKURegional: "gpt4omini-rt-txt1217 cchd Inp rgnl",

				inputSKUDataZone:  "gpt4omini-rt-txt1217 Inp DZone",
				outputSKUDataZone: "gpt4omini-rt-txt1217 Outp DZone",

				cachedInputSKUDataZone: "gpt4omini-rt-txt1217 cchd Inp DZn",

				audioInputSKUGlobal:  "gpt4omini-rt-aud1217 Inp glbl",
				audioOutputSKUGlobal: "gpt4omini-rt-aud1217 Outp glbl",

				audioInputSKURegional:  "gpt4omini-rt-aud1217 Inp regnl",
				audioOutputSKURegional: "gpt4omini-rt-aud1217 Outp regnl",

				audioInputSKUDataZone:  "gpt4omini-rt-aud1217 Inp DZone",
				audioOutputSKUDataZone: "gpt4omini-rt-aud1217 Outp DZone",
			},
		},

		"computer-use-preview": {
			"global": {
				model:            "computer-use-preview",
				version:          "global",
				isDefaultVersion: true,

				inputSKUGlobal:  "computer-use-inpt-glbl",
				outputSKUGlobal: "computer-use-outp-glbl",

				inputSKURegional:  "computer-use-inpt-rgnl",
				outputSKURegional: "computer-use-outp-rgnl",

				inputSKUDataZone:  "computer-use-inpt-datazone",
				outputSKUDataZone: "computer-use-outp-datazone",

				batchInputSKUGlobal:  "computer-use-batch-inpt-glbl",
				batchOutputSKUGlobal: "computer-use-batch-outp-glbl",

				batchInputSKUDataZone:  "computer-use-batch-inpt-datazone",
				batchOutputSKUDataZone: "computer-use-batch-outp-datazone",
			},
		},

		"o1-mini": {
			"2024-09-12": {
				model:            "o1-mini",
				version:          "2024-09-12",
				isDefaultVersion: false,

				inputSKUGlobal:  "o1 mini input glbl",
				outputSKUGlobal: "o1 mini output glbl",

				inputSKURegional:  "o1 mini input regnl",
				outputSKURegional: "o1 mini output regnl",

				cachedInputSKUGlobal:   "o1 mini cached input glbl",
				cachedInputSKURegional: "o1 mini cached input regnl",
				cachedInputSKUDataZone: "o1 mini cached input Data Zone",

				inputSKUDataZone:  "o1 mini input Data Zone",
				outputSKUDataZone: "o1 mini output Data Zone",

				batchInputSKUGlobal:  "o1 mini Batch Inp glbl",
				batchOutputSKUGlobal: "o1 mini Batch Outp glbl",

				batchInputSKUDataZone:  "o1 mini Batch Inp Data Zone",
				batchOutputSKUDataZone: "o1 mini Batch Outp Data Zone",
			},
		},

		"o1": {
			"2024-12-17": {
				model:            "o1",
				version:          "2024-12-17",
				isDefaultVersion: false,

				inputSKUGlobal:  "o1 1217 Inp glbl",
				outputSKUGlobal: "o1 1217 Outp glbl",

				cachedInputSKUGlobal: "o1 1217 cached Inp glbl",

				inputSKURegional:  "o1 1217 Inp regnl",
				outputSKURegional: "o1 1217 Outp regnl",

				cachedInputSKURegional: "o1 1217 cached Inp regnl",

				inputSKUDataZone:  "o1 1217 Inp Data Zone",
				outputSKUDataZone: "o1 1217 Outp Data Zone",

				cachedInputSKUDataZone: "o1 1217 cached Inp Data Zone",

				batchInputSKUGlobal:  "o1 1217 Batch Inp glbl",
				batchOutputSKUGlobal: "o1 1217 Batch Outp glbl",

				batchInputSKUDataZone:  "o1 1217 Batch Inp Data Zone",
				batchOutputSKUDataZone: "o1 1217 Batch Outp Data Zone",
			},
		},

		"o3-mini": {
			"2025-01-31": {
				model:            "o3-mini",
				version:          "2025-01-31",
				isDefaultVersion: true,

				inputSKUGlobal:  "o3 mini 0131 input glbl",
				outputSKUGlobal: "o3 mini 0131 output glbl",

				cachedInputSKUGlobal: "o3 mini 0131 cached input glbl",

				inputSKURegional:  "o3 mini 0131 input regnl",
				outputSKURegional: "o3 mini 0131 output regnl",

				cachedInputSKURegional: "o3 mini 0131 cached input regnl",

				inputSKUDataZone:  "o3 mini 0131 input Data Zone",
				outputSKUDataZone: "o3 mini 0131 output Data Zone",

				cachedInputSKUDataZone: "o3 mini 0131 cached input Data Zone",

				batchInputSKUGlobal:  "o3 mini 0131 Batch Inp glbl",
				batchOutputSKUGlobal: "o3 mini 0131 Batch Outp glbl",

				batchInputSKUDataZone:  "o3 mini 0131 Batch Inp Data Zone",
				batchOutputSKUDataZone: "o3 mini 0131 Batch Outp Data Zone",
			},
		},
	}

	audioModels                  = map[string]struct{}{}
	languageModelDefaultVersions = map[string]string{}

	baseModelSKUs = map[string]string{
		"babbage-002": "Babbage",
		"davinci-002": "Davinci",
	}
	fineTuningSKUs = map[string]string{
		"babbage-002":      "Az-Babbage-002",
		"davinci-002":      "Az-Davinci-002",
		"gpt-35-turbo":     "Az-GPT35-Turbo-4K",
		"gpt-35-turbo-16k": "Az-GPT35-Turbo-16K",
	}

	imageSKUs = map[string]string{
		"dall-e-2": "Az-Image-DALL-E",
		"dall-e-3": "Az-Image-Dall-E-3",
	}

	embeddingSKUs = map[string]string{
		"text-embedding-ada-002": "Az-Embeddings-Ada",
		"text-embedding-3-small": "Az-Text-Embedding-3-Small",
		"text-embedding-3-large": "Az-Text-Embedding-3-Large",
	}

	speechSKUs = map[string]string{
		"whisper": "Az-Speech-Whisper",
		"tts":     "Az-Speech-Text to Speech",
		"tts-hd":  "Az-Speech-Text to Speech HD",
	}
)

func init() {
	for _, versions := range languageModelSKUs {
		for version, sku := range versions {
			if sku.isDefaultVersion {
				languageModelDefaultVersions[sku.model] = version
			}

			if len(versions) == 1 {
				languageModelDefaultVersions[sku.model] = version
			}

			if sku.audioInputSKUGlobal != "" {
				audioModels[sku.model] = struct{}{}
			}
		}
	}

}

// CognitiveDeployment struct represents an Azure OpenAI Deployment.
//
// Since the availability of models is very different across different regions we ignore any cost components
// that we don't have a price for. This is done by setting the `IgnoreIfMissingPrice` field to true.
// See the following URL for more information on different model availability in different regions:
// https://learn.microsoft.com/en-us/azure/ai-services/openai/concepts/models#standard-deployment-model-availability
//
// This only supports Pay-As-You-Go pricing tier, currently since Azure doesn't provide pricing for their
// Provisioned Throughput Units.
//
// This also doesn't support some models that have been deprecated by Azure. See the below for information on those resources:
// https://learn.microsoft.com/en-us/azure/ai-services/openai/concepts/legacy-models
//
// Resource information: https://azure.microsoft.com/en-gb/products/ai-services/openai-service
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/cognitive-services/openai-service/
type CognitiveDeployment struct {
	Address string
	Region  string
	Model   string
	Version string
	Tier    string

	SKU      string
	Capacity int64

	// Usage-based attributes
	MonthlyLanguageInputTokens       *int64   `infracost_usage:"monthly_language_input_tokens"`
	MonthlyLanguageOutputTokens      *int64   `infracost_usage:"monthly_language_output_tokens"`
	MonthlyLanguageCachedInputTokens *int64   `infracost_usage:"monthly_language_cached_input_tokens"`
	MonthlyCodeInterpreterSessions   *int64   `infracost_usage:"monthly_code_interpreter_sessions"`
	MonthlyBaseModelTokens           *int64   `infracost_usage:"monthly_base_model_tokens"`
	MonthlyFineTuningTrainingHours   *float64 `infracost_usage:"monthly_fine_tuning_training_hours"`
	MonthlyFineTuningHostingHours    *float64 `infracost_usage:"monthly_fine_tuning_hosting_hours"`
	MonthlyFineTuningInputTokens     *int64   `infracost_usage:"monthly_fine_tuning_input_tokens"`
	MonthlyFineTuningOutputTokens    *int64   `infracost_usage:"monthly_fine_tuning_output_tokens"`
	MonthlyStandard10241024Images    *int64   `infracost_usage:"monthly_standard_1024_1024_images"`
	MonthlyStandard10241792Images    *int64   `infracost_usage:"monthly_standard_1024_1792_images"`
	MonthlyHD10241024Images          *int64   `infracost_usage:"monthly_hd_1024_1024_images"`
	MonthlyHD10241792Images          *int64   `infracost_usage:"monthly_hd_1024_1792_images"`
	MonthlyTextEmbeddingTokens       *int64   `infracost_usage:"monthly_text_embedding_tokens"`
	MonthlyTextToSpeechCharacters    *int64   `infracost_usage:"monthly_text_to_speech_characters"`
	MonthlyTextToSpeechHours         *float64 `infracost_usage:"monthly_text_to_speech_hours"`
	MonthlyAudioInputTokens          *int64   `infracost_usage:"monthly_audio_input_tokens"`
	MonthlyAudioOutputTokens         *int64   `infracost_usage:"monthly_audio_output_tokens"`
	MonthlyFileSearchToolCalls       *int64   `infracost_usage:"monthly_file_search_tool_calls"`
	MonthlyFileSearchStorage         *float64 `infracost_usage:"monthly_file_search_storage_gb"`
}

// CoreType returns the name of this resource type
func (r *CognitiveDeployment) CoreType() string {
	return "CognitiveDeployment"
}

// UsageSchema defines a list which represents the usage schema of CognitiveDeployment.
func (r *CognitiveDeployment) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_language_input_tokens", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_language_output_tokens", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_code_interpreter_sessions", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_base_model_tokens", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_fine_tuning_training_hours", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_fine_tuning_hosting_hours", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_fine_tuning_input_tokens", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_fine_tuning_output_tokens", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_standard_1024_1024_images", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_standard_1024_1792_images", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_hd_1024_1024_images", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_hd_1024_1792_images", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_text_embeddings", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_text_to_speech_characters", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_text_to_speech_hours", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_audio_input_tokens", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_audio_output_tokens", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_file_search_tool_calls", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_file_search_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

// PopulateUsage parses the u schema.UsageData into the CognitiveDeployment.
// It uses the `infracost_usage` struct tags to populate data into the CognitiveDeployment.
func (r *CognitiveDeployment) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid CognitiveDeployment struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *CognitiveDeployment) BuildResource() *schema.Resource {
	if strings.EqualFold(r.Tier, "free") {
		return &schema.Resource{
			Name:      r.Address,
			NoPrice:   true,
			IsSkipped: true,
		}
	}

	costComponents := make([]*schema.CostComponent, 0)

	if _, ok := languageModelSKUs[r.Model]; ok {
		costComponents = append(costComponents, r.languageCostComponents()...)
		costComponents = append(costComponents, r.toolCallsCostComponents()...)
	}

	if _, ok := audioModels[r.Model]; ok {
		costComponents = append(costComponents, r.audioCostComponents()...)
	}

	if _, ok := baseModelSKUs[r.Model]; ok {
		costComponents = append(costComponents, r.baseModelCostComponents()...)
	}

	if _, ok := fineTuningSKUs[r.Model]; ok {
		costComponents = append(costComponents, r.fineTuningCostComponents()...)
	}

	if _, ok := imageSKUs[r.Model]; ok {
		costComponents = append(costComponents, r.imageCostComponents()...)
	}

	if _, ok := embeddingSKUs[r.Model]; ok {
		costComponents = append(costComponents, r.embeddingCostComponents()...)
	}

	if _, ok := speechSKUs[r.Model]; ok {
		costComponents = append(costComponents, r.speechCostComponents()...)
	}

	if len(costComponents) == 0 {
		logging.Logger.Warn().Msgf("Skipping resource %s. Model '%s' is not supported", r.Address, r.Model)
		return nil
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *CognitiveDeployment) audioCostComponents() []*schema.CostComponent {
	version := r.Version
	if version == "" {
		version = languageModelDefaultVersions[r.Model]
	}

	skuDetails := languageModelSKUs[r.Model][version]
	sku := skuDetails.skuName(r.SKU)

	var inputQty, outputQty *decimal.Decimal
	if r.MonthlyAudioInputTokens != nil {
		inputQty = decimalPtr(decimal.NewFromInt(*r.MonthlyAudioInputTokens).Div(decimal.NewFromInt(1_000)))
	}
	if r.MonthlyAudioOutputTokens != nil {
		outputQty = decimalPtr(decimal.NewFromInt(*r.MonthlyAudioOutputTokens).Div(decimal.NewFromInt(1_000)))
	}

	return []*schema.CostComponent{
		{
			Name:                 fmt.Sprintf("Audio input tokens (%s)", r.Model),
			Unit:                 "1k tokens",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      inputQty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(sku.audioInput)},
				},
			},
		},
		{
			Name:                 fmt.Sprintf("Audio output tokens (%s)", r.Model),
			Unit:                 "1k tokens",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      outputQty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(sku.audioOutput)},
				},
			},
		},
	}
}

func (r *CognitiveDeployment) languageCostComponents() []*schema.CostComponent {
	modelName := r.Model
	version := r.Version
	if version == "" {
		version = languageModelDefaultVersions[r.Model]
	}

	skuDetails := languageModelSKUs[r.Model][version]
	sku := skuDetails.skuName(r.SKU)

	if strings.Contains(strings.ToLower(r.SKU), "provisioned") {
		skuName := "Provisioned Managed Global"
		if strings.EqualFold(r.SKU, "DataZoneProvisionedManaged") {
			skuName = "Provisioned Managed Data Zone"
		}

		if strings.EqualFold(r.SKU, "ProvisionedManaged") {
			skuName = "Provisioned Managed Regional"
		}

		return []*schema.CostComponent{
			{
				Name:                 fmt.Sprintf("Provisioned throughput units (%s)", modelName),
				Unit:                 "hours",
				UnitMultiplier:       decimal.NewFromInt(1),
				HourlyQuantity:       decimalPtr(decimal.NewFromInt(r.Capacity)),
				IgnoreIfMissingPrice: true,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr(vendorName),
					Region:        strPtr(r.Region),
					Service:       strPtr("Cognitive Services"),
					ProductFamily: strPtr("AI + Machine Learning"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "productName", Value: strPtr("Azure OpenAI")},
						{Key: "skuName", Value: strPtr(skuName)},
					},
				},
			},
		}
	}

	var inputQty, outputQty, cachedInputQty *decimal.Decimal
	if r.MonthlyLanguageInputTokens != nil {
		inputQty = decimalPtr(decimal.NewFromInt(*r.MonthlyLanguageInputTokens).Div(decimal.NewFromInt(1_000)))
	}
	if r.MonthlyLanguageOutputTokens != nil {
		outputQty = decimalPtr(decimal.NewFromInt(*r.MonthlyLanguageOutputTokens).Div(decimal.NewFromInt(1_000)))
	}
	if r.MonthlyLanguageCachedInputTokens != nil {
		cachedInputQty = decimalPtr(decimal.NewFromInt(*r.MonthlyLanguageCachedInputTokens).Div(decimal.NewFromInt(1_000)))
	}

	return []*schema.CostComponent{
		{
			Name:                 fmt.Sprintf("Text input (%s)", modelName),
			Unit:                 "1K tokens",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      inputQty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(sku.input)},
				},
			},
		},
		{
			Name:                 fmt.Sprintf("Text output (%s)", modelName),
			Unit:                 "1K tokens",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      outputQty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(sku.output)},
				},
			},
		},
		{
			Name:                 fmt.Sprintf("Cached text input (%s)", modelName),
			Unit:                 "1K tokens",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      cachedInputQty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(sku.cachedInput)},
				},
			},
		},
	}
}

func (r *CognitiveDeployment) baseModelCostComponents() []*schema.CostComponent {
	skuPrefix := baseModelSKUs[r.Model]

	var qty *decimal.Decimal
	if r.MonthlyBaseModelTokens != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyBaseModelTokens).Div(decimal.NewFromInt(1_000)))
	}

	return []*schema.CostComponent{
		{
			Name:                 fmt.Sprintf("Base model tokens (%s)", r.Model),
			Unit:                 "1K tokens",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      qty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("%s - Base", skuPrefix))},
					{Key: "meterName", Value: strPtr(fmt.Sprintf("Text-%s Unit", skuPrefix))},
				},
			},
		},
	}
}

func (r *CognitiveDeployment) fineTuningCostComponents() []*schema.CostComponent {
	skuPrefix := fineTuningSKUs[r.Model]

	var trainingQty, hostingQty, inputQty, outputQty *decimal.Decimal
	if r.MonthlyFineTuningTrainingHours != nil {
		trainingQty = decimalPtr(decimal.NewFromFloat(*r.MonthlyFineTuningTrainingHours))
	}
	if r.MonthlyFineTuningHostingHours != nil {
		hostingQty = decimalPtr(decimal.NewFromFloat(*r.MonthlyFineTuningHostingHours))
	}
	if r.MonthlyFineTuningInputTokens != nil {
		inputQty = decimalPtr(decimal.NewFromInt(*r.MonthlyFineTuningInputTokens).Div(decimal.NewFromInt(1_000)))
	}
	if r.MonthlyFineTuningOutputTokens != nil {
		outputQty = decimalPtr(decimal.NewFromInt(*r.MonthlyFineTuningOutputTokens).Div(decimal.NewFromInt(1_000)))
	}

	return []*schema.CostComponent{
		{
			Name:                 fmt.Sprintf("Fine tuning training (%s)", r.Model),
			Unit:                 "hours",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      trainingQty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("%s-FTuned", skuPrefix))},
					{Key: "meterName", Value: strPtr(fmt.Sprintf("%s-FTuned Training Unit", skuPrefix))},
				},
			},
		},
		{
			Name:                 fmt.Sprintf("Fine tuning hosting (%s)", r.Model),
			Unit:                 "hours",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      hostingQty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("%s-FTuned", skuPrefix))},
					{Key: "meterName", Value: strPtr(fmt.Sprintf("%s-FTuned Deployment Hosting Unit", skuPrefix))},
				},
			},
		},
		{
			Name:                 fmt.Sprintf("Fine tuning input (%s)", r.Model),
			Unit:                 "1K tokens",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      inputQty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("%s-Fine Tuned-Input", skuPrefix))},
					{Key: "meterName", Value: strPtr(fmt.Sprintf("%s-Fine Tuned-Input Tokens", skuPrefix))},
				},
			},
		},
		{
			Name:                 fmt.Sprintf("Fine tuning output (%s)", r.Model),
			Unit:                 "1K tokens",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      outputQty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("%s-Fine Tuned-Output", skuPrefix))},
					{Key: "meterName", Value: strPtr(fmt.Sprintf("%s-Fine Tuned-Output Tokens", skuPrefix))},
				},
			},
		},
	}
}

func (r *CognitiveDeployment) imageCostComponents() []*schema.CostComponent {
	skuPrefix := imageSKUs[r.Model]

	var standard10241024Qty, standard10241792Qty, hd10241024Qty, hd10241792Qty *decimal.Decimal
	if r.MonthlyStandard10241024Images != nil {
		standard10241024Qty = decimalPtr(decimal.NewFromInt(*r.MonthlyStandard10241024Images).Div(decimal.NewFromInt(100)))
	}

	if r.Model == "dall-e-2" {
		return []*schema.CostComponent{
			{
				Name:                 fmt.Sprintf("Standard 1024x1024 images (%s)", r.Model),
				Unit:                 "100 images",
				UnitMultiplier:       decimal.NewFromInt(1),
				MonthlyQuantity:      standard10241024Qty,
				IgnoreIfMissingPrice: true,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr(vendorName),
					Region:        strPtr(r.Region),
					Service:       strPtr("Cognitive Services"),
					ProductFamily: strPtr("AI + Machine Learning"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "productName", Value: strPtr("Azure OpenAI")},
						{Key: "skuName", Value: strPtr(skuPrefix)},
						{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Images", skuPrefix))},
					},
				},
			},
		}
	}

	if r.MonthlyStandard10241792Images != nil {
		standard10241792Qty = decimalPtr(decimal.NewFromInt(*r.MonthlyStandard10241792Images).Div(decimal.NewFromInt(100)))
	}
	if r.MonthlyHD10241024Images != nil {
		hd10241024Qty = decimalPtr(decimal.NewFromInt(*r.MonthlyHD10241024Images).Div(decimal.NewFromInt(100)))
	}
	if r.MonthlyHD10241792Images != nil {
		hd10241792Qty = decimalPtr(decimal.NewFromInt(*r.MonthlyHD10241792Images).Div(decimal.NewFromInt(100)))
	}

	return []*schema.CostComponent{
		{
			Name:                 fmt.Sprintf("Standard 1024x1024 images (%s)", r.Model),
			Unit:                 "100 images",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      standard10241024Qty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("%s Standard LowRes", skuPrefix))},
					{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Standard LowRes Images", skuPrefix))},
				},
			},
		},
		{
			Name:                 fmt.Sprintf("Standard 1024x1792 images (%s)", r.Model),
			Unit:                 "100 images",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      standard10241792Qty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("%s Standard HighRes", skuPrefix))},
					{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Standard HighRes Images", skuPrefix))},
				},
			},
		},
		{
			Name:                 fmt.Sprintf("HD 1024x1024 images (%s)", r.Model),
			Unit:                 "100 images",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      hd10241024Qty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("%s HD LowRes", skuPrefix))},
					{Key: "meterName", Value: strPtr(fmt.Sprintf("%s HD LowRes Images", skuPrefix))},
				},
			},
		},
		{
			Name:                 fmt.Sprintf("HD 1024x1792 images (%s)", r.Model),
			Unit:                 "100 images",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      hd10241792Qty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("%s HD HighRes", skuPrefix))},
					{Key: "meterName", Value: strPtr(fmt.Sprintf("%s HD HighRes Images", skuPrefix))},
				},
			},
		},
	}
}

func (r *CognitiveDeployment) embeddingCostComponents() []*schema.CostComponent {
	sku := embeddingSKUs[r.Model]

	var qty *decimal.Decimal
	if r.MonthlyTextEmbeddingTokens != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyTextEmbeddingTokens).Div(decimal.NewFromInt(1_000)))
	}

	return []*schema.CostComponent{
		{
			Name:                 fmt.Sprintf("Text embeddings (%s)", r.Model),
			Unit:                 "1K tokens",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      qty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(sku)},
					{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Tokens", sku))},
				},
			},
		},
	}
}

func (r *CognitiveDeployment) speechCostComponents() []*schema.CostComponent {
	sku := speechSKUs[r.Model]

	var qty *decimal.Decimal

	if r.Model == "whisper" {
		if r.MonthlyTextToSpeechHours != nil {
			qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyTextToSpeechHours))
		}

		return []*schema.CostComponent{
			{
				Name:                 fmt.Sprintf("Text to speech (%s)", r.Model),
				Unit:                 "hours",
				UnitMultiplier:       decimal.NewFromInt(1),
				MonthlyQuantity:      qty,
				IgnoreIfMissingPrice: true,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr(vendorName),
					Region:        strPtr(r.Region),
					Service:       strPtr("Cognitive Services"),
					ProductFamily: strPtr("AI + Machine Learning"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "productName", Value: strPtr("Azure OpenAI")},
						{Key: "skuName", Value: strPtr(sku)},
						{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Speech to Text Batch", sku))},
					},
				},
			},
		}
	}

	if r.MonthlyTextToSpeechCharacters != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyTextToSpeechCharacters).Div(decimal.NewFromInt(1_000_000)))
	}

	return []*schema.CostComponent{
		{
			Name:                 fmt.Sprintf("Text to speech (%s)", r.Model),
			Unit:                 "1M characters",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      qty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr(sku)},
					{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Characters", sku))},
				},
			},
		},
	}
}

func (r *CognitiveDeployment) toolCallsCostComponents() []*schema.CostComponent {
	var toolCallsQty *decimal.Decimal
	if r.MonthlyFileSearchToolCalls != nil {
		toolCallsQty = decimalPtr(decimal.NewFromInt(*r.MonthlyFileSearchToolCalls).Div(decimal.NewFromInt(1_000)))
	}

	var storageQty *decimal.Decimal
	if r.MonthlyFileSearchStorage != nil {
		storageQty = decimalPtr(decimal.NewFromFloat(*r.MonthlyFileSearchStorage))
	}

	var qty *decimal.Decimal
	if r.MonthlyCodeInterpreterSessions != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyCodeInterpreterSessions))
	}

	return []*schema.CostComponent{
		{
			Name:                 "File search tool calls",
			Unit:                 "1k calls",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      toolCallsQty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr("file-search-tool-calls-glbl")},
				},
			},
		},
		{
			Name:                 "File search vector storage",
			Unit:                 "GB",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      storageQty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr("Assistants-File Search-glbl")},
				},
			},
		},
		{
			Name:                 "Code interpreter sessions",
			Unit:                 "sessions",
			UnitMultiplier:       decimal.NewFromInt(1),
			MonthlyQuantity:      qty,
			IgnoreIfMissingPrice: true,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cognitive Services"),
				ProductFamily: strPtr("AI + Machine Learning"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Azure OpenAI")},
					{Key: "skuName", Value: strPtr("Az-Assistants-Code-Interpreter")},
					{Key: "meterName", Value: strPtr("Az-Assistants-Code-Interpreter Session")},
				},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/azure/container_registry.go
# RESOURCE: azure_container_registry
# SIZE: 6350 bytes | LINES: 165
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type ContainerRegistry struct {
	Address                 string
	GeoReplicationLocations int
	Region                  string
	SKU                     string
	StorageGB               *float64 `infracost_usage:"storage_gb"`
	MonthlyBuildVCPUHrs     *float64 `infracost_usage:"monthly_build_vcpu_hrs"`
}

func (r *ContainerRegistry) CoreType() string {
	return "ContainerRegistry"
}

func (r *ContainerRegistry) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "storage_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_build_vcpu_hrs", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *ContainerRegistry) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ContainerRegistry) BuildResource() *schema.Resource {

	var locationsCount int
	var storageGB, monthlyBuildVCPU *decimal.Decimal
	var overStorage decimal.Decimal

	sku := "Classic"
	includedStorage := decimal.NewFromFloat(10)

	if r.SKU != "" {
		sku = r.SKU
	}

	switch sku {
	case "Basic":
		includedStorage = decimal.NewFromFloat(10)
	case "Standard":
		includedStorage = decimal.NewFromFloat(100)
	case "Premium":
		includedStorage = decimal.NewFromFloat(500)
	}

	locationsCount = r.GeoReplicationLocations

	costComponents := make([]*schema.CostComponent, 0)

	if locationsCount > 0 {
		suffix := fmt.Sprintf("%d locations", locationsCount)
		if locationsCount == 1 {
			suffix = fmt.Sprintf("%d location", locationsCount)
		}
		costComponents = append(costComponents, r.containerRegistryGeolocationCostComponent(fmt.Sprintf("Geo replication (%s)", suffix), sku))
	}

	costComponents = append(costComponents, r.containerRegistryCostComponent(fmt.Sprintf("Registry usage (%s)", sku), sku))

	if r.StorageGB != nil {
		storageGB = decimalPtr(decimal.NewFromFloat(*r.StorageGB))
		if storageGB.GreaterThan(includedStorage) {
			overStorage = storageGB.Sub(includedStorage)
			storageGB = &overStorage
			costComponents = append(costComponents, r.containerRegistryStorageCostComponent(fmt.Sprintf("Storage (over %sGB)", includedStorage), sku, storageGB))
		}
	} else {
		costComponents = append(costComponents, r.containerRegistryStorageCostComponent(fmt.Sprintf("Storage (over %sGB)", includedStorage), sku, storageGB))
	}

	if r.MonthlyBuildVCPUHrs != nil {
		monthlyBuildVCPU = decimalPtr(decimal.NewFromFloat(*r.MonthlyBuildVCPUHrs * 3600))
	}

	costComponents = append(costComponents, r.containerRegistryCPUCostComponent("Build vCPU", sku, monthlyBuildVCPU))

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *ContainerRegistry) containerRegistryCostComponent(name, sku string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "days",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(30)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Container Registry"),
			ProductFamily: strPtr("Containers"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Container Registry")},
				{Key: "skuName", Value: strPtr(sku)},
				{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Registry Unit", sku))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}
func (r *ContainerRegistry) containerRegistryGeolocationCostComponent(name, sku string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "days",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(30 * int64(r.GeoReplicationLocations))),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Container Registry"),
			ProductFamily: strPtr("Containers"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Container Registry")},
				{Key: "skuName", Value: strPtr(sku)},
				{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Registry Unit", sku))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}
func (r *ContainerRegistry) containerRegistryStorageCostComponent(name, sku string, storage *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{

		Name:            name,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: storage,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Container Registry"),
			ProductFamily: strPtr("Containers"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Container Registry")},
				{Key: "skuName", Value: strPtr(sku)},
				{Key: "meterName", Value: strPtr("Data Stored")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	}
}
func (r *ContainerRegistry) containerRegistryCPUCostComponent(name, sku string, monthlyBuildVCPU *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{

		Name:            name,
		Unit:            "seconds",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: monthlyBuildVCPU,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Container Registry"),
			ProductFamily: strPtr("Containers"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Container Registry")},
				{Key: "skuName", Value: strPtr(sku)},
				{Key: "meterName", Value: strPtr("Task vCPU Duration")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("6000"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/data_factory.go
# RESOURCE: azure_data_factory
# SIZE: 4385 bytes | LINES: 109
################################################################################
package azure

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// DataFactory struct represents Azure Data Factory resource.
//
// Resource information: https://azure.microsoft.com/en-us/services/data-factory/
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/data-factory/data-pipeline/
type DataFactory struct {
	Address string
	Region  string

	// "usage" args
	MonthlyReadWriteOperationEntities  *int64 `infracost_usage:"monthly_read_write_operation_entities"`
	MonthlyMonitoringOperationEntities *int64 `infracost_usage:"monthly_monitoring_operation_entities"`
}

func (r *DataFactory) CoreType() string {
	return "DataFactory"
}

func (r *DataFactory) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_read_write_operation_entities", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_monitoring_operation_entities", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the DataFactory.
// It uses the `infracost_usage` struct tags to populate data into the DataFactory.
func (r *DataFactory) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid DataFactory struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *DataFactory) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.readWriteOperationsCostComponent(),
		r.monitoringOperationsCostComponent(),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

// readWriteOperationsCostComponent returns a cost component for
// Data Factory's Read/Write operations.
//
// The pricing is identical for all integration runtimes.
func (r *DataFactory) readWriteOperationsCostComponent() *schema.CostComponent {
	var quantity *decimal.Decimal
	divider := decimal.NewFromInt(50000)

	if r.MonthlyReadWriteOperationEntities != nil {
		quantity = decimalPtr(decimal.NewFromInt(*r.MonthlyReadWriteOperationEntities).Div(divider))
	}

	return &schema.CostComponent{
		Name:            "Read/Write operations",
		Unit:            "50k entities",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Data Factory v2"),
			ProductFamily: strPtr("Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: regexPtr("^Cloud Read Write Operations$")},
				{Key: "skuName", ValueRegex: regexPtr("^Cloud$")},
				{Key: "productName", ValueRegex: regexPtr("^Azure Data Factory v2$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	}
}

// monitoringOperationsCostComponent returns a cost component for
// Data Factory's Monitoring operations.
//
// The pricing is identical for all integration runtimes.
func (r *DataFactory) monitoringOperationsCostComponent() *schema.CostComponent {
	var quantity *decimal.Decimal
	divider := decimal.NewFromInt(50000)

	if r.MonthlyMonitoringOperationEntities != nil {
		quantity = decimalPtr(decimal.NewFromInt(*r.MonthlyMonitoringOperationEntities).Div(divider))
	}

	return &schema.CostComponent{
		Name:            "Monitoring operations",
		Unit:            "50k entities",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Data Factory v2"),
			ProductFamily: strPtr("Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: regexPtr("^Cloud Monitoring Operations$")},
				{Key: "skuName", ValueRegex: regexPtr("^Cloud$")},
				{Key: "productName", ValueRegex: regexPtr("^Azure Data Factory v2$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/data_factory_integration_runtime_azure.go
# RESOURCE: azure_data_factory_integration_runtime_azure
# SIZE: 7531 bytes | LINES: 180
################################################################################
package azure

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// DataFactoryIntegrationRuntimeAzure struct represents Azure Data Factory's
// runtime flow.
//
// Resource information: https://azure.microsoft.com/en-us/services/data-factory/
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/data-factory/data-pipeline/
type DataFactoryIntegrationRuntimeAzure struct {
	Address string
	Region  string

	Cores       int64
	ComputeType string

	// "usage" args
	MonthlyOrchestrationRuns *int64 `infracost_usage:"monthly_orchestration_runs"`
}

func (r *DataFactoryIntegrationRuntimeAzure) CoreType() string {
	return "DataFactoryIntegrationRuntimeAzure"
}

func (r *DataFactoryIntegrationRuntimeAzure) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_orchestration_runs", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the DataFactoryIntegrationRuntimeAzure.
// It uses the `infracost_usage` struct tags to populate data into the DataFactoryIntegrationRuntimeAzure.
func (r *DataFactoryIntegrationRuntimeAzure) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid DataFactoryIntegrationRuntimeAzure struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *DataFactoryIntegrationRuntimeAzure) BuildResource() *schema.Resource {
	runtimeFilter := "Cloud"

	costComponents := []*schema.CostComponent{
		r.computeCostComponent(),
		dataFactoryOrchestrationCostComponent(r.Region, runtimeFilter, r.MonthlyOrchestrationRuns),
		dataFactoryDataMovementCostComponent(r.Region, runtimeFilter),
		dataFactoryPipelineCostComponent(r.Region, runtimeFilter),
		dataFactoryExternalPipelineCostComponent(r.Region, runtimeFilter),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

// computeCostComponent returns a cost component for cluster configuration.
//
// CPAPI contains 2 records with the same price, but one is newer and its
// armSkuName is not empty thus using a non-empty filter.
func (r *DataFactoryIntegrationRuntimeAzure) computeCostComponent() *schema.CostComponent {

	productType := map[string]string{
		"general":           "General Purpose",
		"compute_optimized": "Compute Optimized",
		"memory_optimized":  "Memory Optimized",
	}[r.ComputeType]

	name := fmt.Sprintf("Compute (%s, %d vCores)", productType, r.Cores)

	return &schema.CostComponent{
		Name:           name,
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(r.Cores),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(r.Cores)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Data Factory v2"),
			ProductFamily: strPtr("Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", ValueRegex: regexPtr("^vCore$")},
				{Key: "productName", ValueRegex: regexPtr(fmt.Sprintf("^Azure Data Factory v2 Data Flow - %s$", productType))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

func dataFactoryOrchestrationCostComponent(region string, filter string, runs *int64) *schema.CostComponent {
	var quantity *decimal.Decimal
	divider := decimal.NewFromInt(1000)

	if runs != nil {
		quantity = decimalPtr(decimal.NewFromInt(*runs).Div(divider))
	}

	return &schema.CostComponent{
		Name:            "Orchestration",
		Unit:            "1k runs",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(region),
			Service:       strPtr("Azure Data Factory v2"),
			ProductFamily: strPtr("Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("^%s Orchestration Activity Run$", filter))},
				{Key: "skuName", ValueRegex: regexPtr(fmt.Sprintf("^%s$", filter))},
				{Key: "productName", ValueRegex: regexPtr("^Azure Data Factory v2$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	}
}

func dataFactoryDataMovementCostComponent(region string, filter string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Data movement activity",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(region),
			Service:       strPtr("Azure Data Factory v2"),
			ProductFamily: strPtr("Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("^%s Data Movement$", filter))},
				{Key: "skuName", ValueRegex: regexPtr(fmt.Sprintf("^%s$", filter))},
				{Key: "productName", ValueRegex: regexPtr("^Azure Data Factory v2$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

// dataFactoryPipelineCostComponent returns a cost component for Data Factory
// runtime's pipeline activity.
func dataFactoryPipelineCostComponent(region string, filter string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Pipeline activity",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(region),
			Service:       strPtr("Azure Data Factory v2"),
			ProductFamily: strPtr("Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("^%s Pipeline Activity$", filter))},
				{Key: "skuName", ValueRegex: regexPtr(fmt.Sprintf("^%s$", filter))},
				{Key: "productName", ValueRegex: regexPtr("^Azure Data Factory v2$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

// dataFactoryExternalPipelineCostComponent returns a cost component for Data
// Factory runtime's external pipeline activity.
func dataFactoryExternalPipelineCostComponent(region string, filter string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "External pipeline activity",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(region),
			Service:       strPtr("Azure Data Factory v2"),
			ProductFamily: strPtr("Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("^%s External Pipeline Activity$", filter))},
				{Key: "skuName", ValueRegex: regexPtr(fmt.Sprintf("^%s$", filter))},
				{Key: "productName", ValueRegex: regexPtr("^Azure Data Factory v2$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

################################################################################
# FILE: internal/resources/azure/data_factory_integration_runtime_azure_ssis.go
# RESOURCE: azure_data_factory_integration_runtime_azure_ssis
# SIZE: 2996 bytes | LINES: 77
################################################################################
package azure

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// DataFactoryIntegrationRuntimeAzureSSIS struct represents Data Factory's
// Azure-SSIS runtime.
//
// Resource information: https://azure.microsoft.com/en-us/services/data-factory/
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/data-factory/ssis/
type DataFactoryIntegrationRuntimeAzureSSIS struct {
	Address string
	Region  string

	Instances       int64
	InstanceType    string
	Enterprise      bool
	LicenseIncluded bool
}

func (r *DataFactoryIntegrationRuntimeAzureSSIS) CoreType() string {
	return "DataFactoryIntegrationRuntimeAzureSSIS"
}

func (r *DataFactoryIntegrationRuntimeAzureSSIS) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the DataFactoryIntegrationRuntimeAzureSSIS.
// It uses the `infracost_usage` struct tags to populate data into the DataFactoryIntegrationRuntimeAzureSSIS.
func (r *DataFactoryIntegrationRuntimeAzureSSIS) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid DataFactoryIntegrationRuntimeAzureSSIS struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *DataFactoryIntegrationRuntimeAzureSSIS) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.computeCostComponent(),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

// computeCostComponent returns a cost component for cluster configuration.
func (r *DataFactoryIntegrationRuntimeAzureSSIS) computeCostComponent() *schema.CostComponent {
	tier := "Standard"
	if r.Enterprise {
		tier = "Enterprise"
	}

	license := "License Included"
	licenseTitle := ", license included"
	if !r.LicenseIncluded {
		license = "AHB"
		licenseTitle = ""
	}

	return &schema.CostComponent{
		Name:           fmt.Sprintf("Compute (%s, %s%s)", r.InstanceType, tier, licenseTitle),
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(r.Instances)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Data Factory v2"),
			ProductFamily: strPtr("Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: regexPtr(license)},
				{Key: "skuName", ValueRegex: regexPtr(fmt.Sprintf("^%s$", r.InstanceType))},
				{Key: "productName", ValueRegex: regexPtr(fmt.Sprintf("^SSIS %s", tier))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

################################################################################
# FILE: internal/resources/azure/data_factory_integration_runtime_managed.go
# RESOURCE: azure_data_factory_integration_runtime_managed
# SIZE: 2686 bytes | LINES: 62
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// DataFactoryIntegrationRuntimeManaged struct represents Data Factory's Managed
// VNET integration runtime.
//
// Resource information: https://azure.microsoft.com/en-us/services/data-factory/
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/data-factory/data-pipeline/
type DataFactoryIntegrationRuntimeManaged struct {
	Address string
	Region  string

	Instances       int64
	InstanceType    string
	Enterprise      bool
	LicenseIncluded bool

	// "usage" args
	MonthlyOrchestrationRuns *int64 `infracost_usage:"monthly_orchestration_runs"`
}

func (r *DataFactoryIntegrationRuntimeManaged) CoreType() string {
	return "DataFactoryIntegrationRuntimeManaged"
}

func (r *DataFactoryIntegrationRuntimeManaged) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_orchestration_runs", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the DataFactoryIntegrationRuntimeManaged.
// It uses the `infracost_usage` struct tags to populate data into the DataFactoryIntegrationRuntimeManaged.
func (r *DataFactoryIntegrationRuntimeManaged) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid DataFactoryIntegrationRuntimeManaged struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *DataFactoryIntegrationRuntimeManaged) BuildResource() *schema.Resource {
	runtimeFilter := "Azure Managed VNET"

	// SSIS and Managed runtime resources share the same compute configuration.
	// Terraform provider has deprecated Managed VNET runtime resource in favor of
	// SSIS one.
	ssis := DataFactoryIntegrationRuntimeAzureSSIS{
		Address:         r.Address,
		Region:          r.Region,
		Enterprise:      r.Enterprise,
		LicenseIncluded: r.LicenseIncluded,
		Instances:       r.Instances,
		InstanceType:    r.InstanceType,
	}

	costComponents := []*schema.CostComponent{
		ssis.computeCostComponent(),
		dataFactoryOrchestrationCostComponent(r.Region, runtimeFilter, r.MonthlyOrchestrationRuns),
		dataFactoryDataMovementCostComponent(r.Region, runtimeFilter),
		dataFactoryPipelineCostComponent(r.Region, runtimeFilter),
		dataFactoryExternalPipelineCostComponent(r.Region, runtimeFilter),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

################################################################################
# FILE: internal/resources/azure/data_factory_integration_runtime_self_hosted.go
# RESOURCE: azure_data_factory_integration_runtime_self_hosted
# SIZE: 2134 bytes | LINES: 46
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// DataFactoryIntegrationRuntimeSelfHosted struct represents Data Factory's
// Self-hosted runtime.
//
// Resource information: https://azure.microsoft.com/en-us/services/data-factory/
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/data-factory/data-pipeline/
type DataFactoryIntegrationRuntimeSelfHosted struct {
	Address string
	Region  string

	// "usage" args
	MonthlyOrchestrationRuns *int64 `infracost_usage:"monthly_orchestration_runs"`
}

func (r *DataFactoryIntegrationRuntimeSelfHosted) CoreType() string {
	return "DataFactoryIntegrationRuntimeSelfHosted"
}

func (r *DataFactoryIntegrationRuntimeSelfHosted) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_orchestration_runs", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the DataFactoryIntegrationRuntimeSelfHosted.
// It uses the `infracost_usage` struct tags to populate data into the DataFactoryIntegrationRuntimeSelfHosted.
func (r *DataFactoryIntegrationRuntimeSelfHosted) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid DataFactoryIntegrationRuntimeSelfHosted struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *DataFactoryIntegrationRuntimeSelfHosted) BuildResource() *schema.Resource {
	runtimeFilter := "Self Hosted"

	costComponents := []*schema.CostComponent{
		dataFactoryOrchestrationCostComponent(r.Region, runtimeFilter, r.MonthlyOrchestrationRuns),
		dataFactoryDataMovementCostComponent(r.Region, runtimeFilter),
		dataFactoryPipelineCostComponent(r.Region, runtimeFilter),
		dataFactoryExternalPipelineCostComponent(r.Region, runtimeFilter),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

################################################################################
# FILE: internal/resources/azure/databricks_workspace.go
# RESOURCE: azure_databricks_workspace
# SIZE: 3358 bytes | LINES: 93
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type DatabricksWorkspace struct {
	Address                        string
	Region                         string
	SKU                            string
	MonthlyAllPurposeComputeDBUHrs *int64 `infracost_usage:"monthly_all_purpose_compute_dbu_hrs"`
	MonthlyJobsComputeDBUHrs       *int64 `infracost_usage:"monthly_jobs_compute_dbu_hrs"`
	MonthlyJobsLightComputeDBUHrs  *int64 `infracost_usage:"monthly_jobs_light_compute_dbu_hrs"`
}

func (r *DatabricksWorkspace) CoreType() string {
	return "DatabricksWorkspace"
}

func (r *DatabricksWorkspace) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_all_purpose_compute_dbu_hrs", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_jobs_compute_dbu_hrs", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_jobs_light_compute_dbu_hrs", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *DatabricksWorkspace) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DatabricksWorkspace) BuildResource() *schema.Resource {
	var costComponents []*schema.CostComponent

	sku := cases.Title(language.English).String(r.SKU)

	if sku == "Trial" {
		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	var allPurpose, jobs, jobsLight *decimal.Decimal

	if r.MonthlyAllPurposeComputeDBUHrs != nil {
		allPurpose = decimalPtr(decimal.NewFromInt(*r.MonthlyAllPurposeComputeDBUHrs))
	}
	costComponents = append(costComponents, r.databricksCostComponent(
		"All-purpose compute DBUs",
		fmt.Sprintf("%s All-purpose Compute", sku),
		allPurpose,
	))

	if r.MonthlyJobsComputeDBUHrs != nil {
		jobs = decimalPtr(decimal.NewFromInt(*r.MonthlyJobsComputeDBUHrs))
	}
	costComponents = append(costComponents, r.databricksCostComponent(
		"Jobs compute DBUs",
		fmt.Sprintf("%s Jobs Compute", sku),
		jobs,
	))

	if r.MonthlyJobsLightComputeDBUHrs != nil {
		jobsLight = decimalPtr(decimal.NewFromInt(*r.MonthlyJobsLightComputeDBUHrs))
	}
	costComponents = append(costComponents, r.databricksCostComponent(
		"Jobs light compute DBUs",
		fmt.Sprintf("%s Jobs Light Compute", sku),
		jobsLight,
	))

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *DatabricksWorkspace) databricksCostComponent(name, skuName string, quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "DBU-hours",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Databricks"),
			ProductFamily: strPtr("Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(skuName)},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/dns_a_record.go
# RESOURCE: azure_dns_a_record
# SIZE: 3208 bytes | LINES: 83
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/usage"
)

type DNSARecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *DNSARecord) CoreType() string {
	return "DNSARecord"
}

func (r *DNSARecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *DNSARecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DNSARecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}
func dnsQueriesCostComponent(region string, monthlyQueries *int64) []*schema.CostComponent {
	var monthlyQueriesDec *decimal.Decimal
	var requestQuantities []decimal.Decimal
	costComponents := make([]*schema.CostComponent, 0)
	requests := []int{1000000000}

	if strings.HasPrefix(strings.ToLower(region), "usgov") {
		region = "US Gov Zone 1"
	}
	if strings.HasPrefix(strings.ToLower(region), "germany") {
		region = "DE Zone 1"
	}
	if strings.HasPrefix(strings.ToLower(region), "china") {
		region = "Zone 1 (China)"
	}
	if region != "US Gov Zone 1" && region != "DE Zone 1" && region != "Zone 1 (China)" {
		region = "Zone 1"
	}

	if monthlyQueries != nil {
		monthlyQueriesDec = decimalPtr(decimal.NewFromInt(*monthlyQueries))
		requestQuantities = usage.CalculateTierBuckets(*monthlyQueriesDec, requests)
		firstBqueries := requestQuantities[0].Div(decimal.NewFromInt(1000000))
		overBqueries := requestQuantities[1].Div(decimal.NewFromInt(1000000))
		costComponents = append(costComponents, dnsQueriesFirstCostComponent(region, "DNS queries (first 1B)", "0", &firstBqueries))

		if requestQuantities[1].GreaterThan(decimal.NewFromInt(0)) {
			costComponents = append(costComponents, dnsQueriesFirstCostComponent(region, "DNS queries (over 1B)", "1000", &overBqueries))
		}
	} else {
		var unknown *decimal.Decimal

		costComponents = append(costComponents, dnsQueriesFirstCostComponent(region, "DNS queries (first 1B)", "0", unknown))
	}

	return costComponents
}

func dnsQueriesFirstCostComponent(region, name, startUsage string, monthlyQueries *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "1M queries",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: monthlyQueries,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(region),
			Service:       strPtr("Azure DNS"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr("Public Queries")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: &startUsage,
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/dns_aaaa_record.go
# RESOURCE: azure_dns_aaaa_record
# SIZE: 856 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type DNSAAAARecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *DNSAAAARecord) CoreType() string {
	return "DNSAAAARecord"
}

func (r *DNSAAAARecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *DNSAAAARecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DNSAAAARecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/dns_caa_record.go
# RESOURCE: azure_dns_caa_record
# SIZE: 850 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type DNSCAARecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *DNSCAARecord) CoreType() string {
	return "DNSCAARecord"
}

func (r *DNSCAARecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *DNSCAARecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DNSCAARecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/dns_cname_record.go
# RESOURCE: azure_dns_cname_record
# SIZE: 862 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type DNSCNameRecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *DNSCNameRecord) CoreType() string {
	return "DNSCNameRecord"
}

func (r *DNSCNameRecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *DNSCNameRecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DNSCNameRecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/dns_mx_record.go
# RESOURCE: azure_dns_mx_record
# SIZE: 844 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type DNSMXRecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *DNSMXRecord) CoreType() string {
	return "DNSMXRecord"
}

func (r *DNSMXRecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *DNSMXRecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DNSMXRecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/dns_ns_record.go
# RESOURCE: azure_dns_ns_record
# SIZE: 844 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type DNSNSRecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *DNSNSRecord) CoreType() string {
	return "DNSNSRecord"
}

func (r *DNSNSRecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *DNSNSRecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DNSNSRecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/dns_ptr_record.go
# RESOURCE: azure_dns_ptr_record
# SIZE: 850 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type DNSPtrRecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *DNSPtrRecord) CoreType() string {
	return "DNSPtrRecord"
}

func (r *DNSPtrRecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *DNSPtrRecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DNSPtrRecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/dns_srv_record.go
# RESOURCE: azure_dns_srv_record
# SIZE: 850 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type DNSSrvRecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *DNSSrvRecord) CoreType() string {
	return "DNSSrvRecord"
}

func (r *DNSSrvRecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *DNSSrvRecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DNSSrvRecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/dns_txt_record.go
# RESOURCE: azure_dns_txt_record
# SIZE: 850 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type DNSTxtRecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *DNSTxtRecord) CoreType() string {
	return "DNSTxtRecord"
}

func (r *DNSTxtRecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *DNSTxtRecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DNSTxtRecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/dns_zone.go
# RESOURCE: azure_dns_zone
# SIZE: 1892 bytes | LINES: 60
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"strings"

	"github.com/shopspring/decimal"
)

type DNSZone struct {
	Address string
	Region  string
}

func (r *DNSZone) CoreType() string {
	return "DNSZone"
}

func (r *DNSZone) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *DNSZone) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DNSZone) BuildResource() *schema.Resource {

	var region string
	if strings.HasPrefix(strings.ToLower(r.Region), "usgov") {
		region = "US Gov Zone 1"
	} else if strings.HasPrefix(strings.ToLower(r.Region), "germany") {
		region = "DE Zone 1"
	} else if strings.HasPrefix(strings.ToLower(r.Region), "china") {
		region = "Zone 1 (China)"
	} else {
		region = "Zone 1"
	}

	costComponents := make([]*schema.CostComponent, 0)

	costComponents = append(costComponents, hostedPublicZoneCostComponent(region))
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func hostedPublicZoneCostComponent(region string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Hosted zone",
		Unit:            "months",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(region),
			Service:       strPtr("Azure DNS"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: regexPtr("Public Zone(s)?")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("0"),
		},
	}
}

################################################################################
# FILE: internal/resources/azure/eventgrid_topic.go
# RESOURCE: azure_eventgrid_topic
# SIZE: 4198 bytes | LINES: 100
################################################################################
package azure

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// EventGridTopic struct represents an Azure Event Grid Topic, a fully managed
// event routing service that simplifies the process of creating and managing
// event-driven applications.
//
// Azure Event Grid allows you to build reactive applications by reacting to
// events from various Azure services, custom sources, or on-premises
// infrastructure.
//
// EventGridTopic is used for both System (azurerm_eventgrid_system_topic) and
// Custom (azurerm_eventgrid_topic) topics.
//
// System Topics are predefined, multi-tenant topics that are built-in to Azure
// services and emit events directly from the service. Custom Topics are
// application and solution-specific topics that you define for your own
// applications to publish events to.
//
// For more information about Azure Event Grid System Topics and pricing, refer
// to the following links:
//
// System topic information: https://docs.microsoft.com/en-us/azure/event-grid/system-topics
// Custom topic information: https://learn.microsoft.com/en-us/azure/event-grid/custom-topics
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/event-grid/
type EventGridTopic struct {
	Address           string
	Region            string
	MonthlyOperations *float64 `infracost_usage:"monthly_operations"`
}

// CoreType returns the name of this resource type
func (r *EventGridTopic) CoreType() string {
	return "EventGridTopic"
}

// UsageSchema defines a list which represents the usage schema of EventGridTopic.
func (r *EventGridTopic) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{
			Key:       "monthly_operations",
			ValueType: schema.Float64,
		},
	}
}

// PopulateUsage parses the u schema.UsageData into the EventGridTopic.
// It uses the `infracost_usage` struct tags to populate data into the EventGridTopic.
func (r *EventGridTopic) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid EventGridTopic struct.
// This method is called after the resource is initialized by an IAC provider.
// See providers folder for more information.
//
// The returned resource includes a CostComponent for Event Grid operations,
// taking into account the user's specified number of monthly operations. Azure
// Event Grid pricing is based on the number of operations, where each operation
// is defined as an event ingress, delivery attempt, or management call. The
// pricing is tiered, with the first 100,000 operations free, and then billed per
// 100k operations thereafter.
//
// Note: The pricing page for Azure Event Grid mistakenly describes that it is
// billed per million operations. This is incorrect and has been verified by the
// https://azure.microsoft.com/en-us/pricing/calculator/ and information in the
// cloud pricing API.
func (r *EventGridTopic) BuildResource() *schema.Resource {
	var quantity *decimal.Decimal
	if r.MonthlyOperations != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyOperations).Div(decimal.NewFromInt(100000)).RoundDown(0))
	}

	costComponents := []*schema.CostComponent{
		{
			Name:            "Operations",
			Unit:            "100k operations",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: quantity,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("Event Grid"),
				ProductFamily: strPtr("Internet of Things"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "skuName", Value: strPtr("Standard")},
					{Key: "meterName", Value: strPtr("Standard Operations")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption:   strPtr("Consumption"),
				StartUsageAmount: strPtr("1"),
			},
			UsageBased: true,
		},
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

################################################################################
# FILE: internal/resources/azure/express_route_connection.go
# RESOURCE: azure_express_route_connection
# SIZE: 2625 bytes | LINES: 61
################################################################################
package azure

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// ExpressRouteConnection represents an Express Route Gateway connection, which is a billable component
// of ExpressRouteGateway. See ExpressRouteGateway for more information.
//
// More resource information here: https://docs.microsoft.com/en-us/azure/virtual-wan/virtual-wan-about
// Pricing information here: https://azure.microsoft.com/en-us/pricing/details/virtual-wan/
type ExpressRouteConnection struct {
	// Address is the unique name of the resource in the IAC language.
	Address string
	// Region is the azure region the ExpressRouteConnection is provisioned within.
	Region string
}

func (e *ExpressRouteConnection) CoreType() string {
	return "ExpressRouteConnection"
}

// UsageSchema defines a list which represents the usage schema of EventGridTopic.
func (e *ExpressRouteConnection) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the ExpressRouteConnection.
// It uses the `infracost_usage` struct tags to populate data into the ExpressRouteConnection.
func (e *ExpressRouteConnection) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(e, u)
}

// BuildResource builds a schema.Resource from a valid ExpressRouteConnection.
// It returns a ExpressRouteConnection as a schema.Resource with a single cost component representing the
// connection unit. The hourly quantity is set to 1 as ExpressRouteConnection represents a single connection unit.
//
// This method is called after the resource is initialised by an iac provider.
// See providers folder for more information.
func (e *ExpressRouteConnection) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        e.Address,
		UsageSchema: e.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			{
				Name:           "ER Connections",
				Unit:           "hours",
				UnitMultiplier: decimal.NewFromInt(1),
				HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("azure"),
					Region:        strPtr(e.Region),
					Service:       strPtr("Virtual WAN"),
					ProductFamily: strPtr("Networking"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "skuName", Value: strPtr("ExpressRoute Connection Unit")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					PurchaseOption: strPtr("Consumption"),
				},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/azure/express_route_gateway.go
# RESOURCE: azure_express_route_gateway
# SIZE: 2753 bytes | LINES: 64
################################################################################
package azure

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// ExpressRouteGateway is a Virtual WAN gateway that provides direct connectivity to Azure cloud services.
// All transferred data is not encrypted, and do not go over the public Internet.
//
// More resource information here: https://docs.microsoft.com/en-us/azure/expressroute/expressroute-about-virtual-network-gateways
// Pricing information here: https://azure.microsoft.com/en-us/pricing/details/virtual-wan/
type ExpressRouteGateway struct {
	// Address is the unique name of the resource in the IAC language.
	Address string
	// Region is the azure region the VPNGateway is provisioned within.
	Region string
	// ScaleUnits represents a unit defined to pick an aggregate throughput of a gateway in Virtual hub.
	// 1 scale unit of ExpressRoute = 2 Gbps.
	ScaleUnits int64
}

func (e *ExpressRouteGateway) CoreType() string {
	return "ExpressRouteGateway"
}

// UsageSchema defines a list which represents the usage schema of EventGridTopic.
func (e *ExpressRouteGateway) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the ExpressRouteGateway.
// It uses the `infracost_usage` struct tags to populate data into the ExpressRouteGateway.
func (e *ExpressRouteGateway) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(e, u)
}

// BuildResource builds a schema.Resource from a valid ExpressRouteGateway.
// It returns ExpressRouteGateway with a single cost component "ER scale units".
// See more about scale units reading ExpressRouteGateway.ScaleUnits.
//
// This method is called after the resource is initialised by an iac provider.
// See providers folder for more information.
func (e *ExpressRouteGateway) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        e.Address,
		UsageSchema: e.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			{
				Name:           "ER scale units (2 Gbps)",
				Unit:           "scale units",
				UnitMultiplier: schema.HourToMonthUnitMultiplier,
				HourlyQuantity: decimalPtr(decimal.NewFromInt(e.ScaleUnits)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("azure"),
					Region:        strPtr(e.Region),
					Service:       strPtr("Virtual WAN"),
					ProductFamily: strPtr("Networking"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "skuName", Value: strPtr("ExpressRoute Scale Unit")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					PurchaseOption: strPtr("Consumption"),
				},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/azure/federated_identity_credential.go
# RESOURCE: azure_federated_identity_credential
# SIZE: 4565 bytes | LINES: 108
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// FederatedIdentityCredential struct represents an Azure Federated Identity
// Credential. are a new type of credential that enables workload identity
// federation for software workloads. Workload identity federation allows you to
// access Microsoft Entra protected resources without needing to manage secrets
// (for supported scenarios).
//
// Resource information: https://learn.microsoft.com/en-us/graph/api/resources/federatedidentitycredentials-overview?view=graph-rest-1.0
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/active-directory-external-identities/
type FederatedIdentityCredential struct {
	Address string
	Region  string

	MonthlyActiveP1Users *int64 `infracost_usage:"monthly_active_p1_users"`
	MonthlyActiveP2Users *int64 `infracost_usage:"monthly_active_p2_users"`
}

// CoreType returns the name of this resource type
func (r *FederatedIdentityCredential) CoreType() string {
	return "FederatedIdentityCredential"
}

// UsageSchema defines a list which represents the usage schema of FederatedIdentityCredential.
func (r *FederatedIdentityCredential) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_active_p1_users", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_active_p2_users", ValueType: schema.Int64, DefaultValue: 0},
	}
}

// PopulateUsage parses the u schema.UsageData into the FederatedIdentityCredential.
// It uses the `infracost_usage` struct tags to populate data into the FederatedIdentityCredential.
func (r *FederatedIdentityCredential) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid
// FederatedIdentityCredential struct. This method is called after the resource
// is initialised by an IaC provider. See providers folder for more information.
//
// BuildResource returns cost components for the monthly active users for both P1
// and P2 licence types for Microsoft Entra. It is not possible to infer the
// licence type from the IaC code, so we rely on the user to provide the monthly
// active users for each licence type as a usage parameter. The resource can not
// have both P1 and P2 licence types at the same time, so we check which one is
// set and return the cost component for that licence type.
func (r *FederatedIdentityCredential) BuildResource() *schema.Resource {
	if r.MonthlyActiveP1Users != nil {
		return &schema.Resource{
			Name:        r.Address,
			UsageSchema: r.UsageSchema(),
			CostComponents: []*schema.CostComponent{
				r.activeUserComponent("P1", decimalPtr(decimal.NewFromInt(*r.MonthlyActiveP1Users))),
			},
		}
	}

	if r.MonthlyActiveP2Users != nil {
		return &schema.Resource{
			Name:        r.Address,
			UsageSchema: r.UsageSchema(),
			CostComponents: []*schema.CostComponent{
				r.activeUserComponent("P2", decimalPtr(decimal.NewFromInt(*r.MonthlyActiveP2Users))),
			},
		}
	}

	return &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			r.activeUserComponent("P1", nil),
			r.activeUserComponent("P2", nil),
		},
	}
}

func (r *FederatedIdentityCredential) activeUserComponent(licence string, quantity *decimal.Decimal) *schema.CostComponent {
	var minusFreeTier *decimal.Decimal
	if quantity != nil {
		val := quantity.Sub(decimal.NewFromInt(50000))
		if val.LessThan(decimal.NewFromInt(0)) {
			minusFreeTier = decimalPtr(decimal.NewFromInt(0))
		} else {
			minusFreeTier = decimalPtr(val)
		}
	}

	titled := strings.ToUpper(licence)

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Active users (%s)", titled),
		Unit:            "users",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: minusFreeTier,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Active Directory for External Identities"),
			ProductFamily: strPtr("Security"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(titled)},
				{Key: "meterName", Value: strPtr(titled + " Monthly Active Users")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("50000"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/frontdoor.go
# RESOURCE: azure_frontdoor
# SIZE: 11606 bytes | LINES: 287
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
)

// Frontdoor struct represents Azure's Front Door network service.
//
// More resource information here: https://docs.microsoft.com/en-us/azure/frontdoor/front-door-overview
// Pricing information here: https://azure.microsoft.com/en-us/pricing/details/frontdoor/ (Azure Front Door tab)
type Frontdoor struct {
	Address string
	Region  string

	FrontendHosts int
	RoutingRules  int

	// "usage" args
	MonthlyInboundDataTransferGB  *float64                            `infracost_usage:"monthly_inbound_data_transfer_gb"`
	MonthlyOutboundDataTransferGB *frontdoorOutboundDataTransferUsage `infracost_usage:"monthly_outbound_data_transfer_gb"`
}

// frontdoorOutboundDataTransferUsage represents outbound transfer usage group per
// region.
type frontdoorOutboundDataTransferUsage struct {
	USGovZone1MonthlyTransferGB *float64 `infracost_usage:"us_gov"`
	Zone1MonthlyTransferGB      *float64 `infracost_usage:"north_america_europe_africa"`
	Zone2MonthlyTransferGB      *float64 `infracost_usage:"asia_pacific"`
	Zone3MonthlyTransferGB      *float64 `infracost_usage:"south_america"`
	Zone4MonthlyTransferGB      *float64 `infracost_usage:"australia"`
	Zone5MonthlyTransferGB      *float64 `infracost_usage:"india"`
}

// CoreType returns the name of this resource type
func (r *Frontdoor) CoreType() string {
	return "Frontdoor"
}

// UsageSchema defines a list which represents the usage schema of EventGridTopic.
func (r *Frontdoor) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_inbound_data_transfer_gb", DefaultValue: 0, ValueType: schema.Float64},
		{
			Key:          "monthly_outbound_data_transfer_gb",
			DefaultValue: &usage.ResourceUsage{Name: "monthly_outbound_data_transfer_gb", Items: frontdoorOutboundDataUsageSchema},
			ValueType:    schema.SubResourceUsage,
		},
	}
}

// frontdoorOutboundDataUsageSchema defines a nested list of outbound data
// transfer usage per region.
var frontdoorOutboundDataUsageSchema = []*schema.UsageItem{
	{Key: "us_gov", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "north_america_europe_africa", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "asia_pacific", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "south_america", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "australia", DefaultValue: 0, ValueType: schema.Float64},
	{Key: "india", DefaultValue: 0, ValueType: schema.Float64},
}

// PopulateUsage parses the u schema.UsageData into the Frontdoor.
// It uses the `infracost_usage` struct tags to populate data into the Frontdoor.
func (r *Frontdoor) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from valid Frontdoor data.
// This method is called after the resource is initialised by an IaC provider.
func (r *Frontdoor) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	costComponents = append(costComponents, r.routingRulesCostComponents()...)
	costComponents = append(costComponents, r.frontendHostsCostComponents()...)
	costComponents = append(costComponents, r.inboundDataTransferCostComponents()...)

	// Subresource is used because the cost component has nested tier items
	outboundTransferSubResource := &schema.Resource{
		Name:           "Outbound data transfer",
		CostComponents: r.outboundDataTransferCostComponents(),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
		SubResources:   []*schema.Resource{outboundTransferSubResource},
	}
}

// routingRulesCostComponents returns cost components for defined routing rules.
// The pricing depends on rules quantity.
func (r *Frontdoor) routingRulesCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	name := "Routing rules"
	firstBatchThreshold := 5
	quantity := r.RoutingRules

	type dataTier struct {
		name       string
		meterName  string
		startUsage string
	}

	// For Zones 1 - 5 the price with startUsage 0 in API is free, but Azure
	// pricing calculator bills first rules.
	// US Gov Zone 1 has only one price
	firstRulesStartUsage := "5"
	if r.isGovZone(r.Region) {
		firstRulesStartUsage = "0"
	}

	data := []dataTier{
		{
			name:       fmt.Sprintf("%s (first %d rules)", name, firstBatchThreshold),
			meterName:  "Included Routing Rules",
			startUsage: firstRulesStartUsage,
		}, {
			name:       fmt.Sprintf("%s (per additional rule)", name),
			meterName:  "Overage Routing Rules",
			startUsage: "0",
		},
	}

	tierLimits := []int{firstBatchThreshold}
	tiers := usage.CalculateTierBuckets(decimal.NewFromInt(int64(quantity)), tierLimits)
	for i, d := range data {
		if i < len(tiers) && tiers[i].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, &schema.CostComponent{
				Name:           d.name,
				Unit:           "hours",
				UnitMultiplier: decimal.NewFromInt(1),
				HourlyQuantity: decimalPtr(tiers[i]),
				ProductFilter:  r.buildProductFilter(d.meterName),
				PriceFilter: &schema.PriceFilter{
					PurchaseOption:   strPtr("Consumption"),
					StartUsageAmount: strPtr(d.startUsage),
				},
			})
		}
	}

	return costComponents
}

// frontendHostsCostComponents returns a cost component for frontend hosts.
// Only additional hosts above free limit are billed.
func (r *Frontdoor) frontendHostsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	freeQuantity := 100
	quantity := r.FrontendHosts

	if quantity <= freeQuantity {
		return costComponents
	}

	name := fmt.Sprintf("Frontend hosts (over %d)", freeQuantity)
	billedHostsQuantity := quantity - freeQuantity

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            name,
		Unit:            "hosts",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(int64(billedHostsQuantity))),
		ProductFilter:   r.buildProductFilter("Custom Domain"),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	})

	return costComponents
}

// inboundDataTransferCostComponents returns a cost component for amount of
// transferred inbound data.
func (r *Frontdoor) inboundDataTransferCostComponents() []*schema.CostComponent {
	return []*schema.CostComponent{
		{
			Name:            "Inbound data transfer",
			Unit:            "GB",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyInboundDataTransferGB),
			ProductFilter:   r.buildProductFilter("Data Transfer In"),
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
			UsageBased: true,
		},
	}
}

// outboundDataTransferCostComponents returns cost components for amount of
// transferred outbound data. There are several tiers that are billed
// differently. The pricing depends on the region.
func (r *Frontdoor) outboundDataTransferCostComponents() []*schema.CostComponent {
	if r.isGovZone(r.Region) {
		return r.govOutboundDataTransferCostComponents()
	}

	costComponents := []*schema.CostComponent{}

	resourceUsage := &frontdoorOutboundDataTransferUsage{}
	if r.MonthlyOutboundDataTransferGB != nil {
		resourceUsage = r.MonthlyOutboundDataTransferGB
	}

	type zoneUsage struct {
		zone     string
		name     string
		quantity *float64
	}

	zones := []zoneUsage{
		{zone: "Zone 1", quantity: resourceUsage.Zone1MonthlyTransferGB, name: "North America, Europe and Africa"},
		{zone: "Zone 2", quantity: resourceUsage.Zone2MonthlyTransferGB, name: "Asia Pacific (including Japan)"},
		{zone: "Zone 3", quantity: resourceUsage.Zone3MonthlyTransferGB, name: "South America"},
		{zone: "Zone 4", quantity: resourceUsage.Zone4MonthlyTransferGB, name: "Australia"},
		{zone: "Zone 5", quantity: resourceUsage.Zone5MonthlyTransferGB, name: "India"},
	}

	currentZone := zones[0]
	for _, item := range zones {
		if strings.EqualFold(item.zone, r.Region) {
			currentZone = item
			break
		}
	}

	type dataTier struct {
		name       string
		startUsage string
	}
	data := []dataTier{
		{name: fmt.Sprintf("%s (first 10TB)", currentZone.name), startUsage: "0"},
		{name: fmt.Sprintf("%s (next 40TB)", currentZone.name), startUsage: "10000"},
		{name: fmt.Sprintf("%s (over 50TB)", currentZone.name), startUsage: "50000"},
	}

	if currentZone.quantity != nil {
		quantity := decimal.NewFromFloat(*currentZone.quantity)

		tierLimits := []int{10000, 40000}
		tiers := usage.CalculateTierBuckets(quantity, tierLimits)

		for i, d := range data {
			if i < len(tiers) && tiers[i].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.buildOutboundDataTransferCostComponent(
					d.name,
					d.startUsage,
					decimalPtr(tiers[i]),
				))
			}
		}
	} else {
		costComponents = append(costComponents, r.buildOutboundDataTransferCostComponent(
			data[0].name,
			data[0].startUsage,
			nil,
		))
	}
	return costComponents
}

// govOutboundDataTransferCostComponents returns a cost component for outbound
// data transfer in US Gov zone. This zone doesn't have tiers.
func (r *Frontdoor) govOutboundDataTransferCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	var quantity *decimal.Decimal

	if r.MonthlyOutboundDataTransferGB != nil {
		transferAmount := r.MonthlyOutboundDataTransferGB.USGovZone1MonthlyTransferGB
		if transferAmount != nil {
			quantity = decimalPtr(decimal.NewFromFloat(*transferAmount))
		}
	}

	costComponents = append(costComponents, r.buildOutboundDataTransferCostComponent(
		"US Gov",
		"0",
		quantity,
	))

	return costComponents
}

// buildOutboundDataTransferCostComponent returns a cost component for one tier
// of outbound data transfer usage.
func (r *Frontdoor) buildOutboundDataTransferCostComponent(name, startUsage string, quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter:   r.buildProductFilter("Data Transfer Out"),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr(startUsage),
		},
		UsageBased: true,
	}
}

// buildProductFilter returns a product filter for the Front Door's products.
//
// skuName and productName define the original Front Door service (not
// Standard/Premium).
func (r *Frontdoor) buildProductFilter(meterName string) *schema.ProductFilter {
	return &schema.ProductFilter{
		VendorName:    strPtr("azure"),
		Region:        strPtr(r.Region),
		Service:       strPtr("Azure Front Door Service"),
		ProductFamily: strPtr("Networking"),
		AttributeFilters: []*schema.AttributeFilter{
			{Key: "skuName", Value: strPtr("Standard")},
			{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("%s$", meterName))},
			{Key: "productName", Value: strPtr("Azure Front Door Service")},
		},
	}
}

// isGovZone checks if the region/zone is US Gov
func (r *Frontdoor) isGovZone(zone string) bool {
	return strings.EqualFold(zone, "US Gov Zone 1")
}

################################################################################
# FILE: internal/resources/azure/frontdoor_firewall_policy.go
# RESOURCE: azure_frontdoor_firewall_policy
# SIZE: 6583 bytes | LINES: 160
################################################################################
package azure

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// FrontdoorFirewallPolicy represents a policy for Web Application Firewall (WAF)
// with Azure Front Door.
//
// More resource information here: https://docs.microsoft.com/en-us/azure/web-application-firewall/afds/waf-front-door-drs
// Pricing information here: https://azure.microsoft.com/en-us/pricing/details/frontdoor/#overview
type FrontdoorFirewallPolicy struct {
	Address string
	Region  string

	CustomRules     int
	ManagedRulesets int

	// "usage" args
	MonthlyCustomRuleRequests     *int64 `infracost_usage:"monthly_custom_rule_requests"`
	MonthlyManagedRulesetRequests *int64 `infracost_usage:"monthly_managed_ruleset_requests"`
}

// CoreType returns the name of this resource type
func (r *FrontdoorFirewallPolicy) CoreType() string {
	return "FrontdoorFirewallPolicy"
}

// UsageSchema defines a list which represents the usage schema of EventGridTopic.
func (r *FrontdoorFirewallPolicy) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_custom_rule_requests", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_managed_ruleset_requests", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the FrontdoorFirewallPolicy.
func (r *FrontdoorFirewallPolicy) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid FrontdoorFirewallPolicy.
// This method is called after the resource is initialised by an IaC provider.
func (r *FrontdoorFirewallPolicy) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	costComponents = append(costComponents, r.policyCostComponents()...)
	costComponents = append(costComponents, r.customRulesCostComponents()...)
	costComponents = append(costComponents, r.customRuleRequestsCostComponents()...)
	costComponents = append(costComponents, r.managedRulesetsCostComponents()...)
	costComponents = append(costComponents, r.managedRulesetRequestsCostComponents()...)

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

// policyCostComponents returns cost components for Policy usage
func (r *FrontdoorFirewallPolicy) policyCostComponents() []*schema.CostComponent {
	return []*schema.CostComponent{
		{
			Name:            "Policy",
			Unit:            "months",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter:   r.buildProductFilter("Policy"),
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
		},
	}
}

// customRulesCostComponents returns a cost component for the total number of custom
// rules in the policy.
func (r *FrontdoorFirewallPolicy) customRulesCostComponents() []*schema.CostComponent {
	return []*schema.CostComponent{
		{
			Name:            "Custom rules",
			Unit:            "rules",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: decimalPtr(decimal.NewFromInt(int64(r.CustomRules))),
			ProductFilter:   r.buildProductFilter("Rule"),
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
		},
	}
}

// customRuleRequestsCostComponents returns a usage based cost component for the
// number of custom rules' requests.
func (r *FrontdoorFirewallPolicy) customRuleRequestsCostComponents() []*schema.CostComponent {
	return []*schema.CostComponent{
		{
			Name:            "Custom rule requests",
			Unit:            "1M requests",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: r.monthlyRequestsQuantity(r.MonthlyCustomRuleRequests),
			ProductFilter:   r.buildProductFilter("Requests"),
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
			UsageBased: true,
		},
	}
}

// managedRulesetsCostComponents returns a cost component for the total number
// of managed rulesets in the policy.
func (r *FrontdoorFirewallPolicy) managedRulesetsCostComponents() []*schema.CostComponent {
	return []*schema.CostComponent{
		{
			Name:            "Managed rulesets",
			Unit:            "rulesets",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: decimalPtr(decimal.NewFromInt(int64(r.ManagedRulesets))),
			ProductFilter:   r.buildProductFilter("Default Ruleset"),
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
		},
	}
}

// managedRulesetRequestsCostComponents returns a usage based cost component for
// the number of managed rulesets' requests.
func (r *FrontdoorFirewallPolicy) managedRulesetRequestsCostComponents() []*schema.CostComponent {
	return []*schema.CostComponent{
		{
			Name:            "Managed ruleset requests",
			Unit:            "1M requests",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: r.monthlyRequestsQuantity(r.MonthlyManagedRulesetRequests),
			ProductFilter:   r.buildProductFilter("Default Request"),
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
			UsageBased: true,
		},
	}
}

// buildProductFilter returns a product filter for the Front Door's products.
//
// skuName and productName define the original Front Door service (not
// Standard/Premium).
func (r *FrontdoorFirewallPolicy) buildProductFilter(meterName string) *schema.ProductFilter {
	return &schema.ProductFilter{
		VendorName:    strPtr("azure"),
		Region:        strPtr(r.Region),
		Service:       strPtr("Azure Front Door Service"),
		ProductFamily: strPtr("Networking"),
		AttributeFilters: []*schema.AttributeFilter{
			{Key: "skuName", Value: strPtr("Standard")},
			{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("%s$", meterName))},
			{Key: "productName", Value: strPtr("Azure Front Door Service")},
		},
	}
}

// monthlyRequestsQuantity converts the monthly requests usage number as
// Azure's requests pricing is 1M requests/month.
func (r *FrontdoorFirewallPolicy) monthlyRequestsQuantity(requestsNumber *int64) *decimal.Decimal {
	var monthlyRequests *decimal.Decimal
	divider := decimal.NewFromInt(1000000)

	if requestsNumber != nil {
		requests := decimal.NewFromInt(*requestsNumber)
		monthlyRequests = decimalPtr(requests.Div(divider))
	}

	return monthlyRequests
}

################################################################################
# FILE: internal/resources/azure/function_app.go
# RESOURCE: azure_function_app
# SIZE: 8018 bytes | LINES: 221
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

var (
	functionAppSkuMapCPU = map[string]int64{
		"ep1": 1,
		"ep2": 2,
		"ep3": 4,
	}

	functionAppSkuMapMem = map[string]float64{
		"ep1": 3.5,
		"ep2": 7.0,
		"ep3": 14.0,
	}
)

// FunctionApp struct a serverless function running in an app service environment. The billing for this
// function lies within Azure App Service, however we capture the costs in this component to make it more understandable.
//
// Resource information: https://learn.microsoft.com/en-us/azure/azure-functions/functions-overview
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/app-service/windows/
type FunctionApp struct {
	Address string
	Region  string

	SKUName string
	Tier    string
	OSType  string

	MonthlyExecutions   *int64 `infracost_usage:"monthly_executions"`
	ExecutionDurationMs *int64 `infracost_usage:"execution_duration_ms"`
	MemoryMb            *int64 `infracost_usage:"memory_mb"`
	Instances           *int64 `infracost_usage:"instances"`
}

func (r *FunctionApp) CoreType() string {
	return "FunctionApp"
}

func (r *FunctionApp) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_executions", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "execution_duration_ms", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "memory_mb", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "instances", ValueType: schema.Int64, DefaultValue: 0},
	}
}

// PopulateUsage parses the u schema.UsageData into the FunctionApp struct
// It uses the `infracost_usage` struct tags to populate data into the FunctionApp
func (r *FunctionApp) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid FunctionApp struct.
//
// FunctionApp costs are CPU and Memory usage. These values rely on the user defining their expected
// usage in the usage file.
//
// Function apps are billed in two modes - Premium or Consumption.
func (r *FunctionApp) BuildResource() *schema.Resource {
	var costComponents []*schema.CostComponent

	if r.Tier == "premium" {
		cpu := r.appFunctionPremiumCPUCostComponent()
		if cpu != nil {
			costComponents = append(costComponents, cpu)
		}

		mem := r.appFunctionPremiumMemoryCostComponent()
		if mem != nil {
			costComponents = append(costComponents, mem)
		}

		return &schema.Resource{
			Name:           r.Address,
			CostComponents: costComponents,
			UsageSchema:    r.UsageSchema(),
		}
	}

	costComponents = append(
		costComponents,
		r.appFunctionConsumptionExecutionTimeCostComponent(),
		r.appFunctionConsumptionExecutionsCostComponent(),
	)

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *FunctionApp) appFunctionPremiumCPUCostComponent() *schema.CostComponent {
	var skuCPU *int64

	if val, ok := functionAppSkuMapCPU[r.SKUName]; ok {
		skuCPU = &val
	}

	if skuCPU == nil {
		return nil
	}

	instances := decimal.NewFromInt(1)
	if r.Instances != nil {
		instances = decimal.NewFromInt(*r.Instances)
	}

	return &schema.CostComponent{
		Name:           fmt.Sprintf("vCPU (%s)", strings.ToUpper(r.SKUName)),
		Unit:           "vCPU",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: decimalPtr(instances.Mul(decimal.NewFromInt(*skuCPU))),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Functions"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: regexPtr("vCPU Duration$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

func (r *FunctionApp) appFunctionPremiumMemoryCostComponent() *schema.CostComponent {
	var skuMemory *float64

	if val, ok := functionAppSkuMapMem[r.SKUName]; ok {
		skuMemory = &val
	}

	if skuMemory == nil {
		return nil
	}

	instances := decimal.NewFromInt(1)
	if r.Instances != nil {
		instances = decimal.NewFromInt(*r.Instances)
	}

	return &schema.CostComponent{
		Name:           fmt.Sprintf("Memory (%s)", strings.ToUpper(r.SKUName)),
		Unit:           "GB",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: decimalPtr(instances.Mul(decimal.NewFromFloat(*skuMemory))),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Functions"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: regexPtr("Memory Duration$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

func (r *FunctionApp) appFunctionConsumptionExecutionTimeCostComponent() *schema.CostComponent {
	gbSeconds := r.calculateFunctionAppGBSeconds()
	return &schema.CostComponent{
		Name:            "Execution time",
		Unit:            "GB-seconds",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: gbSeconds,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Functions"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: regexPtr("Execution Time$")},
				{Key: "skuName", Value: strPtr("Standard")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("400000"),
		},
		UsageBased: true,
	}
}

func (r *FunctionApp) appFunctionConsumptionExecutionsCostComponent() *schema.CostComponent {
	// Azure's pricing API returns prices per 10 executions so if the user has provided
	// the number of executions, we should divide it by 10
	var executions *decimal.Decimal
	if r.MonthlyExecutions != nil {
		executions = decimalPtr(decimal.NewFromInt(*r.MonthlyExecutions).Div(decimal.NewFromInt(10)))
	}

	return &schema.CostComponent{
		Name:            "Executions",
		Unit:            "1M requests",
		UnitMultiplier:  decimal.NewFromInt(100000),
		MonthlyQuantity: executions,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Functions"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: regexPtr("Total Executions$")},
				{Key: "skuName", Value: strPtr("Standard")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("100000"),
		},
		UsageBased: true,
	}
}

func (r *FunctionApp) calculateFunctionAppGBSeconds() *decimal.Decimal {
	if r.MemoryMb == nil || r.ExecutionDurationMs == nil || r.MonthlyExecutions == nil {
		return nil
	}

	memorySize := decimal.NewFromInt(*r.MemoryMb)
	averageRequestDuration := decimal.NewFromInt(*r.ExecutionDurationMs)
	monthlyRequests := decimal.NewFromInt(*r.MonthlyExecutions)

	// Use a min of 128MB, and round-up to nearest 128MB
	if memorySize.LessThan(decimal.NewFromInt(128)) {
		memorySize = decimal.NewFromInt(128)
	}
	roundedMemory := memorySize.Div(decimal.NewFromInt(128)).Ceil().Mul(decimal.NewFromInt(128))
	// Apply the minimum request duration
	if averageRequestDuration.LessThan(decimal.NewFromInt(100)) {
		averageRequestDuration = decimal.NewFromInt(100)
	}
	durationSeconds := monthlyRequests.Mul(averageRequestDuration).Mul(decimal.NewFromFloat(0.001))
	gbSeconds := durationSeconds.Mul(roundedMemory).Div(decimal.NewFromInt(1024))

	return &gbSeconds
}

################################################################################
# FILE: internal/resources/azure/image.go
# RESOURCE: azure_image
# SIZE: 3399 bytes | LINES: 85
################################################################################
package azure

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// Image represents a custom image or a snapshot in Azure Cloud.
//
// A custom image in Azure is created from a VHD or a managed disk, and it's used as the base
// for creating new virtual machines. Image, when representing a custom image,
// takes into account the size of the managed disk that backs the image for cost calculation.
//
// A snapshot in Azure is a read-only copy of a disk, created for backup or to create
// new disks with the same data. When representing a snapshot, Image considers
// the used size of the disk snapshot for cost estimation.
//
// The cost of both custom images and snapshots is primarily based on the storage they consume.
//
// Resource information:
// Custom Images: https://docs.microsoft.com/en-us/azure/virtual-machines/windows/capture-image-resource
// Snapshots: https://docs.microsoft.com/en-us/azure/virtual-machines/disks-snapshot
//
// Pricing information:
// Managed Disks: https://azure.microsoft.com/en-us/pricing/details/managed-disks/
// Storage: https://azure.microsoft.com/en-us/pricing/details/storage/
type Image struct {
	Type string

	Address   string
	Region    string
	StorageGB *float64 `infracost_usage:"storage_gb"`
}

// CoreType returns the name of this resource type.
// If no type is specified, it defaults to "Image".
func (r *Image) CoreType() string {
	if r.Type == "" {
		return "Image"
	}

	return r.Type
}

// UsageSchema defines a list which represents the usage schema of Image.
// Currently, it includes a single key "storage_gb" for the storage size in GB.
func (r *Image) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "storage_gb", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the Image.
// It uses the `infracost_usage` struct tags to populate data into the Image.
func (r *Image) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid Image struct.
// This method is called after the resource is initialised by an IaC provider.
//
// As of writing, snapshot and image costs are all billed under the "Standard HDD Managed Disks" product, even if the
// disks they are backing up are premium or SSD.
func (r *Image) BuildResource() *schema.Resource {
	var size *decimal.Decimal
	if r.StorageGB != nil {
		size = decimalPtr(decimal.NewFromFloat(*r.StorageGB))
	}

	return &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Storage",
				Unit:            "GB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: size,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("azure"),
					Region:        strPtr(r.Region),
					Service:       strPtr("Storage"),
					ProductFamily: strPtr("Storage"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "skuName", Value: strPtr("Snapshots LRS")},
						{Key: "meterName", ValueRegex: regexPtr("LRS Snapshots$")},
						{Key: "productName", Value: strPtr("Standard HDD Managed Disks")},
					},
				},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/azure/iothub.go
# RESOURCE: azure_iothub
# SIZE: 3568 bytes | LINES: 116
################################################################################
package azure

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

const (
	iotHubFreeSku = "F1"
)

// IoTHub struct represents an IoT Hub
//
// Resource information: https://azure.microsoft.com/en-us/services/iot-hub/
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/iot-hub/
type IoTHub struct {
	Address  string
	Region   string
	Sku      string
	Capacity int64
}

func (r *IoTHub) CoreType() string {
	return "IoTHub"
}

func (r *IoTHub) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *IoTHub) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *IoTHub) BuildResource() *schema.Resource {
	if r.Sku == iotHubFreeSku {
		return &schema.Resource{
			Name:      r.Address,
			IsSkipped: true,
			NoPrice:   true,
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: r.costComponents(),
	}
}

func (r *IoTHub) costComponents() []*schema.CostComponent {
	return r.iotHubCostComponent()
}

func (r *IoTHub) iotHubCostComponent() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{
		{
			Name:            "IoT Hub",
			Unit:            "units",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: decimalPtr(decimal.NewFromInt(r.Capacity)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(r.Region),
				Service:       strPtr("IoT Hub"),
				ProductFamily: strPtr("Internet of Things"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "skuName", Value: strPtr(r.Sku)},
					{Key: "meterName", ValueRegex: regexPtr("Unit$")},
				},
			},
		},
	}

	return costComponents
}

// IoTHubDPS struct represents an IoT Hub DPS
//
// Resource information: https://azure.microsoft.com/en-us/services/iot-hub/
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/iot-hub/
type IoTHubDPS struct {
	Address string
	Region  string
	Sku     string

	MonthlyOperations *int64 `infracost_usage:"monthly_operations"`
}

func (r *IoTHubDPS) CoreType() string {
	return "IoTHubDPS"
}

func (r *IoTHubDPS) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_operations", DefaultValue: 0, ValueType: schema.Int64},
	}
}

func (r *IoTHubDPS) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *IoTHubDPS) BuildResource() *schema.Resource {
	var monthlyOperations *decimal.Decimal

	if r.MonthlyOperations != nil {
		value := decimal.NewFromInt((*r.MonthlyOperations))
		monthlyOperations = decimalPtr(value.Div(decimal.NewFromInt(1000)))
	}

	return &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Device provisioning",
				Unit:            "1k operations",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: monthlyOperations,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("azure"),
					Region:        strPtr(r.Region),
					Service:       strPtr("IoT Hub"),
					ProductFamily: strPtr("Internet of Things"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "skuName", Value: strPtr(r.Sku)},
						{Key: "meterName", ValueRegex: regexPtr("Operations$")},
					},
				},
				UsageBased: true,
			},
		},
	}
}

################################################################################
# FILE: internal/resources/azure/kubernetes_cluster.go
# RESOURCE: azure_kubernetes_cluster
# SIZE: 5346 bytes | LINES: 134
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"

	"strings"

	"github.com/shopspring/decimal"
)

type KubernetesCluster struct {
	Address                       string
	Region                        string
	SKUTier                       string
	NetworkProfileLoadBalancerSKU string
	DefaultNodePoolNodeCount      int64
	DefaultNodePoolOS             string
	DefaultNodePoolOSDiskType     string
	DefaultNodePoolVMSize         string
	DefaultNodePoolOSDiskSizeGB   int64
	HttpApplicationRoutingEnabled bool
	LoadBalancer                  *KubernetesClusterLoadBalancer    `infracost_usage:"load_balancer"`
	DefaultNodePool               *KubernetesClusterDefaultNodePool `infracost_usage:"default_node_pool"`
	IsDevTest                     bool
}

type KubernetesClusterLoadBalancer struct {
	MonthlyDataProcessedGB *int64 `infracost_usage:"monthly_data_processed_gb"`
}

type KubernetesClusterDefaultNodePool struct {
	Nodes        *int64   `infracost_usage:"nodes"`
	MonthlyHours *float64 `infracost_usage:"monthly_hrs"`
}

var KubernetesClusterLoadBalancerSchema = []*schema.UsageItem{{Key: "monthly_data_processed_gb", ValueType: schema.Int64, DefaultValue: 0}}

var KubernetesClusterDefaultNodePoolSchema = []*schema.UsageItem{
	{Key: "nodes", ValueType: schema.Int64, DefaultValue: 0},
	{Key: "monthly_hrs", ValueType: schema.Float64, DefaultValue: 0},
}

func (r *KubernetesCluster) CoreType() string {
	return "KubernetesCluster"
}

func (r *KubernetesCluster) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{
			Key:          "load_balancer",
			ValueType:    schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "load_balancer", Items: KubernetesClusterLoadBalancerSchema},
		},
		{
			Key:          "default_node_pool",
			ValueType:    schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "default_node_pool", Items: KubernetesClusterDefaultNodePoolSchema},
		},
	}
}

func (r *KubernetesCluster) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *KubernetesCluster) BuildResource() *schema.Resource {
	region := r.Region
	var costComponents []*schema.CostComponent
	var subResources []*schema.Resource

	skuTier := "Free"
	if r.SKUTier != "" {
		skuTier = r.SKUTier
	}

	// Azure switched from "Paid" to "Standard" in API version 2023-02-01
	// (Terraform Azure provider version v3.51.0)
	if contains([]string{"paid", "standard"}, strings.ToLower(skuTier)) {
		costComponents = append(costComponents, &schema.CostComponent{
			Name:           "Uptime SLA",
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(region),
				Service:       strPtr("Azure Kubernetes Service"),
				ProductFamily: strPtr("Compute"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "meterName", Value: strPtr("Standard Uptime SLA")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
		})
	}

	nodeCount := decimal.NewFromInt(1)
	var monthlyHours *float64
	if r.DefaultNodePoolNodeCount > 0 {
		nodeCount = decimal.NewFromInt(r.DefaultNodePoolNodeCount)
	}
	if r.DefaultNodePool != nil && r.DefaultNodePool.Nodes != nil && *r.DefaultNodePool.Nodes > 0 {
		nodeCount = decimal.NewFromInt(*r.DefaultNodePool.Nodes)
		monthlyHours = r.DefaultNodePool.MonthlyHours
	}

	subResources = []*schema.Resource{
		aksClusterNodePool("default_node_pool", region, r.DefaultNodePoolVMSize, r.DefaultNodePoolOS, r.DefaultNodePoolOSDiskType, r.DefaultNodePoolOSDiskSizeGB, nodeCount, monthlyHours, r.IsDevTest),
	}

	if strings.ToLower(r.NetworkProfileLoadBalancerSKU) == "standard" {
		region = convertRegion(region)

		var monthlyDataProcessedGB *decimal.Decimal
		if r.LoadBalancer != nil && r.LoadBalancer.MonthlyDataProcessedGB != nil {
			monthlyDataProcessedGB = decimalPtr(decimal.NewFromInt(*r.LoadBalancer.MonthlyDataProcessedGB))
		}

		lbResource := schema.Resource{
			Name:           "Load Balancer",
			CostComponents: []*schema.CostComponent{lbDataProcessedCostComponent(region, monthlyDataProcessedGB)},
			UsageSchema:    r.UsageSchema(),
		}
		subResources = append(subResources, &lbResource)
	}

	if r.HttpApplicationRoutingEnabled {
		if strings.HasPrefix(strings.ToLower(region), "usgov") {
			region = "US Gov Zone 1"
		} else if strings.HasPrefix(strings.ToLower(region), "germany") {
			region = "DE Zone 1"
		} else if strings.HasPrefix(strings.ToLower(region), "china") {
			region = "Zone 1 (China)"
		} else {
			region = "Zone 1"
		}

		dnsResource := schema.Resource{
			Name:           "DNS",
			CostComponents: []*schema.CostComponent{hostedPublicZoneCostComponent(region)},
			UsageSchema:    r.UsageSchema(),
		}
		subResources = append(subResources, &dnsResource)
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		SubResources:   subResources,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/kubernetes_cluster_node_pool.go
# RESOURCE: azure_kubernetes_cluster_node_pool
# SIZE: 4161 bytes | LINES: 116
################################################################################
package azure

import (
	"regexp"
	"strings"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type KubernetesClusterNodePool struct {
	Address      string
	Region       string
	NodeCount    int64
	VMSize       string
	OS           string
	OSDiskType   string
	OSDiskSizeGB int64
	Nodes        *int64   `infracost_usage:"nodes"`
	MonthlyHours *float64 `infracost_usage:"monthly_hrs"`
	IsDevTest    bool
}

func (r *KubernetesClusterNodePool) CoreType() string {
	return "KubernetesClusterNodePool"
}

func (r *KubernetesClusterNodePool) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "nodes", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_hrs", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *KubernetesClusterNodePool) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *KubernetesClusterNodePool) BuildResource() *schema.Resource {
	nodeCount := decimal.NewFromInt(1)
	if r.NodeCount != 0 {
		nodeCount = decimal.NewFromInt(r.NodeCount)
	}
	if r.Nodes != nil {
		nodeCount = decimal.NewFromInt(*r.Nodes)
	}

	pool := aksClusterNodePool(r.Address, r.Region, r.VMSize, r.OS, r.OSDiskType, r.OSDiskSizeGB, nodeCount, r.MonthlyHours, r.IsDevTest)
	pool.UsageSchema = r.UsageSchema()
	return pool
}

func aksClusterNodePool(name, region, instanceType, os string, osDiskType string, osDiskSizeGB int64, nodeCount decimal.Decimal, monthlyHours *float64, isDevTest bool) *schema.Resource {
	var costComponents []*schema.CostComponent
	var subResources []*schema.Resource

	mainResource := &schema.Resource{
		Name: name,
	}

	if strings.EqualFold(os, "windows") {
		costComponents = append(costComponents, windowsVirtualMachineCostComponent(region, instanceType, "None", monthlyHours, isDevTest))
	} else {
		costComponents = append(costComponents, linuxVirtualMachineCostComponent(region, instanceType, monthlyHours))
	}

	mainResource.CostComponents = costComponents
	schema.MultiplyQuantities(mainResource, nodeCount)

	if osDiskType == "" {
		osDiskType = "Managed"
	}
	if strings.ToLower(osDiskType) == "managed" {
		diskSize := 128
		if osDiskSizeGB > 0 {
			diskSize = int(osDiskSizeGB)
		}
		osDisk := aksOSDiskSubResource(region, diskSize, instanceType)

		if osDisk != nil {
			subResources = append(subResources, osDisk)
			schema.MultiplyQuantities(subResources[0], nodeCount)
			mainResource.SubResources = subResources
		}
	}

	return mainResource
}

func aksOSDiskSubResource(region string, diskSize int, instanceType string) *schema.Resource {
	diskType := aksGetStorageType(instanceType)
	storageReplicationType := "LRS"

	diskName := mapDiskName(diskType, diskSize)
	if diskName == "" {
		logging.Logger.Warn().Msgf("Could not map disk type %s and size %d to disk name", diskType, diskSize)
		return nil
	}

	productName, ok := diskProductNameMap[diskType]
	if !ok {
		logging.Logger.Warn().Msgf("Could not map disk type %s to product name", diskType)
		return nil
	}

	costComponent := []*schema.CostComponent{storageCostComponent(region, diskName, storageReplicationType, productName)}

	return &schema.Resource{
		Name:           "os_disk",
		CostComponents: costComponent,
	}
}

func aksGetStorageType(instanceType string) string {
	parts := strings.Split(instanceType, "_")

	subfamily := ""
	if len(parts) > 1 {
		subfamily = parts[1]
	}

	// Check if the subfamily is a known premium type
	premiumPrefixes := []string{"ds", "gs", "m"}
	for _, p := range premiumPrefixes {
		if strings.HasPrefix(strings.ToLower(subfamily), p) {
			return "Premium"
		}
	}

	// Otherwise check if it contains an s as an 'Additive Feature'
	// as per https://learn.microsoft.com/en-us/azure/virtual-machines/vm-naming-conventions
	re := regexp.MustCompile(`\d+[A-Za-z]*(s)`)
	matches := re.FindStringSubmatch(subfamily)

	if len(matches) > 0 {
		return "Premium"
	}

	return "Standard"
}

################################################################################
# FILE: internal/resources/azure/lb.go
# RESOURCE: azure_lb
# SIZE: 2171 bytes | LINES: 67
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"strings"

	"github.com/shopspring/decimal"
)

type LB struct {
	Address                string
	Region                 string
	SKU                    string
	MonthlyDataProcessedGB *float64 `infracost_usage:"monthly_data_processed_gb"`
}

func (r *LB) CoreType() string {
	return "LB"
}

func (r *LB) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_data_processed_gb", ValueType: schema.Float64, DefaultValue: 0}}
}

func (r *LB) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *LB) BuildResource() *schema.Resource {
	region := convertRegion(r.Region)

	var costComponents []*schema.CostComponent
	sku := "Basic"
	var monthlyDataProcessedGb *decimal.Decimal

	if r.MonthlyDataProcessedGB != nil {
		monthlyDataProcessedGb = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataProcessedGB))
	}

	if r.SKU != "" {
		sku = r.SKU
	}

	if strings.ToLower(sku) == "basic" {
		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	costComponents = append(costComponents, lbDataProcessedCostComponent(region, monthlyDataProcessedGb))

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func lbDataProcessedCostComponent(region string, quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Data processed",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(region),
			Service:       strPtr("Load Balancer"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr("Standard")},
				{Key: "meterName", ValueRegex: regexPtr("Data Processed$")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/linux_virtual_machine.go
# RESOURCE: azure_linux_virtual_machine
# SIZE: 3632 bytes | LINES: 92
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"

	"github.com/shopspring/decimal"
)

type LinuxVirtualMachine struct {
	Address         string
	Region          string
	Size            string
	UltraSSDEnabled bool
	OSDiskData      *ManagedDiskData
	OSDisk          *OSDiskUsage `infracost_usage:"os_disk"`
	MonthlyHrs      *float64     `infracost_usage:"monthly_hrs"`
}

func (r *LinuxVirtualMachine) CoreType() string {
	return "LinuxVirtualMachine"
}

func (r *LinuxVirtualMachine) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{
			Key:          "os_disk",
			ValueType:    schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "os_disk", Items: OSDiskUsageSchema},
		},
	}
}

func (r *LinuxVirtualMachine) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *LinuxVirtualMachine) BuildResource() *schema.Resource {
	instanceType := r.Size

	costComponents := []*schema.CostComponent{linuxVirtualMachineCostComponent(r.Region, instanceType, r.MonthlyHrs)}

	if r.UltraSSDEnabled {
		costComponents = append(costComponents, ultraSSDReservationCostComponent(r.Region))
	}

	subResources := make([]*schema.Resource, 0)

	var monthlyDiskOperations *decimal.Decimal
	if r.OSDisk != nil && r.OSDisk.MonthlyDiskOperations != nil {
		monthlyDiskOperations = decimalPtr(decimal.NewFromInt(*r.OSDisk.MonthlyDiskOperations))
	}

	if r.OSDiskData != nil {
		osDisk := osDiskSubResource(r.Region, r.OSDiskData.DiskType, r.OSDiskData.DiskSizeGB, r.OSDiskData.DiskIOPSReadWrite, r.OSDiskData.DiskMBPSReadWrite, monthlyDiskOperations)
		subResources = append(subResources, osDisk)
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		SubResources:   subResources,
		UsageSchema:    r.UsageSchema(),
	}
}

func linuxVirtualMachineCostComponent(region string, instanceType string, monthlyHours *float64) *schema.CostComponent {
	purchaseOption := "Consumption"
	purchaseOptionLabel := "pay as you go"

	productNameRe := "/Series( Linux)?$/i"
	if strings.HasPrefix(strings.ToLower(instanceType), "basic_") {
		productNameRe = "/Series Basic$/"
	} else if !strings.HasPrefix(strings.ToLower(instanceType), "standard_") {
		instanceType = fmt.Sprintf("Standard_%s", instanceType)
	}

	qty := schema.HourToMonthUnitMultiplier
	if monthlyHours != nil {
		qty = decimal.NewFromFloat(*monthlyHours)
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Instance usage (Linux, %s, %s)", purchaseOptionLabel, instanceType),
		Unit:            "hours",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(qty),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(region),
			Service:       strPtr("Virtual Machines"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", ValueRegex: strPtr("/^(?!.*(Expired|Free)$).*$/i")},
				{Key: "skuName", ValueRegex: strPtr("/^(?!.*(Low Priority|Spot)$).*$/i")},
				{Key: "armSkuName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", instanceType))},
				{Key: "productName", ValueRegex: strPtr(productNameRe)},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr(purchaseOption),
			Unit:           strPtr("1 Hour"),
		},
	}
}

################################################################################
# FILE: internal/resources/azure/linux_virtual_machine_scale_set.go
# RESOURCE: azure_linux_virtual_machine_scale_set
# SIZE: 2245 bytes | LINES: 59
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"

	"github.com/shopspring/decimal"
)

type LinuxVirtualMachineScaleSet struct {
	Address         string
	SKU             string
	UltraSSDEnabled bool
	Region          string
	OSDiskData      *ManagedDiskData
	Instances       *int64       `infracost_usage:"instances"`
	OSDisk          *OSDiskUsage `infracost_usage:"os_disk"`
}

func (r *LinuxVirtualMachineScaleSet) CoreType() string {
	return "LinuxVirtualMachineScaleSet"
}

func (r *LinuxVirtualMachineScaleSet) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "instances", ValueType: schema.Int64, DefaultValue: 0},
		{
			Key:          "os_disk",
			ValueType:    schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "os_disk", Items: OSDiskUsageSchema},
		},
	}
}

func (r *LinuxVirtualMachineScaleSet) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *LinuxVirtualMachineScaleSet) BuildResource() *schema.Resource {

	instanceType := r.SKU

	costComponents := []*schema.CostComponent{linuxVirtualMachineCostComponent(r.Region, instanceType, nil)}
	subResources := make([]*schema.Resource, 0)

	if r.UltraSSDEnabled {
		costComponents = append(costComponents, ultraSSDReservationCostComponent(r.Region))
	}

	var monthlyDiskOperations *decimal.Decimal
	if r.OSDisk != nil && r.OSDisk.MonthlyDiskOperations != nil {
		monthlyDiskOperations = decimalPtr(decimal.NewFromInt(*r.OSDisk.MonthlyDiskOperations))
	}

	if r.OSDiskData != nil {
		osDisk := osDiskSubResource(r.Region, r.OSDiskData.DiskType, r.OSDiskData.DiskSizeGB, r.OSDiskData.DiskIOPSReadWrite, r.OSDiskData.DiskMBPSReadWrite, monthlyDiskOperations)
		if osDisk != nil {
			subResources = append(subResources, osDisk)
		}
	}

	instanceCount := decimal.NewFromInt(*r.Instances)

	res := &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		SubResources:   subResources,
		UsageSchema:    r.UsageSchema(),
	}

	schema.MultiplyQuantities(res, instanceCount)

	return res
}

################################################################################
# FILE: internal/resources/azure/log_analytics_workspace.go
# RESOURCE: azure_log_analytics_workspace
# SIZE: 16901 bytes | LINES: 434
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

const (
	logAnalyticsServiceName = "Log Analytics"
	azureMonitorServiceName = "Azure Monitor"
	governanceProductFamily = "Management and Governance"

	skuCapacityReservation = "CapacityReservation"
	skuPerGB2018           = "PerGB2018"
	skuFree                = "Free"
	skuFilterAnalyticsLogs = "Analytics Logs"
	skuBasicLogsIngest     = "Basic Logs"
	skuBasicLogsSearch     = "Search Queries"
	skuArchive             = "Data Archive"
	skuArchiveRestore      = "Data Restore"
	skuArchiveSearch       = "Search Jobs"

	logRetentionFreeTierLimit = 30
)

var (
	// unsupportedLegacySkus represents skus that Infracost doesn't support because these skus are
	// legacy pricing tiers: https://docs.microsoft.com/en-us/azure/azure-monitor//logs/manage-cost-storage#legacy-pricing-tiers
	unsupportedLegacySkus = map[string]struct{}{
		"unlimited": {},
		"standard":  {},
		"premium":   {},
		"pernode":   {},
	}

	// validCommitmentTiers is a lookup map of valid data ingestion tiers.
	validCommitmentTiers = map[int64]struct{}{
		100:  {},
		200:  {},
		300:  {},
		400:  {},
		500:  {},
		1000: {},
		2000: {},
		5000: {},
	}

	// commitmentTiers list of valid data ingestion tiers, this can be used
	// to transform invalid tier into a billable unit.
	commitmentTiers = []int64{
		100,
		200,
		300,
		400,
		500,
		1000,
		2000,
		5000,
	}
)

// LogAnalyticsWorkspace struct represents an Azure Monitor log workspace. A workspace consolidates data
// from multiple sources into a single data lake. A workspace defines:
//
//  1. The geographic location of the data.
//  2. Access rights that define which users can access data.
//  3. Configuration settings such as the pricing tier and data retention.
//
// Resource information: https://azure.microsoft.com/en-gb/services/monitor/
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/monitor/
type LogAnalyticsWorkspace struct {
	Address string
	Region  string
	SKU     string

	ReservationCapacityInGBPerDay int64
	RetentionInDays               int64
	SentinelEnabled               bool

	MonthlyArchivedDataGB               *float64 `infracost_usage:"monthly_archive_data_gb"`
	MonthlyArchivedDataRestoredGB       *float64 `infracost_usage:"monthly_archive_data_restored_gb"`
	MonthlyArchivedDataSearchedGB       *float64 `infracost_usage:"monthly_archive_data_searched_gb"`
	MonthlyBasicLogDataIngestionGB      *float64 `infracost_usage:"monthly_basic_log_data_ingestion_gb"`
	MonthlyBasicLogSearchGB             *float64 `infracost_usage:"monthly_basic_log_search_gb"`
	MonthlyLogDataIngestionGB           *float64 `infracost_usage:"monthly_log_data_ingestion_gb"`
	MonthlyAdditionalLogDataRetentionGB *float64 `infracost_usage:"monthly_additional_log_data_retention_gb"`
	MonthlyLogDataExportGB              *float64 `infracost_usage:"monthly_log_data_export_gb"`
	MonthlySentinelDataIngestionGB      *float64 `infracost_usage:"monthly_sentinel_data_ingestion_gb"`
}

// CoreType returns the name of this resource type
func (r *LogAnalyticsWorkspace) CoreType() string {
	return "LogAnalyticsWorkspace"
}

// UsageSchema defines a list which represents the usage schema of LogAnalyticsWorkspace.
func (r *LogAnalyticsWorkspace) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{
			Key:          "monthly_archived_data_gb",
			DefaultValue: 0,
			ValueType:    schema.Float64,
		},
		{
			Key:          "monthly_archived_data_restored_gb",
			DefaultValue: 0,
			ValueType:    schema.Float64,
		},
		{
			Key:          "monthly_archived_data_searched_gb",
			DefaultValue: 0,
			ValueType:    schema.Float64,
		},
		{
			Key:          "monthly_basic_log_data_ingestion_gb",
			DefaultValue: 0,
			ValueType:    schema.Float64,
		},
		{
			Key:          "monthly_basic_log_search_gb",
			DefaultValue: 0,
			ValueType:    schema.Float64,
		},
		{
			Key:          "monthly_log_data_ingestion_gb",
			DefaultValue: 0,
			ValueType:    schema.Float64,
		},
		{
			Key:          "monthly_additional_log_data_retention_gb",
			DefaultValue: 0,
			ValueType:    schema.Float64,
		},
		{
			Key:          "monthly_log_data_export_gb",
			DefaultValue: 0,
			ValueType:    schema.Float64,
		},
		{
			Key:          "monthly_sentinel_data_ingestion_gb",
			DefaultValue: 0,
			ValueType:    schema.Float64,
		},
	}
}

// PopulateUsage parses the u schema.UsageData into the LogAnalyticsWorkspace.
// It uses the `infracost_usage` struct tags to populate data into the LogAnalyticsWorkspace.
func (r *LogAnalyticsWorkspace) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid LogAnalyticsWorkspace struct.
// The returned schema.Resource can have 9 potential schema.CostComponent associated with it:
//
//  1. Log data ingestion, which can be either:
//     a) Pay-as-you-go, which is only valid for a sku of PerGB2018 and uses a usage param
//     b) Billed per commitment tiers, which is only valid for a sku of CapacityReservation
//  2. Log retention, which is free up to 31 days. Data retained beyond these no-charge periods
//     will be charged for each GB of data retained for a month (pro-rated daily).
//  3. Data export, which is billed per monthly GB exported and is defined from a usage param.
//  4. Sentinel data ingestion if Sentinel usage is detected.
//  5. Basic log data ingestion, which is a less expensive of tier for "ingesting and storing
//     high-volume verbose logs in your Log Analytics workspace for debugging, troubleshooting,
//     and auditing, but not for analytics and alerts."
//  6. Basic log search, which is billed per monthly GB of basic log data queried.
//  7. Archive data, which is billed per monthly GB of archived data
//  8. Archive restore, which is billed per monthly GB of archived data restored
//  9. Archive search, which is billed per monthly GB of archived data searched
//
// Outside the above rules - if the workspace has sku of Free we return as a free resource & if the workspace sku
// is in a list of unsupported skus then we mark as skipped with a warning.
func (r *LogAnalyticsWorkspace) BuildResource() *schema.Resource {
	if r.SKU == skuFree {
		return &schema.Resource{
			Name:        r.Address,
			IsSkipped:   true,
			NoPrice:     true,
			UsageSchema: r.UsageSchema(),
		}
	}

	if _, ok := unsupportedLegacySkus[strings.ToLower(r.SKU)]; ok {
		logging.Logger.Warn().Msgf("skipping %s as it uses legacy pricing options", r.Address)

		return &schema.Resource{
			Name:        r.Address,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	var costComponents []*schema.CostComponent

	if r.SKU == skuPerGB2018 {
		costComponents = append(costComponents, r.logDataIngestion("Log data ingestion", r.MonthlyLogDataIngestionGB))

		if r.SentinelEnabled {
			costComponents = append(costComponents, r.logDataIngestion("Sentinel data ingestion", r.MonthlySentinelDataIngestionGB))
		}
	}

	if r.SKU == skuCapacityReservation && r.ReservationCapacityInGBPerDay > 0 {
		costComponents = append(costComponents, r.logDataIngestionFromCapacityReservation("Log data ingestion"))

		if r.SentinelEnabled {
			costComponents = append(costComponents, r.logDataIngestionFromCapacityReservation("Sentinel data ingestion"))
		}
	}

	if r.RetentionInDays > logRetentionFreeTierLimit {
		costComponents = append(costComponents, r.logDataRetention())
	}

	costComponents = append(costComponents, r.logDataExport())
	costComponents = append(costComponents, r.basicLogIngestion())
	costComponents = append(costComponents, r.basicLogSearch())
	costComponents = append(costComponents, r.archiveData())
	costComponents = append(costComponents, r.archiveDataRestore())
	costComponents = append(costComponents, r.archiveDataSearch())

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *LogAnalyticsWorkspace) logDataIngestionFromCapacityReservation(name string) *schema.CostComponent {
	selectedTier := r.ReservationCapacityInGBPerDay

	// if the user has set a reservation capacity tier that doesn't exist (or is a legacy tier) we need
	// to convert this to a valid billable tier.
	if _, ok := validCommitmentTiers[r.ReservationCapacityInGBPerDay]; !ok {
		for i, tier := range commitmentTiers {
			// if the current tier is the final valid commitment tier then
			// set selectedTier as it can't be any other tier.
			if len(commitmentTiers)-1 == i {
				selectedTier = tier
				break
			}

			// if the selectedTier is between two valid tiers, set it as the lower of the two tiers.
			if selectedTier > tier && selectedTier < commitmentTiers[i+1] {
				selectedTier = tier
				break
			}
		}
	}

	return &schema.CostComponent{
		Name:            name,
		Unit:            fmt.Sprintf("%d GB (per day)", selectedTier),
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromFloat(30)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(azureMonitorServiceName),
			ProductFamily: strPtr(governanceProductFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(fmt.Sprintf("%d GB Commitment Tier", selectedTier))},
				{Key: "meterName", ValueRegex: strPtr(fmt.Sprintf("^%d GB Commitment Tier", selectedTier))},
			},
		},
		PriceFilter: priceFilterConsumption,
	}
}

func (r *LogAnalyticsWorkspace) logDataIngestion(name string, monthlyData *float64) *schema.CostComponent {
	var quantity *decimal.Decimal
	if monthlyData != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*monthlyData))
	}

	return &schema.CostComponent{
		Name:            name,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(logAnalyticsServiceName),
			ProductFamily: strPtr(governanceProductFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(skuFilterAnalyticsLogs)},
				{Key: "meterName", ValueRegex: regexPtr("Data Ingestion$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("5"),
		},
		UsageBased: true,
	}
}

func (r *LogAnalyticsWorkspace) logDataRetention() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.MonthlyAdditionalLogDataRetentionGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyAdditionalLogDataRetentionGB))
	}

	return &schema.CostComponent{
		Name:            "Log data retention",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(logAnalyticsServiceName),
			ProductFamily: strPtr(governanceProductFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(skuFilterAnalyticsLogs)},
				{Key: "meterName", ValueRegex: regexPtr("Data Retention$")},
			},
		},
		PriceFilter: priceFilterConsumption,
		UsageBased:  true,
	}
}

func (r *LogAnalyticsWorkspace) logDataExport() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.MonthlyLogDataExportGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyLogDataExportGB))
	}

	return &schema.CostComponent{
		Name:            "Log data export",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(azureMonitorServiceName),
			ProductFamily: strPtr(governanceProductFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr("Log Analytics data export")},
				{Key: "meterName", ValueRegex: regexPtr("Data Exported$")},
			},
		},
		PriceFilter: priceFilterConsumption,
		UsageBased:  true,
	}
}

func (r *LogAnalyticsWorkspace) basicLogIngestion() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.MonthlyBasicLogDataIngestionGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyBasicLogDataIngestionGB))
	}

	return &schema.CostComponent{
		Name:            "Basic log data ingestion",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(azureMonitorServiceName),
			ProductFamily: strPtr(governanceProductFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(skuBasicLogsIngest)},
				{Key: "meterName", Value: strPtr("Basic Logs Data Ingestion")},
			},
		},
		UsageBased: true,
	}
}

func (r *LogAnalyticsWorkspace) basicLogSearch() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.MonthlyBasicLogSearchGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyBasicLogSearchGB))
	}

	return &schema.CostComponent{
		Name:            "Basic log search queries",
		Unit:            "GB searched",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(azureMonitorServiceName),
			ProductFamily: strPtr(governanceProductFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(skuBasicLogsSearch)},
				{Key: "meterName", Value: strPtr("Search Queries Scanned")},
			},
		},
		UsageBased: true,
	}
}

func (r *LogAnalyticsWorkspace) archiveData() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.MonthlyArchivedDataGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyArchivedDataGB))
	}

	return &schema.CostComponent{
		Name:            "Archive data",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(azureMonitorServiceName),
			ProductFamily: strPtr(governanceProductFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(skuArchive)},
				{Key: "meterName", Value: strPtr("Data Archive")},
			},
		},
		UsageBased: true,
	}
}

func (r *LogAnalyticsWorkspace) archiveDataRestore() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.MonthlyArchivedDataRestoredGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyArchivedDataRestoredGB))
	}

	return &schema.CostComponent{
		Name:            "Archive data restored",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(azureMonitorServiceName),
			ProductFamily: strPtr(governanceProductFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(skuArchiveRestore)},
				{Key: "meterName", Value: strPtr("Data Restore")},
			},
		},
		UsageBased: true,
	}
}

func (r *LogAnalyticsWorkspace) archiveDataSearch() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.MonthlyArchivedDataSearchedGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyArchivedDataSearchedGB))
	}

	return &schema.CostComponent{
		Name:            "Archive data searched",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(azureMonitorServiceName),
			ProductFamily: strPtr(governanceProductFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(skuArchiveSearch)},
				{Key: "meterName", Value: strPtr("Search Jobs Scanned")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/logic_app_integration_account.go
# RESOURCE: azure_logic_app_integration_account
# SIZE: 3421 bytes | LINES: 84
################################################################################
package azure

import (
	"fmt"

	"github.com/shopspring/decimal"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// LogicAppIntegrationAccount struct represents Microsoft's cloud-based solution for
// integrating business functions and data sources.
//
// Resource information:https://learn.microsoft.com/en-us/azure/logic-apps/logic-apps-pricing
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/logic-apps/
type LogicAppIntegrationAccount struct {
	Address string
	Region  string
	SKU     string
}

// NewLogicAppIntegrationAccount returns an initialised LogicAppIntegrationAccount with the provided attributes.
// This should be used over simple struct initialisation as NewLogicAppIntegrationAccount ensures that the casing
// for the SKU is consistent.
func NewLogicAppIntegrationAccount(address string, region string, sku string) *LogicAppIntegrationAccount {
	return &LogicAppIntegrationAccount{
		Address: address,
		Region:  region,
		SKU:     cases.Title(language.English).String(sku),
	}
}

// CoreType returns the name of this resource type
func (r *LogicAppIntegrationAccount) CoreType() string {
	return "LogicAppIntegrationAccount"
}

// UsageSchema defines a list which represents the usage schema of LogicAppIntegrationAccount.
func (r *LogicAppIntegrationAccount) UsageSchema() []*schema.UsageItem {
	return nil
}

// PopulateUsage parses the u schema.UsageData into the LogicAppIntegrationAccount.
// It uses the `infracost_usage` struct tags to populate data into the LogicAppIntegrationAccount.
func (r *LogicAppIntegrationAccount) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid LogicAppIntegrationAccount struct.
//
// LogicAppIntegrationAccount only have one associated cost with them which is the hourly cost of the account.
// The integration is billed hourly but the prices available are monthly. Therefore, we use the MonthToHourUnitMultiplier
// to convert this price to a more "correct" unit.
func (r *LogicAppIntegrationAccount) BuildResource() *schema.Resource {
	if r.SKU == "Free" {
		return &schema.Resource{
			Name:        r.Address,
			UsageSchema: r.UsageSchema(),
			NoPrice:     true,
		}
	}

	var rounding int32 = 0

	return &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			{
				Name:            fmt.Sprintf("Integration Account (%s)", r.SKU),
				Unit:            "hours",
				MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				UnitMultiplier:  schema.MonthToHourUnitMultiplier,
				UnitRounding:    &rounding,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("azure"),
					Region:        strPtr(r.Region),
					Service:       strPtr("Logic Apps"),
					ProductFamily: strPtr("Integration"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Unit", r.SKU))},
						{Key: "skuName", Value: strPtr(r.SKU)},
						{Key: "productName", Value: strPtr("Logic Apps Integration Account")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					PurchaseOption: strPtr("Consumption"),
				},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/azure/logic_app_standard.go
# RESOURCE: azure_logic_app_standard
# SIZE: 6753 bytes | LINES: 178
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// LogicAppStandard struct represents Azure Logic App Standard.
//
// This resource's pricing is based on the SKU size and the number of standard
// and enterprise connector calls. The SKU size is determined by the related
// App Service Plan SKU, but can be overwritten with a usage-based attribute
// in the usage file. If the SKU cannot be determined we show the pricing per
// vCore and GB of memory. This resource only supports the Standard Plan pricing,
// not the Consumption Plan.
//
// Resource information: https://azure.microsoft.com/en-gb/pricing/details/logic-apps/
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/logic-apps/#pricing
type LogicAppStandard struct {
	Address string
	Region  string

	// Usage-based attributes
	// This is set from the related App Service Plan SKU, but can be overwritten in the usage file
	SKU                             *string `infracost_usage:"sku"`
	MonthlyStandardConnectorCalls   *int64  `infracost_usage:"monthly_standard_connector_calls"`
	MonthlyEnterpriseConnectorCalls *int64  `infracost_usage:"monthly_enterprise_connector_calls"`
}

var logicAppSKUResources = map[string]struct {
	vCores decimal.Decimal
	memory decimal.Decimal
}{
	"WS1": {vCores: decimal.NewFromInt(1), memory: decimal.NewFromFloat(3.5)},
	"WS2": {vCores: decimal.NewFromInt(2), memory: decimal.NewFromFloat(7)},
	"WS3": {vCores: decimal.NewFromInt(4), memory: decimal.NewFromFloat(14)},
}

// CoreType returns the name of this resource type
func (r *LogicAppStandard) CoreType() string {
	return "LogicAppStandard"
}

// UsageSchema defines a list which represents the usage schema of LogicAppStandard.
func (r *LogicAppStandard) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "sku", DefaultValue: "", ValueType: schema.String},
		{Key: "monthly_standard_connector_calls", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_enterprise_connector_calls", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the LogicAppStandard.
// It uses the `infracost_usage` struct tags to populate data into the LogicAppStandard.
func (r *LogicAppStandard) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid LogicAppStandard struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *LogicAppStandard) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.workflowVCoreCostComponent(),
		r.workflowMemoryCostComponent(),
		r.standardConnectorCostComponent(),
		r.enterpriseConnectorCostComponent(),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *LogicAppStandard) workflowVCoreCostComponent() *schema.CostComponent {
	sku := r.normalizedSKU()

	var qty *decimal.Decimal
	if r, ok := logicAppSKUResources[sku]; ok {
		qty = decimalPtr(r.vCores)
	}

	return &schema.CostComponent{
		Name:           fmt.Sprintf("Workflow vCore (%s)", sku),
		Unit:           "vCore",
		HourlyQuantity: qty,
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Logic Apps"),
			ProductFamily: strPtr("Integration"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr("Standard vCPU Duration")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

func (r *LogicAppStandard) workflowMemoryCostComponent() *schema.CostComponent {
	sku := r.normalizedSKU()

	var qty *decimal.Decimal
	if r, ok := logicAppSKUResources[sku]; ok {
		qty = decimalPtr(r.memory)
	}

	return &schema.CostComponent{
		Name:           fmt.Sprintf("Workflow memory (%s)", sku),
		Unit:           "GB",
		HourlyQuantity: qty,
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Logic Apps"),
			ProductFamily: strPtr("Integration"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr("Standard Memory Duration")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

func (r *LogicAppStandard) standardConnectorCostComponent() *schema.CostComponent {
	var qty *decimal.Decimal
	if r.MonthlyStandardConnectorCalls != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyStandardConnectorCalls))
	}

	return &schema.CostComponent{
		Name:            "Standard connectors",
		Unit:            "calls",
		MonthlyQuantity: qty,
		UnitMultiplier:  decimal.NewFromInt(1),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Logic Apps"),
			ProductFamily: strPtr("Integration"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr("Consumption Standard Connector Actions")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	}
}

func (r *LogicAppStandard) enterpriseConnectorCostComponent() *schema.CostComponent {
	var qty *decimal.Decimal
	if r.MonthlyEnterpriseConnectorCalls != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyEnterpriseConnectorCalls))
	}

	return &schema.CostComponent{
		Name:            "Enterprise connectors",
		Unit:            "calls",
		MonthlyQuantity: qty,
		UnitMultiplier:  decimal.NewFromInt(1),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Logic Apps"),
			ProductFamily: strPtr("Integration"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr("Consumption Enterprise Connector Actions")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	}
}

func (r *LogicAppStandard) normalizedSKU() string {
	if r.SKU != nil {
		skuName := strings.ToUpper(*r.SKU)

		if _, ok := logicAppSKUResources[skuName]; ok {
			return skuName
		}
	}

	return "unknown SKU"
}

################################################################################
# FILE: internal/resources/azure/machine_learning_compute_cluster.go
# RESOURCE: azure_machine_learning_compute_cluster
# SIZE: 2684 bytes | LINES: 61
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/shopspring/decimal"
)

// MachineLearningComputeCluster struct represents a Azure Machine Learning Compute Cluster.
//
// These use the same pricing as Azure Linux Virtual Machines. We default to the minimum scale of
// the cluster, but allow the number of instances and monthly hours of each instance to be set.
//
// Resource information: https://azure.microsoft.com/en-gb/pricing/details/machine-learning/#overview
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/machine-learning/
type MachineLearningComputeCluster struct {
	Address      string
	Region       string
	InstanceType string
	MinNodeCount int64
	Instances    *int64   `infracost_usage:"instances"`
	MonthlyHours *float64 `infracost_usage:"monthly_hrs"`
}

// CoreType returns the name of this resource type
func (r *MachineLearningComputeCluster) CoreType() string {
	return "MachineLearningComputeCluster"
}

// UsageSchema defines a list which represents the usage schema of MachineLearningComputeCluster.
func (r *MachineLearningComputeCluster) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "instances", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_hrs", ValueType: schema.Float64, DefaultValue: 0},
	}
}

// PopulateUsage parses the u schema.UsageData into the MachineLearningComputeCluster.
// It uses the `infracost_usage` struct tags to populate data into the MachineLearningComputeCluster.
func (r *MachineLearningComputeCluster) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid MachineLearningComputeCluster struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *MachineLearningComputeCluster) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		linuxVirtualMachineCostComponent(r.Region, r.InstanceType, r.MonthlyHours),
	}

	res := &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}

	instances := r.MinNodeCount

	// If the user has set the monthly hours, but the min node count is 0,
	// we assume that the user wants to calculate the cost of 1 instance.
	if r.MonthlyHours != nil && instances == 0 {
		instances = 1
	}

	if r.Instances != nil {
		instances = *r.Instances
	}

	schema.MultiplyQuantities(res, decimal.NewFromInt(instances))

	return res
}

################################################################################
# FILE: internal/resources/azure/machine_learning_compute_instance.go
# RESOURCE: azure_machine_learning_compute_instance
# SIZE: 2002 bytes | LINES: 45
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// MachineLearningComputeInstance struct represents a Azure Machine Learning Compute Instance.
//
// These use the same pricing as Azure Linux Virtual Machines.
//
// Resource information: https://azure.microsoft.com/en-gb/pricing/details/machine-learning/#overview
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/machine-learning/
type MachineLearningComputeInstance struct {
	Address      string
	Region       string
	InstanceType string
	MonthlyHours *float64 `infracost_usage:"monthly_hrs"`
}

// CoreType returns the name of this resource type
func (r *MachineLearningComputeInstance) CoreType() string {
	return "MachineLearningComputeInstance"
}

// UsageSchema defines a list which represents the usage schema of MachineLearningComputeInstance.
func (r *MachineLearningComputeInstance) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_hrs", ValueType: schema.Float64, DefaultValue: 0},
	}
}

// PopulateUsage parses the u schema.UsageData into the MachineLearningComputeInstance.
// It uses the `infracost_usage` struct tags to populate data into the MachineLearningComputeInstance.
func (r *MachineLearningComputeInstance) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid MachineLearningComputeInstance struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *MachineLearningComputeInstance) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		linuxVirtualMachineCostComponent(r.Region, r.InstanceType, r.MonthlyHours),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

################################################################################
# FILE: internal/resources/azure/managed_disk.go
# RESOURCE: azure_managed_disk
# SIZE: 10420 bytes | LINES: 313
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"math"
	"strings"

	"github.com/shopspring/decimal"
)

const Standard = "Standard"
const StandardSSD = "StandardSSD"
const Premium = "Premium"

type ManagedDisk struct {
	Address string
	Region  string
	ManagedDiskData
	MonthlyDiskOperations *int64 `infracost_usage:"monthly_disk_operations"`
}

type ManagedDiskData struct {
	DiskType          string
	DiskSizeGB        int64
	DiskIOPSReadWrite int64
	DiskMBPSReadWrite int64
}

func (r *ManagedDisk) CoreType() string {
	return "ManagedDisk"
}

func (r *ManagedDisk) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_disk_operations", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *ManagedDisk) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ManagedDisk) BuildResource() *schema.Resource {
	region := r.Region
	diskType := r.DiskType

	var monthlyDiskOperations *decimal.Decimal

	if r.MonthlyDiskOperations != nil {
		monthlyDiskOperations = decimalPtr(decimal.NewFromInt(*r.MonthlyDiskOperations))
	}

	costComponents := managedDiskCostComponents(region, diskType, r.DiskSizeGB, r.DiskIOPSReadWrite, r.DiskMBPSReadWrite, monthlyDiskOperations)

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

var diskSizeMap = map[string][]struct {
	Name string
	Size int
}{

	"Standard": {
		{"S4", 32},
		{"S6", 64},
		{"S10", 128},
		{"S15", 256},
		{"S20", 512},
		{"S30", 1024},
		{"S40", 2048},
		{"S50", 4096},
		{"S60", 8192},
		{"S70", 16384},
		{"S80", 32767},
	},
	"StandardSSD": {
		{"E1", 4},
		{"E2", 8},
		{"E3", 16},
		{"E4", 32},
		{"E6", 64},
		{"E10", 128},
		{"E15", 256},
		{"E20", 512},
		{"E30", 1024},
		{"E40", 2048},
		{"E50", 4096},
		{"E60", 8192},
		{"E70", 16384},
		{"E80", 32767},
	},
	"Premium": {
		{"P1", 4},
		{"P2", 8},
		{"P3", 16},
		{"P4", 32},
		{"P6", 64},
		{"P10", 128},
		{"P15", 256},
		{"P20", 512},
		{"P30", 1024},
		{"P40", 2048},
		{"P50", 4096},
		{"P60", 8192},
		{"P70", 16384},
		{"P80", 32767},
	},
}

var storageReplicationTypes = []string{"LRS", "ZRS"}
var ultraDiskSizes = []int{4, 8, 16, 32, 64, 128, 256, 512}
var ultraDiskSizeStep = 1024
var ultraDiskMaxSize = 65536

var diskProductNameMap = map[string]string{
	"Standard":    "Standard HDD Managed Disks",
	"StandardSSD": "Standard SSD Managed Disks",
	"Premium":     "Premium SSD Managed Disks",
}

func managedDiskCostComponents(region, diskType string, diskSizeGB, diskIOPSReadWrite, diskMBPSReadWrite int64, monthlyDiskOperations *decimal.Decimal) []*schema.CostComponent {
	p := strings.Split(diskType, "_")
	diskTypePrefix := p[0]

	var storageReplicationType string
	if len(p) > 1 {
		storageReplicationType = strings.ToUpper(p[1])
	}

	validstorageReplicationType := mapStorageReplicationType(storageReplicationType)
	if !validstorageReplicationType {
		logging.Logger.Warn().Msgf("Could not map %s to a valid storage type", storageReplicationType)
		return nil
	}

	if strings.ToLower(diskTypePrefix) == "ultrassd" {
		return ultraDiskCostComponents(region, storageReplicationType, diskSizeGB, diskIOPSReadWrite, diskMBPSReadWrite)
	}

	return standardPremiumDiskCostComponents(region, diskTypePrefix, storageReplicationType, diskSizeGB, monthlyDiskOperations)
}

func standardPremiumDiskCostComponents(region string, diskTypePrefix string, storageReplicationType string, diskSizeGB int64, monthlyDiskOperations *decimal.Decimal) []*schema.CostComponent {
	requestedSize := 30

	if diskSizeGB > 0 {
		requestedSize = int(diskSizeGB)
	}

	diskName := mapDiskName(diskTypePrefix, requestedSize)
	if diskName == "" {
		logging.Logger.Warn().Msgf("Could not map disk type %s and size %d to disk name", diskTypePrefix, requestedSize)
		return nil
	}

	productName, ok := diskProductNameMap[diskTypePrefix]
	if !ok {
		logging.Logger.Warn().Msgf("Could not map disk type %s to product name", diskTypePrefix)
		return nil
	}

	costComponents := []*schema.CostComponent{storageCostComponent(region, diskName, storageReplicationType, productName)}

	if strings.ToLower(diskTypePrefix) == "standard" || strings.ToLower(diskTypePrefix) == "standardssd" {
		var opsQty *decimal.Decimal

		if monthlyDiskOperations != nil {
			opsQty = decimalPtr(monthlyDiskOperations.Div(decimal.NewFromInt(10000)))
		}

		costComponents = append(costComponents, &schema.CostComponent{
			Name:            "Disk operations",
			Unit:            "10k operations",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: opsQty,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(region),
				Service:       strPtr("Storage"),
				ProductFamily: strPtr("Storage"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr(productName)},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("%s %s", diskName, storageReplicationType))},
					{Key: "meterName", ValueRegex: regexPtr("Disk Operations$")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
			UsageBased: true,
		})
	}

	return costComponents
}

func storageCostComponent(region, diskName, storageReplicationType, productName string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Storage (%s, %s)", diskName, storageReplicationType),
		Unit:            "months",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(region),
			Service:       strPtr("Storage"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr(productName)},
				{Key: "skuName", Value: strPtr(fmt.Sprintf("%s %s", diskName, storageReplicationType))},
				{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("^%s (%s )?Disk(s)?$", diskName, storageReplicationType))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

func ultraDiskCostComponents(region string, storageReplicationType string, diskSizeGB, diskIOPSReadWrite, diskMBPSReadWrite int64) []*schema.CostComponent {
	requestedSize := 1024
	iops := 2048
	throughput := 8

	if diskSizeGB > 0 {
		requestedSize = int(diskSizeGB)
	}

	if diskIOPSReadWrite > 0 {
		iops = int(diskIOPSReadWrite)
	}

	if diskMBPSReadWrite > 0 {
		throughput = int(diskMBPSReadWrite)
	}

	diskSize := mapUltraDiskSize(requestedSize)

	costComponents := []*schema.CostComponent{
		{
			Name:           fmt.Sprintf("Storage (ultra, %d GiB)", diskSize),
			Unit:           "GiB",
			UnitMultiplier: schema.HourToMonthUnitMultiplier,
			HourlyQuantity: decimalPtr(decimal.NewFromInt(int64(diskSize))),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(region),
				Service:       strPtr("Storage"),
				ProductFamily: strPtr("Storage"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Ultra Disks")},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("Ultra %s", storageReplicationType))},
					{Key: "meterName", ValueRegex: regexPtr("Provisioned Capacity$")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
		},
		{
			Name:           "Provisioned IOPS",
			Unit:           "IOPS",
			UnitMultiplier: schema.HourToMonthUnitMultiplier,
			HourlyQuantity: decimalPtr(decimal.NewFromInt(int64(iops))),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(region),
				Service:       strPtr("Storage"),
				ProductFamily: strPtr("Storage"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Ultra Disks")},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("Ultra %s", storageReplicationType))},
					{Key: "meterName", ValueRegex: regexPtr("Provisioned IOPS$")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
		},
		{
			Name:           "Throughput",
			Unit:           "MB/s",
			UnitMultiplier: schema.HourToMonthUnitMultiplier,
			HourlyQuantity: decimalPtr(decimal.NewFromInt(int64(throughput))),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(region),
				Service:       strPtr("Storage"),
				ProductFamily: strPtr("Storage"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Ultra Disks")},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("Ultra %s", storageReplicationType))},
					{Key: "meterName", ValueRegex: regexPtr("Provisioned Throughput \\(MBps\\)$")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
		},
	}

	return costComponents
}

func mapDiskName(diskType string, requestedSize int) string {
	diskTypeMap, ok := diskSizeMap[diskType]
	if !ok {
		return ""
	}

	name := ""
	for _, v := range diskTypeMap {
		name = v.Name
		if v.Size >= requestedSize {
			break
		}
	}

	if requestedSize > diskTypeMap[len(diskTypeMap)-1].Size {
		return ""
	}

	return name
}

func mapStorageReplicationType(storageReplicationType string) bool {
	for _, b := range storageReplicationTypes {
		if storageReplicationType == b {
			return true
		}
	}

	return false
}

func mapUltraDiskSize(requestedSize int) int {
	if requestedSize >= ultraDiskMaxSize {
		return ultraDiskMaxSize
	}

	if requestedSize < ultraDiskSizes[0] {
		return ultraDiskSizes[0]
	}

	if requestedSize > ultraDiskSizes[len(ultraDiskSizes)-1] {
		return int(math.Ceil(float64(requestedSize)/float64(ultraDiskSizeStep))) * ultraDiskSizeStep
	}

	size := 0
	for _, v := range ultraDiskSizes {
		size = v
		if size >= requestedSize {
			break
		}
	}

	return size

}

################################################################################
# FILE: internal/resources/azure/monitor_action_group.go
# RESOURCE: azure_monitor_action_group
# SIZE: 10413 bytes | LINES: 270
################################################################################
package azure

import (
	"fmt"
	"sort"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// MonitorActionGroup struct represents an Azure Monitor Action Group.
//
// Resource information: https://learn.microsoft.com/en-us/azure/azure-monitor/alerts/action-groups
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/monitor/
type MonitorActionGroup struct {
	Address string
	Region  string

	EmailReceivers                  int
	ITSMEventReceivers              int
	PushNotificationReceivers       int
	SecureWebHookReceivers          int
	WebHookReceivers                int
	SMSReceiversByCountryCode       map[int]int
	VoiceCallReceiversByCountryCode map[int]int

	MonthlyNotifications *int64 `infracost_usage:"monthly_notifications"`
}

func (r *MonitorActionGroup) CoreType() string {
	return "MonitorActionGroup"
}

func (r *MonitorActionGroup) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_notifications", ValueType: schema.Int64, DefaultValue: 0},
	}
}

// PopulateUsage parses the u schema.UsageData
// It uses the `infracost_usage` struct tags to populate data.
func (r *MonitorActionGroup) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from the struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *MonitorActionGroup) BuildResource() *schema.Resource {
	subResources := []*schema.Resource{}
	costComponents := []*schema.CostComponent{}

	if r.EmailReceivers > 0 {
		costComponents = append(costComponents, r.emailCostComponent(r.EmailReceivers, r.MonthlyNotifications))
	}
	if r.ITSMEventReceivers > 0 {
		costComponents = append(costComponents, r.ITSMEventCostComponent(r.ITSMEventReceivers, r.MonthlyNotifications))
	}
	if r.PushNotificationReceivers > 0 {
		costComponents = append(costComponents, r.pushNotificationCostComponent(r.PushNotificationReceivers, r.MonthlyNotifications))
	}
	if r.SecureWebHookReceivers > 0 {
		costComponents = append(costComponents, r.secureWebHookCostComponent(r.SecureWebHookReceivers, r.MonthlyNotifications))
	}
	if r.WebHookReceivers > 0 {
		costComponents = append(costComponents, r.webHookCostComponent(r.WebHookReceivers, r.MonthlyNotifications))
	}

	// SMS messages
	smsCostComponents := []*schema.CostComponent{}
	for _, countryCode := range r.getSortedKeys(r.SMSReceiversByCountryCode) {
		smsCostComponents = append(smsCostComponents, r.smsMessageCostComponent(countryCode, r.SMSReceiversByCountryCode[countryCode], r.MonthlyNotifications))
	}
	if len(smsCostComponents) > 0 {
		subResources = append(subResources, &schema.Resource{
			Name:           "SMS messages",
			CostComponents: smsCostComponents,
		})
	}

	// Voice calls
	voiceCallCostComponents := []*schema.CostComponent{}
	for _, countryCode := range r.getSortedKeys(r.VoiceCallReceiversByCountryCode) {
		voiceCallCostComponents = append(voiceCallCostComponents, r.voiceCallsCostComponent(countryCode, r.VoiceCallReceiversByCountryCode[countryCode], r.MonthlyNotifications))
	}
	if len(voiceCallCostComponents) > 0 {
		subResources = append(subResources, &schema.Resource{
			Name:           "Voice calls",
			CostComponents: voiceCallCostComponents,
		})
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		SubResources:   subResources,
	}
}

func (r *MonitorActionGroup) emailCostComponent(count int, quantity *int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Email notifications (%d)", count),
		Unit:            "emails",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: r.monthlyQuantity(count, quantity),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			Service:       strPtr("Azure Monitor"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr("Emails")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("1000"),
		},
		UsageBased: true,
	}
}

func (r *MonitorActionGroup) ITSMEventCostComponent(count int, quantity *int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("ITSM connectors (%d)", count),
		Unit:            "events",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: r.monthlyQuantity(count, quantity),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			Service:       strPtr("Azure Monitor"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr("Notifications")},
				{Key: "meterName", Value: strPtr("Notifications ITSM Connector Create/Update Event")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("1000"),
		},
		UsageBased: true,
	}
}

func (r *MonitorActionGroup) pushNotificationCostComponent(count int, quantity *int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Push notifications (%d)", count),
		Unit:            "notifications",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: r.monthlyQuantity(count, quantity),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			Service:       strPtr("Azure Monitor"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr("Notifications")},
				{Key: "meterName", Value: strPtr("Notifications Push Notification")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("1000"),
		},
		UsageBased: true,
	}
}

func (r *MonitorActionGroup) secureWebHookCostComponent(count int, quantity *int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Secure web hooks (%d)", count),
		Unit:            "notifications",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: r.monthlyQuantity(count, quantity),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			Service:       strPtr("Azure Monitor"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr("Notifications")},
				{Key: "meterName", Value: strPtr("Notifications Secure web hook")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("100"),
		},
		UsageBased: true,
	}
}

func (r *MonitorActionGroup) webHookCostComponent(count int, quantity *int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Web hooks (%d)", count),
		Unit:            "notifications",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: r.monthlyQuantity(count, quantity),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			Service:       strPtr("Azure Monitor"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr("Notifications")},
				{Key: "meterName", Value: strPtr("Notifications Web hook")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("10000"),
		},
		UsageBased: true,
	}
}

func (r *MonitorActionGroup) smsMessageCostComponent(countryCode int, count int, quantity *int64) *schema.CostComponent {
	var startUsageAmount string
	if countryCode == 1 {
		startUsageAmount = "100" // the first 10 US calls are free
	} else {
		startUsageAmount = "0"
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Country code %d (%d)", countryCode, count),
		Unit:            "messages",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: r.monthlyQuantity(count, quantity),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			Service:       strPtr("Azure Monitor"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(fmt.Sprintf("SMS Country Code %d", countryCode))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(startUsageAmount),
		},
		UsageBased: true,
	}
}

func (r *MonitorActionGroup) voiceCallsCostComponent(countryCode int, count int, quantity *int64) *schema.CostComponent {
	var meterName string
	if countryCode == 1 {
		meterName = "Voice Calls"
	} else {
		meterName = fmt.Sprintf("Voice Calls Voice Call Country Code %d", countryCode)
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Country code %d (%d)", countryCode, count),
		Unit:            "calls",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: r.monthlyQuantity(count, quantity),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			Service:       strPtr("Azure Monitor"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr("Voice Calls")},
				{Key: "meterName", Value: strPtr(meterName)},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("10"),
		},
		UsageBased: true,
	}
}

func (r *MonitorActionGroup) monthlyQuantity(count int, quantity *int64) *decimal.Decimal {
	if quantity == nil {
		return nil
	}

	return decimalPtr(decimal.NewFromInt(int64(count) * *quantity))
}

func (r *MonitorActionGroup) getSortedKeys(m map[int]int) []int {
	keys := make([]int, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}

	sort.Ints(keys)

	return keys
}

func (r *MonitorActionGroup) normalizedRegion() *string {
	if r.Region == "global" {
		return strPtr("Global")
	}
	return strPtr(r.Region)
}

################################################################################
# FILE: internal/resources/azure/monitor_data_collection_rule.go
# RESOURCE: azure_monitor_data_collection_rule
# SIZE: 2805 bytes | LINES: 66
################################################################################
package azure

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// MonitorDataCollectionRule struct represents an Azure Monitor Data Collection Rule.
//
// Resource information: https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/monitor_data_collection_rule
// Pricing information: https://azure.microsoft.com/en-in/pricing/details/monitor/
type MonitorDataCollectionRule struct {
	Address string
	Region  string

	MonthlyCustomMetricsSamplesGB *int64 `infracost_usage:"monthly_custom_metrics_samples"`
}

// CoreType returns the name of this resource type
func (r *MonitorDataCollectionRule) CoreType() string {
	return "MonitorDataCollectionRule"
}

// UsageSchema defines a list which represents the usage schema of MonitorDataCollectionRule.
func (r *MonitorDataCollectionRule) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_custom_metrics_samples", ValueType: schema.Int64, DefaultValue: 0},
	}
}

// PopulateUsage parses the u schema.UsageData into the MonitorDataCollectionRule.
// It uses the `infracost_usage` struct tags to populate data into the MonitorDataCollectionRule.
func (r *MonitorDataCollectionRule) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid MonitorDataCollectionRule struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *MonitorDataCollectionRule) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.metricsIngestionCostComponent(r.MonthlyCustomMetricsSamplesGB),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *MonitorDataCollectionRule) metricsIngestionCostComponent(quantity *int64) *schema.CostComponent {
	var q *decimal.Decimal
	if quantity != nil {
		q = decimalPtr(decimal.NewFromInt(*quantity).Div(decimal.NewFromInt(10000000)))
	}

	return &schema.CostComponent{
		Name:            "Metrics ingestion",
		Unit:            "10M samples",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: q,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Monitor"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr("Metrics ingestion")},
				{Key: "meterName", Value: strPtr("Metrics ingestion Metric samples")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/monitor_diagnostic_setting.go
# RESOURCE: azure_monitor_diagnostic_setting
# SIZE: 2809 bytes | LINES: 69
################################################################################
package azure

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// MonitorDiagnosticSetting struct represents an Azure Monitor Diagnostics Setting
//
// Resource information: https://learn.microsoft.com/en-us/azure/azure-monitor/essentials/diagnostic-settings
// Pricing information: https://azure.microsoft.com/en-in/pricing/details/monitor/
type MonitorDiagnosticSetting struct {
	Address string
	Region  string

	EventHubTarget        bool
	PartnerSolutionTarget bool
	StorageAccountTarget  bool

	MonthlyPlatformLogGB *int64 `infracost_usage:"monthly_platform_log_gb"`
}

// CoreType returns the name of this resource type
func (r *MonitorDiagnosticSetting) CoreType() string {
	return "MonitorDiagnosticSetting"
}

// UsageSchema defines a list which represents the usage schema of MonitorDiagnosticSetting.
func (r *MonitorDiagnosticSetting) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_platform_log_gb", ValueType: schema.Int64, DefaultValue: 0},
	}
}

// PopulateUsage parses the u schema.UsageData into the MonitorDiagnosticSetting.
// It uses the `infracost_usage` struct tags to populate data into the MonitorDiagnosticSetting.
func (r *MonitorDiagnosticSetting) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid MonitorDiagnosticSetting struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *MonitorDiagnosticSetting) BuildResource() *schema.Resource {
	var costComponents []*schema.CostComponent

	if r.EventHubTarget || r.PartnerSolutionTarget || r.StorageAccountTarget {
		costComponents = []*schema.CostComponent{r.platformLogComponent(r.MonthlyPlatformLogGB)}
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *MonitorDiagnosticSetting) platformLogComponent(q *int64) *schema.CostComponent {
	var quantity *decimal.Decimal
	if q != nil {
		quantity = decimalPtr(decimal.NewFromInt(*q))
	}

	return &schema.CostComponent{
		Name:            "Platform logs processed",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Monitor"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr("Platform Logs")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/monitor_metric_alert.go
# RESOURCE: azure_monitor_metric_alert
# SIZE: 3653 bytes | LINES: 98
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/shopspring/decimal"
)

// MonitorMetricAlert struct represents an Azure Monitor Metric Group.
//
// Resource information: https://learn.microsoft.com/en-us/azure/azure-monitor/alerts/alerts-overview
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/monitor/
type MonitorMetricAlert struct {
	Address string
	Region  string

	Enabled                        bool
	ScopeCount                     int
	CriteriaDimensionsCount        int
	DynamicCriteriaDimensionsCount int
}

func (r *MonitorMetricAlert) CoreType() string {
	return "MonitorMetricAlert"
}

func (r *MonitorMetricAlert) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData
// It uses the `infracost_usage` struct tags to populate data.
func (r *MonitorMetricAlert) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from the struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *MonitorMetricAlert) BuildResource() *schema.Resource {
	if !r.Enabled {
		return &schema.Resource{
			Name: r.Address,
		}
	}

	costComponents := []*schema.CostComponent{}

	totalTimeSeries := int64(r.ScopeCount * (r.CriteriaDimensionsCount + r.DynamicCriteriaDimensionsCount))
	if totalTimeSeries > 0 {
		costComponents = append(costComponents, r.alertMetricMonitoringCostComponent(totalTimeSeries))
	}

	dynamicTimeSeries := int64(r.ScopeCount * r.DynamicCriteriaDimensionsCount)
	if dynamicTimeSeries > 0 {
		costComponents = append(costComponents, r.dynamicThresholdCostComponent(dynamicTimeSeries))
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
	}
}

func (r *MonitorMetricAlert) alertMetricMonitoringCostComponent(quantity int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Metrics monitoring",
		Unit:            "time-series",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(quantity)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			Service:       strPtr("Azure Monitor"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr("Alerts Metric Monitored")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("10"),
		},
	}
}

func (r *MonitorMetricAlert) dynamicThresholdCostComponent(quantity int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Dynamic threshold monitoring",
		Unit:            "time-series",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(quantity)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			Service:       strPtr("Azure Monitor"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr("Alerts Dynamic Threshold")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("0"),
		},
	}
}

func (r *MonitorMetricAlert) normalizedRegion() *string {
	if r.Region == "global" {
		return strPtr("Global")
	}
	return strPtr(r.Region)
}

################################################################################
# FILE: internal/resources/azure/monitor_scheduled_query_rules_alert.go
# RESOURCE: azure_monitor_scheduled_query_rules_alert
# SIZE: 4404 bytes | LINES: 108
################################################################################
package azure

import (
	"fmt"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/shopspring/decimal"
)

// MonitorScheduledQueryRulesAlert struct represents Azure Monitor Log Alert Rules,
// aka Scheduled Query Rules.
//
// Resource information:
//
//	 https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/monitor_scheduled_query_rules_alert_v2
//		https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/monitor_scheduled_query_rules_alert
//
// Pricing information: https://azure.microsoft.com/en-in/pricing/details/monitor/
type MonitorScheduledQueryRulesAlert struct {
	Address string
	Region  string

	Enabled          bool
	TimeSeriesCount  int64
	FrequencyMinutes int64
}

// CoreType returns the name of this resource type
func (r *MonitorScheduledQueryRulesAlert) CoreType() string {
	return "MonitorScheduledQueryRulesAlert"
}

// UsageSchema defines a list which represents the usage schema of MonitorScheduledQueryRulesAlert.
func (r *MonitorScheduledQueryRulesAlert) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the MonitorScheduledQueryRulesAlert.
// It uses the `infracost_usage` struct tags to populate data into the MonitorScheduledQueryRulesAlert.
func (r *MonitorScheduledQueryRulesAlert) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid MonitorScheduledQueryRulesAlert struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *MonitorScheduledQueryRulesAlert) BuildResource() *schema.Resource {
	if !r.Enabled {
		return &schema.Resource{
			Name: r.Address,
		}
	}

	var normalizedFrequency int
	switch {
	case r.FrequencyMinutes >= 15:
		normalizedFrequency = 15
	case r.FrequencyMinutes >= 10:
		normalizedFrequency = 10
	case r.FrequencyMinutes >= 5:
		normalizedFrequency = 5
	default:
		normalizedFrequency = 1
	}

	costComponents := []*schema.CostComponent{
		r.logAlertMonitoringCostComponent(normalizedFrequency),
	}

	if r.TimeSeriesCount > 1 {
		costComponents = append(costComponents, r.logAlertAdditionalTimeSeriesCostComponent(normalizedFrequency, r.TimeSeriesCount-1))
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *MonitorScheduledQueryRulesAlert) logAlertMonitoringCostComponent(normalizedFrequency int) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Log alerts monitoring (%d minute frequency)", normalizedFrequency),
		Unit:            "rule",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			Service:       strPtr("Azure Monitor"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr(fmt.Sprintf("Alerts System Log Monitored at %d Minute Frequency", normalizedFrequency))},
			},
		},
	}
}

func (r *MonitorScheduledQueryRulesAlert) logAlertAdditionalTimeSeriesCostComponent(normalizedFrequency int, additionalCount int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Additional time-series monitoring (%d minute frequency)", normalizedFrequency),
		Unit:            "time-series",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(additionalCount)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			Service:       strPtr("Azure Monitor"),
			ProductFamily: strPtr("Management and Governance"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr(fmt.Sprintf("Alerts Resource Monitored at %d Minute Frequency", normalizedFrequency))},
			},
		},
	}
}

func (r *MonitorScheduledQueryRulesAlert) normalizedRegion() *string {
	if r.Region == "global" {
		return strPtr("Global")
	}
	return strPtr(r.Region)
}

################################################################################
# FILE: internal/resources/azure/mssql_elasticpool.go
# RESOURCE: azure_mssql_elasticpool
# SIZE: 7681 bytes | LINES: 186
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

var mssqlElasticPoolPremiumDTUIncludedStorage = map[int]float64{
	125:  250,
	250:  500,
	500:  750,
	1000: 1024,
	1500: 1536,
	2000: 2048,
	2500: 2560,
	3000: 3072,
	3500: 3584,
	4000: 4096,
}

// MSSQLElasticPool represents an Azure MSSQL Elastic Pool instance.
//
// More resource information here: https://azure.microsoft.com/en-gb/products/azure-sql/database/
// Pricing information here: https://azure.microsoft.com/en-gb/pricing/details/azure-sql-database/
type MSSQLElasticPool struct {
	Address       string
	Region        string
	SKU           string
	LicenseType   string
	Tier          string
	Family        string
	Cores         *int64
	DTUCapacity   *int64
	MaxSizeGB     *float64
	ZoneRedundant bool
}

func (r *MSSQLElasticPool) CoreType() string {
	return "MSSQLElasticPool"
}

func (r *MSSQLElasticPool) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the MSSQLElasticPool.
func (r *MSSQLElasticPool) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid MSSQLElasticPool.
// It returns a MSSQLElasticPool as a *schema.Resource with cost components initialized.
//
// MSSQLElasticPool splits pricing into two different models. DTU & vCores.
//
//	Database Transaction Unit (DTU) is made a performance metric representing a mixture of performance metrics
//	in Azure SQL. Some include: CPU, I/O, Memory. DTU is used as Azure tries to simplify billing by using a single metric.
//
//	Virtual Core (vCore) pricing is designed to translate from on premise hardware metrics (cores) into the cloud
//	SQL instance. vCore is designed to allow users to better estimate their resource limits, e.g. RAM.
//
// Elastic pools that follow a DTU pricing model have the following costs associated with them:
//
//  1. Costs based on the number of DTUs that the SQL database has
//  2. Extra backup data costs - this is configured using MSSQLElasticPool.ExtraDataStorageGB
//  3. Long term data backup costs - this is configured using MSSQLElasticPool.LongTermRetentionStorageGB
//
// Elastic pools that follow a vCore pricing model have the following costs associated with them:
//
//  1. Costs based on the number of vCores the resource has
//  2. Additional charge for SQL Server licensing based on vCores amount
//  3. Charges for storage used
//  4. Charges for long term data backup - this is configured using MSSQLElasticPool.LongTermRetentionStorageGB
//
// This method is called after the resource is initialized by an IaC provider. MSSQLElasticPool is used by both mssql_elasticpool
// and sql_elasticpool Terraform resources.
func (r *MSSQLElasticPool) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: r.costComponents(),
	}
}

func (r *MSSQLElasticPool) costComponents() []*schema.CostComponent {
	s := strings.ToLower(r.SKU)
	if s == "basicpool" || s == "standardpool" || s == "premiumpool" {
		return r.dtuCostComponents()
	}

	return r.vCoreCostComponents()
}

func (r *MSSQLElasticPool) dtuCostComponents() []*schema.CostComponent {
	productName := fmt.Sprintf("SQL Database Elastic Pool - %s", r.Tier)

	var dtuCapacity int64
	if r.DTUCapacity != nil {
		dtuCapacity = *r.DTUCapacity
	}

	costComponents := []*schema.CostComponent{
		{
			Name: fmt.Sprintf("Compute (%s, %d DTUs)", r.Tier, dtuCapacity),
			Unit: "hours",
			// This is a bit of a hack, but the Azure pricing API returns the price per day
			// and the Azure pricing calculator uses 730 hours to show the cost
			// so we need to convert the price per day to price per hour.
			UnitMultiplier:  schema.DayToMonthUnitMultiplier,
			MonthlyQuantity: decimalPtr(schema.DaysInMonth),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr("SQL Database"),
				ProductFamily: strPtr("Databases"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr(productName)},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("%d DTU Pack", dtuCapacity))},
					{Key: "meterName", Value: strPtr("eDTUs")},
				},
			},
			PriceFilter: priceFilterConsumption,
		},
	}

	var extraStorageGB float64

	if strings.ToLower(r.Tier) == "standard" && r.MaxSizeGB != nil {
		includedStorageGB := float64(dtuCapacity)
		extraStorageGB = *r.MaxSizeGB - includedStorageGB
	} else if strings.ToLower(r.Tier) == "premium" && r.MaxSizeGB != nil {
		includedStorageGB, ok := mssqlElasticPoolPremiumDTUIncludedStorage[int(*r.DTUCapacity)]
		if ok {
			extraStorageGB = *r.MaxSizeGB - includedStorageGB
		}
	}

	if extraStorageGB > 0 {
		costComponents = append(costComponents, r.extraDataStorageCostComponent(extraStorageGB))
	}

	return costComponents
}

func (r *MSSQLElasticPool) vCoreCostComponents() []*schema.CostComponent {
	costComponents := r.computeHoursCostComponents()

	if strings.ToLower(r.LicenseType) == "licenseincluded" {
		costComponents = append(costComponents, r.sqlLicenseCostComponent())
	}

	costComponents = append(costComponents, r.storageCostComponent())

	return costComponents
}

func (r *MSSQLElasticPool) computeHoursCostComponents() []*schema.CostComponent {
	var cores int64
	if r.Cores != nil {
		cores = *r.Cores
	}

	productNameRegex := fmt.Sprintf("/%s - %s/", r.Tier, r.Family)
	name := fmt.Sprintf("Compute (%s, %d vCore)", r.SKU, cores)

	costComponents := []*schema.CostComponent{
		{
			Name:           name,
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: r.productFilter([]*schema.AttributeFilter{
				{Key: "productName", ValueRegex: strPtr(productNameRegex)},
				{Key: "skuName", Value: strPtr(fmt.Sprintf("%d vCore", cores))},
			}),
			PriceFilter: priceFilterConsumption,
		},
	}

	// Zone redundancy is free for premium and business critical tiers
	if strings.EqualFold(r.Tier, sqlGeneralPurposeTier) && r.ZoneRedundant {
		costComponents = append(costComponents, &schema.CostComponent{
			Name:           fmt.Sprintf("Zone redundancy (%s, %d vCore)", r.SKU, cores),
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: r.productFilter([]*schema.AttributeFilter{
				{Key: "productName", ValueRegex: strPtr(productNameRegex)},
				{Key: "skuName", Value: strPtr(fmt.Sprintf("%d vCore Zone Redundancy", cores))},
			}),
			PriceFilter: priceFilterConsumption,
		})
	}

	return costComponents
}

func (r *MSSQLElasticPool) extraDataStorageCostComponent(extraStorageGB float64) *schema.CostComponent {
	return mssqlExtraDataStorageCostComponent(r.Region, r.Tier, extraStorageGB)
}

func (r *MSSQLElasticPool) sqlLicenseCostComponent() *schema.CostComponent {
	return mssqlLicenseCostComponent(r.Region, r.Cores, r.Tier)
}

func (r *MSSQLElasticPool) storageCostComponent() *schema.CostComponent {
	return mssqlStorageCostComponent(r.Region, r.Tier, r.ZoneRedundant, r.MaxSizeGB)
}

func (r *MSSQLElasticPool) productFilter(filters []*schema.AttributeFilter) *schema.ProductFilter {
	return mssqlProductFilter(r.Region, filters)
}

################################################################################
# FILE: internal/resources/azure/mssql_managed_instance.go
# RESOURCE: azure_mssql_managed_instance
# SIZE: 7862 bytes | LINES: 190
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

const (
	mssqlMIServiceName   = "SQL Managed Instance"
	mssqlMIProductFamily = "Databases"
)

// MSSQLManagedInstance struct represents an azure Sql Managed Instance.
//
// # MSSQLManagedInstance currently only Gen5 database instance
//
// More resource information here: https://azure.microsoft.com/en-gb/products/azure-sql/managed-instance/
// Pricing information here: https://azure.microsoft.com/en-gb/pricing/details/azure-sql-managed-instance/single/
type MSSQLManagedInstance struct {
	Address            string
	Region             string
	SKU                string
	LicenseType        string
	Cores              int64
	StorageSizeInGb    int64
	StorageAccountType string
	// LongTermRetentionStorageGB defines a usage param that allows users to define how many gb of cold storage the database uses.
	// This is storage that can be kept for up to 10 years.
	LongTermRetentionStorageGB *int64 `infracost_usage:"long_term_retention_storage_gb"`
	BackupStorageGB            *int64 `infracost_usage:"backup_storage_gb"`
}

// CoreType returns the name of this resource type
func (r *MSSQLManagedInstance) CoreType() string {
	return "MSSQLManagedInstance"
}

// UsageSchema defines a list which represents the usage schema of MSSQLManagedInstance.
func (r *MSSQLManagedInstance) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "backup_storage_gb", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "long_term_retention_storage_gb", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the MSSQLManagedInstance.
// It uses the `infracost_usage` struct tags to populate data into the MSSQLManagedInstance.
func (r *MSSQLManagedInstance) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid MSSQLManagedInstance struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *MSSQLManagedInstance) BuildResource() *schema.Resource {
	costComponents := r.costComponents()

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *MSSQLManagedInstance) costComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{
		{
			Name:           fmt.Sprintf("Compute (%s %d cores)", strings.ToTitle(r.SKU), r.Cores),
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr(mssqlMIServiceName),
				ProductFamily: strPtr(mssqlMIProductFamily),
				AttributeFilters: ([]*schema.AttributeFilter{
					{Key: "productName", Value: r.productDescription()},
					{Key: "skuName", Value: r.meteredName()},
				}),
			},
			PriceFilter: priceFilterConsumption,
		},
	}

	if r.StorageSizeInGb-32 > 0 {
		costComponents = append(costComponents, r.mssqlMIStorageCostComponent(), r.mssqlMIBackupCostComponent())
	}

	if r.LicenseType == "LicenseIncluded" {
		costComponents = append(costComponents, r.mssqlMILicenseCostComponent())
	}

	costComponents = append(costComponents, r.mssqlMILongTermRetentionStorageGBCostComponent())

	return costComponents
}

func (r *MSSQLManagedInstance) productDescription() *string {
	productDescription := ""

	if strings.Contains(r.SKU, "GP") {
		productDescription = "SQL Managed Instance General Purpose"
	} else if strings.Contains(r.SKU, "BC") {
		productDescription = "SQL Managed Instance Business Critical"
	}

	if strings.Contains(r.SKU, "Gen5") {
		productDescription = fmt.Sprintf("%s - %s", productDescription, "Compute Gen5")
	}

	return strPtr(productDescription)
}

func (r *MSSQLManagedInstance) meteredName() *string {
	meterName := fmt.Sprintf("%d %s", r.Cores, "vCore")

	return strPtr(meterName)
}

func (r *MSSQLManagedInstance) mssqlMIStorageCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Additional Storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(r.StorageSizeInGb - 32)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(mssqlMIServiceName),
			ProductFamily: strPtr(mssqlMIProductFamily),
			AttributeFilters: ([]*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("SQL Managed Instance General Purpose - Storage")},
				{Key: "skuName", Value: strPtr("General Purpose")},
				{Key: "meterName", ValueRegex: regexPtr("Data Stored$")},
			}),
		},
		PriceFilter: priceFilterConsumption,
	}
}

func (r *MSSQLManagedInstance) mssqlMIBackupCostComponent() *schema.CostComponent {
	var backup *decimal.Decimal

	if r.BackupStorageGB != nil {
		backup = decimalPtr(decimal.NewFromInt(*r.BackupStorageGB))
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("PITR backup storage (%s)", r.StorageAccountType),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: backup,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(mssqlMIServiceName),
			ProductFamily: strPtr(mssqlMIProductFamily),
			AttributeFilters: ([]*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("SQL Managed Instance PITR Backup Storage")},
				{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Data Stored", r.StorageAccountType))},
			}),
		},
		PriceFilter: priceFilterConsumption,
		UsageBased:  true,
	}
}

func (r *MSSQLManagedInstance) mssqlMILicenseCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "SQL license",
		Unit:           "vCore-hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(r.Cores)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr("Global"),
			Service:       strPtr(mssqlMIServiceName),
			ProductFamily: strPtr(mssqlMIProductFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("SQL Managed Instance General Purpose - SQL License")},
				{Key: "meterName", Value: strPtr("vCore")},
			},
		},
		PriceFilter: priceFilterConsumption,
	}
}

func (r *MSSQLManagedInstance) mssqlMILongTermRetentionStorageGBCostComponent() *schema.CostComponent {
	var retention *decimal.Decimal

	if r.LongTermRetentionStorageGB != nil {
		retention = decimalPtr(decimal.NewFromInt(*r.LongTermRetentionStorageGB))
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("LTR backup storage (%s)", r.StorageAccountType),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: retention,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(mssqlMIServiceName),
			ProductFamily: strPtr(mssqlMIProductFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("SQL Managed Instance - LTR Backup Storage")},
				{Key: "meterName", Value: strPtr(fmt.Sprintf("LTR Backup %s Data Stored", r.StorageAccountType))},
			},
		},
		PriceFilter: priceFilterConsumption,
		UsageBased:  true,
	}
}

################################################################################
# FILE: internal/resources/azure/mysql_flexible_server.go
# RESOURCE: azure_mysql_flexible_server
# SIZE: 7075 bytes | LINES: 175
################################################################################
package azure

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// MySQLFlexibleServer struct represents Azure MySQL Flexible Server resource.
//
// Resource information: https://docs.microsoft.com/en-gb/azure/mysql/flexible-server/
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/mysql/flexible-server/
type MySQLFlexibleServer struct {
	Address string
	Region  string

	SKU             string
	Tier            string
	InstanceType    string
	InstanceVersion string
	Storage         int64
	IOPS            int64

	// "usage" args
	AdditionalBackupStorageGB *float64 `infracost_usage:"additional_backup_storage_gb"`
}

// CoreType returns the name of this resource type
func (r *MySQLFlexibleServer) CoreType() string {
	return "MySQLFlexibleServer"
}

// UsageSchema defines a list which represents the usage schema of MySQLFlexibleServerUsageSchema.
func (r *MySQLFlexibleServer) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "additional_backup_storage_gb", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the MySQLFlexibleServer.
// It uses the `infracost_usage` struct tags to populate data into the MySQLFlexibleServer.
func (r *MySQLFlexibleServer) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid MySQLFlexibleServer struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *MySQLFlexibleServer) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.computeCostComponent(),
		r.storageCostComponent(),
	}

	if iopsCostComponent := r.iopsCostComponent(); iopsCostComponent != nil {
		costComponents = append(costComponents, iopsCostComponent)
	}

	costComponents = append(costComponents, r.backupCostComponent())

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

// computeCostComponent returns a cost component for server compute requirements.
func (r *MySQLFlexibleServer) computeCostComponent() *schema.CostComponent {
	attrs := getFlexibleServerFilterAttributes(r.Tier, r.InstanceType, r.InstanceVersion)

	// MySQL Flexible Server uses "Business Critical" for the Memory Optimized instances
	tierName := attrs.TierName
	if tierName == "Memory Optimized" {
		tierName = "Business Critical"
	}

	series := attrs.Series
	// We've seen two spaces in the data in the past hence '\s+'
	seriesSuffix := fmt.Sprintf("\\s+%s Series", series)
	// This seems to be a special case where the series doesn't appear in the product name
	if tierName == "Business Critical" && series == "Edsv4" {
		seriesSuffix = " Compute"
	}

	if tierName == "General Purpose" && series == "Dadsv5" {
		seriesSuffix = ""
	}

	productNameRegex := fmt.Sprintf("^Azure Database for MySQL Flexible Server %s%s", tierName, seriesSuffix)

	return &schema.CostComponent{
		Name:           fmt.Sprintf("Compute (%s)", r.SKU),
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Database for MySQL"),
			ProductFamily: strPtr("Databases"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", ValueRegex: regexPtr(productNameRegex)},
				{Key: "skuName", ValueRegex: regexPtr(fmt.Sprintf("^%s$", attrs.SKUName))},
				{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("^%s$", attrs.MeterName))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

// storageCostComponent returns a cost component for server's storage. If
// storage is not defined, it is assumed it is a minimum default of 20GB.
func (r *MySQLFlexibleServer) storageCostComponent() *schema.CostComponent {
	storage := r.Storage
	if storage == 0 {
		storage = 20 // minimum default
	}

	return &schema.CostComponent{
		Name:            "Storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(storage)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Database for MySQL"),
			ProductFamily: strPtr("Databases"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Azure Database for MySQL Flexible Server Storage")},
				{Key: "meterName", Value: strPtr("Storage Data Stored")},
			},
		},
	}
}

// iopsCostComponent returns a cost component for additional IOPS. Each server
// includes free 300 IOPS and 3 IOPS per each storage GB. As minimum storage is
// 20GB, the total free IOPS is 360. If no IOPS is defined it's assumed it is
// the minimum of 360.
func (r *MySQLFlexibleServer) iopsCostComponent() *schema.CostComponent {
	var freeIOPS int64 = 360

	iops := r.IOPS
	if iops == 0 {
		iops = freeIOPS
	}

	additionalIOPS := iops - freeIOPS

	if additionalIOPS <= 0 {
		return nil
	}

	return &schema.CostComponent{
		Name:            "Additional IOPS",
		Unit:            "IOPS",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(additionalIOPS)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Database for MySQL"),
			ProductFamily: strPtr("Databases"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Azure Database for MySQL Flexible Server Storage")},
				{Key: "skuName", Value: strPtr("Additional IOPS")},
			},
		},
	}
}

// backupCostComponent returns a cost component for additional backup storage.
func (r *MySQLFlexibleServer) backupCostComponent() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.AdditionalBackupStorageGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.AdditionalBackupStorageGB))
	}

	return &schema.CostComponent{
		Name:            "Additional backup storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Database for MySQL"),
			ProductFamily: strPtr("Databases"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Azure Database for MySQL Flexible Server Backup Storage")},
				{Key: "meterName", Value: strPtr("Backup Storage LRS Data Stored")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/network_connection_monitor.go
# RESOURCE: azure_network_connection_monitor
# SIZE: 4504 bytes | LINES: 114
################################################################################
package azure

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
)

// NetworkConnectionMonitor struct represents Azure Network Watcher Connection
// Monitor (new)
//
// This resource is charged for each test. Connection Monitors can have
// multiple test groups. A test is a combination of a source endpoint,
// destination endpoint and test configuration within a test group. The number
// of tests is calculated by multiplying the number of source endpoints,
// destination endpoints and test configurations for each enabled test group.
//
// There is a free limit of 1000 tests.
//
// If the test configuration is for a scale set, then each instance of that
// scale set counts as a separate test. Since we can't get the number of
// instances in each scale set we allow the `tests` attribute to be overridden
// in the usage file.
//
// Resource information: https://azure.microsoft.com/en-gb/pricing/details/network-watcher/#overview
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/network-watcher/#pricing
type NetworkConnectionMonitor struct {
	Address string
	Region  string

	Tests *int64 `infracost_usage:"tests"`
}

// CoreType returns the name of this resource type
func (r *NetworkConnectionMonitor) CoreType() string {
	return "NetworkConnectionMonitor"
}

// UsageSchema defines a list which represents the usage schema of NetworkConnectionMonitor.
func (r *NetworkConnectionMonitor) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "tests", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the NetworkConnectionMonitor.
// It uses the `infracost_usage` struct tags to populate data into the NetworkConnectionMonitor.
func (r *NetworkConnectionMonitor) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid NetworkConnectionMonitor struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *NetworkConnectionMonitor) BuildResource() *schema.Resource {
	costComponents := r.testsCostComponents()

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *NetworkConnectionMonitor) testsCostComponents() []*schema.CostComponent {
	var qty *decimal.Decimal
	if r.Tests != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.Tests))
	}

	tierData := []struct {
		suffix     string
		startUsage string
	}{
		{suffix: "(0-10)", startUsage: "0"},
		{suffix: "(10-240,010)", startUsage: "10"},
		{suffix: "(240,010-750,010)", startUsage: "240010"},
		{suffix: "(750,010-1,000,010)", startUsage: "750010"},
		{suffix: "(1,000,010+)", startUsage: "1000010"},
	}

	tierLimits := []int{10, 240000, 510000, 250000}

	var costComponents []*schema.CostComponent

	if len(tierData) == 0 {
		return costComponents
	}

	if qty == nil {
		costComponents = append(costComponents, r.buildTestsCostComponent(tierData[0].suffix, tierData[0].startUsage, nil))
	} else {
		tiers := usage.CalculateTierBuckets(*qty, tierLimits)
		for i, d := range tierData {
			// Skip the first tier since it's free
			if i == 0 {
				continue
			}

			if tiers[i].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.buildTestsCostComponent(d.suffix, d.startUsage, decimalPtr(tiers[i])))
			}
		}
	}

	return costComponents
}

func (r *NetworkConnectionMonitor) buildTestsCostComponent(suffix string, startUsage string, qty *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Tests %s", suffix),
		Unit:            "tests",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Network Watcher"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr("Standard Connection Monitor Test")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(startUsage),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/network_ddos_protection_plan.go
# RESOURCE: azure_network_ddos_protection_plan
# SIZE: 3939 bytes | LINES: 96
################################################################################
package azure

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// NetworkDdosProtectionPlan struct represents Azure DDoS Protection Plan.
// DDoS Protection Plan is a resource that provides DDoS protection for virtual networks and IPs.
//
// Resource information: https://azure.microsoft.com/en-us/products/ddos-protection/
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/ddos-protection/#pricing
type NetworkDdosProtectionPlan struct {
	Address       string
	Region        string
	OverageAmount *int64 `infracost_usage:"overage_amount"`
}

// CoreType returns the name of this resource type.
func (r *NetworkDdosProtectionPlan) CoreType() string {
	return "NetworkDdosProtectionPlan"
}

// UsageSchema defines a list which represents the usage schema of
// NetworkDdosProtectionPlan. There is only one usage item, `overage_amount`,
// which represents the number of resources that fall outside the base ddos
// coverage.
func (r *NetworkDdosProtectionPlan) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "overage_amount", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the
// NetworkDdosProtectionPlan. It uses the `infracost_usage` struct tags to
// populate data into the NetworkDdosProtectionPlan.
func (r *NetworkDdosProtectionPlan) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid NetworkDdosProtectionPlan
// struct. This method is called after the resource is initialised by an IaC
// provider.
//
// BuildResource returns two cost components:
//
//  1. DDoS Protection Plan: The cost of the DDoS Protection Plan.
//  2. Overage charges: The cost of the overage charges for the DDoS Protection Plan.
//     This is the number of resources that fall outside the base coverage offered by
//     the protection plan (100). This amount is defined in the usage file as it is
//     difficult to infer the number of resources that fall outside the base coverage
//     from the IaC.
func (r *NetworkDdosProtectionPlan) BuildResource() *schema.Resource {
	var overageAmount *decimal.Decimal
	overageUnit := "resource"
	if r.OverageAmount != nil {
		overageAmount = decimalPtr(decimal.NewFromInt(*r.OverageAmount))
		if overageAmount.GreaterThan(decimal.NewFromInt(1)) {
			overageUnit = "resources"
		}
	}

	return &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			{
				Name:           "DDoS Protection Plan",
				Unit:           "hours",
				UnitMultiplier: decimal.NewFromInt(1),
				HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr(vendorName),
					Region:        strPtr(r.Region),
					Service:       strPtr("Azure DDOS Protection"),
					ProductFamily: strPtr("Networking"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "skuName", Value: strPtr("Network Protection")},
						{Key: "meterName", Value: strPtr("Network Protection Plan")},
					},
				},
			},
			{
				Name:           "Overage charges",
				Unit:           overageUnit,
				UnitMultiplier: schema.HourToMonthUnitMultiplier,
				HourlyQuantity: overageAmount,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr(vendorName),
					Region:        strPtr(r.Region),
					Service:       strPtr("Azure DDOS Protection"),
					ProductFamily: strPtr("Networking"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "skuName", Value: strPtr("Network Protection")},
						{Key: "meterName", Value: strPtr("Network Protection Resource")},
					},
				},
				UsageBased: true,
			},
		},
	}
}

################################################################################
# FILE: internal/resources/azure/network_watcher.go
# RESOURCE: azure_network_watcher
# SIZE: 3379 bytes | LINES: 87
################################################################################
package azure

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// NetworkWatcher struct represents Azure Network Watcher.
//
// From the Azure Network Watcher pricing page, this resource supports the
// 'Network Diagnostic Checks' pricing.
//
// The other prices are supported as follows:
//
//   - 'Network Logs Collected' and 'Traffic Analytics' are counted against the
//     azurerm_network_watcher_flow_log resource.
//
//   - 'Connection Monitor' is counted against the
//     azurerm_network_connection_monitor resource.
//
//   - 'Network Performance Monitor' charges are not supported since they are
//     deprecated and do not have an equivalent resource.
//
// Resource information: https://azure.microsoft.com/en-gb/pricing/details/network-watcher/#overview
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/network-watcher/#pricing
type NetworkWatcher struct {
	Address string
	Region  string

	MonthlyDiagnosticChecks *int64 `infracost_usage:"monthly_diagnostic_checks"`
}

// CoreType returns the name of this resource type
func (r *NetworkWatcher) CoreType() string {
	return "NetworkWatcher"
}

// UsageSchema defines a list which represents the usage schema of NetworkWatcher.
func (r *NetworkWatcher) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_diagnostic_checks", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the NetworkWatcher.
// It uses the `infracost_usage` struct tags to populate data into the NetworkWatcher.
func (r *NetworkWatcher) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid NetworkWatcher struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *NetworkWatcher) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.networkDiagnosticToolCostComponent(),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *NetworkWatcher) networkDiagnosticToolCostComponent() *schema.CostComponent {
	freeQuantity := decimal.NewFromInt(1000)

	var qty *decimal.Decimal
	if r.MonthlyDiagnosticChecks != nil {
		// 1000 checks per Network Watcher are free
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyDiagnosticChecks).Sub(freeQuantity))
		if qty.LessThan(decimal.Zero) {
			qty = decimalPtr(decimal.Zero)
		}
	}

	return &schema.CostComponent{
		Name:            "Network diagnostic tool (over 1,000 checks)",
		Unit:            "checks",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Network Watcher"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr("Standard Diagnostic Tool API")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(freeQuantity.String()),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/network_watcher_flow_log.go
# RESOURCE: azure_network_watcher_flow_log
# SIZE: 4495 bytes | LINES: 113
################################################################################
package azure

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// NetworkWatcherFlowLog struct represents Azure Network Watcher Flow Log
//
// From the Azure Network Watcher pricing page, this resource supports the
// 'Network Logs Collected' and 'Traffic Analytics' pricing.
//
// Other Network Monitor prices are supported in other resources, as specified
// in the NetworkWatcher resource struct.
//
// Resource information: https://azure.microsoft.com/en-gb/pricing/details/network-watcher/#overview
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/network-watcher/#pricing
type NetworkWatcherFlowLog struct {
	Address                               string
	Region                                string
	TrafficAnalyticsEnabled               bool
	TrafficAnalyticsAcceleratedProcessing bool

	MonthlyLogsCollectedGB *float64 `infracost_usage:"monthly_logs_collected_gb"`
}

// CoreType returns the name of this resource type
func (r *NetworkWatcherFlowLog) CoreType() string {
	return "NetworkWatcherFlowLog"
}

// UsageSchema defines a list which represents the usage schema of NetworkWatcherFlowLog.
func (r *NetworkWatcherFlowLog) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_logs_collected_gb", ValueType: schema.Float64, DefaultValue: 0.0},
	}
}

// PopulateUsage parses the u schema.UsageData into the NetworkWatcherFlowLog.
// It uses the `infracost_usage` struct tags to populate data into the NetworkWatcherFlowLog.
func (r *NetworkWatcherFlowLog) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid NetworkWatcherFlowLog struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *NetworkWatcherFlowLog) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.networkLogsCollectedCostComponent(),
	}

	if r.TrafficAnalyticsEnabled {
		costComponents = append(costComponents, r.trafficAnalyticsDataProcessedCostComponent())
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *NetworkWatcherFlowLog) networkLogsCollectedCostComponent() *schema.CostComponent {
	freeQuantity := decimal.NewFromInt(5)

	var qty *decimal.Decimal
	if r.MonthlyLogsCollectedGB != nil {
		// 5 GB per Network Watcher are free
		qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyLogsCollectedGB).Sub(freeQuantity))
		if qty.LessThan(decimal.Zero) {
			qty = decimalPtr(decimal.Zero)
		}
	}

	return &schema.CostComponent{
		Name:            "Network logs collected (over 5GB)",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Network Watcher"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr("Standard Network Logs Collected")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(freeQuantity.String()),
		},
		UsageBased: true,
	}
}

func (r *NetworkWatcherFlowLog) trafficAnalyticsDataProcessedCostComponent() *schema.CostComponent {
	var qty *decimal.Decimal
	if r.MonthlyLogsCollectedGB != nil {
		qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyLogsCollectedGB))
	}

	meterName := "Standard Traffic Analytics Processing"
	suffix := "(60 min interval)"
	if r.TrafficAnalyticsAcceleratedProcessing {
		meterName = "Standard Traffic Analytics Processing at 10-Minute Interval"
		suffix = "(10 min interval)"
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Traffic Analytics data processed %s", suffix),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Network Watcher"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr(meterName)},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/postgresql_flexible_server.go
# RESOURCE: azure_postgresql_flexible_server
# SIZE: 6731 bytes | LINES: 172
################################################################################
package azure

import (
	"fmt"
	"regexp"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// PostgreSQLFlexibleServer struct represents Azure PostgreSQL Flexible Server resource.
//
// Resource information: https://docs.microsoft.com/en-gb/azure/postgresql/flexible-server/
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/postgresql/flexible-server/
type PostgreSQLFlexibleServer struct {
	Address string
	Region  string

	SKU              string
	Tier             string
	InstanceType     string
	InstanceVersion  string
	Storage          int64
	HighAvailability bool

	AdditionalBackupStorageGB *float64 `infracost_usage:"additional_backup_storage_gb"`
}

// CoreType returns the name of this resource type
func (r *PostgreSQLFlexibleServer) CoreType() string {
	return "PostgreSQLFlexibleServer"
}

// UsageSchema defines a list which represents the usage schema of PostgreSQLFlexibleServer.
func (r *PostgreSQLFlexibleServer) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "additional_backup_storage_gb", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the PostgreSQLFlexibleServer.
// It uses the `infracost_usage` struct tags to populate data into the PostgreSQLFlexibleServer.
func (r *PostgreSQLFlexibleServer) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid PostgreSQLFlexibleServer struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *PostgreSQLFlexibleServer) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.computeCostComponent(),
		r.storageCostComponent(),
		r.backupCostComponent(),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

// computeCostComponent returns a cost component for server compute requirements.
func (r *PostgreSQLFlexibleServer) computeCostComponent() *schema.CostComponent {
	attrs := getFlexibleServerFilterAttributes(r.Tier, r.InstanceType, r.InstanceVersion)

	// Double the quantity if high availability is enabled
	quantity := decimal.NewFromInt(1)
	if r.HighAvailability {
		quantity = quantity.Mul(decimal.NewFromInt(2))
	}

	return &schema.CostComponent{
		Name:           fmt.Sprintf("Compute (%s)", r.SKU),
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(quantity),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Database for PostgreSQL"),
			ProductFamily: strPtr("Databases"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", ValueRegex: strPtr(fmt.Sprintf("/^%s %s (?:-\\s)?%s/i", attrs.ProductName, attrs.TierName, attrs.Series))},
				{Key: "skuName", ValueRegex: regexPtr(fmt.Sprintf("^%s$", attrs.SKUName))},
				{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("^%s$", attrs.MeterName))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

// storageCostComponent returns a cost component for server's storage.
func (r *PostgreSQLFlexibleServer) storageCostComponent() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.Storage > 0 {
		// Storage is in MB
		quantity = decimalPtr(decimal.NewFromInt(r.Storage / 1024))
	}

	return &schema.CostComponent{
		Name:            "Storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Database for PostgreSQL"),
			ProductFamily: strPtr("Databases"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Az DB for PostgreSQL Flexible Server Storage")},
				{Key: "meterName", Value: strPtr("Storage Data Stored")},
			},
		},
	}
}

// backupCostComponent returns a cost component for additional backup storage.
func (r *PostgreSQLFlexibleServer) backupCostComponent() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.AdditionalBackupStorageGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.AdditionalBackupStorageGB))
	}

	return &schema.CostComponent{
		Name:            "Additional backup storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Azure Database for PostgreSQL"),
			ProductFamily: strPtr("Databases"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Azure Database for PostgreSQL Flexible Server Backup Storage")},
				{Key: "meterName", Value: strPtr("Backup Storage LRS Data Stored")},
			},
		},
		UsageBased: true,
	}
}

// flexibleServerFilterAttributes defines CPAPI filter attributes for compute
// cost component derived from IaC provider's SKU.
type flexibleServerFilterAttributes struct {
	ProductName string
	SKUName     string
	TierName    string
	MeterName   string
	Series      string
}

// getFlexibleServerFilterAttributes returns a struct with CPAPI filter
// attributes based on values extracted from IaC provider's SKU.
func getFlexibleServerFilterAttributes(tier, instanceType, instanceVersion string) flexibleServerFilterAttributes {
	var skuName, meterName, series string

	tierName := map[string]string{
		"b":  "Burstable",
		"gp": "General Purpose",
		"mo": "Memory Optimized",
	}[tier]

	productName := "Azure Database for PostgreSQL Flexible Server"

	if tier == "b" {
		meterName = fmt.Sprintf("%s[ vcore]*", instanceType)
		skuName = instanceType
		series = "BS"
	} else {
		meterName = "vCore"

		coreRegex := regexp.MustCompile(`(\d+)`)
		match := coreRegex.FindStringSubmatch(instanceType)
		cores := match[1]
		skuName = fmt.Sprintf("%s vCore", cores)

		series = coreRegex.ReplaceAllString(instanceType, "") + instanceVersion

		if series == "Esv3" {
			productName = "Az DB for PGSQL Flexible Server"
		}
	}

	return flexibleServerFilterAttributes{
		ProductName: productName,
		SKUName:     skuName,
		TierName:    tierName,
		MeterName:   meterName,
		Series:      series,
	}
}

################################################################################
# FILE: internal/resources/azure/powerbi_embedded.go
# RESOURCE: azure_powerbi_embedded
# SIZE: 2080 bytes | LINES: 56
################################################################################
package azure

import (
	"fmt"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/shopspring/decimal"
)

// PowerBIEmbedded struct represents a Power BI Embedded resource.
//
// Resource information: https://learn.microsoft.com/en-us/power-bi/developer/embedded/
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/power-bi-embedded/
type PowerBIEmbedded struct {
	Address string
	SKU     string
	Region  string
}

func (r *PowerBIEmbedded) CoreType() string {
	return "PowerBIEmbedded"
}

func (r *PowerBIEmbedded) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the PowerBIEmbedded.
// It uses the `infracost_usage` struct tags to populate data into the PowerBIEmbedded.
func (r *PowerBIEmbedded) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid PowerBIEmbedded struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *PowerBIEmbedded) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: []*schema.CostComponent{r.instanceUsageCostComponent()},
	}
}

func (r *PowerBIEmbedded) instanceUsageCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           fmt.Sprintf("Node usage (%s)", r.SKU),
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Power BI Embedded"),
			ProductFamily: strPtr("Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(r.SKU)},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

################################################################################
# FILE: internal/resources/azure/private_dns_a_record.go
# RESOURCE: azure_private_dns_a_record
# SIZE: 880 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type PrivateDNSARecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *PrivateDNSARecord) CoreType() string {
	return "PrivateDNSARecord"
}

func (r *PrivateDNSARecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *PrivateDNSARecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *PrivateDNSARecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/private_dns_aaaa_record.go
# RESOURCE: azure_private_dns_aaaa_record
# SIZE: 898 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type PrivateDNSAAAARecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *PrivateDNSAAAARecord) CoreType() string {
	return "PrivateDNSAAAARecord"
}

func (r *PrivateDNSAAAARecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *PrivateDNSAAAARecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *PrivateDNSAAAARecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/private_dns_cname_record.go
# RESOURCE: azure_private_dns_cname_record
# SIZE: 904 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type PrivateDNSCNameRecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *PrivateDNSCNameRecord) CoreType() string {
	return "PrivateDNSCNameRecord"
}

func (r *PrivateDNSCNameRecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *PrivateDNSCNameRecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *PrivateDNSCNameRecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/private_dns_mx_record.go
# RESOURCE: azure_private_dns_mx_record
# SIZE: 886 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type PrivateDNSMXRecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *PrivateDNSMXRecord) CoreType() string {
	return "PrivateDNSMXRecord"
}

func (r *PrivateDNSMXRecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *PrivateDNSMXRecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *PrivateDNSMXRecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/private_dns_ptr_record.go
# RESOURCE: azure_private_dns_ptr_record
# SIZE: 892 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type PrivateDNSPTRRecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *PrivateDNSPTRRecord) CoreType() string {
	return "PrivateDNSPTRRecord"
}

func (r *PrivateDNSPTRRecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *PrivateDNSPTRRecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *PrivateDNSPTRRecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/private_dns_resolver_dns_forwarding_ruleset.go
# RESOURCE: azure_private_dns_resolver_dns_forwarding_ruleset
# SIZE: 2401 bytes | LINES: 54
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/shopspring/decimal"
)

// PrivateDnsResolverDnsForwardingRuleset struct represents Azure DNS Private Resolver Forwarding Ruleset.
//
// Resource information: https://learn.microsoft.com/en-us/azure/dns/dns-private-resolver-overview
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/dns/
type PrivateDnsResolverDnsForwardingRuleset struct {
	Address string
	Region  string
}

// CoreType returns the name of this resource type
func (r *PrivateDnsResolverDnsForwardingRuleset) CoreType() string {
	return "PrivateDnsResolverDnsForwardingRuleset"
}

// UsageSchema defines a list which represents the usage schema of PrivateDnsResolverDnsForwardingRuleset.
func (r *PrivateDnsResolverDnsForwardingRuleset) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the PrivateDnsResolverDnsForwardingRuleset.
// It uses the `infracost_usage` struct tags to populate data into the PrivateDnsResolverDnsForwardingRuleset.
func (r *PrivateDnsResolverDnsForwardingRuleset) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid PrivateDnsResolverDnsForwardingRuleset struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *PrivateDnsResolverDnsForwardingRuleset) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Forwarding ruleset",
				Unit:            "months",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("azure"),
					Region:        strPtr(dnsZoneRegion(r.Region)),
					Service:       strPtr("Azure DNS"),
					ProductFamily: strPtr("Networking"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "skuName", ValueRegex: regexPtr("Private Resolver")},
						{Key: "meterName", ValueRegex: regexPtr("Private Resolver DNS Forwarding Ruleset")},
					},
				},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/azure/private_dns_resolver_inbound_endpoint.go
# RESOURCE: azure_private_dns_resolver_inbound_endpoint
# SIZE: 2338 bytes | LINES: 54
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/shopspring/decimal"
)

// PrivateDnsResolverInboundEndpoint struct represents a Azure DNS Private Resolver Inbound Endpoint.
//
// Resource information: https://learn.microsoft.com/en-us/azure/dns/dns-private-resolver-overview
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/dns/
type PrivateDnsResolverInboundEndpoint struct {
	Address string
	Region  string
}

// CoreType returns the name of this resource type
func (r *PrivateDnsResolverInboundEndpoint) CoreType() string {
	return "PrivateDnsResolverInboundEndpoint"
}

// UsageSchema defines a list which represents the usage schema of PrivateDnsResolverInboundEndpoint.
func (r *PrivateDnsResolverInboundEndpoint) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the PrivateDnsResolverInboundEndpoint.
// It uses the `infracost_usage` struct tags to populate data into the PrivateDnsResolverInboundEndpoint.
func (r *PrivateDnsResolverInboundEndpoint) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid PrivateDnsResolverInboundEndpoint struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *PrivateDnsResolverInboundEndpoint) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Inbound endpoint",
				Unit:            "months",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("azure"),
					Region:        strPtr(dnsZoneRegion(r.Region)),
					Service:       strPtr("Azure DNS"),
					ProductFamily: strPtr("Networking"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "skuName", ValueRegex: regexPtr("Private Resolver")},
						{Key: "meterName", ValueRegex: regexPtr("Private Resolver Inbound Endpoint")},
					},
				},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/azure/private_dns_resolver_outbound_endpoint.go
# RESOURCE: azure_private_dns_resolver_outbound_endpoint
# SIZE: 2352 bytes | LINES: 54
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/shopspring/decimal"
)

// PrivateDnsResolverOutboundEndpoint struct represents a Azure DNS Private Resolver Outbound Endpoint.
//
// Resource information: https://learn.microsoft.com/en-us/azure/dns/dns-private-resolver-overview
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/dns/
type PrivateDnsResolverOutboundEndpoint struct {
	Address string
	Region  string
}

// CoreType returns the name of this resource type
func (r *PrivateDnsResolverOutboundEndpoint) CoreType() string {
	return "PrivateDnsResolverOutboundEndpoint"
}

// UsageSchema defines a list which represents the usage schema of PrivateDnsResolverOutboundEndpoint.
func (r *PrivateDnsResolverOutboundEndpoint) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the PrivateDnsResolverOutboundEndpoint.
// It uses the `infracost_usage` struct tags to populate data into the PrivateDnsResolverOutboundEndpoint.
func (r *PrivateDnsResolverOutboundEndpoint) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid PrivateDnsResolverOutboundEndpoint struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *PrivateDnsResolverOutboundEndpoint) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Outbound endpoint",
				Unit:            "months",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("azure"),
					Region:        strPtr(dnsZoneRegion(r.Region)),
					Service:       strPtr("Azure DNS"),
					ProductFamily: strPtr("Networking"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "skuName", ValueRegex: regexPtr("Private Resolver")},
						{Key: "meterName", ValueRegex: regexPtr("Private Resolver Outbound Endpoint")},
					},
				},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/azure/private_dns_srv_record.go
# RESOURCE: azure_private_dns_srv_record
# SIZE: 892 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type PrivateDNSSRVRecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *PrivateDNSSRVRecord) CoreType() string {
	return "PrivateDNSSRVRecord"
}

func (r *PrivateDNSSRVRecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *PrivateDNSSRVRecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *PrivateDNSSRVRecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/private_dns_txt_record.go
# RESOURCE: azure_private_dns_txt_record
# SIZE: 892 bytes | LINES: 26
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

type PrivateDNSTXTRecord struct {
	Address        string
	Region         string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *PrivateDNSTXTRecord) CoreType() string {
	return "PrivateDNSTXTRecord"
}

func (r *PrivateDNSTXTRecord) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *PrivateDNSTXTRecord) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *PrivateDNSTXTRecord) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: dnsQueriesCostComponent(r.Region, r.MonthlyQueries),
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/private_dns_zone.go
# RESOURCE: azure_private_dns_zone
# SIZE: 1245 bytes | LINES: 41
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"strings"
)

type PrivateDNSZone struct {
	Address string
	Region  string
}

func (r *PrivateDNSZone) CoreType() string {
	return "PrivateDNSZone"
}

func (r *PrivateDNSZone) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *PrivateDNSZone) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *PrivateDNSZone) BuildResource() *schema.Resource {
	region := r.Region

	if strings.HasPrefix(strings.ToLower(region), "usgov") {
		region = "US Gov Zone 1"
	}
	if strings.HasPrefix(strings.ToLower(region), "germany") {
		region = "DE Zone 1"
	}
	if strings.HasPrefix(strings.ToLower(region), "china") {
		region = "Zone 1 (China)"
	}
	if region != "US Gov Zone 1" && region != "DE Zone 1" && region != "Zone 1 (China)" {
		region = "Zone 1"
	}

	costComponents := make([]*schema.CostComponent, 0)

	costComponents = append(costComponents, hostedPublicZoneCostComponent(region))
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/azure/recovery_services_vault.go
# RESOURCE: azure_recovery_services_vault
# SIZE: 2875 bytes | LINES: 72
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
)

// RecoveryServicesVault struct represents a storage vault that can azure users can back up
// various vms into.
//
// See the ProtectedVM struct for more information about backup services are charged.
//
// Resource information: https://learn.microsoft.com/en-us/azure/backup/backup-overview
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/backup/
type RecoveryServicesVault struct {
	Address      string
	Region       string
	ProtectedVMs []*BackupProtectedVM
}

func (r *RecoveryServicesVault) CoreType() string {
	return "RecoveryServicesVault"
}

// UsageSchema dynamically constructs a list of UsageItems based on the ProtectedVM sub resources.
func (r *RecoveryServicesVault) UsageSchema() []*schema.UsageItem {
	items := make([]*schema.UsageItem, len(r.ProtectedVMs))
	for i, pm := range r.ProtectedVMs {
		items[i] = &schema.UsageItem{
			Key:          pm.Address,
			DefaultValue: &usage.ResourceUsage{Name: pm.Address, Items: pm.UsageSchema()},
			ValueType:    schema.SubResourceUsage,
		}
	}

	return items
}

// PopulateUsage parses the u schema.UsageData into the RecoveryServicesVault's sub resources.
//
// RecoveryServicesVault does not have any actual usage associated with itself and instead relies on
// users specifying usage for child ProtectedVM resources.
func (r *RecoveryServicesVault) PopulateUsage(u *schema.UsageData) {
	if u == nil {
		return
	}

	// build a new UsageMap so that we get the wildcard support.
	data := map[string]*schema.UsageData{}
	for s, result := range u.Attributes {
		data[s] = schema.NewUsageData(s, result.Map())
	}
	um := schema.NewUsageMap(data)

	for _, pm := range r.ProtectedVMs {
		pm.PopulateUsage(um.Get(pm.Address))
	}

	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid RecoveryServicesVault struct.
//
// RecoveryServicesVault does not have any top level costs associated with it and instead returns a
// list of sub resources where the costs are encapsulated.
func (r *RecoveryServicesVault) BuildResource() *schema.Resource {
	if len(r.ProtectedVMs) == 0 {
		logging.Logger.Warn().Msgf("recovery services vault %s has been marked as free as no associated protected VMs were found", r.Address)
		return &schema.Resource{Name: r.Address, NoPrice: true}
	}

	subResources := make([]*schema.Resource, len(r.ProtectedVMs))
	for i, pvm := range r.ProtectedVMs {
		subResources[i] = pvm.BuildResource()
	}

	return &schema.Resource{
		Name:         r.Address,
		UsageSchema:  r.UsageSchema(),
		SubResources: subResources,
	}
}

################################################################################
# FILE: internal/resources/azure/security_center_subscription_pricing.go
# RESOURCE: azure_security_center_subscription_pricing
# SIZE: 21611 bytes | LINES: 514
################################################################################
package azure

import (
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// SecurityCenterSubscriptionPricing struct represents the pricing structure for Microsoft Defender for Cloud.
// Currently, pricing is supported through the usage file.
//
// Resource information: https://learn.microsoft.com/en-us/azure/defender-for-cloud/
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/defender-for-cloud/
type SecurityCenterSubscriptionPricing struct {
	Address      string
	Region       string
	Tier         string
	ResourceType string

	MonthlyServersPlan1Nodes *float64 `infracost_usage:"monthly_servers_plan_1_nodes"`
	MonthlyServersPlan2Nodes *float64 `infracost_usage:"monthly_servers_plan_2_nodes"`

	MonthlyContainersVCores        *float64 `infracost_usage:"monthly_containers_vcores"`
	MonthlyContainerRegistryImages *float64 `infracost_usage:"monthly_container_registry_images"`

	MonthlySQLAzureConnectedInstances *float64 `infracost_usage:"monthly_sql_azure_connected_instances"`
	MonthlySQLOutsideAzureVCores      *float64 `infracost_usage:"monthly_sql_outside_azure_vcores"`
	MonthlyMySQLInstances             *float64 `infracost_usage:"monthly_mysql_instances"`
	MonthlyPostgreSQLInstances        *float64 `infracost_usage:"monthly_postgresql_instances"`
	MonthlyMariaDBInstances           *float64 `infracost_usage:"monthly_mariadb_instances"`
	CosmosDBRequestUnits              *float64 `infracost_usage:"cosmosdb_request_units"`

	MonthlyStorageAccounts *float64 `infracost_usage:"monthly_storage_accounts"`

	MonthlyAppServiceNodes  *float64 `infracost_usage:"monthly_app_service_nodes"`
	MonthlyKeyVaults        *int64   `infracost_usage:"monthly_key_vaults"`
	MonthlyARMSubscriptions *int64   `infracost_usage:"monthly_arm_subscriptions"`
	MonthlyDNSQueries       *int64   `infracost_usage:"monthly_dns_queries"`

	MonthlyKubernetesCores *float64 `infracost_usage:"monthly_kubernetes_cores"`
}

// CoreType returns the name of this resource type
func (r *SecurityCenterSubscriptionPricing) CoreType() string {
	return "SecurityCenterSubscriptionPricing"
}

// UsageSchema defines a list which represents the usage schema of SecurityCenterSubscriptionPricing.
func (r *SecurityCenterSubscriptionPricing) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_servers_plan_1_nodes", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "monthly_servers_plan_2_nodes", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "monthly_containers_vcores", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "monthly_container_registry_images", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "monthly_sql_azure_connected_instances", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "monthly_sql_outside_azure_vcores", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "monthly_mysql_instances", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "monthly_postgresql_instances", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "monthly_mariadb_instances", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "cosmosdb_request_units", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "monthly_storage_accounts", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "monthly_app_service_nodes", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "monthly_key_vaults", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_arm_subscriptions", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_dns_queries", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_kubernetes_cores", DefaultValue: 0.0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the SecurityCenterSubscriptionPricing.
// It uses the `infracost_usage` struct tags to populate data into the SecurityCenterSubscriptionPricing.
func (r *SecurityCenterSubscriptionPricing) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid SecurityCenterSubscriptionPricing struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *SecurityCenterSubscriptionPricing) BuildResource() *schema.Resource {
	if strings.ToLower(r.Tier) == "free" {
		return &schema.Resource{
			Name:      r.Address,
			IsSkipped: true,
			NoPrice:   true,
		}
	}

	var costComponents []*schema.CostComponent
	switch strings.ToLower(r.ResourceType) {
	case "appservices":
		costComponents = []*schema.CostComponent{r.addAppServiceCostComponent()}
	case "containerregistry":
		costComponents = []*schema.CostComponent{r.addContainerRegistryCostComponent()}
	case "keyvaults":
		costComponents = []*schema.CostComponent{r.addKeyVaultCostComponent()}
	case "kubernetesservice":
		costComponents = []*schema.CostComponent{r.addKubernetesCostComponent()}
	case "sqlservers":
		costComponents = []*schema.CostComponent{r.addSQLOutsideAzureCostComponent()}
	case "sqlservervirtualmachines":
		costComponents = []*schema.CostComponent{r.addSQLAzureConnectedCostComponent()}
	case "storageaccounts":
		costComponents = []*schema.CostComponent{r.addStorageCostComponent()}
	case "virtualmachines":
		costComponents = []*schema.CostComponent{
			r.addServersP1CostComponent(),
			r.addServersP2CostComponent(),
		}
	case "arm":
		costComponents = []*schema.CostComponent{r.addARMCostComponent()}
	case "dns":
		costComponents = []*schema.CostComponent{r.addDNSCostComponent()}
	case "opensourcerelationaldatabases":
		costComponents = []*schema.CostComponent{
			r.addMySQLCostComponent(),
			r.addPostgreSQLCostComponent(),
			r.addMariaDBCostComponent(),
		}
	case "containers":
		costComponents = []*schema.CostComponent{r.addContainersCostComponent()}
	case "cosmosdbs":
		costComponents = []*schema.CostComponent{r.addCosmosDBCostComponent()}
	default:
		logging.Logger.Warn().Msgf("Skipping resource %s. Unknown resource type  '%s'", r.Address, r.ResourceType)
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *SecurityCenterSubscriptionPricing) addServersP1CostComponent() *schema.CostComponent {
	var vmHours *decimal.Decimal
	if r.MonthlyServersPlan1Nodes != nil {
		vmHours = decimalPtr(decimal.NewFromFloat(*r.MonthlyServersPlan1Nodes).Mul(schema.HourToMonthUnitMultiplier))
	}

	return &schema.CostComponent{
		Name:            "Defender for servers, plan 1",
		Unit:            "server",
		UnitMultiplier:  schema.HourToMonthUnitMultiplier,
		MonthlyQuantity: vmHours,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Microsoft Defender for Cloud"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for Servers")},
				{Key: "meterName", Value: strPtr("Standard P1 Node")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addServersP2CostComponent() *schema.CostComponent {
	var vmHours *decimal.Decimal
	if r.MonthlyServersPlan2Nodes != nil {
		vmHours = decimalPtr(decimal.NewFromFloat(*r.MonthlyServersPlan2Nodes).Mul(schema.HourToMonthUnitMultiplier))
	}

	return &schema.CostComponent{
		Name:            "Defender for servers, plan 2",
		Unit:            "server",
		UnitMultiplier:  schema.HourToMonthUnitMultiplier,
		MonthlyQuantity: vmHours,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Microsoft Defender for Cloud"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for Servers")},
				{Key: "meterName", Value: strPtr("Standard P2 Node")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addContainersCostComponent() *schema.CostComponent {
	var vmHours *decimal.Decimal
	if r.MonthlyContainersVCores != nil {
		vmHours = decimalPtr(decimal.NewFromFloat(*r.MonthlyContainersVCores).Mul(schema.HourToMonthUnitMultiplier))
	}

	return &schema.CostComponent{
		Name:            "Defender for containers",
		Unit:            "vCore",
		UnitMultiplier:  schema.HourToMonthUnitMultiplier,
		MonthlyQuantity: vmHours,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Microsoft Defender for Cloud"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for Containers")},
				{Key: "meterName", Value: strPtr("Standard vCore vCore Pack")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addSQLAzureConnectedCostComponent() *schema.CostComponent {
	var instances *decimal.Decimal
	if r.MonthlySQLAzureConnectedInstances != nil {
		instances = decimalPtr(decimal.NewFromFloat(*r.MonthlySQLAzureConnectedInstances))
	}

	return &schema.CostComponent{
		Name:            "Defender for SQL, Azure-connected",
		Unit:            "instance",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: instances,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Microsoft Defender for Cloud"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for SQL")},
				{Key: "meterName", Value: strPtr("Standard Node")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addSQLOutsideAzureCostComponent() *schema.CostComponent {
	var vCoreHours *decimal.Decimal
	if r.MonthlySQLOutsideAzureVCores != nil {
		vCoreHours = decimalPtr(decimal.NewFromFloat(*r.MonthlySQLOutsideAzureVCores).Mul(schema.HourToMonthUnitMultiplier))
	}

	return &schema.CostComponent{
		Name:            "Defender for SQL, outside Azure",
		Unit:            "vCore",
		UnitMultiplier:  schema.HourToMonthUnitMultiplier,
		MonthlyQuantity: vCoreHours,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Microsoft Defender for Cloud"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for SQL")},
				{Key: "meterName", Value: strPtr("Standard vCore")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addMySQLCostComponent() *schema.CostComponent {
	var instances *decimal.Decimal
	if r.MonthlyMySQLInstances != nil {
		instances = decimalPtr(decimal.NewFromFloat(*r.MonthlyMySQLInstances))
	}

	return &schema.CostComponent{
		Name:            "Defender for MySQL",
		Unit:            "instance",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: instances,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Microsoft Defender for Cloud"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for MySQL")},
				{Key: "meterName", Value: strPtr("Standard Node")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addPostgreSQLCostComponent() *schema.CostComponent {
	var instances *decimal.Decimal
	if r.MonthlyPostgreSQLInstances != nil {
		instances = decimalPtr(decimal.NewFromFloat(*r.MonthlyPostgreSQLInstances))
	}

	return &schema.CostComponent{
		Name:            "Defender for PostgreSQL",
		Unit:            "instance",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: instances,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Microsoft Defender for Cloud"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for PostgreSQL")},
				{Key: "meterName", Value: strPtr("Standard Node")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addMariaDBCostComponent() *schema.CostComponent {
	var instances *decimal.Decimal
	if r.MonthlyMariaDBInstances != nil {
		instances = decimalPtr(decimal.NewFromFloat(*r.MonthlyMariaDBInstances))
	}

	region := r.normalizedRegion()
	if *region == "Global" {
		// force to west-us2 since price is not available in Global
		region = strPtr("westus2")
	}

	return &schema.CostComponent{
		Name:           "Defender for MariaDB",
		Unit:           "instance",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: instances,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        region,
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Microsoft Defender for Cloud"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for MariaDB")},
				{Key: "meterName", Value: strPtr("Standard Instance")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addCosmosDBCostComponent() *schema.CostComponent {
	var averageRUs *decimal.Decimal
	if r.CosmosDBRequestUnits != nil {
		averageRUs = decimalPtr(decimal.NewFromFloat(*r.CosmosDBRequestUnits).Div(decimal.NewFromInt(100)))
	}

	return &schema.CostComponent{
		Name:           "Defender for Cosmos DB",
		Unit:           "RU/s x 100",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: averageRUs,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Microsoft Defender for Cloud"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for Azure Cosmos DB")},
				{Key: "meterName", Value: strPtr("Standard 100 RU/s")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addStorageCostComponent() *schema.CostComponent {
	var storageAccounts *decimal.Decimal
	if r.MonthlyStorageAccounts != nil {
		storageAccounts = decimalPtr(decimal.NewFromFloat(*r.MonthlyStorageAccounts))
	}

	return &schema.CostComponent{
		Name:           "Defender for storage",
		Unit:           "storage account",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: storageAccounts,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Microsoft Defender for Cloud"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for Storage")},
				{Key: "meterName", Value: strPtr("Standard Node")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addAppServiceCostComponent() *schema.CostComponent {
	var nodes *decimal.Decimal
	if r.MonthlyAppServiceNodes != nil {
		nodes = decimalPtr(decimal.NewFromFloat(*r.MonthlyAppServiceNodes))
	}

	return &schema.CostComponent{
		Name:           "Defender for app service",
		Unit:           "node",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: nodes,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Microsoft Defender for Cloud"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for App Service")},
				{Key: "meterName", Value: strPtr("Standard Node")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addKeyVaultCostComponent() *schema.CostComponent {
	var keyVaults *decimal.Decimal
	if r.MonthlyKeyVaults != nil {
		keyVaults = decimalPtr(decimal.NewFromInt(*r.MonthlyKeyVaults))
	}

	region := r.normalizedRegion()
	if *region == "Global" {
		// force to west-us2 since price is not available in Global
		region = strPtr("westus2")
	}

	return &schema.CostComponent{
		Name:           "Defender for Key Vault",
		Unit:           "key vault",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: keyVaults,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        region,
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Microsoft Defender for Cloud"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for Key Vault")},
				{Key: "meterName", Value: strPtr("Per node Std Node")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addARMCostComponent() *schema.CostComponent {
	var subscriptions *decimal.Decimal
	if r.MonthlyARMSubscriptions != nil {
		subscriptions = decimalPtr(decimal.NewFromInt(*r.MonthlyARMSubscriptions))
	}

	region := r.normalizedRegion()
	if *region == "Global" {
		// force to west-us2 since price is not available in Global
		region = strPtr("westus2")
	}

	return &schema.CostComponent{
		Name:           "Defender for ARM",
		Unit:           "subscription",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: subscriptions,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        region,
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Microsoft Defender for Cloud"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for Resource Manager")},
				{Key: "meterName", Value: strPtr("Per node Std Node")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addDNSCostComponent() *schema.CostComponent {
	var apiCalls *decimal.Decimal
	if r.MonthlyDNSQueries != nil {
		apiCalls = decimalPtr(decimal.NewFromInt(*r.MonthlyDNSQueries).Div(decimal.NewFromInt(1000000)))
	}

	region := r.normalizedRegion()
	if *region == "Global" {
		// force to west-us2 since price is not available in Global
		region = strPtr("westus2")
	}

	return &schema.CostComponent{
		Name:            "Defender for DNS",
		Unit:            "1M queries",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: apiCalls,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        region,
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Microsoft Defender for Cloud"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for DNS")},
				{Key: "meterName", Value: strPtr("Standard Queries")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addKubernetesCostComponent() *schema.CostComponent {
	var nodes *decimal.Decimal
	if r.MonthlyKubernetesCores != nil {
		nodes = decimalPtr(decimal.NewFromFloat(*r.MonthlyKubernetesCores))
	}

	return &schema.CostComponent{
		Name:           "Defender for kubernetes",
		Unit:           "core",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: nodes,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Advanced Threat Protection"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for Kubernetes")},
				{Key: "meterName", Value: strPtr("Standard Cores")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) addContainerRegistryCostComponent() *schema.CostComponent {
	var instances *decimal.Decimal
	if r.MonthlyContainerRegistryImages != nil {
		instances = decimalPtr(decimal.NewFromFloat(*r.MonthlyContainerRegistryImages))
	}
	return &schema.CostComponent{
		Name:            "Defender for container registries",
		Unit:            "image",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: instances,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        r.normalizedRegion(),
			ProductFamily: strPtr("Security"),
			Service:       strPtr("Advanced Threat Protection"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Microsoft Defender for Container Registries")},
				{Key: "meterName", Value: strPtr("Standard Images")},
			},
		},
		UsageBased: true,
	}
}

func (r *SecurityCenterSubscriptionPricing) normalizedRegion() *string {
	if r.Region == "global" {
		return strPtr("Global")
	}
	return strPtr(r.Region)
}

################################################################################
# FILE: internal/resources/azure/service_plan.go
# RESOURCE: azure_service_plan
# SIZE: 2981 bytes | LINES: 90
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"
)

// ServicePlan struct represents a user commitment to an App Service Plan. A service plan has a dedicated
// amount of compute and storage and can be used to run any number of apps/containers.
//
// Resource information: https://learn.microsoft.com/en-us/azure/app-service/overview-hosting-plans
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/app-service/windows/
type ServicePlan struct {
	Address     string
	SKUName     string
	WorkerCount int64
	OSType      string
	Region      string
	IsDevTest   bool
}

func (r *ServicePlan) CoreType() string {
	return "ServicePlan"
}

func (r *ServicePlan) UsageSchema() []*schema.UsageItem {
	return nil
}

// PopulateUsage parses the u schema.UsageData into the ServicePlan struct
// It uses the `infracost_usage` struct tags to populate data into the ServicePlan
func (r *ServicePlan) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid ServicePlan struct.
//
// ServicePlan only has one cost component associated with the compute cost of the plan.
func (r *ServicePlan) BuildResource() *schema.Resource {
	productName := "Standard Plan"
	sku := r.SKUName

	if len(r.SKUName) < 2 || strings.ToLower(r.SKUName[:2]) == "ep" || strings.ToLower(r.SKUName[:2]) == "ws" || strings.ToLower(r.SKUName[:2]) == "y1" {
		return &schema.Resource{
			Name:        r.Address,
			IsSkipped:   true,
			NoPrice:     true,
			UsageSchema: r.UsageSchema(),
		}
	}

	firstLetter := strings.ToLower(r.SKUName[:1])
	os := strings.ToLower(r.OSType)
	var additionalAttributeFilters []*schema.AttributeFilter

	switch firstLetter {
	case "s":
		sku = "S" + r.SKUName[1:]
	case "b":
		sku = "B" + r.SKUName[1:]
		productName = "Basic Plan"
	case "f":
		productName = "Free Plan"
	case "d":
		sku = "Shared"
		productName = "Shared Plan"
	case "p", "i":
		sku, productName, additionalAttributeFilters = getVersionedAppServicePlanSKU(sku, os)
	}

	if strings.ToLower(r.SKUName) == "shared" {
		sku = "Shared"
		productName = "Shared Plan"
	}

	if os == "linux" && productName != "Isolated Plan" && productName != "Premium Plan" && productName != "Shared Plan" {
		productName += " - Linux"
	}

	purchaseOption := "Consumption"
	name := fmt.Sprintf("Instance usage (%s)", r.SKUName)
	if r.IsDevTest && strings.Contains(os, "windows") {
		purchaseOption = "DevTestConsumption"
		name = fmt.Sprintf("Instance usage (dev/test, %s)", r.SKUName)
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			servicePlanCostComponent(
				r.Region,
				name,
				productName,
				sku,
				r.WorkerCount,
				purchaseOption,
				additionalAttributeFilters...,
			),
		},
	}
}

################################################################################
# FILE: internal/resources/azure/servicebus_namespace.go
# RESOURCE: azure_servicebus_namespace
# SIZE: 8726 bytes | LINES: 223
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
)

// ServiceBusNamespace struct represents Azure Service Bus Namespace
//
// This resource is charged based on the SKU (Basic, Standard or Premium) and
// Capacity (only for Premium).
//
// Relay hours and Hybrid connection pricing should be associated with other
// Terraform resources in the future (azurerm_relay_namespace,
// azurerm_relay_hybrid_connection).
//
// Resource information: https://azure.microsoft.com/en-gb/pricing/details/service-bus/#pricing
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/service-bus/#pricing
type ServiceBusNamespace struct {
	Address  string
	Region   string
	SKU      string
	Capacity int64

	// Usage-based fields
	MonthlyMessagingOperations *int64 `infracost_usage:"monthly_messaging_operations"`
	MonthlyBrokeredConnections *int64 `infracost_usage:"monthly_brokered_connections"`
}

// CoreType returns the name of this resource type
func (r *ServiceBusNamespace) CoreType() string {
	return "ServiceBusNamespace"
}

// UsageSchema defines a list which represents the usage schema of ServiceBusNamespace.
func (r *ServiceBusNamespace) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_messaging_operations", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_brokered_connections", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the ServiceBusNamespace.
// It uses the `infracost_usage` struct tags to populate data into the ServiceBusNamespace.
func (r *ServiceBusNamespace) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid ServiceBusNamespace struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *ServiceBusNamespace) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	if strings.EqualFold(r.SKU, "premium") {
		costComponents = append(costComponents, r.messagingUnitsCostComponent())
	} else if strings.EqualFold(r.SKU, "basic") {
		costComponents = append(costComponents, r.messagingOperationsCostComponents()...)
	} else { // standard
		costComponents = append(costComponents, r.baseChargeCostComponent())
		costComponents = append(costComponents, r.messagingOperationsCostComponents()...)
		costComponents = append(costComponents, r.brokeredConnectionsCostComponents()...)
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *ServiceBusNamespace) baseChargeCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Base charge",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Service Bus"),
			ProductFamily: strPtr("Integration"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(r.normalizedSku())},
				{Key: "meterName", ValueRegex: regexPtr("Base Unit$")},
			},
		},
	}
}

func (r *ServiceBusNamespace) messagingOperationsCostComponents() []*schema.CostComponent {
	var qty *decimal.Decimal
	if r.MonthlyMessagingOperations != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyMessagingOperations))
	}

	if strings.EqualFold(r.SKU, "basic") {
		return []*schema.CostComponent{
			r.buildMessagingOperationsCostComponent("", "0", qty),
		}
	}

	tierData := []struct {
		suffix     string
		startUsage string
	}{
		{suffix: " (first 13M)", startUsage: "0"},
		{suffix: " (13M-100M)", startUsage: "13"},
		{suffix: " (100M-2,500M)", startUsage: "100"},
		{suffix: " (over 2,500M)", startUsage: "2500"},
	}

	tierLimits := []int{13_000_000, 87_000_000, 2_400_000_000}

	var costComponents []*schema.CostComponent

	if qty == nil {
		costComponents = append(costComponents, r.buildMessagingOperationsCostComponent(tierData[1].suffix, tierData[1].startUsage, nil))
	} else {
		tiers := usage.CalculateTierBuckets(*qty, tierLimits)
		for i, d := range tierData {
			// Skip the first tier since it's free
			if i == 0 {
				continue
			}

			if tiers[i].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.buildMessagingOperationsCostComponent(d.suffix, d.startUsage, decimalPtr(tiers[i])))
			}
		}
	}

	return costComponents
}

func (r *ServiceBusNamespace) buildMessagingOperationsCostComponent(suffix, startUsage string, qty *decimal.Decimal) *schema.CostComponent {
	var perMQty *decimal.Decimal
	if qty != nil {
		perMQty = decimalPtr(qty.Div(decimal.NewFromInt(1_000_000)))
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Messaging operations%s", suffix),
		Unit:            "1M operations",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: perMQty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Service Bus"),
			ProductFamily: strPtr("Integration"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(r.normalizedSku())},
				{Key: "meterName", ValueRegex: regexPtr("Messaging Operations$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(startUsage),
		},
		UsageBased: true,
	}
}

func (r *ServiceBusNamespace) messagingUnitsCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Messaging units",
		Unit:           "units",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: decimalPtr(decimal.NewFromInt(r.Capacity)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Service Bus"),
			ProductFamily: strPtr("Integration"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(r.normalizedSku())},
				{Key: "meterName", ValueRegex: regexPtr("Messaging Unit$")},
			},
		},
	}
}

func (r *ServiceBusNamespace) brokeredConnectionsCostComponents() []*schema.CostComponent {
	var qty *decimal.Decimal
	if r.MonthlyBrokeredConnections != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyBrokeredConnections))
	}

	tierData := []struct {
		suffix     string
		startUsage string
	}{
		{suffix: " (first 1K)", startUsage: "0"},
		{suffix: " (1K-100K)", startUsage: "1000"},
		{suffix: " (100K-500K)", startUsage: "500000"},
		{suffix: " (over 500K)", startUsage: "100000"},
	}

	tierLimits := []int{1000, 99000, 400000}

	var costComponents []*schema.CostComponent

	if qty == nil {
		costComponents = append(costComponents, r.buildBrokeredConnectionsCostComponent(tierData[1].suffix, tierData[1].startUsage, nil))
	} else {
		tiers := usage.CalculateTierBuckets(*qty, tierLimits)
		for i, d := range tierData {
			// Skip the first tier since it's free
			if i == 0 {
				continue
			}

			if tiers[i].GreaterThan(decimal.Zero) {
				costComponents = append(costComponents, r.buildBrokeredConnectionsCostComponent(d.suffix, d.startUsage, decimalPtr(tiers[i])))
			}
		}
	}

	return costComponents
}

func (r *ServiceBusNamespace) buildBrokeredConnectionsCostComponent(suffix, startUsage string, qty *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Brokered connections%s", suffix),
		Unit:            "connections",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Service Bus"),
			ProductFamily: strPtr("Integration"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(r.normalizedSku())},
				{Key: "meterName", ValueRegex: regexPtr("Brokered Connection$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(startUsage),
		},
		UsageBased: true,
	}
}

func (r *ServiceBusNamespace) normalizedSku() string {
	return cases.Title(language.English).String(strings.ToLower(r.SKU))
}

################################################################################
# FILE: internal/resources/azure/signalr_service.go
# RESOURCE: azure_signalr_service
# SIZE: 3882 bytes | LINES: 103
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// SignalRService struct represents an Azure SignalR Service.
//
// Resource information: https://azure.microsoft.com/en-us/products/signalr-service
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/signalr-service/
type SignalRService struct {
	Address     string
	Region      string
	SkuName     string
	SkuCapacity int64

	MonthlyAdditionalMessages *int64 `infracost_usage:"monthly_additional_messages"`
}

// CoreType returns the name of this resource type
func (r *SignalRService) CoreType() string {
	return "SignalRService"
}

// UsageSchema defines a list which represents the usage schema of SignalRService.
func (r *SignalRService) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_additional_messages", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the SignalRService.
// It uses the `infracost_usage` struct tags to populate data into the SignalRService.
func (r *SignalRService) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid SignalRService struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *SignalRService) BuildResource() *schema.Resource {
	// normalize sku to first letter capitalized
	sku := cases.Title(language.English).String(strings.ToLower(r.SkuName))

	if s := strings.Split(r.SkuName, "_"); len(s) == 2 {
		sku = s[0]
	}

	if sku == "Free" {
		return &schema.Resource{
			Name:      r.Address,
			IsSkipped: true,
			NoPrice:   true,
		}
	}

	costComponents := []*schema.CostComponent{
		r.serviceUsageCostComponent(sku, r.SkuCapacity),
		r.additionalMessagesCostComponent(sku, r.MonthlyAdditionalMessages),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *SignalRService) serviceUsageCostComponent(sku string, capacity int64) *schema.CostComponent {
	return &schema.CostComponent{
		Name: fmt.Sprintf("Service usage (%s)", sku),
		Unit: "units",
		// This is a bit of a hack, but the Azure pricing API returns the price per day,
		// so we need to convert the price per day to price per hour.
		UnitMultiplier:  schema.DaysInMonth,
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(capacity).Mul(schema.DaysInMonth)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("SignalR"),
			ProductFamily: strPtr("Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Unit", sku))},
			},
		},
	}
}

func (r *SignalRService) additionalMessagesCostComponent(sku string, quantity *int64) *schema.CostComponent {
	var q *decimal.Decimal
	if quantity != nil {
		q = decimalPtr(decimal.NewFromInt(*quantity).Div(decimal.NewFromInt(1000000)))
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Additional messages (%s)", sku),
		Unit:            "1M messages",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: q,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("SignalR"),
			ProductFamily: strPtr("Analytics"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Message", sku))},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/sql_database.go
# RESOURCE: azure_sql_database
# SIZE: 19110 bytes | LINES: 465
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

const (
	sqlServerlessTier     = "general purpose - serverless"
	sqlHyperscaleTier     = "hyperscale"
	sqlGeneralPurposeTier = "general purpose"
)

var (
	mssqlTierMapping = map[string]string{
		"b": "Basic",
		"p": "Premium",
		"s": "Standard",
	}

	mssqlPremiumDTUIncludedStorage = map[string]float64{
		"p1":  500,
		"p2":  500,
		"p4":  500,
		"p6":  500,
		"p11": 4096,
		"p15": 4096,
	}

	mssqlStorageRedundancyTypeMapping = map[string]string{
		"geo":   "RA-GRS",
		"local": "LRS",
		"zone":  "ZRS",
	}
)

// SQLDatabase represents an Azure SQL database instance.
//
// More resource information here: https://azure.microsoft.com/en-gb/products/azure-sql/database/
// Pricing information here: https://azure.microsoft.com/en-gb/pricing/details/azure-sql-database/single/
type SQLDatabase struct {
	Address           string
	Region            string
	SKU               string
	IsElasticPool     bool
	LicenseType       string
	Tier              string
	Family            string
	Cores             *int64
	MaxSizeGB         *float64
	ReadReplicaCount  *int64
	ZoneRedundant     bool
	BackupStorageType string
	IsDevTest         bool

	// ExtraDataStorageGB represents a usage cost of additional backup storage used by the sql database.
	ExtraDataStorageGB *float64 `infracost_usage:"extra_data_storage_gb"`
	// MonthlyVCoreHours represents a usage param that allows users to define how many hours of usage a serverless sql database instance uses.
	MonthlyVCoreHours *int64 `infracost_usage:"monthly_vcore_hours"`
	// LongTermRetentionStorageGB defines a usage param that allows users to define how many GB of cold storage the database uses.
	// This is storage that can be kept for up to 10 years.
	LongTermRetentionStorageGB *int64 `infracost_usage:"long_term_retention_storage_gb"`
	// BackupStorageGB defines a usage param that allows users to define how many GB Point-In-Time Restore (PITR) backup storage the database uses.
	BackupStorageGB *int64 `infracost_usage:"backup_storage_gb"`
}

// PopulateUsage parses the u schema.UsageData into the SQLDatabase.
func (r *SQLDatabase) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *SQLDatabase) CoreType() string {
	return "SQLDatabase"
}

func (r *SQLDatabase) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "extra_data_storage_gb", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "monthly_vcore_hours", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "long_term_retention_storage_gb", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "backup_storage_gb", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// BuildResource builds a schema.Resource from a valid SQLDatabase.
// It returns a SQLDatabase as a *schema.Resource with cost components initialized.
//
// SQLDatabase splits pricing into two different models. DTU & vCores.
//
//	Database Transaction Unit (DTU) is made a performance metric representing a mixture of performance metrics
//	in Azure SQL. Some include: CPU, I/O, Memory. DTU is used as Azure tries to simplify billing by using a single metric.
//
//	Virtual Core (vCore) pricing is designed to translate from on premise hardware metrics (cores) into the cloud
//	SQL instance. vCore is designed to allow users to better estimate their resource limits, e.g. RAM.
//
// SQL databases that follow a DTU pricing model have the following costs associated with them:
//
//  1. Costs based on the number of DTUs that the sql database has
//  2. Extra backup data costs - this is configured using SQLDatabase.ExtraDataStorageGB
//  3. Long term data backup costs - this is configured using SQLDatabase.LongTermRetentionStorageGB
//
// SQL databases that follow a vCore pricing model have the following costs associated with them:
//
//  1. Costs based on the number of vCores the resource has
//  2. Extra pricing if any database read replicas have been provisioned
//  3. Additional charge for SQL Server licensing based on vCores amount
//  4. Charges for storage used
//  5. Charges for long term data backup - this is configured using SQLDatabase.LongTermRetentionStorageGB
//
// This method is called after the resource is initialized by an IaC provider. SQLDatabase is used by both mssql_database
// and sql_database Terraform resources.
func (r *SQLDatabase) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: r.costComponents(),
	}
}

func (r *SQLDatabase) costComponents() []*schema.CostComponent {
	if r.IsElasticPool {
		return r.elasticPoolCostComponents()
	}

	if r.Cores != nil {
		return r.vCoreCostComponents()
	}

	return r.dtuCostComponents()
}

func (r *SQLDatabase) dtuCostComponents() []*schema.CostComponent {
	skuName := strings.ToLower(r.SKU)
	if skuName == "basic" {
		skuName = "b"
	}

	// This is a bit of a hack, but the Azure pricing API returns the price per day
	// and the Azure pricing calculator uses 730 hours to show the cost
	// so we need to convert the price per day to price per hour.
	// Use precision 24 to avoid rounding errors later since the default decimal precision is 16.
	daysInMonth := schema.HourToMonthUnitMultiplier.DivRound(decimal.NewFromInt(24), 24)

	name := fmt.Sprintf("Compute (%s)", strings.ToTitle(r.SKU))
	purchaseOption := priceFilterConsumption
	if r.IsDevTest {
		name = fmt.Sprintf("Compute (dev/test, %s)", strings.ToTitle(r.SKU))
		purchaseOption = priceFilterDevTestConsumption
	}

	costComponents := []*schema.CostComponent{
		{
			Name:            name,
			Unit:            "hours",
			UnitMultiplier:  daysInMonth.DivRound(schema.HourToMonthUnitMultiplier, 24),
			MonthlyQuantity: decimalPtr(daysInMonth),
			ProductFilter: r.productFilter([]*schema.AttributeFilter{
				{Key: "productName", ValueRegex: regexPtr("^SQL Database Single")},
				{Key: "skuName", ValueRegex: regexPtr(fmt.Sprintf("^%s$", skuName))},
				{Key: "meterName", ValueRegex: regexPtr("DTU(s)?$")},
			}),
			PriceFilter: purchaseOption,
		},
	}

	var extraStorageGB float64

	if !strings.HasPrefix(skuName, "b") && r.ExtraDataStorageGB != nil {
		extraStorageGB = *r.ExtraDataStorageGB
	} else if strings.HasPrefix(skuName, "s") && r.MaxSizeGB != nil {
		includedStorageGB := 250.0
		extraStorageGB = *r.MaxSizeGB - includedStorageGB
	} else if strings.HasPrefix(skuName, "p") && r.MaxSizeGB != nil {
		includedStorageGB, ok := mssqlPremiumDTUIncludedStorage[skuName]
		if ok {
			extraStorageGB = *r.MaxSizeGB - includedStorageGB
		}
	}

	if extraStorageGB > 0 {
		c := r.extraDataStorageCostComponent(extraStorageGB)
		if c != nil {
			costComponents = append(costComponents, c)
		}
	}

	costComponents = append(costComponents, r.longTermRetentionCostComponent())
	costComponents = append(costComponents, r.pitrBackupCostComponent())

	return costComponents
}

func (r *SQLDatabase) vCoreCostComponents() []*schema.CostComponent {
	costComponents := r.computeHoursCostComponents()

	if strings.ToLower(r.Tier) == sqlHyperscaleTier {
		costComponents = append(costComponents, r.readReplicaCostComponent())
	}

	if strings.ToLower(r.Tier) != sqlServerlessTier && strings.ToLower(r.LicenseType) == "licenseincluded" {
		costComponents = append(costComponents, r.sqlLicenseCostComponent())
	}

	costComponents = append(costComponents, r.storageCostComponent())

	if strings.ToLower(r.Tier) != sqlHyperscaleTier {
		costComponents = append(costComponents, r.longTermRetentionCostComponent())
		costComponents = append(costComponents, r.pitrBackupCostComponent())
	}

	return costComponents
}

func (r *SQLDatabase) elasticPoolCostComponents() []*schema.CostComponent {
	return []*schema.CostComponent{
		r.longTermRetentionCostComponent(),
		r.pitrBackupCostComponent(),
	}
}

func (r *SQLDatabase) computeHoursCostComponents() []*schema.CostComponent {
	if strings.ToLower(r.Tier) == sqlServerlessTier {
		return r.serverlessComputeHoursCostComponents()
	}

	return r.provisionedComputeCostComponents()
}

func (r *SQLDatabase) serverlessComputeHoursCostComponents() []*schema.CostComponent {
	productNameRegex := fmt.Sprintf("/%s - %s/", r.Tier, r.Family)

	var vCoreHours *decimal.Decimal
	if r.MonthlyVCoreHours != nil {
		vCoreHours = decimalPtr(decimal.NewFromInt(*r.MonthlyVCoreHours))
	}

	name := fmt.Sprintf("Compute (serverless, %s)", r.SKU)
	purchaseOption := priceFilterConsumption
	if r.IsDevTest && strings.ToLower(r.LicenseType) != "licenseincluded" {
		name = fmt.Sprintf("Compute (dev/test, serverless, %s)", r.SKU)
		purchaseOption = priceFilterDevTestConsumption
	}

	costComponents := []*schema.CostComponent{
		{
			Name:            name,
			Unit:            "vCore-hours",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: vCoreHours,
			ProductFilter: r.productFilter([]*schema.AttributeFilter{
				{Key: "productName", ValueRegex: strPtr(productNameRegex)},
				{Key: "skuName", Value: strPtr("1 vCore")},
				{Key: "meterName", ValueRegex: regexPtr("^(?!.* - Free$).*$")},
			}),
			PriceFilter: purchaseOption,
			UsageBased:  true,
		},
	}

	// Zone redundancy is free for premium and business critical tiers
	if r.ZoneRedundant {
		costComponents = append(costComponents, &schema.CostComponent{
			Name:            fmt.Sprintf("Zone redundancy (serverless, %s)", r.SKU),
			Unit:            "vCore-hours",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: vCoreHours,
			ProductFilter: r.productFilter([]*schema.AttributeFilter{
				{Key: "productName", ValueRegex: strPtr(productNameRegex)},
				{Key: "skuName", Value: strPtr("1 vCore Zone Redundancy")},
				{Key: "meterName", ValueRegex: regexPtr("^(?!.* - Free$).*$")},
			}),
			PriceFilter: priceFilterConsumption,
		})
	}

	return costComponents
}

func (r *SQLDatabase) provisionedComputeCostComponents() []*schema.CostComponent {
	var cores int64
	if r.Cores != nil {
		cores = *r.Cores
	}

	productNameRegex := fmt.Sprintf("/%s - %s/", r.Tier, r.Family)
	name := fmt.Sprintf("Compute (provisioned, %s)", r.SKU)
	purchaseOption := priceFilterConsumption
	if r.IsDevTest && strings.ToLower(r.LicenseType) != "licenseincluded" {
		name = fmt.Sprintf("Compute (dev/test, provisioned, %s)", r.SKU)
		purchaseOption = priceFilterDevTestConsumption
	}

	costComponents := []*schema.CostComponent{
		{
			Name:           name,
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: r.productFilter([]*schema.AttributeFilter{
				{Key: "productName", ValueRegex: strPtr(productNameRegex)},
				{Key: "skuName", Value: strPtr(fmt.Sprintf("%d vCore", cores))},
			}),
			PriceFilter: purchaseOption,
		},
	}

	// Zone redundancy is free for premium and business critical tiers
	if strings.EqualFold(r.Tier, sqlGeneralPurposeTier) && r.ZoneRedundant {
		costComponents = append(costComponents, &schema.CostComponent{
			Name:           fmt.Sprintf("Zone redundancy (provisioned, %s)", r.SKU),
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: r.productFilter([]*schema.AttributeFilter{
				{Key: "productName", ValueRegex: strPtr(productNameRegex)},
				{Key: "skuName", Value: strPtr(fmt.Sprintf("%d vCore Zone Redundancy", cores))},
			}),
			PriceFilter: priceFilterConsumption,
		})
	}

	return costComponents
}

func (r *SQLDatabase) readReplicaCostComponent() *schema.CostComponent {
	productNameRegex := fmt.Sprintf("/%s - %s/", r.Tier, r.Family)
	skuName := mssqlSkuName(*r.Cores, r.ZoneRedundant)

	var replicaCount *decimal.Decimal
	if r.ReadReplicaCount != nil {
		replicaCount = decimalPtr(decimal.NewFromInt(*r.ReadReplicaCount))
	}

	return &schema.CostComponent{
		Name:           "Read replicas",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: replicaCount,
		ProductFilter: r.productFilter([]*schema.AttributeFilter{
			{Key: "productName", ValueRegex: strPtr(productNameRegex)},
			{Key: "skuName", Value: strPtr(skuName)},
		}),
		PriceFilter: priceFilterConsumption,
	}
}

func (r *SQLDatabase) longTermRetentionCostComponent() *schema.CostComponent {
	var retention *decimal.Decimal
	if r.LongTermRetentionStorageGB != nil {
		retention = decimalPtr(decimal.NewFromInt(*r.LongTermRetentionStorageGB))
	}

	redundancyType, ok := mssqlStorageRedundancyTypeMapping[strings.ToLower(r.BackupStorageType)]
	if !ok {
		logging.Logger.Warn().Msgf("Unrecognized backup storage type '%s'", r.BackupStorageType)
		redundancyType = "RA-GRS"
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Long-term retention (%s)", redundancyType),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: retention,
		ProductFilter: r.productFilter([]*schema.AttributeFilter{
			{Key: "productName", Value: strPtr("SQL Database - LTR Backup Storage")},
			{Key: "skuName", Value: strPtr(fmt.Sprintf("Backup %s", redundancyType))},
			{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("%s Data Stored", redundancyType))},
		}),
		PriceFilter: priceFilterConsumption,
		UsageBased:  true,
	}
}

func (r *SQLDatabase) pitrBackupCostComponent() *schema.CostComponent {
	var pitrGB *decimal.Decimal
	if r.BackupStorageGB != nil {
		pitrGB = decimalPtr(decimal.NewFromInt(*r.BackupStorageGB))
	}

	redundancyType, ok := mssqlStorageRedundancyTypeMapping[strings.ToLower(r.BackupStorageType)]
	if !ok {
		logging.Logger.Warn().Msgf("Unrecognized backup storage type '%s'", r.BackupStorageType)
		redundancyType = "RA-GRS"
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("PITR backup storage (%s)", redundancyType),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: pitrGB,
		ProductFilter: r.productFilter([]*schema.AttributeFilter{
			{Key: "productName", ValueRegex: regexPtr("PITR Backup Storage")},
			{Key: "skuName", Value: strPtr(fmt.Sprintf("Backup %s", redundancyType))},
			{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("%s Data Stored", redundancyType))},
		}),
		PriceFilter: priceFilterConsumption,
		UsageBased:  true,
	}
}

func (r *SQLDatabase) extraDataStorageCostComponent(extraStorageGB float64) *schema.CostComponent {
	tier := r.Tier
	if tier == "" {
		var ok bool
		tier, ok = mssqlTierMapping[strings.ToLower(r.SKU)[:1]]

		if !ok {
			logging.Logger.Warn().Msgf("Unrecognized tier for SKU '%s' for resource %s", r.SKU, r.Address)
			return nil
		}
	}

	return mssqlExtraDataStorageCostComponent(r.Region, tier, extraStorageGB)
}

func (r *SQLDatabase) sqlLicenseCostComponent() *schema.CostComponent {
	return mssqlLicenseCostComponent(r.Region, r.Cores, r.Tier)
}

func (r *SQLDatabase) storageCostComponent() *schema.CostComponent {
	return mssqlStorageCostComponent(r.Region, r.Tier, r.ZoneRedundant, r.MaxSizeGB)
}

func (r *SQLDatabase) productFilter(filters []*schema.AttributeFilter) *schema.ProductFilter {
	return mssqlProductFilter(r.Region, filters)
}

func mssqlSkuName(cores int64, zoneRedundant bool) string {
	sku := fmt.Sprintf("%d vCore", cores)

	if zoneRedundant {
		sku += " Zone Redundancy"
	}
	return sku
}

func mssqlProductFilter(region string, filters []*schema.AttributeFilter) *schema.ProductFilter {
	return &schema.ProductFilter{
		VendorName:       strPtr(vendorName),
		Region:           strPtr(region),
		Service:          strPtr("SQL Database"),
		ProductFamily:    strPtr("Databases"),
		AttributeFilters: filters,
	}
}

func mssqlExtraDataStorageCostComponent(region string, tier string, extraStorageGB float64) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Extra data storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromFloat(extraStorageGB)),
		ProductFilter: mssqlProductFilter(region, []*schema.AttributeFilter{
			{Key: "productName", ValueRegex: strPtr(fmt.Sprintf("/SQL Database %s - Storage/i", tier))},
			{Key: "skuName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", tier))},
			{Key: "meterName", Value: strPtr("Data Stored")},
		}),
		PriceFilter: priceFilterConsumption,
		UsageBased:  true,
	}
}

func mssqlLicenseCostComponent(region string, cores *int64, tier string) *schema.CostComponent {
	licenseRegion := "Global"
	if strings.Contains(region, "usgov") {
		licenseRegion = "US Gov"
	}

	if strings.Contains(region, "china") {
		licenseRegion = "China"
	}

	if strings.Contains(region, "germany") {
		licenseRegion = "Germany"
	}

	coresVal := int64(1)
	if cores != nil {
		coresVal = *cores
	}

	return &schema.CostComponent{
		Name:           "SQL license",
		Unit:           "vCore-hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(coresVal)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(licenseRegion),
			Service:       strPtr("SQL Database"),
			ProductFamily: strPtr("Databases"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", ValueRegex: strPtr(fmt.Sprintf("/%s - %s/", tier, "SQL License"))},
			},
		},
		PriceFilter: priceFilterConsumption,
	}
}

func mssqlStorageCostComponent(region string, tier string, zoneRedundant bool, maxSizeGB *float64) *schema.CostComponent {
	storageGB := decimalPtr(decimal.NewFromInt(5))
	if maxSizeGB != nil {
		storageGB = decimalPtr(decimal.NewFromFloat(*maxSizeGB))
	}

	storageTier := tier
	if strings.EqualFold(tier, sqlServerlessTier) {
		storageTier = "General Purpose"
	}

	skuName := storageTier
	if (strings.EqualFold(tier, sqlGeneralPurposeTier) || strings.EqualFold(tier, sqlServerlessTier)) && zoneRedundant {
		skuName += " Zone Redundancy"
	}

	productNameRegex := fmt.Sprintf("/%s - Storage/", storageTier)

	filters := []*schema.AttributeFilter{
		{Key: "productName", ValueRegex: strPtr(productNameRegex)},
		{Key: "skuName", Value: strPtr(skuName)},
		{Key: "meterName", ValueRegex: regexPtr("Data Stored$")},
	}

	if skuName == "Hyperscale" {
		filters = append(filters, &schema.AttributeFilter{Key: "armSkuName", Value: strPtr(skuName)})
	}

	return &schema.CostComponent{
		Name:            "Storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: storageGB,
		ProductFilter:   mssqlProductFilter(region, filters),
	}
}

################################################################################
# FILE: internal/resources/azure/sql_managed_instance.go
# RESOURCE: azure_sql_managed_instance
# SIZE: 7692 bytes | LINES: 187
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

const (
	sqlMIServiceName   = "SQL Managed Instance"
	sqlMIProductFamily = "Databases"
)

// *** this resource is deprecated in v3.0 of AzureRM provider and will be removed in v4.0 ***
// SQLManagedInstance struct represents an azure Sql Managed Instance.
//
// # SQLManagedInstance currently only Gen5 database instance
//
// More resource information here: https://azure.microsoft.com/en-gb/products/azure-sql/managed-instance/
// Pricing information here: https://azure.microsoft.com/en-gb/pricing/details/azure-sql-managed-instance/single/
type SQLManagedInstance struct {
	Address            string
	Region             string
	SKU                string
	LicenseType        string
	Cores              int64
	StorageSizeInGb    int64
	StorageAccountType string
	// LongTermRetentionStorageGB defines a usage param that allows users to define how many gb of cold storage the database uses.
	// This is storage that can be kept for up to 10 years.
	LongTermRetentionStorageGB *int64 `infracost_usage:"long_term_retention_storage_gb"`
	BackupStorageGB            *int64 `infracost_usage:"backup_storage_gb"`
}

func (r *SQLManagedInstance) CoreType() string {
	return "SQLManagedInstance"
}

func (r *SQLManagedInstance) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "backup_storage_gb", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "long_term_retention_storage_gb", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the SQLManagedInstance.
// It uses the `infracost_usage` struct tags to populate data into the SQLManagedInstance.
func (r *SQLManagedInstance) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid SQLManagedInstance struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *SQLManagedInstance) BuildResource() *schema.Resource {
	costComponents := r.costComponents()

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *SQLManagedInstance) costComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{
		{
			Name:           fmt.Sprintf("Compute (%s %d Cores)", strings.ToTitle(r.SKU), r.Cores),
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr(vendorName),
				Region:        strPtr(r.Region),
				Service:       strPtr(sqlMIServiceName),
				ProductFamily: strPtr(sqlMIProductFamily),
				AttributeFilters: ([]*schema.AttributeFilter{
					{Key: "productName", Value: r.productDescription()},
					{Key: "skuName", Value: r.meteredName()},
				}),
			},
			PriceFilter: priceFilterConsumption,
		},
	}

	costComponents = append(costComponents, r.sqlMIStorageCostComponent(), r.sqlMIBackupCostComponent())

	if r.LicenseType == "LicenseIncluded" {
		costComponents = append(costComponents, r.sqlMILicenseCostComponent())
	}

	costComponents = append(costComponents, r.sqlMILongTermRetentionStorageGBCostComponent())

	return costComponents
}

func (r *SQLManagedInstance) productDescription() *string {
	productDescription := ""

	if strings.Contains(r.SKU, "GP") {
		productDescription = "SQL Managed Instance General Purpose"
	} else if strings.Contains(r.SKU, "BC") {
		productDescription = "SQL Managed Instance Business Critical"
	}

	if strings.Contains(r.SKU, "Gen5") {
		productDescription = fmt.Sprintf("%s - %s", productDescription, "Compute Gen5")
	}

	return strPtr(productDescription)
}

func (r *SQLManagedInstance) meteredName() *string {
	meterName := fmt.Sprintf("%d %s", r.Cores, "vCore")

	return strPtr(meterName)
}

func (r *SQLManagedInstance) sqlMIStorageCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(r.StorageSizeInGb - 32)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(sqlMIServiceName),
			ProductFamily: strPtr(sqlMIProductFamily),
			AttributeFilters: ([]*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("SQL Managed Instance General Purpose - Storage")},
				{Key: "skuName", Value: strPtr("General Purpose")},
				{Key: "meterName", ValueRegex: regexPtr("Data Stored$")},
			}),
		},
		PriceFilter: priceFilterConsumption,
	}
}

func (r *SQLManagedInstance) sqlMIBackupCostComponent() *schema.CostComponent {
	var backup *decimal.Decimal

	if r.BackupStorageGB != nil {
		backup = decimalPtr(decimal.NewFromInt(*r.BackupStorageGB))
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("PITR backup storage (%s)", r.StorageAccountType),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: backup,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(sqlMIServiceName),
			ProductFamily: strPtr(sqlMIProductFamily),
			AttributeFilters: ([]*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("SQL Managed Instance PITR Backup Storage")},
				{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Data Stored", r.StorageAccountType))},
			}),
		},
		PriceFilter: priceFilterConsumption,
		UsageBased:  true,
	}
}

func (r *SQLManagedInstance) sqlMILicenseCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "SQL license",
		Unit:           "vCore-hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(r.Cores)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr("Global"),
			Service:       strPtr(sqlMIServiceName),
			ProductFamily: strPtr(sqlMIProductFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("SQL Managed Instance General Purpose - SQL License")},
				{Key: "meterName", Value: strPtr("vCore")},
			},
		},
		PriceFilter: priceFilterConsumption,
	}
}

func (r *SQLManagedInstance) sqlMILongTermRetentionStorageGBCostComponent() *schema.CostComponent {
	var retention *decimal.Decimal

	if r.LongTermRetentionStorageGB != nil {
		retention = decimalPtr(decimal.NewFromInt(*r.LongTermRetentionStorageGB))
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("LTR backup storage (%s)", r.StorageAccountType),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: retention,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr(vendorName),
			Region:        strPtr(r.Region),
			Service:       strPtr(sqlMIServiceName),
			ProductFamily: strPtr(sqlMIProductFamily),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("SQL Managed Instance - LTR Backup Storage")},
				{Key: "meterName", Value: strPtr(fmt.Sprintf("LTR Backup %s Data Stored", r.StorageAccountType))},
			},
		},
		PriceFilter: priceFilterConsumption,
		UsageBased:  true,
	}
}

################################################################################
# FILE: internal/resources/azure/storage_account.go
# RESOURCE: azure_storage_account
# SIZE: 33167 bytes | LINES: 993
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
)

// StorageAccount represents Azure data storage services.
//
// More resource information here:
//
//	Block Blob Storage: https://azure.microsoft.com/en-us/services/storage/blobs/
//	File Storage: https://azure.microsoft.com/en-us/services/storage/files/
//
// Pricing information here:
//
//	Block Blob Storage: https://azure.microsoft.com/en-us/pricing/details/storage/blobs/
//	File Storage: https://azure.microsoft.com/en-us/pricing/details/storage/files/
type StorageAccount struct {
	Address string
	Region  string

	AccessTier             string
	AccountKind            string
	AccountReplicationType string
	AccountTier            string
	NFSv3                  bool

	// "usage" args
	MonthlyStorageGB                        *float64 `infracost_usage:"storage_gb"`
	MonthlyIterativeReadOperations          *int64   `infracost_usage:"monthly_iterative_read_operations"`
	MonthlyReadOperations                   *int64   `infracost_usage:"monthly_read_operations"`
	MonthlyIterativeWriteOperations         *int64   `infracost_usage:"monthly_iterative_write_operations"`
	MonthlyWriteOperations                  *int64   `infracost_usage:"monthly_write_operations"`
	MonthlyListAndCreateContainerOperations *int64   `infracost_usage:"monthly_list_and_create_container_operations"`
	MonthlyOtherOperations                  *int64   `infracost_usage:"monthly_other_operations"`
	MonthlyDataRetrievalGB                  *float64 `infracost_usage:"monthly_data_retrieval_gb"`
	MonthlyDataWriteGB                      *float64 `infracost_usage:"monthly_data_write_gb"`
	BlobIndexTags                           *int64   `infracost_usage:"blob_index_tags"`
	DataAtRestStorageGB                     *float64 `infracost_usage:"data_at_rest_storage_gb"`
	SnapshotsStorageGB                      *float64 `infracost_usage:"snapshots_storage_gb"`
	MetadataAtRestStorageGB                 *float64 `infracost_usage:"metadata_at_rest_storage_gb"`
	EarlyDeletionGB                         *float64 `infracost_usage:"early_deletion_gb"`
}

// CoreType returns the name of this resource type
func (r *StorageAccount) CoreType() string {
	return "StorageAccount"
}

func (r *StorageAccount) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "storage_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_iterative_read_operations", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_read_operations", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_iterative_write_operations", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_write_operations", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_list_and_create_container_operations", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_other_operations", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_data_retrieval_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_data_write_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "blob_index_tags", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "data_at_rest_storage_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "snapshots_storage_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "metadata_at_rest_storage_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "early_deletion_gb", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the StorageAccount.
// It uses the `infracost_usage` struct tags to populate data into the StorageAccount.
func (r *StorageAccount) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from valid StorageAccount data.
// This method is called after the resource is initialized by an IaC provider.
func (r *StorageAccount) BuildResource() *schema.Resource {
	if !r.isReplicationTypeSupported() {
		logging.Logger.Warn().Msgf("Skipping resource %s. %s %s doesn't support %s redundancy", r.Address, r.AccountKind, r.AccountTier, r.AccountReplicationType)
		return nil
	}

	if r.isPremium() {
		// Premium tier doesn't differentiate between Hot or Cool storage. This
		// helps to simplify skuName search.
		r.AccessTier = "Premium"
	}

	if r.isStorageV1() {
		// StorageV1 doesn't support Hot or Cool storage.
		r.AccessTier = "Standard"
	}

	costComponents := []*schema.CostComponent{}

	costComponents = append(costComponents, r.storageCostComponents()...)

	costComponents = append(costComponents, r.dataAtRestCostComponents()...)
	costComponents = append(costComponents, r.snapshotsCostComponents()...)
	costComponents = append(costComponents, r.metadataAtRestCostComponents()...)

	costComponents = append(costComponents, r.iterativeWriteOperationsCostComponents()...)
	costComponents = append(costComponents, r.writeOperationsCostComponents()...)
	costComponents = append(costComponents, r.listAndCreateContainerOperationsCostComponents()...)
	costComponents = append(costComponents, r.iterativeReadOperationsCostComponents()...)
	costComponents = append(costComponents, r.readOperationsCostComponents()...)
	costComponents = append(costComponents, r.otherOperationsCostComponents()...)
	costComponents = append(costComponents, r.dataRetrievalCostComponents()...)
	costComponents = append(costComponents, r.dataWriteCostComponents()...)
	costComponents = append(costComponents, r.blobIndexTagsCostComponents()...)

	costComponents = append(costComponents, r.earlyDeletionCostComponents()...)

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

// buildProductFilter returns a product filter for the Storage Account's products.
func (r *StorageAccount) buildProductFilter(meterName string) *schema.ProductFilter {
	var productName string

	switch {
	case r.isBlockBlobStorage():
		productName = map[string]string{
			"Standard": "Blob Storage",
			"Premium":  "Premium Block Blob",
		}[r.AccountTier]
	case r.isStorageV1():
		productName = map[string]string{
			"Standard": "General Block Blob",
			"Premium":  "Premium Block Blob",
		}[r.AccountTier]
	case r.isStorageV2():
		if r.NFSv3 {
			productName = map[string]string{
				"Standard": "General Block Blob v2 Hierarchical Namespace",
				"Premium":  "Premium Block Blob v2 Hierarchical Namespace",
			}[r.AccountTier]
		} else if strings.EqualFold(r.AccountReplicationType, "lrs") && r.isHot() {
			// For some reason the Azure pricing doesn't contain all the LRS costs for all regions under "General Block Blob v2" product name.
			// But, the same pricing is available under "Blob Storage" product name.
			productName = map[string]string{
				"Standard": "Blob Storage",
				"Premium":  "Premium Block Blob",
			}[r.AccountTier]
		} else {
			productName = map[string]string{
				"Standard": "General Block Blob v2",
				"Premium":  "Premium Block Blob",
			}[r.AccountTier]
		}
	case r.isBlobStorage():
		productName = map[string]string{
			"Standard": "Blob Storage",
			"Premium":  "Premium Block Blob",
		}[r.AccountTier]
	case r.isFileStorage():
		productName = map[string]string{
			"Standard": "Files v2",
			"Premium":  "Premium Files",
		}[r.AccountTier]
	}

	skuName := fmt.Sprintf("%s %s", cases.Title(language.English).String(r.AccessTier), strings.ToUpper(r.AccountReplicationType))

	return &schema.ProductFilter{
		VendorName:    strPtr("azure"),
		Region:        strPtr(r.Region),
		Service:       strPtr("Storage"),
		ProductFamily: strPtr("Storage"),
		AttributeFilters: []*schema.AttributeFilter{
			{Key: "productName", Value: strPtr(productName)},
			{Key: "skuName", Value: strPtr(skuName)},
			{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("%s$", meterName))},
		},
	}
}

// storageCostComponents returns one or several tier cost components for monthly
// storage capacity in Blob Storage.
//
// BlockBlobStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       cost exists
//
// BlobStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       cost exists
//
// Storage:
//
// Standard: cost exists
//
// StorageV2:
//
//	Standard Hot:        cost exists
//	Standard Hot NFSv3:  cost exists
//	Standard Cool:       cost exists
//	Standard Cool NFSv3: cost exists
//	Premium:             cost exists
//	Premium NFSv3:       cost exists
//
// FileStorage: see dataAtRestCostComponents()
func (r *StorageAccount) storageCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if r.isFileStorage() {
		return costComponents
	}

	var quantity *decimal.Decimal
	name := "Capacity"

	if r.MonthlyStorageGB == nil {
		costComponents = append(costComponents, r.buildStorageCostComponent(
			name,
			"0",
			quantity,
		))
		return costComponents
	}

	quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyStorageGB))

	// Only Hot storage has pricing tiers, others have a single price for any
	// amount.
	if !r.isHot() {
		costComponents = append(costComponents, r.buildStorageCostComponent(
			name,
			"0",
			quantity,
		))
		return costComponents
	}

	type dataTier struct {
		name       string
		startUsage string
	}

	data := []dataTier{
		{name: fmt.Sprintf("%s (first 50TB)", name), startUsage: "0"},
		{name: fmt.Sprintf("%s (next 450TB)", name), startUsage: "51200"},
		{name: fmt.Sprintf("%s (over 500TB)", name), startUsage: "512000"},
	}

	tierLimits := []int{51200, 512000}
	tiers := usage.CalculateTierBuckets(*quantity, tierLimits)

	for i, d := range data {
		if i < len(tiers) && tiers[i].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, r.buildStorageCostComponent(
				d.name,
				d.startUsage,
				decimalPtr(tiers[i]),
			))
		}
	}

	return costComponents
}

// iterativeWriteOperationsCostComponents returns a cost component for Iterative
// Write Operations.
//
// BlockBlobStorage: n/a
//
// BlobStorage: n/a
//
// Storage: n/a
//
// StorageV2:
//
//	Standard Hot:        no cost
//	Standard Hot NFSv3:  cost exists
//	Standard Cool:       no cost
//	Standard Cool NFSv3: cost exists
//	Premium:             no cost
//	Premium NFSv3:       no cost
//
// FileStorage: n/a
func (r *StorageAccount) iterativeWriteOperationsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if !r.isStorageV2() || !r.NFSv3 || r.isPremium() {
		return costComponents
	}

	var quantity *decimal.Decimal
	itemsPerCost := 100

	if r.MonthlyIterativeWriteOperations != nil {
		value := decimal.NewFromInt(*r.MonthlyIterativeWriteOperations)
		quantity = decimalPtr(value.Div(decimal.NewFromInt(int64(itemsPerCost))))
	}

	meterName := "Iterative Write Operations"

	costComponents = append(costComponents, &schema.CostComponent{
		Name:                 "Iterative write operations",
		Unit:                 "100 operations",
		UnitMultiplier:       decimal.NewFromInt(1),
		MonthlyQuantity:      quantity,
		IgnoreIfMissingPrice: r.canSkipPrice(),
		ProductFilter:        r.buildProductFilter(meterName),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	})

	return costComponents
}

// writeOperationsCostComponents returns a cost component for Write Operations.
//
// BlockBlobStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       cost exists
//
// BlobStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       cost exists
//
// Storage:
//
// Standard: cost exists
//
// StorageV2:
//
//	Standard Hot:        cost exists
//	Standard Hot NFSv3:  cost exists
//	Standard Cool:       cost exists
//	Standard Cool NFSv3: cost exists
//	Premium:             cost exists
//	Premium NFSv3:       cost exists
//
// FileStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       no cost
func (r *StorageAccount) writeOperationsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if r.isFileStorage() && r.isPremium() {
		return costComponents
	}

	var quantity *decimal.Decimal
	itemsPerCost := 10000

	if r.MonthlyWriteOperations != nil {
		value := decimal.NewFromInt(*r.MonthlyWriteOperations)
		quantity = decimalPtr(value.Div(decimal.NewFromInt(int64(itemsPerCost))))
	}

	meterName := "Write Operations"
	if r.isStorageV2() && r.NFSv3 {
		meterName = "(?<!Iterative) Write Operations"
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:                 "Write operations",
		Unit:                 "10k operations",
		UnitMultiplier:       decimal.NewFromInt(1),
		MonthlyQuantity:      quantity,
		IgnoreIfMissingPrice: r.canSkipPrice(),
		ProductFilter:        r.buildProductFilter(meterName),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	})

	return costComponents
}

// listAndCreateContainerOperationsCostComponents returns a cost component for
// List and Create Container Operations (List Operations for File storage).
//
// BlockBlobStorage:
//
//	Standard Hot:  no cost
//	Standard Cool: cost exists
//	Premium:       cost exists
//
// BlobStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       cost exists
//
// Storage:
//
// Standard: cost exists
//
// StorageV2:
//
//	Standard Hot:        cost exists
//	Standard Hot NFSv3:  no cost
//	Standard Cool:       cost exists
//	Standard Cool NFSv3: no cost
//	Premium:             no cost
//	Premium NFSv3:       no cost
//
// FileStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       no cost
func (r *StorageAccount) listAndCreateContainerOperationsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if r.isFileStorage() && r.isPremium() {
		return costComponents
	}

	if r.isStorageV2() && r.NFSv3 {
		return costComponents
	}

	var quantity *decimal.Decimal
	itemsPerCost := 10000

	if r.MonthlyListAndCreateContainerOperations != nil {
		value := decimal.NewFromInt(*r.MonthlyListAndCreateContainerOperations)
		quantity = decimalPtr(value.Div(decimal.NewFromInt(int64(itemsPerCost))))
	}

	name := "List and create container operations"
	meterName := "List and Create Container Operations"

	if r.isFileStorage() {
		name = "List operations"
		meterName = "List Operations"
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:                 name,
		Unit:                 "10k operations",
		UnitMultiplier:       decimal.NewFromInt(1),
		MonthlyQuantity:      quantity,
		IgnoreIfMissingPrice: r.canSkipPrice(),
		ProductFilter:        r.buildProductFilter(meterName),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	})

	return costComponents
}

// iterativeReadOperationsCostComponents returns a cost component for Iterative Read Operations.
//
// BlockBlobStorage: n/a
//
// BlobStorage: n/a
//
// Storage: n/a
//
// StorageV2:
//
//	Standard Hot:        no cost
//	Standard Hot NFSv3:  cost exists
//	Standard Cool:       no cost
//	Standard Cool NFSv3: cost exists
//	Premium:             no cost
//	Premium NFSv3:       no cost
//
// FileStorage: n/a
func (r *StorageAccount) iterativeReadOperationsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if !r.isStorageV2() || !r.NFSv3 || r.isPremium() {
		return costComponents
	}

	var quantity *decimal.Decimal
	itemsPerCost := 10000

	if r.MonthlyIterativeReadOperations != nil {
		value := decimal.NewFromInt(*r.MonthlyIterativeReadOperations)
		quantity = decimalPtr(value.Div(decimal.NewFromInt(int64(itemsPerCost))))
	}

	meterName := "Iterative Read Operations"

	costComponents = append(costComponents, &schema.CostComponent{
		Name:                 "Iterative read operations",
		Unit:                 "10k operations",
		UnitMultiplier:       decimal.NewFromInt(1),
		MonthlyQuantity:      quantity,
		IgnoreIfMissingPrice: r.canSkipPrice(),
		ProductFilter:        r.buildProductFilter(meterName),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	})

	return costComponents
}

// readOperationsCostComponents returns a cost component for Read Operations.
//
// BlockBlobStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       cost exists
//
// Storage:
//
// Standard: cost exists
//
// StorageV2:
//
//	Standard Hot:        cost exists
//	Standard Hot NFSv3:  cost exists
//	Standard Cool:       cost exists
//	Standard Cool NFSv3: cost exists
//	Premium:             cost exists
//	Premium NFSv3:       cost exists
//
// FileStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       no cost
func (r *StorageAccount) readOperationsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if r.isFileStorage() && r.isPremium() {
		return costComponents
	}

	var quantity *decimal.Decimal
	itemsPerCost := 10000

	if r.MonthlyReadOperations != nil {
		value := decimal.NewFromInt(*r.MonthlyReadOperations)
		quantity = decimalPtr(value.Div(decimal.NewFromInt(int64(itemsPerCost))))
	}

	meterName := "Read Operations"
	if r.isStorageV2() && r.NFSv3 {
		meterName = "(?<!Iterative) Read Operations"
	}
	if r.isStorageV1() && contains([]string{"LRS", "GRS", "RA-GRS"}, strings.ToUpper(r.AccountReplicationType)) {
		// Storage V1 GRS/LRS/RA-GRS doesn't always have a Read Operations meter name, but we can use this regex
		// to match Read or Other Operations meter since they are the same price.
		meterName = "(Other|Read) Operations"
	}

	filter := r.buildProductFilter(meterName)
	costComponents = append(costComponents, &schema.CostComponent{
		Name:                 "Read operations",
		Unit:                 "10k operations",
		UnitMultiplier:       decimal.NewFromInt(1),
		MonthlyQuantity:      quantity,
		IgnoreIfMissingPrice: r.canSkipPrice(),
		ProductFilter:        filter,
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	})

	return costComponents
}

// otherOperationsCostComponents returns a cost component for All Other Operations.
//
// BlockBlobStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       cost exists
//
// BlobStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       cost exists
//
// Storage:
//
// Standard: cost exists
//
// StorageV2:
//
//	Standard Hot:        cost exists
//	Standard Hot NFSv3:  cost exists
//	Standard Cool:       cost exists
//	Standard Cool NFSv3: cost exists
//	Premium:             cost exists
//	Premium NFSv3:       cost exists
//
// FileStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       no cost
func (r *StorageAccount) otherOperationsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if r.isFileStorage() && r.isPremium() {
		return costComponents
	}

	var quantity *decimal.Decimal
	itemsPerCost := 10000

	if r.MonthlyOtherOperations != nil {
		value := decimal.NewFromInt(*r.MonthlyOtherOperations)
		quantity = decimalPtr(value.Div(decimal.NewFromInt(int64(itemsPerCost))))
	}

	meterName := "Other Operations"
	if r.isStorageV1() {
		// Most StorageV1 rows don't have a meter name called Other Operations,
		// but they do have Delete Operations which is the same price.
		meterName = "Delete Operations"
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:                 "All other operations",
		Unit:                 "10k operations",
		UnitMultiplier:       decimal.NewFromInt(1),
		MonthlyQuantity:      quantity,
		IgnoreIfMissingPrice: r.canSkipPrice(),
		ProductFilter:        r.buildProductFilter(meterName),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	})

	return costComponents
}

// dataRetrievalCostComponents returns a cost component for Data Retrieval
// amount.
//
// BlockBlobStorage:
//
//	Standard Hot:  no cost
//	Standard Cool: cost exists
//	Premium:       no cost
//
// BlobStorage:
//
//	Standard Hot:  no cost
//	Standard Cool: cost exists
//	Premium:       no cost
//
// Storage: n/a
//
// StorageV2:
//
//	Standard Hot:        no cost
//	Standard Hot NFSv3:  no cost
//	Standard Cool:       cost exists
//	Standard Cool NFSv3: cost exists
//	Premium:             no cost
//	Premium NFSv3:       no cost
//
// FileStorage:
//
//	Standard Hot:  no cost
//	Standard Cool: cost exists
//	Premium:       no cost
func (r *StorageAccount) dataRetrievalCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if !r.isCool() {
		return costComponents
	}

	var quantity *decimal.Decimal

	if r.MonthlyDataRetrievalGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataRetrievalGB))
	}

	meterName := "Data Retrieval"

	costComponents = append(costComponents, &schema.CostComponent{
		Name:                 "Data retrieval",
		Unit:                 "GB",
		UnitMultiplier:       decimal.NewFromInt(1),
		MonthlyQuantity:      quantity,
		IgnoreIfMissingPrice: r.canSkipPrice(),
		ProductFilter:        r.buildProductFilter(meterName),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	})

	return costComponents
}

// dataWriteCostComponents returns a cost component for Data Write amount.
//
// BlockBlobStorage:
//
//	Standard Hot:  no cost
//	Standard Cool: cost exists
//	Premium:       no cost
//
// BlobStorage:
//
//	Standard Hot:  no cost
//	Standard Cool: cost exists
//	Premium:       no cost
//
// Storage: n/a
//
// StorageV2:
//
//	Standard Hot:        no cost
//	Standard Hot NFSv3:  no cost
//	Standard Cool:       no cost
//	Standard Cool NFSv3: no cost
//	Premium:             no cost
//	Premium NFSv3:       no cost
//
// FileStorage:
//
//	Standard Hot:  no cost
//	Standard Cool: no cost
//	Premium:       no cost
func (r *StorageAccount) dataWriteCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if !(r.isBlockBlobStorage() && !r.isBlobStorage()) || !r.isCool() {
		return costComponents
	}

	var quantity *decimal.Decimal

	if r.MonthlyDataWriteGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataWriteGB))
	}

	meterName := "Data Write"

	costComponents = append(costComponents, &schema.CostComponent{
		Name:                 "Data write",
		Unit:                 "GB",
		UnitMultiplier:       decimal.NewFromInt(1),
		MonthlyQuantity:      quantity,
		IgnoreIfMissingPrice: r.canSkipPrice(),
		ProductFilter:        r.buildProductFilter(meterName),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	})

	return costComponents
}

// blobIndexTagsCostComponents returns a cost component for Blob Index
// subresources amount.
//
// BlockBlobStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       no cost
//
// BlobStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       no cost
//
// Storage: n/a
//
// StorageV2:
//
//	Standard Hot:        cost exists
//	Standard Hot NFSv3:  no cost
//	Standard Cool:       cost exists
//	Standard Cool NFSv3: no cost
//	Premium:             no cost
//	Premium NFSv3:       no cost
//
// FileStorage:
//
//	Standard Hot:  no cost
//	Standard Cool: no cost
//	Premium:       no cost
func (r *StorageAccount) blobIndexTagsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	isBlockPremium := r.isBlockBlobStorage() && r.isPremium()
	isBlobPremium := r.isBlobStorage() && r.isPremium()
	isV2NFSv3 := r.isStorageV2() && (r.NFSv3 || r.isPremium())
	if r.isFileStorage() || r.isStorageV1() || isBlockPremium || isBlobPremium || isV2NFSv3 {
		return costComponents
	}

	var quantity *decimal.Decimal
	itemsPerCost := 10000

	if r.BlobIndexTags != nil {
		value := decimal.NewFromInt(*r.BlobIndexTags)
		quantity = decimalPtr(value.Div(decimal.NewFromInt(int64(itemsPerCost))))
	}

	meterName := "Index Tags"

	costComponents = append(costComponents, &schema.CostComponent{
		Name:                 "Blob index",
		Unit:                 "10k tags",
		UnitMultiplier:       decimal.NewFromInt(1),
		MonthlyQuantity:      quantity,
		IgnoreIfMissingPrice: r.canSkipPrice(),
		ProductFilter:        r.buildProductFilter(meterName),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	})

	return costComponents
}

// dataAtRestCostComponents returns a cost component for Data at Rest amount in
// File Storage.
//
// BlockBlobStorage: n/a
//
// BlobStorage: n/a
//
// Storage: n/a
//
// StorageV2: n/a
//
// FileStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       cost exists
func (r *StorageAccount) dataAtRestCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if !r.isFileStorage() {
		return costComponents
	}

	var quantity *decimal.Decimal

	if r.DataAtRestStorageGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.DataAtRestStorageGB))
	}

	meterName := "Data Stored"
	if r.isPremium() {
		meterName = "Provisioned"
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Data at rest",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter:   r.buildProductFilter(meterName),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	})

	return costComponents
}

// snapshotsCostComponents returns a cost component for Snapshots amount in
// File Storage.
//
// BlockBlobStorage: n/a
//
// BlobStorage: n/a
//
// Storage: n/a
//
// StorageV2: n/a
//
// FileStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       cost exists
func (r *StorageAccount) snapshotsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if !r.isFileStorage() {
		return costComponents
	}

	var quantity *decimal.Decimal

	if r.SnapshotsStorageGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.SnapshotsStorageGB))
	}

	meterName := "Data Stored"
	if r.isPremium() {
		meterName = "Snapshots"
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Snapshots",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter:   r.buildProductFilter(meterName),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	})

	return costComponents
}

// metadataAtRestCostComponents returns a cost component for Metadata at-rest amount in
// File Storage.
//
// BlockBlobStorage: n/a
//
// BlobStorage: n/a
//
// Storage: n/a
//
// StorageV2: n/a
//
// FileStorage:
//
//	Standard Hot:  cost exists
//	Standard Cool: cost exists
//	Premium:       no cost
func (r *StorageAccount) metadataAtRestCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if !r.isFileStorage() || r.isPremium() {
		return costComponents
	}

	var quantity *decimal.Decimal

	if r.MetadataAtRestStorageGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MetadataAtRestStorageGB))
	}

	meterName := "Metadata"

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Metadata at rest",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter:   r.buildProductFilter(meterName),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	})

	return costComponents
}

// earlyDeletionCostComponents returns a cost component for Metadata at-rest amount in
// File Storage.
//
// BlockBlobStorage: n/a
//
// BlobStorage: n/a
//
// Storage: n/a
//
// StorageV2:
//
//	Standard Hot:        no cost
//	Standard Hot NFSv3:  no cost
//	Standard Cool:       cost exists
//	Standard Cool NFSv3: cost exists
//	Premium:             no cost
//	Premium NFSv3:       no cost
//
// FileStorage:
//
//	Standard Hot:  no cost
//	Standard Cool: cost exists
//	Premium:       no cost
func (r *StorageAccount) earlyDeletionCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if r.isStorageV1() || r.isBlockBlobStorage() || r.isBlobStorage() || !r.isCool() {
		return costComponents
	}

	var quantity *decimal.Decimal

	if r.EarlyDeletionGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.EarlyDeletionGB))
	}

	meterName := "Early Delete"

	costComponents = append(costComponents, &schema.CostComponent{
		Name:                 "Early deletion",
		Unit:                 "GB",
		UnitMultiplier:       decimal.NewFromInt(1),
		MonthlyQuantity:      quantity,
		IgnoreIfMissingPrice: r.canSkipPrice(),
		ProductFilter:        r.buildProductFilter(meterName),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	})

	return costComponents
}

// buildStorageCostComponent builds one cost component for storage amount costs.
func (r *StorageAccount) buildStorageCostComponent(name string, startUsage string, quantity *decimal.Decimal) *schema.CostComponent {
	meterName := "Data Stored"

	return &schema.CostComponent{
		Name:                 name,
		Unit:                 "GB",
		UnitMultiplier:       decimal.NewFromInt(1),
		MonthlyQuantity:      quantity,
		IgnoreIfMissingPrice: r.canSkipPrice(),
		ProductFilter:        r.buildProductFilter(meterName),
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr(startUsage),
		},
		UsageBased: true,
	}
}

func (r *StorageAccount) isBlockBlobStorage() bool {
	return strings.EqualFold(r.AccountKind, "blockblobstorage")
}

func (r *StorageAccount) isFileStorage() bool {
	return strings.EqualFold(r.AccountKind, "filestorage")
}

func (r *StorageAccount) isBlobStorage() bool {
	return strings.EqualFold(r.AccountKind, "blobstorage")
}

func (r *StorageAccount) isStorageV1() bool {
	return strings.EqualFold(r.AccountKind, "storage")
}

func (r *StorageAccount) isStorageV2() bool {
	return strings.EqualFold(r.AccountKind, "storagev2")
}

func (r *StorageAccount) isHot() bool {
	return strings.EqualFold(r.AccessTier, "hot")
}

func (r *StorageAccount) isCool() bool {
	return strings.EqualFold(r.AccessTier, "cool")
}

func (r *StorageAccount) isPremium() bool {
	return strings.EqualFold(r.AccountTier, "premium")
}

func (r *StorageAccount) isReplicationTypeSupported() bool {
	var validReplicationTypes []string

	switch {
	case r.isPremium():
		validReplicationTypes = []string{"LRS", "ZRS"}
	case r.isBlockBlobStorage():
		validReplicationTypes = []string{"LRS", "GRS", "RA-GRS"}
	case r.isStorageV1():
		validReplicationTypes = []string{"LRS", "ZRS", "GRS", "RA-GRS"}
	case r.isStorageV2():
		validReplicationTypes = []string{"LRS", "ZRS", "GRS", "RA-GRS", "GZRS", "RA-GZRS"}
	case r.isBlobStorage():
		validReplicationTypes = []string{"LRS", "GRS", "RA-GRS"}
	case r.isFileStorage():
		validReplicationTypes = []string{"LRS", "GRS", "ZRS"}
	}

	if validReplicationTypes != nil {
		return contains(validReplicationTypes, strings.ToUpper(r.AccountReplicationType))
	}

	return true
}

func (r *StorageAccount) canSkipPrice() bool {
	// Not all regions support GZRS/RA-GZRS redundancy types. Some operations miss
	// prices for specific regions.
	// Read more: https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy
	return r.isStorageV2()
}

################################################################################
# FILE: internal/resources/azure/storage_queue.go
# RESOURCE: azure_storage_queue
# SIZE: 8476 bytes | LINES: 211
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// StorageQueue struct represents Azure Queue Storage.
//
// Resource information: https://azure.microsoft.com/en-gb/pricing/details/storage/queues/
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/storage/queues/#pricing
type StorageQueue struct {
	Address                string
	Region                 string
	AccountKind            string
	AccountReplicationType string

	MonthlyStorageGB                    *float64 `infracost_usage:"monthly_storage_gb"`
	MonthlyClass1Operations             *int64   `infracost_usage:"monthly_class_1_operations"`
	MonthlyClass2Operations             *int64   `infracost_usage:"monthly_class_2_operations"`
	MonthlyGeoReplicationDataTransferGB *float64 `infracost_usage:"monthly_geo_replication_data_transfer_gb"`
}

// CoreType returns the name of this resource type
func (r *StorageQueue) CoreType() string {
	return "StorageQueue"
}

// UsageSchema defines a list which represents the usage schema of StorageQueue.
func (r *StorageQueue) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_storage_gb", DefaultValue: 0.0, ValueType: schema.Float64},
		{Key: "monthly_class_1_operations", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_class_2_operations", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_geo_replication_data_transfer_gb", DefaultValue: 0.0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the StorageQueue.
// It uses the `infracost_usage` struct tags to populate data into the StorageQueue.
func (r *StorageQueue) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid StorageQueue struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *StorageQueue) BuildResource() *schema.Resource {
	if !r.isAccountKindSupported() {
		logging.Logger.Warn().Msgf("Skipping resource %s. Storage Queues don't support %s accounts", r.Address, r.AccountKind)
		return nil
	}

	if !r.isReplicationTypeSupported() {
		logging.Logger.Warn().Msgf("Skipping resource %s. Storage Queues don't support %s redundancy", r.Address, r.AccountReplicationType)
		return nil
	}

	costComponents := []*schema.CostComponent{
		r.dataStorageCostComponent(),
	}
	costComponents = append(costComponents, r.operationsCostComponents()...)
	costComponents = append(costComponents, r.geoReplicationDataTransferCostComponents()...)

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *StorageQueue) isAccountKindSupported() bool {
	return r.isStorageV1() || r.isStorageV2()
}

func (r *StorageQueue) isReplicationTypeSupported() bool {
	var validReplicationTypes []string

	switch {
	case r.isStorageV1():
		validReplicationTypes = []string{"LRS", "GRS", "RA-GRS"}
	case r.isStorageV2():
		validReplicationTypes = []string{"LRS", "ZRS", "GRS", "RA-GRS", "GZRS", "RA-GZRS"}
	}

	if validReplicationTypes != nil {
		return contains(validReplicationTypes, strings.ToUpper(r.AccountReplicationType))
	}

	return true
}

func (r *StorageQueue) isStorageV1() bool {
	return strings.EqualFold(r.AccountKind, "storage")
}

func (r *StorageQueue) isStorageV2() bool {
	return strings.EqualFold(r.AccountKind, "storagev2")
}

func (r *StorageQueue) productName() string {
	if r.isStorageV1() {
		return "Queues"
	}

	return "Queues v2"
}

func (r *StorageQueue) dataStorageCostComponent() *schema.CostComponent {
	var qty *decimal.Decimal
	if r.MonthlyStorageGB != nil {
		qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyStorageGB))
	}

	return &schema.CostComponent{
		Name:            "Capacity",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Storage"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr(r.productName())},
				{Key: "skuName", Value: strPtr(fmt.Sprintf("Standard %s", strings.ToUpper(r.AccountReplicationType)))},
				{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Data Stored", strings.ToUpper(r.AccountReplicationType)))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}
}

func (r *StorageQueue) operationsCostComponents() []*schema.CostComponent {
	costComponents := []*schema.CostComponent{}

	if !contains([]string{"GZRS", "RA-GZRS"}, strings.ToUpper(r.AccountReplicationType)) {
		var class1Qty *decimal.Decimal
		if r.MonthlyClass1Operations != nil {
			class1Qty = decimalPtr(decimal.NewFromInt(*r.MonthlyClass1Operations).Div(decimal.NewFromInt(10000)))
		}

		costComponents = append(costComponents, &schema.CostComponent{
			Name:            "Class 1 operations",
			Unit:            "10k operations",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: class1Qty,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Storage"),
				ProductFamily: strPtr("Storage"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr(r.productName())},
					{Key: "skuName", Value: strPtr(fmt.Sprintf("Standard %s", strings.ToUpper(r.AccountReplicationType)))},
					{Key: "meterName", ValueRegex: regexPtr("Class 1 Operations$")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption:   strPtr("Consumption"),
				StartUsageAmount: strPtr("0"),
			},
			UsageBased: true,
		})
	}

	var class2Qty *decimal.Decimal
	if r.MonthlyClass1Operations != nil {
		class2Qty = decimalPtr(decimal.NewFromInt(*r.MonthlyClass2Operations).Div(decimal.NewFromInt(10000)))
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Class 2 operations",
		Unit:            "10k operations",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: class2Qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Storage"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr(r.productName())},
				{Key: "skuName", Value: strPtr(fmt.Sprintf("Standard %s", strings.ToUpper(r.AccountReplicationType)))},
				{Key: "meterName", ValueRegex: regexPtr("Class 2 Operations$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	})

	return costComponents
}

func (r *StorageQueue) geoReplicationDataTransferCostComponents() []*schema.CostComponent {
	if contains([]string{"LRS", "ZRS"}, strings.ToUpper(r.AccountReplicationType)) {
		return []*schema.CostComponent{}
	}

	var qty *decimal.Decimal
	if r.MonthlyGeoReplicationDataTransferGB != nil {
		qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyGeoReplicationDataTransferGB))
	}

	return []*schema.CostComponent{
		{
			Name:            "Geo-replication data transfer",
			Unit:            "GB",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: qty,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Storage"),
				ProductFamily: strPtr("Storage"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr("Storage - Bandwidth")},
					{Key: "skuName", Value: strPtr("Geo-Replication v2")},
					{Key: "meterName", Value: strPtr("Geo-Replication v2 Data Transfer")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption:   strPtr("Consumption"),
				StartUsageAmount: strPtr("0"),
			},
			UsageBased: true,
		},
	}
}

################################################################################
# FILE: internal/resources/azure/storage_share.go
# RESOURCE: azure_storage_share
# SIZE: 13598 bytes | LINES: 351
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// StorageShare struct represents an Azure Files Storage Shares
//
// Resource information: https://azure.microsoft.com/en-gb/pricing/details/storage/files/
// Pricing information: https://azure.microsoft.com/en-gb/pricing/details/storage/files/#pricing
type StorageShare struct {
	Address                string
	Region                 string
	AccountReplicationType string
	AccessTier             string
	Quota                  int64

	// "usage" args
	MonthlyStorageGB        *float64 `infracost_usage:"storage_gb"`
	MonthlyReadOperations   *int64   `infracost_usage:"monthly_read_operations"`
	MonthlyWriteOperations  *int64   `infracost_usage:"monthly_write_operations"`
	MonthlyListOperations   *int64   `infracost_usage:"monthly_list_operations"`
	MonthlyOtherOperations  *int64   `infracost_usage:"monthly_other_operations"`
	MonthlyDataRetrievalGB  *float64 `infracost_usage:"monthly_data_retrieval_gb"`
	SnapshotsStorageGB      *float64 `infracost_usage:"snapshots_storage_gb"`
	MetadataAtRestStorageGB *float64 `infracost_usage:"metadata_at_rest_storage_gb"`
}

// CoreType returns the name of this resource type
func (r *StorageShare) CoreType() string {
	return "StorageShare"
}

// UsageSchema defines a list which represents the usage schema of StorageShare.
func (r *StorageShare) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "storage_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "monthly_read_operations", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_write_operations", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_list_operations", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_other_operations", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_data_retrieval_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "snapshots_storage_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "metadata_at_rest_storage_gb", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the StorageShare.
// It uses the `infracost_usage` struct tags to populate data into the StorageShare.
func (r *StorageShare) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid StorageShare struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *StorageShare) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.dataStorageCostComponent(),
	}

	costComponents = append(costComponents, r.snapshotCostComponents()...)
	costComponents = append(costComponents, r.metadataCostComponents()...)
	costComponents = append(costComponents, r.readOperationsCostComponents()...)
	costComponents = append(costComponents, r.writeOperationsCostComponents()...)
	costComponents = append(costComponents, r.listOperationsCostComponents()...)
	costComponents = append(costComponents, r.otherOperationsCostComponents()...)
	costComponents = append(costComponents, r.dataRetrievalCostComponents()...)

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *StorageShare) productName() string {
	if r.accessTier() == "Premium" {
		return "Premium Files"
	}

	return "Files v2"
}

func (r *StorageShare) accessTier() string {
	return map[string]string{
		"hot":                  "Hot",
		"cool":                 "Cool",
		"transactionoptimized": "Standard",
		"premium":              "Premium",
	}[strings.ToLower(r.AccessTier)]
}

func (r *StorageShare) dataStorageCostComponent() *schema.CostComponent {
	var qty *decimal.Decimal

	if r.accessTier() == "Premium" {
		qty = decimalPtr(decimal.NewFromInt(r.Quota))
	}

	if r.MonthlyStorageGB != nil {
		qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyStorageGB))
	}

	skuName := fmt.Sprintf("%s %s", r.accessTier(), strings.ToUpper(r.AccountReplicationType))
	meterName := "Data Stored"
	if r.accessTier() == "Premium" {
		meterName = "Provisioned"
	}

	return &schema.CostComponent{
		Name:            "Data at rest",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Storage"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr(r.productName())},
				{Key: "skuName", Value: strPtr(skuName)},
				{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("%s$", meterName))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}
}

func (r *StorageShare) snapshotCostComponents() []*schema.CostComponent {
	var qty *decimal.Decimal
	if r.SnapshotsStorageGB != nil {
		qty = decimalPtr(decimal.NewFromFloat(*r.SnapshotsStorageGB))
	}

	skuName := fmt.Sprintf("%s %s", r.accessTier(), strings.ToUpper(r.AccountReplicationType))
	meterName := "Data Stored"
	if r.accessTier() == "Premium" {
		meterName = "Snapshots"
	}

	return []*schema.CostComponent{{
		Name:            "Snapshots",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Storage"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr(r.productName())},
				{Key: "skuName", Value: strPtr(skuName)},
				{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("%s$", meterName))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}}
}

func (r *StorageShare) metadataCostComponents() []*schema.CostComponent {
	if contains([]string{"Premium", "Standard"}, r.accessTier()) {
		return []*schema.CostComponent{}
	}

	var qty *decimal.Decimal
	if r.MetadataAtRestStorageGB != nil {
		qty = decimalPtr(decimal.NewFromFloat(*r.MetadataAtRestStorageGB))
	}

	skuName := fmt.Sprintf("%s %s", r.accessTier(), strings.ToUpper(r.AccountReplicationType))

	return []*schema.CostComponent{{
		Name:            "Metadata at rest",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Storage"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr(r.productName())},
				{Key: "skuName", Value: strPtr(skuName)},
				{Key: "meterName", ValueRegex: regexPtr("Metadata$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}}
}

func (r *StorageShare) readOperationsCostComponents() []*schema.CostComponent {
	if r.accessTier() == "Premium" {
		return []*schema.CostComponent{}
	}

	var qty *decimal.Decimal
	if r.MonthlyReadOperations != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyReadOperations).Div(decimal.NewFromInt(10000)))
	}

	skuName := fmt.Sprintf("%s %s", r.accessTier(), strings.ToUpper(r.AccountReplicationType))

	return []*schema.CostComponent{{
		Name:            "Read operations",
		Unit:            "10k operations",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Storage"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr(r.productName())},
				{Key: "skuName", Value: strPtr(skuName)},
				{Key: "meterName", ValueRegex: regexPtr("Read Operations$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}}
}

func (r *StorageShare) writeOperationsCostComponents() []*schema.CostComponent {
	if r.accessTier() == "Premium" {
		return []*schema.CostComponent{}
	}

	var qty *decimal.Decimal
	if r.MonthlyWriteOperations != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyWriteOperations).Div(decimal.NewFromInt(10000)))
	}

	skuName := fmt.Sprintf("%s %s", r.accessTier(), strings.ToUpper(r.AccountReplicationType))

	return []*schema.CostComponent{{
		Name:            "Write operations",
		Unit:            "10k operations",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Storage"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr(r.productName())},
				{Key: "skuName", Value: strPtr(skuName)},
				{Key: "meterName", ValueRegex: regexPtr("Write Operations$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}}
}

func (r *StorageShare) listOperationsCostComponents() []*schema.CostComponent {
	if r.accessTier() == "Premium" {
		return []*schema.CostComponent{}
	}

	var qty *decimal.Decimal
	if r.MonthlyListOperations != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyListOperations).Div(decimal.NewFromInt(10000)))
	}

	skuName := fmt.Sprintf("%s %s", r.accessTier(), strings.ToUpper(r.AccountReplicationType))

	return []*schema.CostComponent{{
		Name:            "List operations",
		Unit:            "10k operations",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: qty,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Storage"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr(r.productName())},
				{Key: "skuName", Value: strPtr(skuName)},

				{Key: "meterName", ValueRegex: regexPtr("List Operations$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption:   strPtr("Consumption"),
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}}
}

func (r *StorageShare) otherOperationsCostComponents() []*schema.CostComponent {
	if r.accessTier() == "Premium" {
		return []*schema.CostComponent{}
	}

	var qty *decimal.Decimal
	if r.MonthlyOtherOperations != nil {
		qty = decimalPtr(decimal.NewFromInt(*r.MonthlyOtherOperations).Div(decimal.NewFromInt(10000)))
	}

	skuName := fmt.Sprintf("%s %s", r.accessTier(), strings.ToUpper(r.AccountReplicationType))
	meterName := "Other Operations"
	if r.accessTier() == "Standard" {
		meterName = "Protocol Operations"
	}

	return []*schema.CostComponent{
		{
			Name:            "Other operations",
			Unit:            "10k operations",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: qty,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Storage"),
				ProductFamily: strPtr("Storage"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr(r.productName())},
					{Key: "skuName", Value: strPtr(skuName)},
					{Key: "meterName", ValueRegex: regexPtr(fmt.Sprintf("%s$", meterName))},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption:   strPtr("Consumption"),
				StartUsageAmount: strPtr("0"),
			},
			UsageBased: true,
		}}
}

func (r *StorageShare) dataRetrievalCostComponents() []*schema.CostComponent {
	if contains([]string{"Premium", "Standard", "Hot"}, r.accessTier()) || strings.ToUpper(r.AccountReplicationType) == "GZRS" {
		return []*schema.CostComponent{}
	}

	var qty *decimal.Decimal
	if r.MonthlyDataRetrievalGB != nil {
		qty = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataRetrievalGB))
	}

	skuName := fmt.Sprintf("%s %s", r.accessTier(), strings.ToUpper(r.AccountReplicationType))

	return []*schema.CostComponent{
		{
			Name:            "Data retrieval",
			Unit:            "GB",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: qty,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Storage"),
				ProductFamily: strPtr("Storage"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "productName", Value: strPtr(r.productName())},
					{Key: "skuName", Value: strPtr(skuName)},
					{Key: "meterName", ValueRegex: regexPtr("Data Retrieval$")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption:   strPtr("Consumption"),
				StartUsageAmount: strPtr("0"),
			},
			UsageBased: true,
		}}
}

################################################################################
# FILE: internal/resources/azure/traffic_manager_endpoint.go
# RESOURCE: azure_traffic_manager_endpoint
# SIZE: 3797 bytes | LINES: 97
################################################################################
package azure

import (
	"fmt"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/shopspring/decimal"
)

// TrafficManagerEndpoint struct represents Azure Traffic Manager Endpoints.
//
// Resource information: https://learn.microsoft.com/en-us/azure/traffic-manager/traffic-manager-endpoint-types
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/traffic-manager/#pricing
type TrafficManagerEndpoint struct {
	Address string
	Region  string

	ProfileEnabled      bool
	External            bool
	HealthCheckInterval int64
}

// CoreType returns the name of this resource type
func (r *TrafficManagerEndpoint) CoreType() string {
	return "TrafficManagerEndpoint"
}

// UsageSchema defines a list which represents the usage schema of TrafficManagerEndpoint.
func (r *TrafficManagerEndpoint) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the TrafficManagerEndpoint.
// It uses the `infracost_usage` struct tags to populate data into the TrafficManagerEndpoint.
func (r *TrafficManagerEndpoint) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid TrafficManagerEndpoint struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *TrafficManagerEndpoint) BuildResource() *schema.Resource {
	if !r.ProfileEnabled {
		return &schema.Resource{
			Name: r.Address,
		}
	}

	costComponents := []*schema.CostComponent{
		r.healthCheckCostComponent(),
	}

	if r.HealthCheckInterval < 30 {
		costComponents = append(costComponents, r.fastHealthCheckCostComponent())
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *TrafficManagerEndpoint) sku() string {
	if r.External {
		return "Non-Azure Endpoint"
	} else {
		return "Azure Endpoint"
	}
}

func (r *TrafficManagerEndpoint) healthCheckCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Basic health check (%s)", trafficManagerBillingRegion(r.Region)),
		Unit:            "hours",
		UnitMultiplier:  schema.MonthToHourUnitMultiplier,
		UnitRounding:    int32Ptr(0),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),

		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(trafficManagerBillingRegion(r.Region)),
			Service:       strPtr("Traffic Manager"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(r.sku())},
				{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Health Checks", r.sku()))},
			},
		},
	}
}

func (r *TrafficManagerEndpoint) fastHealthCheckCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Fast interval health checks add-on (%s)", trafficManagerBillingRegion(r.Region)),
		Unit:            "hours",
		UnitMultiplier:  schema.MonthToHourUnitMultiplier,
		UnitRounding:    int32Ptr(0),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(trafficManagerBillingRegion(r.Region)),
			Service:       strPtr("Traffic Manager"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(r.sku())},
				{Key: "meterName", Value: strPtr(fmt.Sprintf("%s Fast Interval Health Check Add-ons", r.sku()))},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/azure/traffic_manager_profile.go
# RESOURCE: azure_traffic_manager_profile
# SIZE: 5059 bytes | LINES: 129
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
)

// TrafficManagerProfile struct represents an Azure Traffic Manager profile.
//
// Resource information: https://learn.microsoft.com/en-us/azure/traffic-manager/traffic-manager-overview
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/traffic-manager/#pricing
type TrafficManagerProfile struct {
	Address string
	Region  string

	Enabled            bool
	TrafficViewEnabled bool

	MonthlyDNSQueries            *int64 `infracost_usage:"monthly_dns_queries"`
	MonthlyTrafficViewDataPoints *int64 `infracost_usage:"monthly_traffic_view_data_points"`
}

// CoreType returns the name of this resource type
func (r *TrafficManagerProfile) CoreType() string {
	return "TrafficManagerProfile"
}

// UsageSchema defines a list which represents the usage schema of TrafficManagerProfile.
func (r *TrafficManagerProfile) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_dns_queries", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_traffic_view_data_points", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the TrafficManagerProfile.
// It uses the `infracost_usage` struct tags to populate data into the TrafficManagerProfile.
func (r *TrafficManagerProfile) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid TrafficManagerProfile struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *TrafficManagerProfile) BuildResource() *schema.Resource {
	if !r.Enabled {
		return &schema.Resource{
			Name: r.Address,
		}
	}

	costComponents := []*schema.CostComponent{}

	if r.MonthlyDNSQueries != nil {
		dnsQuantities := usage.CalculateTierBuckets(
			*decimalPtr(decimal.NewFromInt(*r.MonthlyDNSQueries)),
			[]int{1000000000},
		)
		costComponents = append(costComponents, r.dnsQueriesCostComponent(&dnsQuantities[0], "first 1B", "0"))

		if dnsQuantities[1].GreaterThan(decimal.NewFromInt(0)) {
			costComponents = append(costComponents, r.dnsQueriesCostComponent(&dnsQuantities[1], "over 1B", "1000"))
		}
	} else {
		costComponents = append(costComponents, r.dnsQueriesCostComponent(nil, "first 1B", "0"))
	}

	if r.TrafficViewEnabled {
		costComponents = append(costComponents, r.trafficViewCostComponent())
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *TrafficManagerProfile) dnsQueriesCostComponent(q *decimal.Decimal, tierName, startUsage string) *schema.CostComponent {
	var millions *decimal.Decimal
	if q != nil {
		millions = decimalPtr(q.Div(decimal.NewFromInt(1000000)))
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("DNS queries (%s)", tierName),
		Unit:            "1M queries",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: millions,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(trafficManagerBillingRegion(r.Region)),
			Service:       strPtr("Traffic Manager"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr("Azure Endpoint")},
				{Key: "meterName", Value: strPtr("DNS Queries")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(startUsage),
		},
		UsageBased: true,
	}
}

func (r *TrafficManagerProfile) trafficViewCostComponent() *schema.CostComponent {
	var millions *decimal.Decimal
	if r.MonthlyTrafficViewDataPoints != nil {
		millions = decimalPtr(decimal.NewFromInt(*r.MonthlyTrafficViewDataPoints).Div(decimal.NewFromInt(1000000)))
	}

	return &schema.CostComponent{
		Name:            "Traffic view",
		Unit:            "1M data points",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: millions,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(trafficManagerBillingRegion(r.Region)),
			Service:       strPtr("Traffic Manager"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr("Traffic View")},
				{Key: "meterName", Value: strPtr("Traffic View Data Points Processed")},
			},
		},
		UsageBased: true,
	}
}

func trafficManagerBillingRegion(region string) string {
	switch {
	case strings.Contains(strings.ToLower(region), "usgov"):
		return "US Gov"
	case strings.Contains(strings.ToLower(region), "china"):
		return "China"
	case strings.Contains(strings.ToLower(region), "germany"):
		return "Germany"
	default:
		return "Global"
	}
}

################################################################################
# FILE: internal/resources/azure/util.go
# RESOURCE: azure_util
# SIZE: 1793 bytes | LINES: 79
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/schema"
)

const (
	vendorName = "azure"
)

var (
	priceFilterConsumption = &schema.PriceFilter{
		PurchaseOption: strPtr("Consumption"),
	}
	priceFilterDevTestConsumption = &schema.PriceFilter{
		PurchaseOption: strPtr("DevTestConsumption"),
	}
)

func strPtr(s string) *string {
	return &s
}

func decimalPtr(d decimal.Decimal) *decimal.Decimal {
	return &d
}

func int32Ptr(i int32) *int32 {
	return &i
}

func intPtrToDecimalPtr(i *int64) *decimal.Decimal {
	if i == nil {
		return nil
	}
	return decimalPtr(decimal.NewFromInt(*i))
}

func floatPtrToDecimalPtr(f *float64) *decimal.Decimal {
	if f == nil {
		return nil
	}
	return decimalPtr(decimal.NewFromFloat(*f))
}

func contains(a []string, x string) bool {
	for _, n := range a {
		if x == n {
			return true
		}
	}
	return false
}

func containsInt64(arr []int64, val int64) bool {
	for _, a := range arr {
		if a == val {
			return true
		}
	}
	return false
}

func regexPtr(regex string) *string {
	return strPtr(fmt.Sprintf("/%s/i", regex))
}

func convertRegion(region string) string {
	if strings.Contains(strings.ToLower(region), "usgov") {
		return "US Gov"
	} else if strings.Contains(strings.ToLower(region), "china") {
		return "Ð¡hina"
	} else {
		return "Global"
	}
}

func dnsZoneRegion(region string) string {
	switch {
	case strings.HasPrefix(strings.ToLower(region), "usgov"):
		return "US Gov Zone 1"
	case strings.HasPrefix(strings.ToLower(region), "germany"):
		return "DE Zone 1"
	case strings.HasPrefix(strings.ToLower(region), "china"):
		return "Zone 1 (China)"
	default:
		return "Zone 1"
	}
}

################################################################################
# FILE: internal/resources/azure/virtual_hub.go
# RESOURCE: azure_virtual_hub
# SIZE: 4637 bytes | LINES: 119
################################################################################
package azure

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// VirtualHub is the central hub in the "hub and spoke architecture" of Azure Virtual WAN.
// It enables transitive connectivity between endpoints that may be distributed across different types of 'spokes'.
//
// More resource information here: https://docs.microsoft.com/en-us/azure/virtual-wan/virtual-wan-about
// Pricing information here: https://azure.microsoft.com/en-us/pricing/details/virtual-wan/
type VirtualHub struct {
	// Address is the unique name of the resource in the IAC language.
	Address string
	// Region is the azure region the VirtualHub is provisioned within.
	Region string
	// SKU is the VirtualHub hub type. It can be one of: Basic|Standard.
	SKU string

	// MonthlyDataProcessedGB represents a usage cost for the amount of gb of data that is processed
	// through the hub on a monthly basis. It is a float to allow users to specify values whole GBs.
	MonthlyDataProcessedGB *float64 `infracost_usage:"monthly_data_processed_gb"`
}

// CoreType returns the name of this resource type
func (v *VirtualHub) CoreType() string {
	return "VirtualHub"
}

// UsageSchema defines a list which represents the usage schema of VirtualHubUsageSchema.
func (v *VirtualHub) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_data_processed_gb", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the VirtualHub.
// It uses the `infracost_usage` struct tags to populate data into the VirtualHub.
func (v *VirtualHub) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(v, u)
}

// BuildResource builds a schema.Resource from a valid VirtualHub.
// It returns VirtualHub as a *schema.Resource with 2 cost components provided.
// These cost components are only applicable if the VirtualHub is type Standard.
// The Basic hub is provided free by azure.
// See here: https://azure.microsoft.com/en-us/pricing/details/virtual-wan/ for more information.
//
// This method is called after the resource is initialised by an iac provider.
// See providers folder for more information.
func (v *VirtualHub) BuildResource() *schema.Resource {
	if v.SKU == "Basic" {
		return &schema.Resource{
			Name:        v.Address,
			UsageSchema: v.UsageSchema(),
			NoPrice:     true,
			IsSkipped:   true,
		}
	}

	components := []*schema.CostComponent{
		v.deploymentHours(),
	}

	if v.MonthlyDataProcessedGB != nil {
		components = append(components, v.dataProcessed())
	}

	return &schema.Resource{
		Name:           v.Address,
		UsageSchema:    v.UsageSchema(),
		CostComponents: components,
	}
}

func (v VirtualHub) dataProcessed() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Data processed",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromFloat(*v.MonthlyDataProcessedGB)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(v.Region),
			Service:       strPtr("Virtual WAN"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: v.hubTypeFilter()},
				{Key: "meterName", Value: v.hubTypeDataFilter()},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	}
}

func (v VirtualHub) deploymentHours() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Deployment",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(v.Region),
			Service:       strPtr("Virtual WAN"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: v.hubTypeFilter()},
				{Key: "meterName", Value: v.hubTypeUnitFilter()},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

func (v VirtualHub) hubTypeFilter() *string {
	return strPtr(fmt.Sprintf("%s Hub", v.SKU))
}

func (v VirtualHub) hubTypeUnitFilter() *string {
	return strPtr(fmt.Sprintf("%s Hub Unit", v.SKU))
}

func (v VirtualHub) hubTypeDataFilter() *string {
	return strPtr(fmt.Sprintf("%s Hub Data Processed", v.SKU))
}

################################################################################
# FILE: internal/resources/azure/virtual_machine.go
# RESOURCE: azure_virtual_machine
# SIZE: 5830 bytes | LINES: 136
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"

	"strings"

	"github.com/shopspring/decimal"
)

type VirtualMachine struct {
	Address                    string
	Region                     string
	StorageImageReferenceOffer string
	VMSize                     string
	StorageOSDiskOSType        string
	LicenseType                string
	StorageOSDiskData          *ManagedDiskData
	OSDiskData                 *ManagedDiskData
	StoragesDiskData           []*ManagedDiskData
	MonthlyHours               *float64              `infracost_usage:"monthly_hrs"`
	StorageOSDisk              *StorageOSDiskUsage   `infracost_usage:"storage_os_disk"`
	StorageDataDisk            *StorageDataDiskUsage `infracost_usage:"storage_data_disk"`
	IsDevTest                  bool
}

type StorageOSDiskUsage struct {
	MonthlyDiskOperations *int64 `infracost_usage:"monthly_disk_operations"`
}

type StorageDataDiskUsage struct {
	MonthlyDiskOperations *int64 `infracost_usage:"monthly_disk_operations"`
}

var StorageOSDiskUsageSchema = []*schema.UsageItem{
	{ValueType: schema.Int64, DefaultValue: 0, Key: "monthly_disk_operations"},
}

var StorageDataDiskUsageSchema = []*schema.UsageItem{
	{ValueType: schema.Int64, DefaultValue: 0, Key: "monthly_disk_operations"},
}

func (r *VirtualMachine) CoreType() string {
	return "VirtualMachine"
}

func (r *VirtualMachine) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{
			Key:          "storage_os_disk",
			ValueType:    schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "storage_os_disk", Items: StorageOSDiskUsageSchema},
		},
		{
			Key:          "storage_data_disk",
			ValueType:    schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "storage_data_disk", Items: StorageDataDiskUsageSchema},
		},
	}
}

func (r *VirtualMachine) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *VirtualMachine) BuildResource() *schema.Resource {
	region := r.Region

	costComponents := []*schema.CostComponent{}
	instanceType := r.VMSize

	os := "Linux"
	if r.StorageImageReferenceOffer != "" {
		if strings.ToLower(r.StorageImageReferenceOffer) == "windowsserver" {
			os = "Windows"
		}
	}
	if strings.ToLower(r.StorageOSDiskOSType) == "windows" {
		os = "Windows"
	}

	if strings.ToLower(os) == "windows" {
		licenseType := r.LicenseType
		costComponents = append(costComponents, windowsVirtualMachineCostComponent(region, instanceType, licenseType, r.MonthlyHours, r.IsDevTest))
	} else {
		costComponents = append(costComponents, linuxVirtualMachineCostComponent(region, instanceType, r.MonthlyHours))
	}

	// TODO: is this always assuming ultrassdreservation cost?
	costComponents = append(costComponents, ultraSSDReservationCostComponent(region))

	var storageOperations *decimal.Decimal
	if r.StorageOSDisk != nil && r.StorageOSDisk.MonthlyDiskOperations != nil {
		storageOperations = decimalPtr(decimal.NewFromInt(*r.StorageOSDisk.MonthlyDiskOperations))
	}

	subResources := []*schema.Resource{}

	if r.StorageOSDiskData != nil {
		subResources = append(subResources, legacyOSDiskSubResource(region, r.StorageOSDiskData.DiskType, r.StorageOSDiskData.DiskSizeGB, r.StorageOSDiskData.DiskIOPSReadWrite, r.StorageOSDiskData.DiskMBPSReadWrite, storageOperations))
	}

	if r.StorageOSDisk != nil && r.StorageDataDisk.MonthlyDiskOperations != nil {
		storageOperations = decimalPtr(decimal.NewFromInt(*r.StorageDataDisk.MonthlyDiskOperations))
	}

	for _, s := range r.StoragesDiskData {
		subResources = append(subResources, &schema.Resource{
			Name:           "storage_data_disk",
			CostComponents: managedDiskCostComponents(region, s.DiskType, s.DiskSizeGB, s.DiskIOPSReadWrite, s.DiskMBPSReadWrite, storageOperations),
			UsageSchema:    r.UsageSchema(),
		})
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		SubResources:   subResources,
		UsageSchema:    r.UsageSchema(),
	}
}

func ultraSSDReservationCostComponent(region string) *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Ultra disk reservation (if unattached)",
		Unit:           "vCPU",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: nil,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(region),
			Service:       strPtr("Storage"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "productName", Value: strPtr("Ultra Disks")},
				{Key: "skuName", Value: strPtr("Ultra LRS")},
				{Key: "meterName", ValueRegex: regexPtr("Reservation per vCPU Provisioned$")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

func legacyOSDiskSubResource(region, diskType string, diskSizeGB, diskIOPSReadWrite, diskMBPSReadWrite int64, monthlyDiskOperations *decimal.Decimal) *schema.Resource {
	return &schema.Resource{
		Name:           "storage_os_disk",
		CostComponents: managedDiskCostComponents(region, diskType, diskSizeGB, diskIOPSReadWrite, diskMBPSReadWrite, monthlyDiskOperations),
	}
}

func osDiskSubResource(region, diskType string, diskSizeGB, diskIOPSReadWrite, diskMBPSReadWrite int64, monthlyDiskOperations *decimal.Decimal) *schema.Resource {
	return &schema.Resource{
		Name:           "os_disk",
		CostComponents: managedDiskCostComponents(region, diskType, diskSizeGB, diskIOPSReadWrite, diskMBPSReadWrite, monthlyDiskOperations),
	}
}

################################################################################
# FILE: internal/resources/azure/virtual_machine_scale_set.go
# RESOURCE: azure_virtual_machine_scale_set
# SIZE: 4388 bytes | LINES: 104
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"

	"strings"

	"github.com/shopspring/decimal"
)

type VirtualMachineScaleSet struct {
	Address                   string
	Region                    string
	SKUName                   string
	SKUCapacity               int64
	IsWindows                 bool
	IsDevTest                 bool
	LicenseType               string
	StorageProfileOSDiskData  *ManagedDiskData
	StorageProfileOSDisksData []*ManagedDiskData

	Instances              *int64                     `infracost_usage:"instances"`
	StorageProfileOSDisk   *StorageProfileOSDiskUsage `infracost_usage:"storage_profile_os_disk"`
	StorageProfileDataDisk *StorageProfileOSDiskUsage `infracost_usage:"storage_profile_data_disk"`
}

type StorageProfileOSDiskUsage struct {
	MonthlyDiskOperations *int64 `infracost_usage:"monthly_disk_operations"`
}

type StorageProfileDataDiskUsage struct {
	MonthlyDiskOperations *int64 `infracost_usage:"monthly_disk_operations"`
}

var StorageProfileOSDiskUsageSchema = []*schema.UsageItem{
	{ValueType: schema.Int64, DefaultValue: 0, Key: "monthly_disk_operations"},
}

var StorageProfileDataDiskUsageSchema = []*schema.UsageItem{
	{ValueType: schema.Int64, DefaultValue: 0, Key: "monthly_disk_operations"},
}

func (r *VirtualMachineScaleSet) CoreType() string {
	return "VirtualMachineScaleSet"
}

func (r *VirtualMachineScaleSet) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "instances", ValueType: schema.Int64, DefaultValue: 0},
		{
			Key:          "storage_profile_os_disk",
			ValueType:    schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "storage_profile_os_disk", Items: StorageProfileOSDiskUsageSchema},
		},
		{
			Key:          "storage_profile_data_disk",
			ValueType:    schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "storage_profile_data_disk", Items: StorageProfileDataDiskUsageSchema},
		},
	}
}

func (r *VirtualMachineScaleSet) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *VirtualMachineScaleSet) BuildResource() *schema.Resource {
	region := r.Region

	costComponents := []*schema.CostComponent{}
	subResources := []*schema.Resource{}

	instanceType := r.SKUName
	capacity := decimal.NewFromInt(r.SKUCapacity)

	if r.Instances != nil {
		capacity = decimal.NewFromInt(*r.Instances)
	}

	os := "Linux"
	if r.IsWindows {
		os = "Windows"
	}

	if strings.ToLower(os) == "linux" {
		costComponents = append(costComponents, linuxVirtualMachineCostComponent(region, instanceType, nil))
	}

	if strings.ToLower(os) == "windows" {
		licenseType := "Windows_Client"
		if r.LicenseType != "" {
			licenseType = r.LicenseType
		}
		costComponents = append(costComponents, windowsVirtualMachineCostComponent(region, instanceType, licenseType, nil, r.IsDevTest))
	}

	res := &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		SubResources:   subResources,
		UsageSchema:    r.UsageSchema(),
	}

	schema.MultiplyQuantities(res, capacity)

	var storageOperations *decimal.Decimal
	if r.StorageProfileOSDisk != nil && r.StorageProfileOSDisk.MonthlyDiskOperations != nil {
		storageOperations = decimalPtr(decimal.NewFromInt(*r.StorageProfileOSDisk.MonthlyDiskOperations))
	}
	if r.StorageProfileOSDiskData != nil {
		res.SubResources = append(res.SubResources, legacyOSDiskSubResource(region, r.StorageProfileOSDiskData.DiskType, r.StorageProfileOSDiskData.DiskSizeGB, r.StorageProfileOSDiskData.DiskIOPSReadWrite, r.StorageProfileOSDiskData.DiskMBPSReadWrite, storageOperations))
	}

	if r.StorageProfileDataDisk != nil && r.StorageProfileDataDisk.MonthlyDiskOperations != nil {
		storageOperations = decimalPtr(decimal.NewFromInt(*r.StorageProfileDataDisk.MonthlyDiskOperations))
	}

	for _, s := range r.StorageProfileOSDisksData {
		res.SubResources = append(res.SubResources, &schema.Resource{
			Name:           "storage_data_disk",
			CostComponents: managedDiskCostComponents(region, s.DiskType, s.DiskSizeGB, s.DiskIOPSReadWrite, s.DiskMBPSReadWrite, storageOperations),
			UsageSchema:    r.UsageSchema(),
		})
	}

	return res
}

################################################################################
# FILE: internal/resources/azure/virtual_network_peering.go
# RESOURCE: azure_virtual_network_peering
# SIZE: 4591 bytes | LINES: 126
################################################################################
package azure

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// VirtualNetworkPeering struct represents a VNET peering.
//

// Resource information: https://azure.microsoft.com/en-us/services/virtual-network/#overview
// Pricing information: https://azure.microsoft.com/en-us/pricing/details/virtual-network/
type VirtualNetworkPeering struct {
	Address           string
	SourceRegion      string
	DestinationRegion string
	SourceZone        string
	DestinationZone   string

	MonthlyDataTransferGB *float64 `infracost_usage:"monthly_data_transfer_gb"`
}

func (r *VirtualNetworkPeering) CoreType() string {
	return "VirtualNetworkPeering"
}

func (r *VirtualNetworkPeering) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_data_transfer_gb", DefaultValue: 0, ValueType: schema.Float64},
	}
}

func (r *VirtualNetworkPeering) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *VirtualNetworkPeering) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.ingressDataProcessedCostComponent(),
		r.egressDataProcessedCostComponent(),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *VirtualNetworkPeering) egressDataProcessedCostComponent() *schema.CostComponent {
	if r.DestinationRegion == r.SourceRegion {
		return &schema.CostComponent{
			Name:            "Outbound data transfer",
			Unit:            "GB",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyDataTransferGB),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr("Global"),
				Service:       strPtr("Virtual Network"),
				ProductFamily: strPtr("Networking"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "meterName", Value: strPtr("Intra-Region Egress")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
			UsageBased: true,
		}
	}

	return &schema.CostComponent{
		Name:            "Outbound data transfer",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyDataTransferGB),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("azure"),
			Region:     strPtr(r.SourceZone),
			Service:    strPtr("VPN Gateway"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "serviceFamily", ValueRegex: regexPtr("Networking")},
				{Key: "productName", ValueRegex: regexPtr("VPN Gateway Bandwidth")},
				{Key: "meterName", ValueRegex: regexPtr("Inter-Virtual Network Data Transfer Out")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	}
}

func (r *VirtualNetworkPeering) ingressDataProcessedCostComponent() *schema.CostComponent {
	if r.DestinationRegion == r.SourceRegion {
		return &schema.CostComponent{
			Name:            "Inbound data transfer",
			Unit:            "GB",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyDataTransferGB),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("azure"),
				Region:        strPtr("Global"),
				Service:       strPtr("Virtual Network"),
				ProductFamily: strPtr("Networking"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "meterName", Value: strPtr("Intra-Region Ingress")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("Consumption"),
			},
			UsageBased: true,
		}
	}

	return &schema.CostComponent{
		Name:            "Inbound data transfer",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.MonthlyDataTransferGB),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("azure"),
			Region:     strPtr(r.DestinationZone),
			Service:    strPtr("VPN Gateway"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "serviceFamily", ValueRegex: regexPtr("Networking")},
				{Key: "productName", ValueRegex: regexPtr("VPN Gateway Bandwidth")},
				{Key: "meterName", ValueRegex: regexPtr("Inter-Virtual Network Data Transfer Out")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/azure/vpn_gateway.go
# RESOURCE: azure_vpn_gateway
# SIZE: 4992 bytes | LINES: 119
################################################################################
package azure

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// VPNGateway represents a Virtual WAN VPN gateway. It can represent a
// Point-to-site gateway (P2S) or a Site-to-site (S2S) gateway.
// Both gateways have similar price components on azure: Scale Unit & Connection Unit.
// However, S2S gateway connection costs are found through VPNGatewayConnection resource.
// Whereas P2S defines a usage param which is parsed below.
//
// More resource information here: https://docs.microsoft.com/en-us/azure/virtual-wan/virtual-wan-about
// Pricing information here: https://azure.microsoft.com/en-us/pricing/details/virtual-wan/
type VPNGateway struct {
	// Address is the unique name of the resource in the IAC language.
	Address string
	// Region is the azure region the VPNGateway is provisioned within.
	Region string
	// ScaleUnits represents a unit defined to pick an aggregate throughput of a gateway in Virtual hub.
	// 1 scale unit of VPN = 500 Mbps.
	ScaleUnits int64
	// Type represents the type of WAN Vpn Gateway, it can be one of: P2S|S2S.
	Type string

	// MonthlyP2SConnectionHrs represents a usage cost for the number of connection hours that the vpn
	// gateway has been in use for. Can be a fraction to denote smaller time increments lower than a whole hour.
	// This usage cost is only applicable for point to site vpns.
	MonthlyP2SConnectionHrs *float64 `infracost_usage:"monthly_p2s_connections_hrs"`
}

func (v *VPNGateway) CoreType() string {
	return "VPNGateway"
}

// UsageSchema defines a list which represents the usage schema of VPNGateway if of type P2S.
func (v *VPNGateway) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_p2s_connections_hrs", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the VPNGateway.
// It uses the `infracost_usage` struct tags to populate data into the VPNGateway.
func (v *VPNGateway) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(v, u)
}

// BuildResource builds a schema.Resource from a valid VPNGateway. It returns different Resources
// based on the VPNGateway.Type. If type Point to Site (P2S) it will include a usage cost component
// based on the connection usage. For other cases (S2S) it will just include a single scale unit
// cost component. See VPNGatewayConnection for S2S connection costs associated with S2S gateway.
//
// This method is called after the resource is initialised by an iac provider.
// See providers folder for more information.
func (v *VPNGateway) BuildResource() *schema.Resource {
	if v.Type == "P2S" {
		return v.buildP2SResource()
	}

	return v.buildS2SResource()
}

func (v *VPNGateway) buildS2SResource() *schema.Resource {
	return &schema.Resource{
		Name:           v.Address,
		CostComponents: []*schema.CostComponent{v.scaleUnitComponent()},
	}
}

func (v *VPNGateway) buildP2SResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		v.scaleUnitComponent(),
		v.connectionUnitComponent(),
	}

	return &schema.Resource{
		Name:           v.Address,
		CostComponents: costComponents,
		UsageSchema:    v.UsageSchema(),
	}
}

func (v *VPNGateway) scaleUnitComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           fmt.Sprintf("%s scale units (500 Mbps)", v.Type),
		Unit:           "scale units",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: decimalPtr(decimal.NewFromInt(v.ScaleUnits)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(v.Region),
			Service:       strPtr("Virtual WAN"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(fmt.Sprintf("VPN %s Scale Unit", v.Type))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
	}
}

func (v *VPNGateway) connectionUnitComponent() *schema.CostComponent {
	var connections float64
	if v.MonthlyP2SConnectionHrs != nil {
		connections = *v.MonthlyP2SConnectionHrs
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("%s connections", v.Type),
		Unit:            "hours",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromFloat(connections)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(v.Region),
			Service:       strPtr("Virtual WAN"),
			ProductFamily: strPtr("Networking"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", Value: strPtr(fmt.Sprintf("VPN %s Connection Unit", v.Type))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("Consumption"),
		},
		UsageBased: true,
	}

}

################################################################################
# FILE: internal/resources/azure/vpn_gateway_connection.go
# RESOURCE: azure_vpn_gateway_connection
# SIZE: 2489 bytes | LINES: 60
################################################################################
package azure

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// VPNGatewayConnection represents a VPN Gateway connection, which is a billable component
// of a S2S VPN gateway. See VPNGateway for more information.
//
// More resource information here: https://docs.microsoft.com/en-us/azure/virtual-wan/virtual-wan-about
// Pricing information here: https://azure.microsoft.com/en-us/pricing/details/virtual-wan/
type VPNGatewayConnection struct {
	// Address is the unique name of the resource in the IAC language.
	Address string
	// Region is the azure region the VPNGatewayConnection is provisioned within.
	Region string
}

func (r *VPNGatewayConnection) CoreType() string {
	return "VPNGatewayConnection"
}

func (r *VPNGatewayConnection) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the VPNGatewayConnection.
// It uses the `infracost_usage` struct tags to populate data into the VPNGatewayConnection.
func (r *VPNGatewayConnection) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid VPNGatewayConnection.
// It returns a VPNGatewayConnection as a schema.Resource with a single cost component representing the
// connection unit. The hourly quantity is set to 1 as VPNGatewayConnection represents a single connection unit.
//
// This method is called after the resource is initialised by an iac provider.
// See providers folder for more information.
func (r *VPNGatewayConnection) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name:        r.Address,
		UsageSchema: r.UsageSchema(),
		CostComponents: []*schema.CostComponent{
			{
				Name:           "S2S Connections",
				Unit:           "hours",
				UnitMultiplier: decimal.NewFromInt(1),
				HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("azure"),
					Region:        strPtr(r.Region),
					Service:       strPtr("Virtual WAN"),
					ProductFamily: strPtr("Networking"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "skuName", Value: strPtr("VPN S2S Connection Unit")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					PurchaseOption: strPtr("Consumption"),
				},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/azure/windows_virtual_machine.go
# RESOURCE: azure_windows_virtual_machine
# SIZE: 4481 bytes | LINES: 111
################################################################################
package azure

import (
	"fmt"
	"strings"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"

	"github.com/shopspring/decimal"
)

type WindowsVirtualMachine struct {
	Address                               string
	Region                                string
	Size                                  string
	LicenseType                           string
	AdditionalCapabilitiesUltraSSDEnabled bool
	OSDiskData                            *ManagedDiskData
	MonthlyHours                          *float64     `infracost_usage:"monthly_hrs"`
	OSDisk                                *OSDiskUsage `infracost_usage:"os_disk"`
	IsDevTest                             bool
}

type OSDiskUsage struct {
	MonthlyDiskOperations *int64 `infracost_usage:"monthly_disk_operations"`
}

var OSDiskUsageSchema = []*schema.UsageItem{
	{ValueType: schema.Int64, DefaultValue: 0, Key: "monthly_disk_operations"},
}

func (r *WindowsVirtualMachine) CoreType() string {
	return "WindowsVirtualMachine"
}

func (r *WindowsVirtualMachine) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_hrs", ValueType: schema.Float64, DefaultValue: 0},
		{
			Key:          "os_disk",
			ValueType:    schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "os_disk", Items: OSDiskUsageSchema},
		},
	}
}

func (r *WindowsVirtualMachine) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *WindowsVirtualMachine) BuildResource() *schema.Resource {
	region := r.Region

	instanceType := r.Size
	licenseType := r.LicenseType

	costComponents := []*schema.CostComponent{windowsVirtualMachineCostComponent(region, instanceType, licenseType, r.MonthlyHours, r.IsDevTest)}

	if r.AdditionalCapabilitiesUltraSSDEnabled {
		costComponents = append(costComponents, ultraSSDReservationCostComponent(region))
	}

	subResources := make([]*schema.Resource, 0)

	var monthlyDiskOperations *decimal.Decimal
	if r.OSDisk != nil && r.OSDisk.MonthlyDiskOperations != nil {
		monthlyDiskOperations = decimalPtr(decimal.NewFromInt(*r.OSDisk.MonthlyDiskOperations))
	}
	if r.OSDiskData != nil {
		osDisk := osDiskSubResource(region, r.OSDiskData.DiskType, r.OSDiskData.DiskSizeGB, r.OSDiskData.DiskIOPSReadWrite, r.OSDiskData.DiskMBPSReadWrite, monthlyDiskOperations)
		if osDisk != nil {
			subResources = append(subResources, osDisk)
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		SubResources:   subResources,
		UsageSchema:    r.UsageSchema(),
	}
}

func windowsVirtualMachineCostComponent(region string, instanceType string, licenseType string, monthlyHours *float64, isDevTest bool) *schema.CostComponent {
	purchaseOption := "Consumption"
	purchaseOptionLabel := "pay as you go"

	productNameRe := "/(Series )?Windows$/i"
	if strings.HasPrefix(instanceType, "Basic_") {
		productNameRe = "/Basic Windows$/"
	} else if !strings.HasPrefix(instanceType, "Standard_") {
		instanceType = fmt.Sprintf("Standard_%s", instanceType)
	}

	if strings.ToLower(licenseType) == "windows_client" || strings.ToLower(licenseType) == "windows_server" {
		purchaseOption = "DevTestConsumption"
		purchaseOptionLabel = "hybrid benefit"
	}

	if isDevTest {
		purchaseOption = "DevTestConsumption"
		purchaseOptionLabel = "dev/test"
	}

	qty := schema.HourToMonthUnitMultiplier
	if monthlyHours != nil {
		qty = decimal.NewFromFloat(*monthlyHours)
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Instance usage (Windows, %s, %s)", purchaseOptionLabel, instanceType),
		Unit:            "hours",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(qty),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("azure"),
			Region:        strPtr(region),
			Service:       strPtr("Virtual Machines"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "skuName", ValueRegex: strPtr("/^(?!.*(Low Priority|Spot)$).*$/i")},
				{Key: "armSkuName", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", instanceType))},
				{Key: "productName", ValueRegex: strPtr(productNameRe)},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr(purchaseOption),
			Unit:           strPtr("1 Hour"),
		},
	}
}

################################################################################
# FILE: internal/resources/azure/windows_virtual_machine_scale_set.go
# RESOURCE: azure_windows_virtual_machine_scale_set
# SIZE: 2683 bytes | LINES: 66
################################################################################
package azure

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"

	"github.com/shopspring/decimal"
)

type WindowsVirtualMachineScaleSet struct {
	Address                               string
	Region                                string
	SKU                                   string
	LicenseType                           string
	AdditionalCapabilitiesUltraSSDEnabled bool
	IsDevTest                             bool
	OSDiskData                            *ManagedDiskData
	Instances                             *int64       `infracost_usage:"instances"`
	OSDisk                                *OSDiskUsage `infracost_usage:"os_disk"`
}

func (r *WindowsVirtualMachineScaleSet) CoreType() string {
	return "WindowsVirtualMachineScaleSet"
}

func (r *WindowsVirtualMachineScaleSet) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "instances", ValueType: schema.Int64, DefaultValue: 0},
		{
			Key:          "os_disk",
			ValueType:    schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "os_disk", Items: OSDiskUsageSchema},
		},
	}
}

func (r *WindowsVirtualMachineScaleSet) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *WindowsVirtualMachineScaleSet) BuildResource() *schema.Resource {
	region := r.Region

	instanceType := r.SKU
	licenseType := r.LicenseType

	costComponents := []*schema.CostComponent{windowsVirtualMachineCostComponent(region, instanceType, licenseType, nil, r.IsDevTest)}

	if r.AdditionalCapabilitiesUltraSSDEnabled {
		costComponents = append(costComponents, ultraSSDReservationCostComponent(region))
	}

	subResources := make([]*schema.Resource, 0)

	var monthlyDiskOperations *decimal.Decimal
	if r.OSDisk != nil && r.OSDisk.MonthlyDiskOperations != nil {
		monthlyDiskOperations = decimalPtr(decimal.NewFromInt(*r.OSDisk.MonthlyDiskOperations))
	}

	if r.OSDiskData != nil {
		osDisk := osDiskSubResource(region, r.OSDiskData.DiskType, r.OSDiskData.DiskSizeGB, r.OSDiskData.DiskIOPSReadWrite, r.OSDiskData.DiskMBPSReadWrite, monthlyDiskOperations)
		if osDisk != nil {
			subResources = append(subResources, osDisk)
		}
	}

	instanceCount := decimal.NewFromInt(*r.Instances)
	if r.Instances != nil {
		instanceCount = decimal.NewFromInt(*r.Instances)
	}

	res := &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		SubResources:   subResources,
		UsageSchema:    r.UsageSchema(),
	}

	schema.MultiplyQuantities(res, instanceCount)

	return res
}

################################################################################
#                                                                              #
#                              GOOGLE RESOURCES                                  #
#                                                                              #
################################################################################

################################################################################
# FILE: internal/resources/google/artifact_registry_repository.go
# RESOURCE: google_artifact_registry_repository
# SIZE: 11052 bytes | LINES: 280
################################################################################
package google

import (
	"fmt"
	"regexp"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
)

var (
	artifactRegSvcName = strPtr("Artifact Registry")

	continentDefault      = "Intercontinental (Excl Oceania)"
	continentNorthAmerica = "North America"
	continentSouthAmerica = "South America"
	continentEurope       = "Europe"
	// GCP misspells AsiaPacific without the i. The below is not a typo!
	continentApac    = "AsiaPacfic"
	continentOceania = "Oceania"

	artifactGlobalEgressContinents = map[string]struct{}{
		continentOceania:      {},
		continentSouthAmerica: {},
	}
	artifactRegMultiRegionNames = map[string]struct{}{
		"us":     {},
		"europe": {},
		"asia":   {},
	}

	regionSep = regexp.MustCompile(`[_\-]`)
)

// ArtifactRegistryRepository struct represents a GCP artifact Registry. Artifact registry is essentially
// a next generation version of google's container registry. It allows users to store container images and language
// packages in the GCP.
//
// Pricing for Artifact Registry is based on storage amounts and data transfer.
//
// Resource information: https://cloud.google.com/artifact-registry
// Pricing information: https://cloud.google.com/artifact-registry/pricing
type ArtifactRegistryRepository struct {
	Address   string
	Region    string
	Continent string

	// StorageGB represents a usage cost that defines the amount of gb the artifact registry uses on a per monthly basis.
	StorageGB *float64 `infracost_usage:"storage_gb"`
	// MonthlyEgressDataTransferGB represents a complex usage cost that defines data transfer to different regions in the
	// google cloud infra. This does not include outbound internet egress (e.g. downloading artifact data to a local machine).
	MonthlyEgressDataTransferGB *RegionsUsage `infracost_usage:"monthly_egress_data_transfer_gb"`
}

// artifactRegistryRepositoryUsageSchema defines a list which represents the usage schema of ArtifactRegistryRepository.
func (r *ArtifactRegistryRepository) CoreType() string {
	return "ArtifactRegistryRepository"
}

func (r *ArtifactRegistryRepository) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "storage_gb", DefaultValue: 0, ValueType: schema.Float64},
		{
			Key: "monthly_egress_data_transfer_gb",
			DefaultValue: &usage.ResourceUsage{
				Name:  "monthly_egress_data_transfer_gb",
				Items: RegionUsageSchema,
			},
			ValueType: schema.SubResourceUsage,
		},
	}
}

// PopulateUsage parses the u schema.UsageData into the ArtifactRegistryRepository.
// It uses the `infracost_usage` struct tags to populate data into the ArtifactRegistryRepository.
func (r *ArtifactRegistryRepository) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid ArtifactRegistryRepository struct. It returns ArtifactRegistryRepository
// as a schema.Resource with two main cost components: storage costs & egress costs.
//
// Storage costs:
//
//	priced at $0.10 a month after artifact registry usage is > 0.5 GB. We ignore the free tier as there
//	is no way to currently tell if other artifact registry resources have gone beyond this free usage tier.
//
// Network costs:
//  1. free within the same region
//  2. free from multi-region to a region within the same continent, e.g. europe -> europe-west1
//  3. $0.01 when between different regions in North America continent
//  4. $0.02 when between different regions in Europe continent
//  5. $0.05 when between different regions in AsiaPacific continent
//  6. $0.15 when between any region and Oceania continent
//  7. $0.08 for all other intercontinental data transfer
//
// This method is called after the resource is initialised by an IaC provider. See providers folder for more information.
func (r *ArtifactRegistryRepository) BuildResource() *schema.Resource {
	r.Continent = continentName(r.Region)

	costComponents := []*schema.CostComponent{
		r.storageCostComponent(),
	}

	if r.MonthlyEgressDataTransferGB != nil {
		costComponents = append(costComponents, r.internalEgressComponents()...)
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *ArtifactRegistryRepository) internalEgressComponents() []*schema.CostComponent {
	filters := r.toEgressFilters()
	components := make([]*schema.CostComponent, 0, len(filters))
	for _, v := range filters {
		components = append(components, &schema.CostComponent{
			Name:            v.name,
			Unit:            "GB",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: v.value,
			ProductFilter: &schema.ProductFilter{
				VendorName:    vendorName,
				Region:        v.region,
				Service:       artifactRegSvcName,
				ProductFamily: strPtr("Network"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "description", Value: v.desc},
					{Key: "resourceGroup", Value: strPtr("InterregionEgress")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr("OnDemand"),
			},
			UsageBased: true,
		})
	}

	return components
}

func (r *ArtifactRegistryRepository) storageCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: floatPtrToDecimalPtr(r.StorageGB),
		ProductFilter: &schema.ProductFilter{
			VendorName:    vendorName,
			Service:       artifactRegSvcName,
			ProductFamily: strPtr("ApplicationServices"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", Value: strPtr("Artifact Registry Storage")},
				{Key: "resourceGroup", Value: strPtr("Storage")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("OnDemand"),
			// we ignore the free tier pricing and start at the paid pricing which is at 0.5.
			StartUsageAmount: strPtr("0.5"),
		},
		UsageBased: true,
	}
}

type artifactRegistryEgressFilters struct {
	name   string
	desc   *string
	region *string
	value  *decimal.Decimal
}

// toEgressFilters returns ArtifactRegistryRepository.MonthlyEgressDataTransferGB as a slice of filters to be used to build
// a set of cost components. One artifactRegistryEgressFilters is used by one schema.CostComponent.
//
// It uses reflection to loop over the ArtifactRegistryRepository.MonthlyEgressDataTransferGB, checking if a value has been
// given at the given region. If it has we also make sure that the region usage isn't free. See isEgressFree method for more
// details. toEgressFilters also bunches costs into continent to continent filters, as this is how they are displayed on
// the pricing page. This means that if the user specifies egress to two regions in the same continent, e.g. europe-west1 & europe-west2
// from europe-north1. Then these will be aggregated under a "Europe to Europe" artifactRegistryEgressFilters and in turn
// a schema.CostComponent.
func (r *ArtifactRegistryRepository) toEgressFilters() []artifactRegistryEgressFilters {
	if r.MonthlyEgressDataTransferGB == nil {
		return nil
	}

	values := r.MonthlyEgressDataTransferGB.Values()

	data := make([]artifactRegistryEgressFilters, 0, len(values))
	transferMap := make(map[string]int)

	for _, region := range values {
		if region.Value == 0 {
			continue
		}

		if r.isEgressFree(region.Key) {
			continue
		}

		continent := continentName(region.Key)
		value := decimal.NewFromFloat(region.Value)

		// check if the user has specified multiple regions that are based in the same continent.
		// We want to bunch these cost components into a single value output.
		name := r.egressComponentName(continent)
		if x, ok := transferMap[name]; ok {
			value = data[x].value.Add(value)
			data[x].value = &value
			continue
		}

		data = append(data, artifactRegistryEgressFilters{
			name:   name,
			desc:   r.egressDescriptionFilter(continent),
			region: r.egressRegionFilter(continent),
			value:  &value,
		})
		transferMap[name] = len(data) - 1
	}

	return data
}

func (r *ArtifactRegistryRepository) isEgressFree(region string) bool {
	// data moving within the same region is free
	if r.Region == region {
		return true
	}

	// data moving from multi-region artifact repository to a region located in the same continent as the multi-region
	// artifact repository is free.
	if _, ok := artifactRegMultiRegionNames[r.Region]; ok {
		p := regionSep.Split(region, -1)

		if p[0] == r.Region {
			return true
		}
	}

	return false
}

func (r *ArtifactRegistryRepository) egressDescriptionFilter(continent string) *string {
	if continent == continentOceania {
		return strPtr("Artifact Registry Network Inter Region Egress Intercontinental to/from Oceania")
	}

	if r.Continent == continentSouthAmerica || continent == continentSouthAmerica {
		return strPtr("Artifact Registry Network Inter Region Egress Intercontinental (Excl Oceania)")
	}

	if r.Continent == continent {
		return strPtr(fmt.Sprintf("Artifact Registry Network Inter Region Egress %s to %s", r.Continent, continent))
	}

	return strPtr("Artifact Registry Network Inter Region Egress Intercontinental (Excl Oceania)")
}

func (r *ArtifactRegistryRepository) egressComponentName(continent string) string {
	if continent == continentOceania || r.Continent == continentOceania {
		return "Data egress from/to Oceania"
	}

	if r.Continent == continentSouthAmerica || continent == continentSouthAmerica {
		return "Intercontinental (Excl Oceania)"
	}

	// replace the gcp continent naming with the correctly spelled continent
	// for the cli output.
	from := r.Continent
	if from == continentApac {
		from = "AsiaPacific"
	}

	to := continent
	if to == continentApac {
		to = "AsiaPacific"
	}

	if continent == r.Continent {
		return fmt.Sprintf("Data egress %s to %s", from, to)
	}

	return "Intercontinental (Excl Oceania)"
}

func (r *ArtifactRegistryRepository) egressRegionFilter(continent string) *string {
	if _, ok := artifactGlobalEgressContinents[r.Continent]; ok {
		return strPtr("global")
	}

	if _, ok := artifactGlobalEgressContinents[continent]; ok {
		return strPtr("global")
	}

	if r.Continent != continent {
		return strPtr("global")
	}

	return strPtr(r.Region)
}

func continentName(region string) string {
	p := regionSep.Split(region, -1)
	if len(p) == 0 {
		return continentNorthAmerica
	}

	switch p[0] {
	case "us", "northamerica":
		return continentNorthAmerica
	case "europe":
		return continentEurope
	case "asia":
		return continentApac
	case "southamerica":
		return continentSouthAmerica
	case "australia":
		return continentOceania
	}

	return continentDefault
}

################################################################################
# FILE: internal/resources/google/bigquery_dataset.go
# RESOURCE: google_bigquery_dataset
# SIZE: 1679 bytes | LINES: 54
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"

	"github.com/shopspring/decimal"
)

type BigQueryDataset struct {
	Address          string
	Region           string
	MonthlyQueriesTB *float64 `infracost_usage:"monthly_queries_tb"`
}

func (r *BigQueryDataset) CoreType() string {
	return "BigQueryDataset"
}

func (r *BigQueryDataset) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_queries_tb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *BigQueryDataset) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *BigQueryDataset) BuildResource() *schema.Resource {
	var queriesTB *decimal.Decimal
	if r.MonthlyQueriesTB != nil {
		queriesTB = decimalPtr(decimal.NewFromFloat(*r.MonthlyQueriesTB))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Queries (on-demand)",
				Unit:            "TB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: queriesTB,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr(r.Region),
					Service:       strPtr("BigQuery"),
					ProductFamily: strPtr("ApplicationServices"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", Value: strPtr(fmt.Sprintf("Analysis (%s)", r.Region))},
					},
				},
				PriceFilter: &schema.PriceFilter{
					StartUsageAmount: strPtr("1"),
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/google/bigquery_table.go
# RESOURCE: google_bigquery_table
# SIZE: 7012 bytes | LINES: 194
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type BigQueryTable struct {
	Address                   string
	Region                    string
	MonthlyStreamingInsertsMB *float64 `infracost_usage:"monthly_streaming_inserts_mb"`
	MonthlyStorageWriteAPIGB  *float64 `infracost_usage:"monthly_storage_write_api_gb"`
	MonthlyStorageReadAPITB   *float64 `infracost_usage:"monthly_storage_read_api_tb"`
	MonthlyActiveStorageGB    *float64 `infracost_usage:"monthly_active_storage_gb"`
	MonthlyLongTermStorageGB  *float64 `infracost_usage:"monthly_long_term_storage_gb"`
}

func (r *BigQueryTable) CoreType() string {
	return "BigQueryTable"
}

func (r *BigQueryTable) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_streaming_inserts_mb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_storage_write_api_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_storage_read_api_tb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_active_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_long_term_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *BigQueryTable) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *BigQueryTable) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.activeStorageCostComponent(),
		r.longTermStorageCostComponent(),
		r.streamingInsertsCostComponent(),
	}

	storageWriteAPICostComponent := r.storageWriteAPICostComponent()
	if storageWriteAPICostComponent != nil {
		costComponents = append(costComponents, storageWriteAPICostComponent)
	}

	storageReadAPICostComponent := r.storageReadAPICostComponent()
	if storageReadAPICostComponent != nil {
		costComponents = append(costComponents, storageReadAPICostComponent)
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *BigQueryTable) activeStorageCostComponent() *schema.CostComponent {
	var activeStorageGB *decimal.Decimal
	if r.MonthlyActiveStorageGB != nil {
		activeStorageGB = decimalPtr(decimal.NewFromFloat(*r.MonthlyActiveStorageGB))
	}

	return &schema.CostComponent{
		Name:            "Active storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: activeStorageGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(r.Region),
			Service:       strPtr("BigQuery"),
			ProductFamily: strPtr("ApplicationServices"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", Value: strPtr(fmt.Sprintf("Active Logical Storage (%s)", r.Region))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("10"),
		},
		UsageBased: true,
	}
}

func (r *BigQueryTable) longTermStorageCostComponent() *schema.CostComponent {
	var longTermStorageGB *decimal.Decimal
	if r.MonthlyLongTermStorageGB != nil {
		longTermStorageGB = decimalPtr(decimal.NewFromFloat(*r.MonthlyLongTermStorageGB))
	}

	return &schema.CostComponent{
		Name:            "Long-term storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: longTermStorageGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(r.Region),
			Service:       strPtr("BigQuery"),
			ProductFamily: strPtr("ApplicationServices"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", Value: strPtr(fmt.Sprintf("Long Term Logical Storage (%s)", r.Region))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("10"),
		},
		UsageBased: true,
	}
}

func (r *BigQueryTable) streamingInsertsCostComponent() *schema.CostComponent {
	var streamingInsertsMB *decimal.Decimal
	if r.MonthlyStreamingInsertsMB != nil {
		streamingInsertsMB = decimalPtr(decimal.NewFromFloat(*r.MonthlyStreamingInsertsMB))
	}

	return &schema.CostComponent{
		Name:            "Streaming inserts",
		Unit:            "MB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: streamingInsertsMB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(r.Region),
			Service:       strPtr("BigQuery"),
			ProductFamily: strPtr("ApplicationServices"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", Value: strPtr(fmt.Sprintf("Streaming Insert (%s)", r.Region))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}
}

func (r *BigQueryTable) storageWriteAPICostComponent() *schema.CostComponent {
	var storageWriteAPIGB *decimal.Decimal
	if r.MonthlyStorageWriteAPIGB != nil {
		storageWriteAPIGB = decimalPtr(decimal.NewFromFloat(*r.MonthlyStorageWriteAPIGB))
	}

	region := r.mapRegion()
	if region == "" {
		return nil
	}

	return &schema.CostComponent{
		Name:            "Storage write API",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: storageWriteAPIGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(region),
			Service:       strPtr("BigQuery Storage API"),
			ProductFamily: strPtr("ApplicationServices"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", Value: strPtr(fmt.Sprintf("BigQuery Storage API - Write (%s)", region))},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("2048"),
		},
		UsageBased: true,
	}
}

func (r *BigQueryTable) storageReadAPICostComponent() *schema.CostComponent {
	var storageReadPITB *decimal.Decimal
	if r.MonthlyStorageReadAPITB != nil {
		storageReadPITB = decimalPtr(decimal.NewFromFloat(*r.MonthlyStorageReadAPITB))
	}

	region := r.mapRegion()
	if region == "" {
		return nil
	}

	return &schema.CostComponent{
		Name:            "Storage read API",
		Unit:            "TB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: storageReadPITB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(region),
			Service:       strPtr("BigQuery Storage API"),
			ProductFamily: strPtr("ApplicationServices"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", Value: strPtr("BigQuery Storage API - Read")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("0"),
		},
		UsageBased: true,
	}
}

func (r *BigQueryTable) mapRegion() string {
	if strings.HasPrefix(strings.ToLower(r.Region), "us") {
		return "us"
	}
	if strings.HasPrefix(strings.ToLower(r.Region), "europe") {
		return "europe"
	}

	return ""
}

################################################################################
# FILE: internal/resources/google/cloud_run_v2_job.go
# RESOURCE: google_cloud_run_v2_job
# SIZE: 3553 bytes | LINES: 92
################################################################################
package google

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// CloudRunV2Job represents a resource that references a container image which is run to completion.
type CloudRunV2Job struct {
	Address              string
	Region               string
	CpuLimit             int64
	MemoryLimit          int64
	TaskCount            int64
	MonthlyJobExecutions *int64   `infracost_usage:"monthly_job_executions"`
	AvgTaskExecutionMins *float64 `infracost_usage:"average_task_execution_mins"`
}

// CoreType returns the name of this resource type
func (r *CloudRunV2Job) CoreType() string {
	return "CloudRunV2Job"
}

// UsageSchema defines a list which represents the usage schema of CloudRunV2Job.
func (r *CloudRunV2Job) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_job_executions", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "average_task_execution_mins", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *CloudRunV2Job) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *CloudRunV2Job) BuildResource() *schema.Resource {
	regionTier := GetRegionTier(r.Region)
	cpuName := "CPU allocation time"
	memoryName := "Memory allocation time"
	if regionTier == "Tier 2" {
		cpuName = "CPU allocation time (tier 2)"
		memoryName = "Memory allocation time (tier 2)"
	}

	costComponents := []*schema.CostComponent{
		{
			Name:            cpuName,
			Unit:            "vCPU-seconds",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: r.calculateCpuSeconds(),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("gcp"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cloud Run"),
				ProductFamily: strPtr("ApplicationServices"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "description", Value: strPtr(fmt.Sprintf("Jobs CPU in %s", r.Region))},
				},
			},
		},
		{
			Name:            memoryName,
			Unit:            "GiB-seconds",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: r.calculateGBSeconds(),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("gcp"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cloud Run"),
				ProductFamily: strPtr("ApplicationServices"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "description", Value: strPtr(fmt.Sprintf("Jobs Memory in %s", r.Region))},
				},
			},
		},
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *CloudRunV2Job) calculateCpuSeconds() *decimal.Decimal {
	if r.AvgTaskExecutionMins == nil || r.MonthlyJobExecutions == nil {
		return nil
	}

	seconds := decimal.NewFromFloat(*r.AvgTaskExecutionMins * 60)
	return decimalPtr(decimal.NewFromInt(*r.MonthlyJobExecutions).Mul(decimal.NewFromInt(r.TaskCount)).Mul(seconds).Mul(decimal.NewFromInt(r.CpuLimit)))
}

func (r *CloudRunV2Job) calculateGBSeconds() *decimal.Decimal {
	if r.AvgTaskExecutionMins == nil || r.MonthlyJobExecutions == nil {
		return nil
	}

	seconds := decimal.NewFromFloat(*r.AvgTaskExecutionMins * 60)
	gb := decimal.NewFromInt(r.MemoryLimit).Div(decimal.NewFromInt(1024 * 1024 * 1024))
	return decimalPtr(decimal.NewFromInt(*r.MonthlyJobExecutions).Mul(decimal.NewFromInt(r.TaskCount)).Mul(seconds).Mul(gb))
}

################################################################################
# FILE: internal/resources/google/cloud_run_v2_service.go
# RESOURCE: google_cloud_run_v2_service
# SIZE: 7699 bytes | LINES: 180
################################################################################
package google

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// CloudRunService acts as a top-level container that manages a set of configurations and revision
// templates which implement a network service. Service exists to provide a singular abstraction which can
// be access controlled, reasoned about, and which encapsulates software lifecycle decisions such as rollout
// policy and team resource ownership.
//
// Resource information: https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/cloud_run_v2_service/
type CloudRunService struct {
	Address                       string
	Region                        string
	CpuLimit                      int64
	IsThrottlingEnabled           bool
	MemoryLimit                   int64
	MinInstanceCount              float64
	MonthlyRequests               *int64 `infracost_usage:"monthly_requests"`
	AverageRequestDurationMs      *int64 `infracost_usage:"average_request_duration_ms"`
	ConcurrentRequestsPerInstance *int64 `infracost_usage:"concurrent_requests_per_instance"`
	InstanceHrs                   *int64 `infracost_usage:"instance_hrs"`
}

func (r *CloudRunService) CoreType() string {
	return "CloudRunService"
}

func (r *CloudRunService) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_requests", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "average_request_duration_ms", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "concurrent_requests_per_instance", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "instance_hrs", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *CloudRunService) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *CloudRunService) BuildResource() *schema.Resource {
	regionTier := GetRegionTier(r.Region)
	cpuName := "CPU allocation Time"
	cpuDesc := "Services CPU (Instance-based billing) in " + r.Region
	memoryName := "Memory allocation time"
	memoryDesc := "Services Memory (Instance-based billing) in " + r.Region

	if regionTier == "Tier 2" {
		cpuName = "CPU allocation time (tier 2)"
		cpuDesc = "Services CPU Tier 2  (Request-based billing)"
		memoryName = "Memory allocation time (tier 2)"
		memoryDesc = "Services Memory Tier 2 (Request-based billing)"
	}

	var costComponents []*schema.CostComponent
	if r.IsThrottlingEnabled {
		costComponents = r.throttlingEnabledCostComponents(cpuName, cpuDesc, memoryName, memoryDesc)
	} else {
		costComponents = r.throttlingDisabledCostComponents(cpuName, memoryName)
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

func (r *CloudRunService) throttlingEnabledCostComponents(cpuName, cpuDesc, memoryName, memoryDesc string) []*schema.CostComponent {
	var requests *decimal.Decimal
	if r.MonthlyRequests != nil {
		requests = decimalPtr(decimal.NewFromInt(*r.MonthlyRequests))
	}

	return []*schema.CostComponent{
		{
			Name:            cpuName,
			Unit:            "vCPU-seconds",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: r.calculateCpuSeconds(),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("gcp"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cloud Run"),
				ProductFamily: strPtr("ApplicationServices"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "description", Value: strPtr(cpuDesc)},
				},
			},
		},
		{
			Name:            memoryName,
			Unit:            "GiB-seconds",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: r.calculateGBSeconds(),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("gcp"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cloud Run"),
				ProductFamily: strPtr("ApplicationServices"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "description", Value: strPtr(memoryDesc)},
				},
			},
		},
		{
			Name:            "Number of requests",
			Unit:            "requests",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: requests,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("gcp"),
				Region:        strPtr("global"),
				Service:       strPtr("Cloud Run"),
				ProductFamily: strPtr("ApplicationServices"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "description", Value: strPtr("Requests")},
				},
			},
			PriceFilter: &schema.PriceFilter{
				StartUsageAmount: strPtr("2000000"),
			},
		},
	}
}
func (r *CloudRunService) throttlingDisabledCostComponents(cpuName, memoryName string) []*schema.CostComponent {
	return []*schema.CostComponent{
		{
			Name:            cpuName,
			Unit:            "vCPU-seconds",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: r.calculateCpuSeconds(),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("gcp"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cloud Run"),
				ProductFamily: strPtr("ApplicationServices"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "description", Value: strPtr(fmt.Sprintf("Services CPU (Instance-based billing) in %s", r.Region))},
				},
			},
		},
		{
			Name:            memoryName,
			Unit:            "GiB-seconds",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: r.calculateGBSeconds(),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("gcp"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cloud Run"),
				ProductFamily: strPtr("ApplicationServices"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "description", Value: strPtr(fmt.Sprintf("Services Memory (Instance-based billing) in %s", r.Region))},
				},
			},
		},
	}
}

func (r *CloudRunService) calculateCpuSeconds() *decimal.Decimal {
	if r.IsThrottlingEnabled {
		if r.AverageRequestDurationMs == nil || r.MonthlyRequests == nil || r.ConcurrentRequestsPerInstance == nil {
			return nil
		}

		requestDurationInSeconds := decimal.NewFromInt(*r.AverageRequestDurationMs).Div(decimal.NewFromInt(1000))
		return decimalPtr(decimal.NewFromInt(*r.MonthlyRequests).Mul(requestDurationInSeconds).Div(decimal.NewFromInt(*r.ConcurrentRequestsPerInstance)).Mul(decimal.NewFromInt(r.CpuLimit)))
	}

	if r.InstanceHrs != nil && *r.InstanceHrs > 0 {
		return decimalPtr(decimal.NewFromInt(*r.InstanceHrs * 60 * 60).Mul(decimal.NewFromInt(r.CpuLimit)).Mul(decimal.NewFromFloat(r.MinInstanceCount)))
	}

	return decimalPtr(decimal.NewFromFloat(r.MinInstanceCount * (730 * 60 * 60)).Mul(decimal.NewFromInt(r.CpuLimit)))
}

func (r *CloudRunService) calculateGBSeconds() *decimal.Decimal {
	gb := decimal.NewFromInt(r.MemoryLimit).Div(decimal.NewFromInt(1024 * 1024 * 1024))
	if r.IsThrottlingEnabled {
		if r.AverageRequestDurationMs == nil || r.MonthlyRequests == nil || r.ConcurrentRequestsPerInstance == nil {
			return nil
		}

		requestDurationInSeconds := decimal.NewFromInt(*r.AverageRequestDurationMs).Div(decimal.NewFromInt(1000))
		return decimalPtr(decimal.NewFromInt(*r.MonthlyRequests).Mul(requestDurationInSeconds).Div(decimal.NewFromInt(*r.ConcurrentRequestsPerInstance)).Mul(gb))
	}

	if r.InstanceHrs != nil && *r.InstanceHrs > 0 {
		return decimalPtr(decimal.NewFromInt(*r.InstanceHrs * 60 * 60).Mul(gb).Mul(decimal.NewFromFloat(r.MinInstanceCount)))
	}

	return decimalPtr(decimal.NewFromFloat(r.MinInstanceCount * (730 * 60 * 60)).Mul(gb))
}

################################################################################
# FILE: internal/resources/google/cloudfunctions_function.go
# RESOURCE: google_cloudfunctions_function
# SIZE: 5648 bytes | LINES: 142
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type CloudFunctionsFunction struct {
	Address                    string
	Region                     string
	AvailableMemoryMB          *int64
	RequestDurationMs          *int64   `infracost_usage:"request_duration_ms"`
	MonthlyFunctionInvocations *int64   `infracost_usage:"monthly_function_invocations"`
	MonthlyOutboundDataGB      *float64 `infracost_usage:"monthly_outbound_data_gb"`
}

func (r *CloudFunctionsFunction) CoreType() string {
	return "CloudFunctionsFunction"
}

func (r *CloudFunctionsFunction) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "request_duration_ms", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_function_invocations", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_outbound_data_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *CloudFunctionsFunction) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *CloudFunctionsFunction) BuildResource() *schema.Resource {
	memorySize := decimal.NewFromInt(256)
	if r.AvailableMemoryMB != nil {
		memorySize = decimal.NewFromInt(*r.AvailableMemoryMB)
	}

	var cpuMapping = map[int]decimal.Decimal{
		128:  decimal.NewFromInt(200),
		256:  decimal.NewFromInt(400),
		512:  decimal.NewFromInt(800),
		1024: decimal.NewFromInt(1400),
		2048: decimal.NewFromInt(2400),
		4096: decimal.NewFromInt(4800),
	}

	cpuSize := cpuMapping[int(memorySize.IntPart())]

	requestDuration := decimal.NewFromInt(100)
	if r.RequestDurationMs != nil {

		requestDuration = decimal.NewFromInt(*r.RequestDurationMs).Div(decimal.NewFromInt(100)).Ceil().Mul(decimal.NewFromFloat(100))
	}

	var invocations, monthlyCPUUsage, monthlyMemoryUsage *decimal.Decimal
	if r.MonthlyFunctionInvocations != nil {
		invocations = decimalPtr(decimal.NewFromInt(*r.MonthlyFunctionInvocations))
		monthlyCPUUsage = decimalPtr(r.calculateGHzSeconds(cpuSize, requestDuration, *invocations))
		monthlyMemoryUsage = decimalPtr(r.calculateGBSeconds(memorySize, requestDuration, *invocations))
	}

	var networkEgress *decimal.Decimal
	if r.MonthlyOutboundDataGB != nil {
		networkEgress = decimalPtr(decimal.NewFromFloat(*r.MonthlyOutboundDataGB))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "CPU",
				Unit:            "GHz-seconds",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: monthlyCPUUsage,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr(r.Region),
					Service:       strPtr("Cloud Run Functions"),
					ProductFamily: strPtr("ApplicationServices"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", ValueRegex: regexPtr("\\(1st Gen\\) CPU")},
					},
				},
				UsageBased: true,
			},
			{
				Name:            "Memory",
				Unit:            "GB-seconds",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: monthlyMemoryUsage,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr(r.Region),
					Service:       strPtr("Cloud Run Functions"),
					ProductFamily: strPtr("ApplicationServices"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", ValueRegex: regexPtr("\\(1st Gen\\) Memory")},
					},
				},
				UsageBased: true,
			},
			{
				Name:            "Invocations",
				Unit:            "invocations",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: invocations,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr("global"),
					Service:       strPtr("Cloud Run Functions"),
					ProductFamily: strPtr("ApplicationServices"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", ValueRegex: regexPtr("\\(1st Gen\\) Invocations")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					StartUsageAmount: strPtr("2000000"),
				},
				UsageBased: true,
			},
			{
				Name:            "Outbound data transfer",
				Unit:            "GB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: networkEgress,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr(r.Region),
					Service:       strPtr("Cloud Run Functions"),
					ProductFamily: strPtr("ApplicationServices"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", ValueRegex: regexPtr("\\(1st Gen\\) Network Data Transfer Out")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					StartUsageAmount: strPtr("5"),
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

func (r *CloudFunctionsFunction) calculateGBSeconds(memorySize decimal.Decimal, averageRequestDuration decimal.Decimal, monthlyRequests decimal.Decimal) decimal.Decimal {
	gb := memorySize.Div(decimal.NewFromInt(1024))
	seconds := averageRequestDuration.Div(decimal.NewFromInt(1000))
	return monthlyRequests.Mul(gb).Mul(seconds)
}

func (r *CloudFunctionsFunction) calculateGHzSeconds(memorySize decimal.Decimal, averageRequestDuration decimal.Decimal, monthlyRequests decimal.Decimal) decimal.Decimal {
	gb := memorySize.Div(decimal.NewFromInt(1000))
	seconds := averageRequestDuration.Div(decimal.NewFromInt(1000))
	return monthlyRequests.Mul(gb).Mul(seconds)
}

################################################################################
# FILE: internal/resources/google/compute_address.go
# RESOURCE: google_compute_address
# SIZE: 3664 bytes | LINES: 109
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"strings"

	"github.com/shopspring/decimal"
)

type ComputeAddress struct {
	Address                string
	Region                 string
	AddressType            string
	Purpose                string
	InstancePurchaseOption string
}

func (r *ComputeAddress) CoreType() string {
	return "ComputeAddress"
}

func (r *ComputeAddress) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *ComputeAddress) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ComputeAddress) BuildResource() *schema.Resource {
	addressType := r.AddressType
	isFreePurpose := r.Purpose != "" && strings.ToLower(r.Purpose) != "gce_endpoint"

	if strings.ToLower(addressType) == "internal" || isFreePurpose {
		return &schema.Resource{
			Name:        r.Address,
			NoPrice:     true,
			IsSkipped:   true,
			UsageSchema: r.UsageSchema(),
		}
	}

	costComponents := []*schema.CostComponent{}

	switch r.InstancePurchaseOption {
	case "on_demand":
		costComponents = append(costComponents, r.standardVMComputeAddress())
	case "preemptible":
		costComponents = append(costComponents, r.preemptibleVMComputeAddress())
	default:
		costComponents = append(costComponents, r.unusedVMComputeAddress())
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *ComputeAddress) standardVMComputeAddress() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "IP address (standard VM)",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr("global"),
			Service:       strPtr("Compute Engine"),
			ProductFamily: strPtr("Network"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", Value: strPtr("External IP Charge on a Standard VM")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("696"),
		},
	}
}

func (r *ComputeAddress) preemptibleVMComputeAddress() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "IP address (preemptible VM)",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr("global"),
			Service:       strPtr("Compute Engine"),
			ProductFamily: strPtr("Network"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", Value: strPtr("External IP Charge on a Spot Preemptible VM")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			EndUsageAmount: strPtr(""),
		},
	}
}

func (r *ComputeAddress) unusedVMComputeAddress() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "IP address (unused)",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Compute Engine"),
			ProductFamily: strPtr("Network"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: regexPtr("^Static Ip Charge.*")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			EndUsageAmount: strPtr(""),
		},
	}
}

################################################################################
# FILE: internal/resources/google/compute_cost_component_helpers.go
# RESOURCE: google_compute_cost_component_helpers
# SIZE: 16548 bytes | LINES: 412
################################################################################
package google

import (
	"errors"
	"fmt"
	"math"
	"regexp"
	"strconv"
	"strings"

	"github.com/shopspring/decimal"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/schema"
)

// ComputeGuestAccelerator defines Guest Accelerator setup for Compute resources.
type ComputeGuestAccelerator struct {
	Type  string
	Count int64
}

// ContainerNodeConfig defines Node configuration for Container resources.
type ContainerNodeConfig struct {
	MachineType       string
	PurchaseOption    string
	DiskType          string
	DiskSize          float64
	LocalSSDCount     int64
	GuestAccelerators []*ComputeGuestAccelerator
}

/*
For the values initialized in the struct below, please refer to the

	sustained-use-discounts section of the GCP Documentation.

size_SUD is set to 4 as the Usage level (% of month) is 4

	to make sure we don't overshoot the array
*/
const sudRateSize = 4

type sudRates struct {
	thresholds [sudRateSize]float64
	rates      [sudRateSize]float64
}

var sudRate20 = sudRates{
	thresholds: [sudRateSize]float64{0.25, 0.50, 0.75, 1.0},
	rates:      [sudRateSize]float64{1.0, 0.8678, 0.733, 0.6},
}

var sudRate30 = sudRates{
	thresholds: [sudRateSize]float64{0.25, 0.50, 0.75, 1.0},
	rates:      [sudRateSize]float64{1.0, 0.80, 0.60, 0.40},
}

// computeCostComponent returns a cost component for Compute instance usage.
func computeCostComponents(region, machineType string, purchaseOption string, instanceCount int64, monthlyHours *float64) ([]*schema.CostComponent, error) {
	if strings.HasPrefix(strings.ToLower(machineType), "e2-custom") {
		return nil, errors.New("Infracost currently does not support E2 custom instances")
	}

	sustainedUseDiscount := 0.0
	fixPurchaseOption := ""
	hours, _ := schema.HourToMonthUnitMultiplier.Float64()

	if monthlyHours != nil {
		// Assume 730 hours(max) if monthly_hrs is not set
		if *monthlyHours == 0 {
			*monthlyHours = 730.0
		}
		hours = *monthlyHours
	}

	if strings.ToLower(purchaseOption) == "on_demand" {
		fixPurchaseOption = "OnDemand"
		switch strings.ToLower(strings.Split(machineType, "-")[0]) {
		case "c2", "n2", "n2d":
			sustainedUseDiscount = getSustainedUseDiscount(hours, sudRate20)
		case "custom", "n1", "f1", "g1", "m1":
			sustainedUseDiscount = getSustainedUseDiscount(hours, sudRate30)
		default:
			sustainedUseDiscount = 0.0
		}
	}

	purchaseOptionPrefix := ""
	if purchaseOption == "preemptible" {
		purchaseOptionPrefix = "Spot Preemptible "
		fixPurchaseOption = "Preemptible"
	}

	qty := schema.HourToMonthUnitMultiplier
	if monthlyHours != nil {
		qty = decimal.NewFromFloat(*monthlyHours)
	}
	qty = qty.Mul(decimal.NewFromInt(instanceCount))

	if !strings.Contains(machineType, "custom") {
		return []*schema.CostComponent{
			{
				Name:                fmt.Sprintf("Instance usage (Linux/UNIX, %s, %s)", purchaseOptionLabel(purchaseOption), machineType),
				Unit:                "hours",
				UnitMultiplier:      decimal.NewFromInt(1),
				MonthlyQuantity:     decimalPtr(qty),
				MonthlyDiscountPerc: sustainedUseDiscount,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr(region),
					Service:       strPtr("Compute Engine"),
					ProductFamily: strPtr("Compute Instance"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "machineType", ValueRegex: regexPtr(fmt.Sprintf("^%s$", machineType))},
					},
				},
				PriceFilter: &schema.PriceFilter{
					PurchaseOption: strPtr(purchaseOption),
				}},
		}, nil
	} else {
		// GCP Custom Instances
		re := regexp.MustCompile(`(\D.+)-(\d+)-(\d.+)`)
		machineTypePrefix := re.ReplaceAllString(machineType, "$1")
		strCPUAmount := re.ReplaceAllString(machineType, "$2")
		strRAMAmount := re.ReplaceAllString(machineType, "$3")

		extended := false
		if strings.Contains(strRAMAmount, "ext") {
			extended = true
			strRAMAmount = strings.Split(strRAMAmount, "-")[0]
		}

		instanceType := "N1"
		instanceTypePrefix := "Custom"

		if machineTypePrefix != "custom" {
			instanceType = strings.ToUpper(strings.Split(machineTypePrefix, "-")[0])

			if strings.HasSuffix(instanceType, "D") {
				instanceTypePrefix = fmt.Sprintf("%s AMD Custom", instanceType)
			} else if instanceType != "N1" {
				instanceTypePrefix = fmt.Sprintf("%s Custom", instanceType)
			}
		}

		cores, err := strconv.ParseInt(strCPUAmount, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("could not parse the custom number of cores for %s", machineType)
		}

		memMB, err := strconv.ParseInt(strRAMAmount, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("could not parse the custom amount of RAM for %s", machineType)
		}
		memGB := float64(memMB) / 1024.0

		maxMemRatio := 8.0
		if instanceType == "N1" {
			maxMemRatio = 6.5
		}

		extendedMemGB := 0.0
		if extended {
			maxMemGB := float64(cores) * maxMemRatio
			extendedMemGB = math.Max(memGB-maxMemGB, 0)
			if extendedMemGB > 0.0 {
				memGB = maxMemGB
			}
		}

		costComponents := make([]*schema.CostComponent, 0)

		costComponents = append(costComponents, &schema.CostComponent{
			Name:                fmt.Sprintf("Custom instance CPU (Linux/UNIX, %s, %s %d vCPUs)", purchaseOptionLabel(purchaseOption), instanceType, cores),
			Unit:                "hours",
			UnitMultiplier:      decimal.NewFromInt(cores),
			MonthlyQuantity:     decimalPtr(qty.Mul(decimal.NewFromInt(cores))),
			MonthlyDiscountPerc: sustainedUseDiscount,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("gcp"),
				Region:        strPtr(region),
				Service:       strPtr("Compute Engine"),
				ProductFamily: strPtr("Compute"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "description", ValueRegex: regexPtr(fmt.Sprintf("^%s%s Instance Core", purchaseOptionPrefix, instanceTypePrefix))},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr(fixPurchaseOption),
			},
		})

		costComponents = append(costComponents, &schema.CostComponent{
			Name:                fmt.Sprintf("Custom Instance RAM (Linux/UNIX, %s, %s %s GB)", purchaseOptionLabel(purchaseOption), instanceType, strconv.FormatFloat(memGB, 'f', -1, 64)),
			Unit:                "hours",
			UnitMultiplier:      decimal.NewFromFloat(memGB),
			MonthlyQuantity:     decimalPtr(qty.Mul(decimal.NewFromFloat(memGB))),
			MonthlyDiscountPerc: sustainedUseDiscount,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("gcp"),
				Region:        strPtr(region),
				Service:       strPtr("Compute Engine"),
				ProductFamily: strPtr("Compute"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "description", ValueRegex: regexPtr(fmt.Sprintf("^%s%s Instance Ram", purchaseOptionPrefix, instanceTypePrefix))},
				},
			},
			PriceFilter: &schema.PriceFilter{
				PurchaseOption: strPtr(fixPurchaseOption),
			},
		})

		if extendedMemGB > 0.0 {
			costComponents = append(costComponents, &schema.CostComponent{
				Name:                fmt.Sprintf("Custom Instance Extended RAM (Linux/UNIX, %s, %s %s GB)", purchaseOptionLabel(purchaseOption), instanceType, strconv.FormatFloat(extendedMemGB, 'f', -1, 64)),
				Unit:                "hours",
				UnitMultiplier:      decimal.NewFromFloat(extendedMemGB),
				MonthlyQuantity:     decimalPtr(qty.Mul(decimal.NewFromFloat(extendedMemGB))),
				MonthlyDiscountPerc: sustainedUseDiscount,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr(region),
					Service:       strPtr("Compute Engine"),
					ProductFamily: strPtr("Compute"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", ValueRegex: regexPtr(fmt.Sprintf("^%s%s Extended Instance Ram", purchaseOptionPrefix, instanceTypePrefix))},
					},
				},
				PriceFilter: &schema.PriceFilter{
					PurchaseOption: strPtr(fixPurchaseOption),
				},
			})
		}

		return costComponents, nil
	}

}

func getSustainedUseDiscount(hours float64, rates sudRates) float64 {
	if hours == 0 {
		return 0
	}

	totalHoursInMonth, _ := schema.HourToMonthUnitMultiplier.Float64()

	// Keep track of how many hours we have remaining after each threshold is applied
	remainingHours := hours

	// Keep track of the total hours that are charged for
	ratedHours := 0.0

	index := 0
	for remainingHours > 0 && index < len(rates.rates) {
		// Calculate the percentage of the month that is covered by the current threshold
		lastThreshold := 0.0
		if index > 0 {
			lastThreshold = rates.thresholds[index-1]
		}

		thresholdHours := (rates.thresholds[index] - lastThreshold) * totalHoursInMonth

		// If the remaining hours are less than the threshold, add them and then we are done
		if remainingHours <= thresholdHours {
			ratedHours += remainingHours * rates.rates[index]
			break
		}

		// Otherwise, add the discount for the current threshold and continue
		ratedHours += thresholdHours * rates.rates[index]
		remainingHours -= thresholdHours

		index++
	}

	// Return the average discount over the hours the instance is running
	avgDiscount := 1 - (ratedHours / hours)
	// Round so the calculations match up with Google's 20% discount
	rounded, _ := decimal.NewFromFloat(avgDiscount).Round(2).Float64()
	return rounded
}

// bootDiskCostComponent returns a cost component for Boot Disk storage for
// Compute resources.
func bootDiskCostComponent(region string, diskSize float64, diskType string) *schema.CostComponent {
	return computeDiskCostComponent(region, diskType, diskSize, int64(1))
}

// scratchDiskCostComponent returns a cost component for local SSD Disk storage for
// Compute resources.
func scratchDiskCostComponent(region string, purchaseOption string, count int) *schema.CostComponent {
	descRegex := "/^SSD backed Local Storage( in .*)?$/"
	if strings.ToLower(purchaseOption) == "preemptible" {
		descRegex = "/^SSD backed Local Storage attached to Spot Preemptible VMs/"
	}

	return &schema.CostComponent{
		Name:            "Local SSD provisioned storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(int64(375 * count))), // local SSDs are always 375 GB
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(region),
			Service:       strPtr("Compute Engine"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: strPtr(descRegex)},
			},
		},
	}
}

// computeDiskCostComponent returns a cost component for provisioned storage for
// Compute resources.
func computeDiskCostComponent(region string, diskType string, diskSize float64, instanceCount int64) *schema.CostComponent {
	diskTypeDesc := "/^Storage PD Capacity/"
	diskTypeLabel := "Standard provisioned storage (pd-standard)"
	switch diskType {
	case "pd-balanced":
		diskTypeDesc = "/^Balanced PD Capacity/"
		diskTypeLabel = "Balanced provisioned storage (pd-balanced)"
	case "pd-ssd":
		diskTypeDesc = "/^SSD backed PD Capacity/"
		diskTypeLabel = "SSD provisioned storage (pd-ssd)"
	case "pd-extreme":
		diskTypeDesc = "/^Extreme PD Capacity/"
		diskTypeLabel = "Extreme provisioned storage (pd-extreme)"
	case "hyperdisk-extreme":
		diskTypeDesc = "/^Hyperdisk Extreme Capacity( in .*)?$/"
		diskTypeLabel = "Hyperdisk provisioned storage (hyperdisk-extreme)"
	}

	size := decimalPtr(decimal.NewFromInt(instanceCount).Mul(decimal.NewFromFloat(diskSize)))

	return &schema.CostComponent{
		Name:            diskTypeLabel,
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: size,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(region),
			Service:       strPtr("Compute Engine"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: strPtr(diskTypeDesc)},
			},
		},
		PriceFilter: &schema.PriceFilter{
			EndUsageAmount: strPtr(""), // use the non-free tier
		},
	}
}

func computeDiskIOPSCostComponent(region string, diskType string, diskSize float64, instanceCount int64, iops int64) *schema.CostComponent {
	var iopsTypeDesc string

	switch diskType {
	case "pd-extreme":
		iopsTypeDesc = "/^Extreme PD IOPS/"
	case "hyperdisk-extreme":
		iopsTypeDesc = "/^Hyperdisk Extreme IOPS( in .*)?$/"
	}

	return &schema.CostComponent{
		Name:            "Provisioned IOPS",
		Unit:            "IOPS",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(iops)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(region),
			Service:       strPtr("Compute Engine"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: strPtr(iopsTypeDesc)},
			},
		},
		PriceFilter: &schema.PriceFilter{
			EndUsageAmount: strPtr(""), // use the non-free tier
		},
	}
}

// guestAcceleratorCostComponent returns a cost component for Guest Accelerator usage for Compute resources.
// Callers should be aware guestAcceleratorCostComponent returns nil if the provided guestAcceleratorType is not supported.
func guestAcceleratorCostComponent(region string, purchaseOption string, guestAcceleratorType string, guestAcceleratorCount int64, instanceCount int64, monthlyHours *float64) *schema.CostComponent {
	// From strings in format 'nvidia-tesla-a100' create:
	// - name: 'NVIDIA Tesla A100'
	// - descPrefix: 'Nvidia Tesla A100 GPU'
	parts := strings.Split(guestAcceleratorType, "-")
	if len(parts) < 2 {
		logging.Logger.Debug().Msgf("skipping cost component because guest_accelerator.type '%s' is not supported", guestAcceleratorType)
		return nil
	}

	caser := cases.Title(language.English)
	rest := caser.String(strings.Join(parts[1:], " "))

	name := fmt.Sprintf("%s %s", strings.ToUpper(parts[0]), rest)
	descPrefix := fmt.Sprintf("%s %s GPU", caser.String(parts[0]), rest)

	descRegex := fmt.Sprintf("/^%s running/", descPrefix)
	if strings.ToLower(purchaseOption) == "preemptible" {
		descRegex = fmt.Sprintf("/^%s attached to Spot Preemptible VMs running/", descPrefix)
	}

	count := decimal.NewFromInt(guestAcceleratorCount)
	count = decimal.NewFromInt(instanceCount).Mul(count)

	sustainedUseDiscount := 0.0
	if strings.ToLower(purchaseOption) == "on_demand" {
		sustainedUseDiscount = 0.3
	}

	qty := decimal.NewFromFloat(730)
	if monthlyHours != nil {
		qty = decimal.NewFromFloat(*monthlyHours)
	}
	qty = qty.Mul(count)

	return &schema.CostComponent{
		Name:                fmt.Sprintf("%s (%s)", name, purchaseOptionLabel(purchaseOption)),
		Unit:                "hours",
		UnitMultiplier:      decimal.NewFromInt(1),
		MonthlyQuantity:     decimalPtr(qty),
		MonthlyDiscountPerc: sustainedUseDiscount,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(region),
			Service:       strPtr("Compute Engine"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: strPtr(descRegex)},
			},
		},
		PriceFilter: &schema.PriceFilter{
			EndUsageAmount: strPtr(""),
		},
	}
}

// purchaseOptionLabel returns a Purchase Option label based on provider's
// purchase option value.
func purchaseOptionLabel(purchaseOption string) string {
	return map[string]string{
		"on_demand":   "on-demand",
		"preemptible": "preemptible",
	}[purchaseOption]
}

func storageImageCostComponent(region string, description string, storageSize *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: storageSize,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(region),
			Service:       strPtr("Compute Engine"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: regexPtr(description)},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/google/compute_disk.go
# RESOURCE: google_compute_disk
# SIZE: 1690 bytes | LINES: 47
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// ComputeDisk struct represents Compute Disk resource.
type ComputeDisk struct {
	Address       string
	Region        string
	Type          string
	Size          float64
	InstanceCount *int64

	// applicable for pd-extreme and hyperdisk-extreme
	IOPS int64
}

func (r *ComputeDisk) CoreType() string {
	return "ComputeDisk"
}

// UsageSchema defines a list which represents the usage schema of ComputeDisk.
func (r *ComputeDisk) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the ComputeDisk.
// It uses the `infracost_usage` struct tags to populate data into the ComputeDisk.
func (r *ComputeDisk) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid ComputeDisk struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *ComputeDisk) BuildResource() *schema.Resource {
	count := int64(1)
	if r.InstanceCount != nil {
		count = *r.InstanceCount
	}

	costComponents := []*schema.CostComponent{
		computeDiskCostComponent(r.Region, r.Type, r.Size, count),
	}

	if r.Type == "pd-extreme" || r.Type == "hyperdisk-extreme" {
		costComponents = append(costComponents, computeDiskIOPSCostComponent(r.Region, r.Type, r.Size, 1, r.IOPS))
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

################################################################################
# FILE: internal/resources/google/compute_external_vpn_gateway.go
# RESOURCE: google_compute_external_vpn_gateway
# SIZE: 1541 bytes | LINES: 42
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
)

type ComputeExternalVPNGateway struct {
	Address string
	Region  string

	MonthlyEgressDataTransferGB *ComputeExternalVPNGatewayNetworkEgressUsage `infracost_usage:"monthly_egress_data_transfer_gb"`
}

func (r *ComputeExternalVPNGateway) CoreType() string {
	return "ComputeExternalVPNGateway"
}

func (r *ComputeExternalVPNGateway) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{
			Key:       "monthly_egress_data_transfer_gb",
			ValueType: schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "monthly_egress_data_transfer_gb",
				Items: ComputeExternalVPNGatewayNetworkEgressUsageSchema},
		},
	}
}

func (r *ComputeExternalVPNGateway) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
	if r.MonthlyEgressDataTransferGB == nil {
		r.MonthlyEgressDataTransferGB = &ComputeExternalVPNGatewayNetworkEgressUsage{}
	}
}

func (r *ComputeExternalVPNGateway) BuildResource() *schema.Resource {
	region := r.Region
	r.MonthlyEgressDataTransferGB.Region = region
	r.MonthlyEgressDataTransferGB.Address = "Network egress"
	r.MonthlyEgressDataTransferGB.PrefixName = "IPSec traffic"
	return &schema.Resource{
		Name: r.Address,
		SubResources: []*schema.Resource{
			r.MonthlyEgressDataTransferGB.BuildResource(),
		}, UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/google/compute_forwarding_rule.go
# RESOURCE: google_compute_forwarding_rule
# SIZE: 2855 bytes | LINES: 76
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type ComputeForwardingRule struct {
	Address              string
	Region               string
	MonthlyIngressDataGB *float64 `infracost_usage:"monthly_ingress_data_gb"`
}

func (r *ComputeForwardingRule) CoreType() string {
	return "ComputeForwardingRule"
}

func (r *ComputeForwardingRule) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_ingress_data_gb", ValueType: schema.Float64, DefaultValue: 0}}
}

func (r *ComputeForwardingRule) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ComputeForwardingRule) BuildResource() *schema.Resource {
	var monthlyIngressDataGb *decimal.Decimal
	region := r.Region
	costComponents := make([]*schema.CostComponent, 0)

	costComponents = append(costComponents, r.computeForwardingCostComponent())

	if r.MonthlyIngressDataGB != nil {
		monthlyIngressDataGb = decimalPtr(decimal.NewFromFloat(*r.MonthlyIngressDataGB))
	}

	costComponents = append(costComponents, computeIngressDataCostComponent(region, monthlyIngressDataGb))

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *ComputeForwardingRule) computeForwardingCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "Forwarding rules",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Compute Engine"),
			ProductFamily: strPtr("Network"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: strPtr("/^Network Load Balancing: Forwarding Rule Additional/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("OnDemand"),
		},
	}
}

func computeIngressDataCostComponent(region string, quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Ingress data",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(region),
			Service:       strPtr("Compute Engine"),
			ProductFamily: strPtr("Network"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: strPtr("/^Network Load Balancing: Data Processing Charge/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("OnDemand"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/google/compute_image.go
# RESOURCE: google_compute_image
# SIZE: 1705 bytes | LINES: 49
################################################################################
package google

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// ComputeImage struct represents Compute Image resource.
type ComputeImage struct {
	Address     string
	Region      string
	StorageSize float64

	// "usage" args
	StorageGB *float64 `infracost_usage:"storage_gb"`
}

func (r *ComputeImage) CoreType() string {
	return "ComputeImage"
}

// UsageSchema defines a list which represents the usage schema of ComputeImage.
func (r *ComputeImage) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "storage_gb", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the ComputeImage.
// It uses the `infracost_usage` struct tags to populate data into the ComputeImage.
func (r *ComputeImage) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid ComputeImage struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *ComputeImage) BuildResource() *schema.Resource {
	storageSize := r.StorageSize
	if r.StorageGB != nil {
		storageSize = *r.StorageGB
	}

	var size *decimal.Decimal
	if storageSize > 0 {
		size = decimalPtr(decimal.NewFromFloat(storageSize))
	}

	costComponents := []*schema.CostComponent{
		storageImageCostComponent(r.Region, "Storage Image", size),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

################################################################################
# FILE: internal/resources/google/compute_instance.go
# RESOURCE: google_compute_instance
# SIZE: 2408 bytes | LINES: 60
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// ComputeInstance struct represents Compute Instance resource.
type ComputeInstance struct {
	Address string
	Region  string

	MachineType       string
	PurchaseOption    string
	Size              int64
	HasBootDisk       bool
	BootDiskSize      float64
	BootDiskType      string
	ScratchDisks      int
	GuestAccelerators []*ComputeGuestAccelerator

	MonthlyHours *float64 `infracost_usage:"monthly_hrs"`
}

func (r *ComputeInstance) CoreType() string {
	return "ComputeInstance"
}

// UsageSchema defines a list which represents the usage schema of ComputeInstance.
func (r *ComputeInstance) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_hrs", DefaultValue: 730, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the ComputeInstance.
// It uses the `infracost_usage` struct tags to populate data into the ComputeInstance.
func (r *ComputeInstance) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid ComputeInstance struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *ComputeInstance) BuildResource() *schema.Resource {
	costComponents, err := computeCostComponents(r.Region, r.MachineType, r.PurchaseOption, r.Size, r.MonthlyHours)
	if err != nil {
		logging.Logger.Warn().Msgf("Skipping resource %s. %s", r.Address, err)
		return nil
	}

	if r.HasBootDisk {
		costComponents = append(costComponents, bootDiskCostComponent(r.Region, r.BootDiskSize, r.BootDiskType))
	}

	if r.ScratchDisks > 0 {
		costComponents = append(costComponents, scratchDiskCostComponent(r.Region, r.PurchaseOption, r.ScratchDisks))
	}

	for _, guestAccel := range r.GuestAccelerators {
		if component := guestAcceleratorCostComponent(r.Region, r.PurchaseOption, guestAccel.Type, guestAccel.Count, r.Size, r.MonthlyHours); component != nil {
			costComponents = append(costComponents, component)
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

################################################################################
# FILE: internal/resources/google/compute_instance_group_manager.go
# RESOURCE: google_compute_instance_group_manager
# SIZE: 2435 bytes | LINES: 58
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// ComputeInstanceGroupManager struct represents Compute Instance Group Manager
// resource.
type ComputeInstanceGroupManager struct {
	Address string
	Region  string

	MachineType       string
	PurchaseOption    string
	TargetSize        int64
	Disks             []*ComputeDisk
	ScratchDisks      int
	GuestAccelerators []*ComputeGuestAccelerator
}

func (r *ComputeInstanceGroupManager) CoreType() string {
	return "ComputeInstanceGroupManager"
}

// UsageSchema defines a list which represents the usage schema of ComputeInstanceGroupManager.
func (r *ComputeInstanceGroupManager) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the ComputeInstanceGroupManager.
// It uses the `infracost_usage` struct tags to populate data into the ComputeInstanceGroupManager.
func (r *ComputeInstanceGroupManager) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid ComputeInstanceGroupManager struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *ComputeInstanceGroupManager) BuildResource() *schema.Resource {
	costComponents, err := computeCostComponents(r.Region, r.MachineType, r.PurchaseOption, r.TargetSize, nil)
	if err != nil {
		logging.Logger.Warn().Msgf("Skipping resource %s. %s", r.Address, err)
		return nil
	}

	subResources := make([]*schema.Resource, 0)

	for _, disk := range r.Disks {
		subResources = append(subResources, disk.BuildResource())
	}

	if r.ScratchDisks > 0 {
		costComponents = append(costComponents, scratchDiskCostComponent(r.Region, r.PurchaseOption, r.ScratchDisks*int(r.TargetSize)))
	}

	for _, guestAccel := range r.GuestAccelerators {
		if component := guestAcceleratorCostComponent(r.Region, r.PurchaseOption, guestAccel.Type, guestAccel.Count, r.TargetSize, nil); component != nil {
			costComponents = append(costComponents, component)
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		SubResources:   subResources,
		CostComponents: costComponents,
	}
}

################################################################################
# FILE: internal/resources/google/compute_machine_image.go
# RESOURCE: google_compute_machine_image
# SIZE: 1700 bytes | LINES: 44
################################################################################
package google

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// ComputeMachineImage struct represents Compute Machine Image resource.
type ComputeMachineImage struct {
	Address string
	Region  string

	// "usage" args
	StorageGB *float64 `infracost_usage:"storage_gb"`
}

func (r *ComputeMachineImage) CoreType() string {
	return "ComputeMachineImage"
}

// UsageSchema defines a list which represents the usage schema of ComputeMachineImage.
func (r *ComputeMachineImage) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "storage_gb", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the ComputeMachineImage.
// It uses the `infracost_usage` struct tags to populate data into the ComputeMachineImage.
func (r *ComputeMachineImage) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid ComputeMachineImage struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *ComputeMachineImage) BuildResource() *schema.Resource {
	var storageSize *decimal.Decimal
	if r.StorageGB != nil {
		storageSize = decimalPtr(decimal.NewFromFloat(*r.StorageGB))
	}

	costComponents := []*schema.CostComponent{
		storageImageCostComponent(r.Region, "Storage Machine Image", storageSize),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

################################################################################
# FILE: internal/resources/google/compute_region_instance_group_manager.go
# RESOURCE: google_compute_region_instance_group_manager
# SIZE: 2508 bytes | LINES: 58
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// ComputeRegionInstanceGroupManager struct represents Compute Region Instance
// Group Manager resource.
type ComputeRegionInstanceGroupManager struct {
	Address string
	Region  string

	MachineType       string
	PurchaseOption    string
	TargetSize        int64
	ScratchDisks      int
	Disks             []*ComputeDisk
	GuestAccelerators []*ComputeGuestAccelerator
}

func (r *ComputeRegionInstanceGroupManager) CoreType() string {
	return "ComputeRegionInstanceGroupManager"
}

// UsageSchema defines a list which represents the usage schema of ComputeRegionInstanceGroupManager.
func (r *ComputeRegionInstanceGroupManager) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

// PopulateUsage parses the u schema.UsageData into the ComputeRegionInstanceGroupManager.
// It uses the `infracost_usage` struct tags to populate data into the ComputeRegionInstanceGroupManager.
func (r *ComputeRegionInstanceGroupManager) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid ComputeRegionInstanceGroupManager struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *ComputeRegionInstanceGroupManager) BuildResource() *schema.Resource {
	costComponents, err := computeCostComponents(r.Region, r.MachineType, r.PurchaseOption, r.TargetSize, nil)
	if err != nil {
		logging.Logger.Warn().Msgf("Skipping resource %s. %s", r.Address, err)
		return nil
	}

	subResources := make([]*schema.Resource, 0)

	for _, disk := range r.Disks {
		subResources = append(subResources, disk.BuildResource())
	}

	if r.ScratchDisks > 0 {
		costComponents = append(costComponents, scratchDiskCostComponent(r.Region, r.PurchaseOption, r.ScratchDisks*int(r.TargetSize)))
	}

	for _, guestAccel := range r.GuestAccelerators {
		if component := guestAcceleratorCostComponent(r.Region, r.PurchaseOption, guestAccel.Type, guestAccel.Count, r.TargetSize, nil); component != nil {
			costComponents = append(costComponents, component)
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		SubResources:   subResources,
		CostComponents: costComponents,
	}
}

################################################################################
# FILE: internal/resources/google/compute_router_nat.go
# RESOURCE: google_compute_router_nat
# SIZE: 2505 bytes | LINES: 75
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type ComputeRouterNAT struct {
	Address                string
	Region                 string
	AssignedVMs            *int64   `infracost_usage:"assigned_vms"`
	MonthlyDataProcessedGB *float64 `infracost_usage:"monthly_data_processed_gb"`
}

func (r *ComputeRouterNAT) CoreType() string {
	return "ComputeRouterNAT"
}

func (r *ComputeRouterNAT) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "assigned_vms", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_data_processed_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *ComputeRouterNAT) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ComputeRouterNAT) BuildResource() *schema.Resource {
	var assignedVMs int64
	if r.AssignedVMs != nil {
		assignedVMs = *r.AssignedVMs
		if assignedVMs > 32 {
			assignedVMs = 32
		}
	}

	var dataProcessedGB *decimal.Decimal
	if r.MonthlyDataProcessedGB != nil {
		dataProcessedGB = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataProcessedGB))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:           "Assigned VMs (first 32)",
				Unit:           "VM-hours",
				UnitMultiplier: decimal.NewFromInt(1),
				HourlyQuantity: decimalPtr(decimal.NewFromInt(assignedVMs)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr(r.Region),
					Service:       strPtr("Compute Engine"),
					ProductFamily: strPtr("Network"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", ValueRegex: strPtr("/NAT Gateway: Uptime charge/")},
					},
				},
				UsageBased: true,
			},
			{
				Name:            "Data processed",
				Unit:            "GB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: dataProcessedGB,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr(r.Region),
					Service:       strPtr("Compute Engine"),
					ProductFamily: strPtr("Network"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", ValueRegex: strPtr("/NAT Gateway: Data processing charge/")},
					},
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/google/compute_snapshot.go
# RESOURCE: google_compute_snapshot
# SIZE: 2475 bytes | LINES: 72
################################################################################
package google

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// ComputeSnapshot struct represents Compute Snapshot resource.
type ComputeSnapshot struct {
	Address  string
	Region   string
	DiskSize float64

	// "usage" args
	StorageGB *float64 `infracost_usage:"storage_gb"`
}

func (r *ComputeSnapshot) CoreType() string {
	return "ComputeSnapshot"
}

// UsageSchema defines a list which represents the usage schema of ComputeSnapshot.
func (r *ComputeSnapshot) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "storage_gb", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the ComputeSnapshot.
// It uses the `infracost_usage` struct tags to populate data into the ComputeSnapshot.
func (r *ComputeSnapshot) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid ComputeSnapshot struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *ComputeSnapshot) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{
		r.storageCostComponent(),
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

// storageCostComponent returns a cost component for snapshot storage.
func (r *ComputeSnapshot) storageCostComponent() *schema.CostComponent {
	description := "Storage PD Snapshot"

	size := r.DiskSize
	if r.StorageGB != nil {
		size = *r.StorageGB
	}

	var snapshotDiskSize *decimal.Decimal
	if size > 0 {
		snapshotDiskSize = decimalPtr(decimal.NewFromFloat(size))
	}

	return &schema.CostComponent{
		Name:            "Storage",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: snapshotDiskSize,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Compute Engine"),
			ProductFamily: strPtr("Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: regexPtr(description)},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("5"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/google/compute_target_grpc_proxy.go
# RESOURCE: google_compute_target_grpc_proxy
# SIZE: 3398 bytes | LINES: 86
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type ComputeTargetGRPCProxy struct {
	Address                string
	Region                 string
	MonthlyProxyInstances  *float64 `infracost_usage:"monthly_proxy_instances"`
	MonthlyDataProcessedGB *float64 `infracost_usage:"monthly_data_processed_gb"`
}

func (r *ComputeTargetGRPCProxy) CoreType() string {
	return "ComputeTargetGRPCProxy"
}

func (r *ComputeTargetGRPCProxy) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "monthly_proxy_instances", ValueType: schema.Float64, DefaultValue: 0.000000}, {Key: "monthly_data_processed_gb", ValueType: schema.Float64, DefaultValue: 0}}
}

func (r *ComputeTargetGRPCProxy) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ComputeTargetGRPCProxy) BuildResource() *schema.Resource {
	var monthlyProxyInstances, monthlyDataProcessedGb *decimal.Decimal
	region := r.Region
	costComponents := make([]*schema.CostComponent, 0)

	if r.MonthlyProxyInstances != nil {
		monthlyProxyInstances = decimalPtr(decimal.NewFromFloat(*r.MonthlyProxyInstances))
	}

	costComponents = append(costComponents, r.proxyInstanceCostComponent(monthlyProxyInstances))

	if r.MonthlyDataProcessedGB != nil {
		monthlyDataProcessedGb = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataProcessedGB))
	}

	costComponents = append(costComponents, dataProcessedCostComponent(region, monthlyDataProcessedGb))

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *ComputeTargetGRPCProxy) proxyInstanceCostComponent(instanceCount *decimal.Decimal) *schema.CostComponent {
	var quantity *decimal.Decimal
	if instanceCount != nil {
		instanceHours := schema.HourToMonthUnitMultiplier.Mul(*instanceCount)
		quantity = &instanceHours
	}

	return &schema.CostComponent{
		Name:            "Proxy instance",
		Unit:            "hours",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Compute Engine"),
			ProductFamily: strPtr("Network"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: strPtr("/^Network Load Balancing: Forwarding Rule Minimum/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("OnDemand"),
		},
		UsageBased: true,
	}
}

func dataProcessedCostComponent(region string, quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Data processed",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(region),
			Service:       strPtr("Compute Engine"),
			ProductFamily: strPtr("Network"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: strPtr("/^Network Internal Load Balancing: Data Processing/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			PurchaseOption: strPtr("OnDemand"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/google/compute_vpn_gateway.go
# RESOURCE: google_compute_vpn_gateway
# SIZE: 1473 bytes | LINES: 42
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
)

type ComputeVPNGateway struct {
	Address string
	Region  string

	MonthlyEgressDataTransferGB *ComputeVPNGatewayNetworkEgressUsage `infracost_usage:"monthly_egress_data_transfer_gb"`
}

func (r *ComputeVPNGateway) CoreType() string {
	return "ComputeVPNGateway"
}

func (r *ComputeVPNGateway) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{
			Key:          "monthly_egress_data_transfer_gb",
			ValueType:    schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "monthly_egress_data_transfer_gb", Items: ComputeVPNGatewayNetworkEgressUsageSchema},
		},
	}
}

func (r *ComputeVPNGateway) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ComputeVPNGateway) BuildResource() *schema.Resource {
	if r.MonthlyEgressDataTransferGB == nil {
		r.MonthlyEgressDataTransferGB = &ComputeVPNGatewayNetworkEgressUsage{}
	}
	region := r.Region
	r.MonthlyEgressDataTransferGB.Region = region
	r.MonthlyEgressDataTransferGB.Address = "Network egress"
	r.MonthlyEgressDataTransferGB.PrefixName = "IPSec traffic"
	return &schema.Resource{
		Name: r.Address,
		SubResources: []*schema.Resource{
			r.MonthlyEgressDataTransferGB.BuildResource(),
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/google/compute_vpn_tunnel.go
# RESOURCE: google_compute_vpn_tunnel
# SIZE: 1354 bytes | LINES: 44
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type ComputeVPNTunnel struct {
	Address string
	Region  string
}

func (r *ComputeVPNTunnel) CoreType() string {
	return "ComputeVPNTunnel"
}

func (r *ComputeVPNTunnel) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *ComputeVPNTunnel) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ComputeVPNTunnel) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			r.vpnTunnelCostComponent(),
		}, UsageSchema: r.UsageSchema(),
	}
}

func (r *ComputeVPNTunnel) vpnTunnelCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "VPN Tunnel",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Compute Engine"),
			ProductFamily: strPtr("Network"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "resourceGroup", Value: strPtr("VPNTunnel")},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/google/container_cluster.go
# RESOURCE: google_container_cluster
# SIZE: 6781 bytes | LINES: 181
################################################################################
package google

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// ContainerCluster struct represents Container Cluster resource.
type ContainerCluster struct {
	Address string
	Region  string

	AutopilotEnabled bool

	IsZone          bool
	DefaultNodePool *ContainerNodePool
	NodePools       []*ContainerNodePool

	// "usage" args
	DefaultNodePoolNodes        *int64   `infracost_usage:"nodes"`
	AutopilotVCPUCount          *float64 `infracost_usage:"autopilot_vcpu_count"`
	AutopilotMemoryGB           *float64 `infracost_usage:"autopilot_memory_gb"`
	AutopilotEphemeralStorageGB *float64 `infracost_usage:"autopilot_ephemeral_storage_gb"`
}

func (r *ContainerCluster) CoreType() string {
	return "ContainerCluster"
}

func (r *ContainerCluster) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "nodes", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "autopilot_vcpu_count", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "autopilot_memory_gb", DefaultValue: 0, ValueType: schema.Float64},
		{Key: "autopilot_ephemeral_storage_gb", DefaultValue: 0, ValueType: schema.Float64},
	}
}

// PopulateUsage parses the u schema.UsageData into the ContainerCluster.
// It uses the `infracost_usage` struct tags to populate data into the ContainerCluster.
func (r *ContainerCluster) PopulateUsage(u *schema.UsageData) {
	if u == nil {
		return
	}

	resources.PopulateArgsWithUsage(r, u)

	if r.DefaultNodePool != nil {
		r.DefaultNodePool.PopulateUsage(u)
	}

	for _, nodePool := range r.NodePools {
		nodePool.PopulateUsage(&schema.UsageData{
			Attributes: u.Get(nodePool.Address).Map(),
		})
	}
}

// BuildResource builds a schema.Resource from a valid ContainerCluster struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *ContainerCluster) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	costComponents = append(costComponents, r.managementFeeCostComponent())

	if r.AutopilotEnabled {
		costComponents = append(costComponents, r.autopilotCPUCostComponent())
		costComponents = append(costComponents, r.autopilotMemoryCostComponent())
		costComponents = append(costComponents, r.autopilotStorageCostComponent())
	}

	subresources := []*schema.Resource{}

	if r.DefaultNodePool != nil {
		poolResource := r.DefaultNodePool.BuildResource()
		if poolResource != nil {
			subresources = append(subresources, poolResource)
		}
	}

	for _, nodePool := range r.NodePools {
		poolResource := nodePool.BuildResource()
		if poolResource != nil {
			subresources = append(subresources, poolResource)
		}
	}

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
		SubResources:   subresources,
	}
}

// managementFeeCostComponent returns a cost component for cluster management
// fee.
func (r *ContainerCluster) managementFeeCostComponent() *schema.CostComponent {
	description := "Regional Kubernetes Clusters"
	name := "Cluster management fee"

	if r.IsZone {
		description = "Zonal Kubernetes Clusters"
	}

	if r.AutopilotEnabled {
		description = "Autopilot Kubernetes Clusters"
		name = "Autopilot"
	}

	return &schema.CostComponent{
		Name:           name,
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr("global"),
			Service:       strPtr("Kubernetes Engine"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", Value: strPtr(description)},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("0"),
			EndUsageAmount:   strPtr(""),
		},
	}
}

// autopilotCPUCostComponent returns a cost component for Autopilot vCPU usage.
func (r *ContainerCluster) autopilotCPUCostComponent() *schema.CostComponent {
	var quantity *decimal.Decimal
	multiplier := decimal.NewFromInt(1000) // Price is for mCPU

	if r.AutopilotVCPUCount != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.AutopilotVCPUCount).Mul(multiplier))
	}

	return &schema.CostComponent{
		Name:           "Autopilot vCPU",
		Unit:           "vCPU",
		UnitMultiplier: schema.HourToMonthUnitMultiplier.Mul(multiplier),
		HourlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Kubernetes Engine"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: regexPtr("^Autopilot Pod mCPU Requests")},
			},
		},
		UsageBased: true,
	}
}

// autopilotMemoryCostComponent returns a cost component for Autopilot memory usage.
func (r *ContainerCluster) autopilotMemoryCostComponent() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.AutopilotMemoryGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.AutopilotMemoryGB))
	}

	return &schema.CostComponent{
		Name:           "Autopilot memory",
		Unit:           "GB",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Kubernetes Engine"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: regexPtr("^Autopilot Pod Memory Requests")},
			},
		},
		UsageBased: true,
	}
}

// autopilotStorageCostComponent returns a cost component for Autopilot
// ephemeral storage usage.
func (r *ContainerCluster) autopilotStorageCostComponent() *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.AutopilotEphemeralStorageGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.AutopilotEphemeralStorageGB))
	}

	return &schema.CostComponent{
		Name:           "Autopilot ephemeral storage",
		Unit:           "GB",
		UnitMultiplier: schema.HourToMonthUnitMultiplier,
		HourlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Kubernetes Engine"),
			ProductFamily: strPtr("Compute"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: regexPtr("^Autopilot Pod Ephemeral Storage Requests")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/google/container_node_pool.go
# RESOURCE: google_container_node_pool
# SIZE: 2548 bytes | LINES: 62
################################################################################
package google

import (
	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// ContainerNodePool struct represents Container Cluster's Node Pool resource.
type ContainerNodePool struct {
	Address string
	Region  string

	Zones        int64
	CountPerZone int64
	NodeConfig   *ContainerNodeConfig

	// "usage" args
	Nodes *int64 `infracost_usage:"nodes"`
}

func (r *ContainerNodePool) CoreType() string {
	return "ContainerNodePool"
}

func (r *ContainerNodePool) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "nodes", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the ContainerNodePool.
// It uses the `infracost_usage` struct tags to populate data into the ContainerNodePool.
func (r *ContainerNodePool) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid ContainerNodePool struct.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *ContainerNodePool) BuildResource() *schema.Resource {
	countPerZone := r.CountPerZone
	if r.Nodes != nil {
		countPerZone = *r.Nodes
	}

	nodeCount := decimal.NewFromInt(r.Zones * countPerZone)

	poolSize := int64(1)

	costComponents, err := computeCostComponents(r.Region, r.NodeConfig.MachineType, r.NodeConfig.PurchaseOption, poolSize, nil)
	if err != nil {
		logging.Logger.Warn().Msgf("Skipping resource %s. %s", r.Address, err)
		return nil
	}

	costComponents = append(costComponents, computeDiskCostComponent(r.Region, r.NodeConfig.DiskType, r.NodeConfig.DiskSize, poolSize))

	if r.NodeConfig.LocalSSDCount > 0 {
		costComponents = append(costComponents, scratchDiskCostComponent(r.Region, r.NodeConfig.PurchaseOption, int(r.NodeConfig.LocalSSDCount)))
	}

	for _, guestAccel := range r.NodeConfig.GuestAccelerators {
		if component := guestAcceleratorCostComponent(r.Region, r.NodeConfig.PurchaseOption, guestAccel.Type, guestAccel.Count, poolSize, nil); component != nil {
			costComponents = append(costComponents, component)
		}
	}

	resource := &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}

	schema.MultiplyQuantities(resource, nodeCount)

	return resource
}

################################################################################
# FILE: internal/resources/google/container_registry.go
# RESOURCE: google_container_registry
# SIZE: 2516 bytes | LINES: 55
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"
)

type ContainerRegistry struct {
	Address                     string
	Region                      string
	Location                    string
	StorageClass                string
	StorageGB                   *float64                             `infracost_usage:"storage_gb"`
	MonthlyClassAOperations     *int64                               `infracost_usage:"monthly_class_a_operations"`
	MonthlyClassBOperations     *int64                               `infracost_usage:"monthly_class_b_operations"`
	MonthlyEgressDataTransferGB *ContainerRegistryNetworkEgressUsage `infracost_usage:"monthly_egress_data_transfer_gb"`
}

func (r *ContainerRegistry) CoreType() string {
	return "ContainerRegistry"
}

func (r *ContainerRegistry) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "storage_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_class_a_operations", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_class_b_operations", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_data_retrieval_gb", ValueType: schema.Float64, DefaultValue: 0},
		{
			Key:          "monthly_egress_data_transfer_gb",
			ValueType:    schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "monthly_egress_data_transfer_gb", Items: ContainerRegistryNetworkEgressUsageSchema},
		},
	}
}

func (r *ContainerRegistry) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *ContainerRegistry) BuildResource() *schema.Resource {
	if r.MonthlyEgressDataTransferGB == nil {
		r.MonthlyEgressDataTransferGB = &ContainerRegistryNetworkEgressUsage{}
	}
	region := r.Region
	components := []*schema.CostComponent{
		dataStorageCostComponent(r.Location, r.StorageClass, r.StorageGB),
	}

	components = append(components, operationsCostComponents(r.StorageClass, r.MonthlyClassAOperations, r.MonthlyClassBOperations)...)

	r.MonthlyEgressDataTransferGB.Region = region
	r.MonthlyEgressDataTransferGB.Address = "Network egress"
	r.MonthlyEgressDataTransferGB.PrefixName = "Data transfer"
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: components,
		SubResources: []*schema.Resource{
			r.MonthlyEgressDataTransferGB.BuildResource(),
		}, UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/google/dns_managed_zone.go
# RESOURCE: google_dns_managed_zone
# SIZE: 1303 bytes | LINES: 44
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type DNSManagedZone struct {
	Address string
}

func (r *DNSManagedZone) CoreType() string {
	return "DNSManagedZone"
}

func (r *DNSManagedZone) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *DNSManagedZone) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DNSManagedZone) BuildResource() *schema.Resource {
	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Managed zone",
				Unit:            "months",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: decimalPtr(decimal.NewFromInt(1)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr("global"),
					Service:       strPtr("Cloud DNS"),
					ProductFamily: strPtr("Network"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", Value: strPtr("ManagedZone")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					StartUsageAmount: strPtr("0"),
				},
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/google/dns_record_set.go
# RESOURCE: google_dns_record_set
# SIZE: 1596 bytes | LINES: 52
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type DNSRecordSet struct {
	Address        string
	MonthlyQueries *int64 `infracost_usage:"monthly_queries"`
}

func (r *DNSRecordSet) CoreType() string {
	return "DNSRecordSet"
}

func (r *DNSRecordSet) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_queries", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *DNSRecordSet) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *DNSRecordSet) BuildResource() *schema.Resource {
	var monthlyQueries *decimal.Decimal

	if r.MonthlyQueries != nil {
		monthlyQueries = decimalPtr(decimal.NewFromInt(*r.MonthlyQueries))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Queries",
				Unit:            "1M queries",
				UnitMultiplier:  decimal.NewFromInt(1000000),
				MonthlyQuantity: monthlyQueries,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr("global"),
					Service:       strPtr("Cloud DNS"),
					ProductFamily: strPtr("Network"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", Value: strPtr("DNS Query (port 53)")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					StartUsageAmount: strPtr("0"),
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/google/kms_crypto_key.go
# RESOURCE: google_kms_crypto_key
# SIZE: 7196 bytes | LINES: 195
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strconv"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/usage"
)

type KMSCryptoKey struct {
	Address              string
	Region               string
	VersionTemplate      string
	Algorithm            string
	ProtectionLevel      string
	RotationPeriod       string
	KeyVersions          *int64 `infracost_usage:"key_versions"`
	MonthlyKeyOperations *int64 `infracost_usage:"monthly_key_operations"`
}

func (r *KMSCryptoKey) CoreType() string {
	return "KMSCryptoKey"
}

func (r *KMSCryptoKey) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{{Key: "key_versions", ValueType: schema.Int64, DefaultValue: 0}, {Key: "monthly_key_operations", ValueType: schema.Int64, DefaultValue: 0}}
}

func (r *KMSCryptoKey) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *KMSCryptoKey) BuildResource() *schema.Resource {
	region := r.Region

	algorithm := "GOOGLE_SYMMETRIC_ENCRYPTION"
	protectionLevel := "SOFTWARE"

	if r.VersionTemplate != "" {
		algorithm = r.Algorithm
		protectionLevel = r.ProtectionLevel
	}

	var monthlyKeys *decimal.Decimal
	if r.KeyVersions != nil {
		monthlyKeys = decimalPtr(decimal.NewFromInt(*r.KeyVersions))
	} else if r.RotationPeriod != "" {
		rotation, err := strconv.ParseFloat(strings.Split(r.RotationPeriod, "s")[0], 64)

		if err == nil {
			monthlyKeys = decimalPtr(decimal.NewFromFloat(2592000.0 / rotation))
		}
	}

	var monthlyKeyOperations *decimal.Decimal
	if r.MonthlyKeyOperations != nil {
		monthlyKeyOperations = decimalPtr(decimal.NewFromInt(*r.MonthlyKeyOperations))
	}

	var keyDescript = r.cryptoKeyDescription(algorithm, protectionLevel)
	var operationDesctipt = keyOperationsDescription(algorithm, protectionLevel)

	costComponents := []*schema.CostComponent{}

	if strings.ToLower(keyDescript) == "hsm rsa 3072" || strings.ToLower(keyDescript) == "hsm rsa 4096" || strings.ToLower(keyDescript) == "hsm ecdsa p-256" || strings.ToLower(keyDescript) == "hsm ecdsa p-384" {
		tierLimits := []int{2000}
		var firstTierQty *decimal.Decimal
		var tiers []decimal.Decimal
		if monthlyKeys != nil {
			tiers = usage.CalculateTierBuckets(*monthlyKeys, tierLimits)
			firstTierQty = &tiers[0]
		}

		costComponents = append(costComponents, &schema.CostComponent{
			Name:            "Key versions (first 2K)",
			Unit:            "months",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: firstTierQty,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("gcp"),
				Region:        strPtr(region),
				Service:       strPtr("Cloud Key Management Service (KMS)"),
				ProductFamily: strPtr("ApplicationServices"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "description", ValueRegex: strPtr(fmt.Sprintf("/%s/i", keyDescript))},
				},
			},
			PriceFilter: &schema.PriceFilter{
				EndUsageAmount: strPtr("2000"),
			},
			UsageBased: true,
		})

		if len(tiers) > 1 && tiers[1].GreaterThan(decimal.NewFromInt(0)) {

			costComponents = append(costComponents, &schema.CostComponent{
				Name:            "Key versions (over 2K)",
				Unit:            "months",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: &tiers[1],
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr(region),
					Service:       strPtr("Cloud Key Management Service (KMS)"),
					ProductFamily: strPtr("ApplicationServices"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", ValueRegex: strPtr(fmt.Sprintf("/%s/i", keyDescript))},
					},
				},
				PriceFilter: &schema.PriceFilter{
					StartUsageAmount: strPtr("2000"),
				},
				UsageBased: true,
			})
		}
	} else {
		costComponents = append(costComponents, &schema.CostComponent{
			Name:            "Key versions",
			Unit:            "months",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: monthlyKeys,
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("gcp"),
				Region:        strPtr(region),
				Service:       strPtr("Cloud Key Management Service (KMS)"),
				ProductFamily: strPtr("ApplicationServices"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "description", ValueRegex: strPtr(fmt.Sprintf("/%s/i", keyDescript))},
				},
			},
			UsageBased: true,
		})
	}

	costComponents = append(costComponents, &schema.CostComponent{
		Name:            "Operations",
		Unit:            "10k operations",
		UnitMultiplier:  decimal.NewFromInt(10000),
		MonthlyQuantity: monthlyKeyOperations,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(region),
			Service:       strPtr("Cloud Key Management Service (KMS)"),
			ProductFamily: strPtr("ApplicationServices"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: strPtr(fmt.Sprintf("/%s/i", operationDesctipt))},
			},
		},
		UsageBased: true,
	})

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *KMSCryptoKey) cryptoKeyDescription(algorithm string, protectionLevel string) string {
	protectionLevel = strings.ToLower(protectionLevel)
	switch protectionLevel {
	case "software":
		if strings.ToLower(algorithm) == "google_symmetric_encryption" {
			return "Active software symmetric key versions"
		}
		return "Software asymmetric"
	case "hsm":
		if strings.ToLower(algorithm) == "google_symmetric_encryption" {
			return "HSM symmetric"
		}
		if strings.ToLower(algorithm) == "ec_sign_p256_sha256" {
			return "HSM ECDSA P-256"
		}
		if strings.ToLower(algorithm) == "ec_sign_p384_sha384" {
			return "HSM ECDSA P-384"
		}
		if strings.HasPrefix(strings.ToLower(algorithm), "rsa_sign_") {
			parts := strings.Split(algorithm, "_")
			if len(parts) > 3 {
				return "HSM RSA " + parts[3]
			}
		}
	}
	return ""
}

func keyOperationsDescription(algorithm string, protectionLevel string) string {
	protectionLevel = strings.ToLower(protectionLevel)
	switch protectionLevel {
	case "software":
		if strings.ToLower(algorithm) == "google_symmetric_encryption" {
			return "Cryptographic operations with a software symmetric"
		}
		return "Software asymmetric cryptographic"
	case "hsm":
		if strings.ToLower(algorithm) == "google_symmetric_encryption" {
			return "HSM symmetric cryptographic"
		}
		if strings.ToLower(algorithm) == "ec_sign_p256_sha256" {
			return "HSM cryptographic operations with an ECDSA P-256"
		}
		if strings.ToLower(algorithm) == "ec_sign_p384_sha384" {
			return "HSM cryptographic operations with an ECDSA P-384"
		}
		if strings.HasPrefix(strings.ToLower(algorithm), "rsa_sign_") {
			parts := strings.Split(algorithm, "_")
			if len(parts) > 3 {
				return "HSM cryptographic operations with a RSA   " + parts[3]
			}
		}
	}
	return ""
}

################################################################################
# FILE: internal/resources/google/logging.go
# RESOURCE: google_logging
# SIZE: 1740 bytes | LINES: 53
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type Logging struct {
	Address              string
	MonthlyLoggingDataGB *float64 `infracost_usage:"monthly_logging_data_gb"`
}

func (r *Logging) CoreType() string {
	return "Logging"
}

func (r *Logging) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_logging_data_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *Logging) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *Logging) BuildResource() *schema.Resource {
	var loggingDataGB *decimal.Decimal
	if r.MonthlyLoggingDataGB != nil {
		loggingDataGB = decimalPtr(decimal.NewFromFloat(*r.MonthlyLoggingDataGB))
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: []*schema.CostComponent{r.loggingDataCostComponent(loggingDataGB)},
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *Logging) loggingDataCostComponent(quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Logging data",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr("global"),
			Service:       strPtr("Cloud Logging"),
			ProductFamily: strPtr("ApplicationServices"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", Value: strPtr("Log Volume")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("50"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/google/monitoring_metric_descriptor.go
# RESOURCE: google_monitoring_metric_descriptor
# SIZE: 3901 bytes | LINES: 94
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/usage"
)

type MonitoringMetricDescriptor struct {
	Address                 string
	MonthlyMonitoringDataMB *int64 `infracost_usage:"monthly_monitoring_data_mb"`
	MonthlyAPICalls         *int64 `infracost_usage:"monthly_api_calls"`
}

func (r *MonitoringMetricDescriptor) CoreType() string {
	return "MonitoringMetricDescriptor"
}

func (r *MonitoringMetricDescriptor) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_monitoring_data_mb", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_api_calls", ValueType: schema.Int64, DefaultValue: 0},
	}
}

func (r *MonitoringMetricDescriptor) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *MonitoringMetricDescriptor) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	var monitoringDataMB *decimal.Decimal
	if r.MonthlyMonitoringDataMB != nil {
		monitoringDataMB = decimalPtr(decimal.NewFromInt(*r.MonthlyMonitoringDataMB))

		monitoringDataTiers := usage.CalculateTierBuckets(*monitoringDataMB, []int{100000, 150000})

		if monitoringDataTiers[0].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, r.monitoringDataCostComponent("Monitoring data (first 100K)", "150", &monitoringDataTiers[0]))
		}

		if monitoringDataTiers[1].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, r.monitoringDataCostComponent("Monitoring data (next 150K)", "100000", &monitoringDataTiers[1]))
		}

		if monitoringDataTiers[2].GreaterThan(decimal.Zero) {
			costComponents = append(costComponents, r.monitoringDataCostComponent("Monitoring data (over 250K)", "250000", &monitoringDataTiers[2]))
		}
	} else {
		var unknown *decimal.Decimal
		costComponents = append(costComponents, r.monitoringDataCostComponent("Monitoring data (first 100K)", "150", unknown))
	}

	var apiCalls *decimal.Decimal
	if r.MonthlyAPICalls != nil {
		apiCalls = decimalPtr(decimal.NewFromInt(*r.MonthlyAPICalls))
	}

	costComponents = append(costComponents, r.apiCallsCostComponent(apiCalls))
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *MonitoringMetricDescriptor) monitoringDataCostComponent(name string, usageTier string, monitoringDataMB *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            name,
		Unit:            "MB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: monitoringDataMB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Service:       strPtr("Cloud Monitoring"),
			ProductFamily: strPtr("ApplicationServices"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: strPtr("/Metric Volume/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr(usageTier),
		},
		UsageBased: true,
	}
}

func (r *MonitoringMetricDescriptor) apiCallsCostComponent(apiCalls *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "API calls",
		Unit:            "1k calls",
		UnitMultiplier:  decimal.NewFromInt(1000),
		MonthlyQuantity: apiCalls,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Service:       strPtr("Cloud Monitoring"),
			ProductFamily: strPtr("ApplicationServices"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: strPtr("/Monitoring API Requests/i")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: strPtr("1000000"),
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/google/network_egress_internal.go
# RESOURCE: google_network_egress_internal
# SIZE: 16417 bytes | LINES: 435
################################################################################
package google

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/schema"
)

type NetworkEgressUsage struct {
	Address    string
	Region     string
	PrefixName string
}

type StorageBucketNetworkEgressUsage struct {
	SameContinent *float64 `infracost_usage:"same_continent"`
	Asia          *float64 `infracost_usage:"asia"`
	Worldwide     *float64 `infracost_usage:"worldwide"`
	China         *float64 `infracost_usage:"china"`
	Australia     *float64 `infracost_usage:"australia"`

	NetworkEgressUsage
}

var StorageBucketNetworkEgressUsageSchema = []*schema.UsageItem{
	{ValueType: schema.Float64, DefaultValue: 0, Key: "same_continent"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "asia"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "worldwide"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "china"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "australia"},
}

func (r *StorageBucketNetworkEgressUsage) CoreType() string {
	return "StorageBucketNetworkEgressUsage"
}

func (r *StorageBucketNetworkEgressUsage) UsageSchema() []*schema.UsageItem {
	return StorageBucketNetworkEgressUsageSchema
}

func (r *StorageBucketNetworkEgressUsage) BuildResource() *schema.Resource {
	regionsData := []*egressRegionData{
		{
			gRegion:        fmt.Sprintf("%s to worldwide excluding Asia, Australia", r.PrefixName),
			apiDescription: "Download Worldwide Destinations (excluding Asia & Australia)",
			usageKey:       "worldwide",
		},
		{
			gRegion:        fmt.Sprintf("%s to Asia excluding China, but including Hong Kong", r.PrefixName),
			apiDescription: "Download APAC",
			usageKey:       "asia",
		},
		{
			gRegion:        fmt.Sprintf("%s to China excluding Hong Kong", r.PrefixName),
			apiDescription: "Download China",
			usageKey:       "china",
		},
		{
			gRegion:        fmt.Sprintf("%s to Australia", r.PrefixName),
			apiDescription: "Download Australia",
			usageKey:       "australia",
		},
	}
	usageFiltersData := []*egressRegionUsageFilterData{
		{
			usageName:   "first 1TB",
			usageNumber: 1024,
		},
		{
			usageName:   "next 9TB",
			usageNumber: 10240,
		},
		{
			usageName:   "over 10TB",
			usageNumber: 0,
		},
	}
	serviceName := "Cloud Storage"

	resource := &schema.Resource{
		Name:           r.Address,
		CostComponents: []*schema.CostComponent{},
	}

	// Same continent
	var quantity *decimal.Decimal
	if r.SameContinent != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.SameContinent))
	}
	resource.CostComponents = append(resource.CostComponents, &schema.CostComponent{
		Name:            fmt.Sprintf("%s in same continent", r.PrefixName),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("gcp"),
			Region:     strPtr("global"),
			Service:    strPtr("Cloud Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", Value: strPtr("Network Data Transfer GCP Inter Region within Europe")},
			},
		},
		UsageBased: true,
	})

	for _, regData := range regionsData {
		usageKey := regData.usageKey
		usage := GetFloatFieldValueByUsageTag(usageKey, *r)
		newCostComponents := egressStepPricingHelper(usage, usageFiltersData, regData, "", serviceName)
		resource.CostComponents = append(resource.CostComponents, newCostComponents...)
	}

	return resource
}

type ContainerRegistryNetworkEgressUsage struct {
	SameContinent *float64 `infracost_usage:"same_continent"`
	Asia          *float64 `infracost_usage:"asia"`
	Worldwide     *float64 `infracost_usage:"worldwide"`
	China         *float64 `infracost_usage:"china"`
	Australia     *float64 `infracost_usage:"australia"`

	NetworkEgressUsage
}

var ContainerRegistryNetworkEgressUsageSchema = []*schema.UsageItem{
	{ValueType: schema.Float64, DefaultValue: 0, Key: "same_continent"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "asia"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "worldwide"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "china"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "australia"},
}

func (r *ContainerRegistryNetworkEgressUsage) CoreType() string {
	return "ContainerRegistryNetworkEgressUsage"
}

func (r *ContainerRegistryNetworkEgressUsage) UsageSchema() []*schema.UsageItem {
	return ContainerRegistryNetworkEgressUsageSchema
}

func (r *ContainerRegistryNetworkEgressUsage) BuildResource() *schema.Resource {
	regionsData := []*egressRegionData{
		{
			gRegion:        fmt.Sprintf("%s to worldwide excluding Asia, Australia", r.PrefixName),
			apiDescription: "Download Worldwide Destinations (excluding Asia & Australia)",
			usageKey:       "worldwide",
		},
		{
			gRegion:        fmt.Sprintf("%s to Asia excluding China, but including Hong Kong", r.PrefixName),
			apiDescription: "Download APAC",
			usageKey:       "asia",
		},
		{
			gRegion:        fmt.Sprintf("%s to China excluding Hong Kong", r.PrefixName),
			apiDescription: "Download China",
			usageKey:       "china",
		},
		{
			gRegion:        fmt.Sprintf("%s to Australia", r.PrefixName),
			apiDescription: "Download Australia",
			usageKey:       "australia",
		},
	}
	usageFiltersData := []*egressRegionUsageFilterData{
		{
			usageName:   "first 1TB",
			usageNumber: 1024,
		},
		{
			usageName:   "next 9TB",
			usageNumber: 10240,
		},
		{
			usageName:   "over 10TB",
			usageNumber: 0,
		},
	}
	serviceName := "Cloud Storage"

	resource := &schema.Resource{
		Name:           r.Address,
		CostComponents: []*schema.CostComponent{},
	}

	// Same continent
	var quantity *decimal.Decimal
	if r.SameContinent != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.SameContinent))
	}

	var startUsage *string
	continent := regionToContinent(r.Region)
	// Northern America has three prices available to it, only the start usage 100 is applicable to us, as this is what is reflected in the
	// pricing calculator.
	if continent == "Northern America" {
		startUsage = strPtr("100")
	}

	resource.CostComponents = append(resource.CostComponents, &schema.CostComponent{
		Name:            fmt.Sprintf("%s in same continent", r.PrefixName),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("gcp"),
			Region:     strPtr("global"),
			Service:    strPtr("Cloud Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", Value: strPtr(fmt.Sprintf("Network Data Transfer GCP Inter Region within %s", continent))},
				{Key: "resourceGroup", Value: strPtr("InterregionEgress")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			StartUsageAmount: startUsage,
		},
		UsageBased: true,
	})

	for _, regData := range regionsData {
		usageKey := regData.usageKey
		usage := GetFloatFieldValueByUsageTag(usageKey, *r)
		newCostComponents := egressStepPricingHelper(usage, usageFiltersData, regData, "", serviceName)
		resource.CostComponents = append(resource.CostComponents, newCostComponents...)
	}

	return resource
}

type ComputeVPNGatewayNetworkEgressUsage struct {
	SameRegion   *float64 `infracost_usage:"same_region"`
	USOrCanada   *float64 `infracost_usage:"us_or_canada"`
	Europe       *float64 `infracost_usage:"europe"`
	Asia         *float64 `infracost_usage:"asia"`
	SouthAmerica *float64 `infracost_usage:"south_america"`
	Oceania      *float64 `infracost_usage:"oceania"`
	Worldwide    *float64 `infracost_usage:"worldwide"`

	NetworkEgressUsage
}

var ComputeVPNGatewayNetworkEgressUsageSchema = []*schema.UsageItem{
	{ValueType: schema.Float64, DefaultValue: 0, Key: "same_region"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "us_or_canada"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "europe"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "asia"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "south_america"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "oceania"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "worldwide"},
}

func (r *ComputeVPNGatewayNetworkEgressUsage) CoreType() string {
	return "ComputeVPNGatewayNetworkEgressUsage"
}

func (r *ComputeVPNGatewayNetworkEgressUsage) UsageSchema() []*schema.UsageItem {
	return ComputeVPNGatewayNetworkEgressUsageSchema
}

func (r *ComputeVPNGatewayNetworkEgressUsage) BuildResource() *schema.Resource {
	regionsData := []*egressRegionData{
		{
			gRegion: fmt.Sprintf("%s within the same region", r.PrefixName),
			// There is no same region option in APIs, so we always take this price in us-central1 region.
			apiDescription: "Network Inter Region Data Transfer Out from Americas to Virginia",
			usageKey:       "same_region",
			fixedRegion:    "us-central1",
		},
		{
			gRegion:        fmt.Sprintf("%s within the US or Canada", r.PrefixName),
			apiDescription: "Network Inter Region Data Transfer Out from Americas to Montreal",
			usageKey:       "us_or_canada",
			fixedRegion:    "us-central1",
		},
		{
			gRegion:        fmt.Sprintf("%s within Europe", r.PrefixName),
			apiDescription: "Network Inter Region Data Transfer Out from EMEA to Frankfurt",
			usageKey:       "europe",
			fixedRegion:    "europe-west1",
		},
		{
			gRegion:        fmt.Sprintf("%s within Asia", r.PrefixName),
			apiDescription: "Network Inter Region Data Transfer Out from Japan to Seoul",
			usageKey:       "asia",
			fixedRegion:    "asia-northeast1",
		},
		{
			gRegion:        fmt.Sprintf("%s within South America", r.PrefixName),
			apiDescription: "Network Inter Region Data Transfer Out from Sao Paulo to Sao Paulo",
			usageKey:       "south_america",
			fixedRegion:    "southamerica-east1",
		},
		{
			gRegion:        fmt.Sprintf("%s to/from Indonesia and Oceania", r.PrefixName),
			apiDescription: "Network Inter Region Data Transfer Out from Sydney to Jakarta",
			usageKey:       "oceania",
			fixedRegion:    "australia-southeast1",
		},
		{
			gRegion:        fmt.Sprintf("%s between continents (excludes Oceania)", r.PrefixName),
			apiDescription: "Network Inter Region Data Transfer Out from Finland to Singapore",
			usageKey:       "worldwide",
			fixedRegion:    "europe-north1",
		},
	}
	usageFiltersData := []*egressRegionUsageFilterData{
		{
			usageNumber: 0,
		},
	}
	defaultAPIRegionName := r.Region
	serviceName := "Compute Engine"

	resource := &schema.Resource{
		Name:           r.Address,
		CostComponents: []*schema.CostComponent{},
	}

	for _, regData := range regionsData {
		usageKey := regData.usageKey
		usage := GetFloatFieldValueByUsageTag(usageKey, *r)
		newCostComponents := egressStepPricingHelper(usage, usageFiltersData, regData, defaultAPIRegionName, serviceName)
		resource.CostComponents = append(resource.CostComponents, newCostComponents...)
	}

	return resource
}

type ComputeExternalVPNGatewayNetworkEgressUsage struct {
	Asia      *float64 `infracost_usage:"asia"`
	Worldwide *float64 `infracost_usage:"worldwide"`
	China     *float64 `infracost_usage:"china"`
	Australia *float64 `infracost_usage:"australia"`

	NetworkEgressUsage
}

var ComputeExternalVPNGatewayNetworkEgressUsageSchema = []*schema.UsageItem{
	{ValueType: schema.Float64, DefaultValue: 0, Key: "asia"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "worldwide"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "china"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "australia"},
}

func (r *ComputeExternalVPNGatewayNetworkEgressUsage) CoreType() string {
	return "ComputeExternalVPNGatewayNetworkEgressUsage"
}

func (r *ComputeExternalVPNGatewayNetworkEgressUsage) UsageSchema() []*schema.UsageItem {
	return ComputeExternalVPNGatewayNetworkEgressUsageSchema
}

func (r *ComputeExternalVPNGatewayNetworkEgressUsage) BuildResource() *schema.Resource {
	regionsData := []*egressRegionData{
		{
			gRegion: fmt.Sprintf("%s to worldwide excluding China, Australia but including Hong Kong", r.PrefixName),
			// There is no worldwide option in APIs, so we take a random region.
			apiDescription: "Network Vpn Internet Data Transfer Out from Americas to Americas",
			usageKey:       "worldwide",
		},
		{
			gRegion:        fmt.Sprintf("%s to China excluding Hong Kong", r.PrefixName),
			apiDescription: "Network Vpn Internet Data Transfer Out from Americas to China",
			usageKey:       "china",
		},
		{
			gRegion:        fmt.Sprintf("%s to Australia", r.PrefixName),
			apiDescription: "Network Vpn Internet Data Transfer Out from Americas to Australia",
			usageKey:       "australia",
		},
	}
	usageFiltersData := []*egressRegionUsageFilterData{
		{
			usageName:   "first 1TB",
			usageNumber: 1024,
		},
		{
			usageName:   "next 9TB",
			usageNumber: 10240,
		},
		{
			usageName:   "over 10TB",
			usageNumber: 0,
		},
	}
	defaultAPIRegionName := r.Region
	serviceName := "Compute Engine"

	resource := &schema.Resource{
		Name:           r.Address,
		CostComponents: []*schema.CostComponent{},
	}

	for _, regData := range regionsData {
		usageKey := regData.usageKey
		usage := GetFloatFieldValueByUsageTag(usageKey, *r)
		newCostComponents := egressStepPricingHelper(usage, usageFiltersData, regData, defaultAPIRegionName, serviceName)
		resource.CostComponents = append(resource.CostComponents, newCostComponents...)
	}

	return resource
}

type egressRegionData struct {
	gRegion             string // gRegion is the name used in pricing pages that is more human friendly.
	apiDescription      string
	apiDescriptionRegex string
	usageKey            string
	fixedRegion         string // fixedRegion is the region used in pricing API.
}

type egressRegionUsageFilterData struct {
	usageNumber float64
	usageName   string
}

func egressStepPricingHelper(usage float64, usageFiltersData []*egressRegionUsageFilterData, regData *egressRegionData, defaultAPIRegionName, serviceName string) []*schema.CostComponent {
	costComponents := make([]*schema.CostComponent, 0)
	// TODO: Reformat to use tier helpers.
	var used float64
	var lastEndUsageAmount float64

	for idx, usageFilter := range usageFiltersData {
		usageName := usageFilter.usageName
		endUsageAmount := usageFilter.usageNumber
		var quantity *decimal.Decimal
		if endUsageAmount != 0 && usage >= endUsageAmount {
			used = endUsageAmount - used
			lastEndUsageAmount = endUsageAmount
			quantity = decimalPtr(decimal.NewFromFloat(used))
		} else if usage > lastEndUsageAmount {
			used = usage - lastEndUsageAmount
			lastEndUsageAmount = endUsageAmount
			quantity = decimalPtr(decimal.NewFromFloat(used))
		}
		var usageFilter string
		if endUsageAmount != 0 {
			usageFilter = fmt.Sprint(endUsageAmount)
		} else {
			usageFilter = ""
		}
		if quantity == nil && idx > 0 {
			continue
		}
		var apiRegion *string
		if regData.fixedRegion != "" {
			apiRegion = strPtr(regData.fixedRegion)
		} else if defaultAPIRegionName != "" {
			apiRegion = strPtr(defaultAPIRegionName)
		}
		var name string
		if usageName != "" {
			name = fmt.Sprintf("%v (%v)", regData.gRegion, usageName)
		} else {
			name = fmt.Sprintf("%v", regData.gRegion)
		}
		attributeFilters := make([]*schema.AttributeFilter, 0)
		if regData.apiDescriptionRegex != "" {
			attributeFilters = append(attributeFilters, &schema.AttributeFilter{Key: "description", ValueRegex: strPtr(regData.apiDescriptionRegex)})
		} else {
			attributeFilters = append(attributeFilters, &schema.AttributeFilter{Key: "description", Value: strPtr(regData.apiDescription)})
		}
		costComponents = append(costComponents, &schema.CostComponent{
			Name:            name,
			Unit:            "GB",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: quantity,
			ProductFilter: &schema.ProductFilter{
				Region:           apiRegion,
				VendorName:       strPtr("gcp"),
				Service:          strPtr(serviceName),
				AttributeFilters: attributeFilters,
			},
			PriceFilter: &schema.PriceFilter{
				EndUsageAmount: strPtr(usageFilter),
			},
			UsageBased: true,
		})
	}
	return costComponents
}

################################################################################
# FILE: internal/resources/google/pubsub_subscription.go
# RESOURCE: google_pubsub_subscription
# SIZE: 3553 bytes | LINES: 102
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type PubSubSubscription struct {
	Address              string
	MonthlyMessageDataTB *float64 `infracost_usage:"monthly_message_data_tb"`
	StorageGB            *float64 `infracost_usage:"storage_gb"`
	SnapshotStorageGB    *float64 `infracost_usage:"snapshot_storage_gb"`
}

func (r *PubSubSubscription) CoreType() string {
	return "PubSubSubscription"
}

func (r *PubSubSubscription) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_message_data_tb", ValueType: schema.Float64, DefaultValue: 0.0},
		{Key: "storage_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "snapshot_storage_gb", ValueType: schema.Float64, DefaultValue: 0.0},
	}
}

func (r *PubSubSubscription) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *PubSubSubscription) BuildResource() *schema.Resource {
	var messageDataTB, storageGB, snapshotStorageGB *decimal.Decimal

	if r != nil {
		if r.MonthlyMessageDataTB != nil {
			messageDataTB = decimalPtr(decimal.NewFromFloat(*r.MonthlyMessageDataTB))
		}
		if r.StorageGB != nil {
			storageGB = decimalPtr(decimal.NewFromFloat(*r.StorageGB))
		}
		if r.SnapshotStorageGB != nil {
			snapshotStorageGB = decimalPtr(decimal.NewFromFloat(*r.SnapshotStorageGB))
		}
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Message delivery data",
				Unit:            "TiB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: messageDataTB,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr("global"),
					Service:       strPtr("Cloud Pub/Sub"),
					ProductFamily: strPtr("ApplicationServices"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", Value: strPtr("Message Delivery Basic")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					EndUsageAmount: strPtr(""),
				},
				UsageBased: true,
			},
			{
				Name:            "Retained acknowledged message storage",
				Unit:            "GiB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: storageGB,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr("global"),
					Service:       strPtr("Cloud Pub/Sub"),
					ProductFamily: strPtr("ApplicationServices"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", Value: strPtr("Subscriptions retained acknowledged messages")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					EndUsageAmount: strPtr(""),
				},
				UsageBased: true,
			},
			{
				Name:            "Snapshot message backlog storage",
				Unit:            "GiB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: snapshotStorageGB,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr("global"),
					Service:       strPtr("Cloud Pub/Sub"),
					ProductFamily: strPtr("ApplicationServices"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", Value: strPtr("Snapshots message backlog")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					EndUsageAmount: strPtr(""),
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/google/pubsub_topic.go
# RESOURCE: google_pubsub_topic
# SIZE: 1653 bytes | LINES: 52
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"github.com/shopspring/decimal"
)

type PubSubTopic struct {
	Address              string
	MonthlyMessageDataTB *float64 `infracost_usage:"monthly_message_data_tb"`
}

func (r *PubSubTopic) CoreType() string {
	return "PubSubTopic"
}

func (r *PubSubTopic) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_message_data_tb", ValueType: schema.Float64, DefaultValue: 0.0},
	}
}

func (r *PubSubTopic) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *PubSubTopic) BuildResource() *schema.Resource {
	var messageDataTB *decimal.Decimal

	if r.MonthlyMessageDataTB != nil {
		messageDataTB = decimalPtr(decimal.NewFromFloat(*r.MonthlyMessageDataTB))
	}

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:            "Message ingestion data",
				Unit:            "TiB",
				UnitMultiplier:  decimal.NewFromInt(1),
				MonthlyQuantity: messageDataTB,
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr("global"),
					Service:       strPtr("Cloud Pub/Sub"),
					ProductFamily: strPtr("ApplicationServices"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", Value: strPtr("Message Delivery Basic")},
					},
				},
				PriceFilter: &schema.PriceFilter{
					EndUsageAmount: strPtr(""),
				},
				UsageBased: true,
			},
		},
		UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/google/redis_cluster.go
# RESOURCE: google_redis_cluster
# SIZE: 4257 bytes | LINES: 121
################################################################################
package google

import (
	"fmt"
	"strings"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/shopspring/decimal"
)

var redisNodeTypeNames = map[string]string{
	"REDIS_SHARED_CORE_NANO": "shared core nano",
	"REDIS_STANDARD_SMALL":   "standard small",
	"REDIS_HIGHMEM_MEDIUM":   "highmem medium",
	"REDIS_HIGHMEM_XLARGE":   "highmem xlarge",
}

var redisNodeTypeDescSuffixes = map[string]string{
	"REDIS_SHARED_CORE_NANO": "Shared Core Nano",
	"REDIS_STANDARD_SMALL":   "Standard Small",
	"REDIS_HIGHMEM_MEDIUM":   "Default",
	"REDIS_HIGHMEM_XLARGE":   "Highmem XLarge",
}

type RedisCluster struct {
	Address          string
	Region           string
	NodeType         string
	NodeCount        int
	AOFProvisionedGB int64
	AOFEnabled       bool
	BackupsEnabled   bool
	BackupStorageGB  *float64 `infracost_usage:"backup_storage_gb"`
}

func (r *RedisCluster) CoreType() string {
	return "RedisCluster"
}

func (r *RedisCluster) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "backup_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

func (r *RedisCluster) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *RedisCluster) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	costComponents = append(costComponents, r.nodeTypeCostComponent())

	if r.AOFEnabled {
		costComponents = append(costComponents, r.aofCostComponent())
	}

	if r.BackupsEnabled {
		costComponents = append(costComponents, r.backupCostComponent())
	}

	return &schema.Resource{
		Name:           r.Address,
		CostComponents: costComponents,
		UsageSchema:    r.UsageSchema(),
	}
}

func (r *RedisCluster) nodeTypeCostComponent() *schema.CostComponent {
	nameSuffix, ok := redisNodeTypeNames[strings.ToUpper(r.NodeType)]
	if !ok {
		nameSuffix = r.NodeType
	}
	name := fmt.Sprintf("Cluster node (%s)", strings.ToLower(nameSuffix))

	descSuffix, ok := redisNodeTypeDescSuffixes[strings.ToUpper(r.NodeType)]
	if !ok {
		descSuffix = r.NodeType
	}
	descriptionRegex := fmt.Sprintf("Redis Cluster Node %s", descSuffix)

	return &schema.CostComponent{
		Name:           name,
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(int64(r.NodeCount))),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Cloud Memorystore for Redis"),
			ProductFamily: strPtr("ApplicationServices"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: regexPtr(descriptionRegex)},
			},
		},
	}
}

func (r *RedisCluster) aofCostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "AOF persistence",
		Unit:           "GB",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(r.AOFProvisionedGB)),
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Cloud Memorystore for Redis"),
			ProductFamily: strPtr("ApplicationServices"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: regexPtr("Memorystore for Redis Cluster: AOF Storage")},
			},
		},
	}
}

func (r *RedisCluster) backupCostComponent() *schema.CostComponent {
	var backupGB *decimal.Decimal
	if r.BackupStorageGB != nil {
		backupGB = decimalPtr(decimal.NewFromFloat(*r.BackupStorageGB).Mul(schema.HourToMonthUnitMultiplier))
	}

	return &schema.CostComponent{
		Name:            "Backups",
		Unit:            "GB",
		UnitMultiplier:  schema.HourToMonthUnitMultiplier,
		MonthlyQuantity: backupGB,
		ProductFilter: &schema.ProductFilter{
			VendorName:    strPtr("gcp"),
			Region:        strPtr(r.Region),
			Service:       strPtr("Cloud Memorystore for Redis"),
			ProductFamily: strPtr("ApplicationServices"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "description", ValueRegex: regexPtr("Memorystore for Redis Cluster: Backups")},
			},
		},
	}
}

################################################################################
# FILE: internal/resources/google/redis_instance.go
# RESOURCE: google_redis_instance
# SIZE: 2099 bytes | LINES: 68
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type RedisInstance struct {
	Address      string
	Region       string
	Tier         string
	MemorySizeGB float64
}

func (r *RedisInstance) CoreType() string {
	return "RedisInstance"
}

func (r *RedisInstance) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{}
}

func (r *RedisInstance) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *RedisInstance) BuildResource() *schema.Resource {
	serviceTier := "Basic"

	var tierMapping = map[string]string{
		"BASIC":       "Basic",
		"STANDARD_HA": "Standard",
	}

	if r.Tier != "" {
		serviceTier = tierMapping[r.Tier]
	}

	var memorySize = r.MemorySizeGB
	var capacityTier string

	if memorySize >= 1 && memorySize <= 4 {
		capacityTier = "M1"
	} else if memorySize >= 5 && memorySize <= 10 {
		capacityTier = "M2"
	} else if memorySize >= 11 && memorySize <= 35 {
		capacityTier = "M3"
	} else if memorySize >= 36 && memorySize <= 100 {
		capacityTier = "M4"
	} else {
		capacityTier = "M5"
	}

	description := fmt.Sprintf("/Redis Capacity %s %s/", serviceTier, capacityTier)
	name := fmt.Sprintf("Redis instance (%s, %s)", strings.ToLower(serviceTier), capacityTier)

	return &schema.Resource{
		Name: r.Address,
		CostComponents: []*schema.CostComponent{
			{
				Name:           name,
				Unit:           "GB",
				UnitMultiplier: schema.HourToMonthUnitMultiplier,
				HourlyQuantity: decimalPtr(decimal.NewFromFloat(memorySize)),
				ProductFilter: &schema.ProductFilter{
					VendorName:    strPtr("gcp"),
					Region:        strPtr(r.Region),
					Service:       strPtr("Cloud Memorystore for Redis"),
					ProductFamily: strPtr("ApplicationServices"),
					AttributeFilters: []*schema.AttributeFilter{
						{Key: "description", ValueRegex: strPtr(description)},
					},
				},
			},
		}, UsageSchema: r.UsageSchema(),
	}
}

################################################################################
# FILE: internal/resources/google/secret_manager_secret.go
# RESOURCE: google_secret_manager_secret
# SIZE: 5452 bytes | LINES: 127
################################################################################
package google

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// SecretManagerSecret represents Google Secret Manager's Secret resource.
//
// The cost of active secret versions depends on the number of replication
// locations. If it's more than one then the price is multiplied by the
// locations' quantity. Pricing API includes Free Tier, but it's not used.
//
// More resource information here: https://cloud.google.com/secret-manager
// Pricing information here: https://cloud.google.com/secret-manager/pricing
type SecretManagerSecret struct {
	Address              string
	Region               string
	ReplicationLocations int64

	// "usage" args
	ActiveSecretVersions         *int64 `infracost_usage:"active_secret_versions"`
	MonthlyAccessOperations      *int64 `infracost_usage:"monthly_access_operations"`
	MonthlyRotationNotifications *int64 `infracost_usage:"monthly_rotation_notifications"`
}

func (r *SecretManagerSecret) CoreType() string {
	return "SecretManagerSecret"
}

func (r *SecretManagerSecret) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "active_secret_versions", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_access_operations", DefaultValue: 0, ValueType: schema.Int64},
		{Key: "monthly_rotation_notifications", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the SecretManagerSecret.
// It uses the `infracost_usage` struct tags to populate data into the SecretManagerSecret.
func (r *SecretManagerSecret) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid SecretManagerSecret.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *SecretManagerSecret) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	costComponents = append(costComponents, r.activeSecretVersionsCostComponents()...)
	costComponents = append(costComponents, r.accessOperationsCostComponents()...)
	costComponents = append(costComponents, r.rotationNotificationsCostComponents()...)

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

// activeSecretVersionsCostComponents returns a cost component for Active Secret
// Versions.
// The cost is multiplied by the number of replication locations. Free tier
// pricing is excluded.
func (r *SecretManagerSecret) activeSecretVersionsCostComponents() []*schema.CostComponent {
	var quantity *int64

	if r.ActiveSecretVersions != nil {
		multiplied := r.ReplicationLocations * *r.ActiveSecretVersions
		quantity = &multiplied
	}

	return []*schema.CostComponent{
		{
			Name:            "Active secret versions",
			Unit:            "versions",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: intPtrToDecimalPtr(quantity),
			ProductFilter:   r.buildProductFilter("Secret version replica storage"),
			PriceFilter:     r.buildPriceFilter("6"),
			UsageBased:      true,
		},
	}
}

// accessOperationsCostComponents returns a cost component for Secret's Access
// Operations. Free tier pricing is excluded.
func (r *SecretManagerSecret) accessOperationsCostComponents() []*schema.CostComponent {
	multiplier := 10000

	return []*schema.CostComponent{
		{
			Name:            "Access operations",
			Unit:            "10K requests",
			UnitMultiplier:  decimal.NewFromInt(int64(multiplier)),
			MonthlyQuantity: intPtrToDecimalPtr(r.MonthlyAccessOperations),
			ProductFilter:   r.buildProductFilter("Secret access operations"),
			PriceFilter:     r.buildPriceFilter(fmt.Sprint(multiplier)),
			UsageBased:      true,
		},
	}
}

// rotationNotificationsCostComponents returns a cost component for Secret's
// Rotation Notifications. Free tier pricing is excluded.
func (r *SecretManagerSecret) rotationNotificationsCostComponents() []*schema.CostComponent {
	return []*schema.CostComponent{
		{
			Name:            "Rotation notifications",
			Unit:            "rotations",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: intPtrToDecimalPtr(r.MonthlyRotationNotifications),
			ProductFilter:   r.buildProductFilter("Secret rotate operations"),
			PriceFilter:     r.buildPriceFilter("3"),
			UsageBased:      true,
		},
	}
}

// buildProductFilter creates a product filter for Secret Manager's Secret
// product.
func (r *SecretManagerSecret) buildProductFilter(description string) *schema.ProductFilter {
	return &schema.ProductFilter{
		VendorName:    strPtr("gcp"),
		Region:        strPtr(r.Region),
		Service:       strPtr("Secret Manager"),
		ProductFamily: strPtr("ApplicationServices"),
		AttributeFilters: []*schema.AttributeFilter{
			{Key: "description", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", description))},
		},
	}
}

// buildPriceFilter creates a price filter based on start usage amount to ignore
// free tier pricing.
func (r *SecretManagerSecret) buildPriceFilter(startUsageAmount string) *schema.PriceFilter {
	return &schema.PriceFilter{
		PurchaseOption:   strPtr("OnDemand"),
		StartUsageAmount: strPtr(startUsageAmount),
	}
}

################################################################################
# FILE: internal/resources/google/secret_manager_secret_version.go
# RESOURCE: google_secret_manager_secret_version
# SIZE: 4421 bytes | LINES: 102
################################################################################
package google

import (
	"fmt"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
)

// SecretManagerSecretVersion represents one Google Secret Manager Secret's Version resource.
//
// The cost of active secret version depends on the number of replication
// locations specified by its parent secret. If it's more than one then the price
// is multiplied by the locations' quantity.
// Pricing API includes Free Tier, but it's not used.
//
// More resource information here: https://cloud.google.com/secret-manager
// Pricing information here: https://cloud.google.com/secret-manager/pricing
type SecretManagerSecretVersion struct {
	Address              string
	Region               string
	ReplicationLocations int64

	// "usage" args
	MonthlyAccessOperations *int64 `infracost_usage:"monthly_access_operations"`
}

func (r *SecretManagerSecretVersion) CoreType() string {
	return "SecretManagerSecretVersion"
}

func (r *SecretManagerSecretVersion) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "monthly_access_operations", DefaultValue: 0, ValueType: schema.Int64},
	}
}

// PopulateUsage parses the u schema.UsageData into the SecretManagerSecretVersion.
// It uses the `infracost_usage` struct tags to populate data into the SecretManagerSecretVersion.
func (r *SecretManagerSecretVersion) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

// BuildResource builds a schema.Resource from a valid SecretManagerSecretVersion.
// This method is called after the resource is initialised by an IaC provider.
// See providers folder for more information.
func (r *SecretManagerSecretVersion) BuildResource() *schema.Resource {
	costComponents := []*schema.CostComponent{}

	costComponents = append(costComponents, r.activeSecretVersionsCostComponents()...)
	costComponents = append(costComponents, r.accessOperationsCostComponents()...)

	return &schema.Resource{
		Name:           r.Address,
		UsageSchema:    r.UsageSchema(),
		CostComponents: costComponents,
	}
}

// activeSecretVersionsCostComponents returns a cost component for the Active Secret
// Version. By default it represents one version.
// The cost is multiplied by the number of replication locations. Free tier
// pricing is excluded.
func (r *SecretManagerSecretVersion) activeSecretVersionsCostComponents() []*schema.CostComponent {
	return []*schema.CostComponent{
		{
			Name:            "Active secret versions",
			Unit:            "versions",
			UnitMultiplier:  decimal.NewFromInt(1),
			MonthlyQuantity: intPtrToDecimalPtr(&r.ReplicationLocations),
			ProductFilter:   r.buildProductFilter("Secret version replica storage"),
			PriceFilter:     r.buildPriceFilter("6"),
		},
	}
}

// accessOperationsCostComponents returns a cost component for Secret Version's Access
// Operations. Free tier pricing is excluded.
func (r *SecretManagerSecretVersion) accessOperationsCostComponents() []*schema.CostComponent {
	multiplier := 10000

	return []*schema.CostComponent{
		{
			Name:            "Access operations",
			Unit:            "10K requests",
			UnitMultiplier:  decimal.NewFromInt(int64(multiplier)),
			MonthlyQuantity: intPtrToDecimalPtr(r.MonthlyAccessOperations),
			ProductFilter:   r.buildProductFilter("Secret access operations"),
			PriceFilter:     r.buildPriceFilter(fmt.Sprint(multiplier)),
			UsageBased:      true,
		},
	}
}

// buildProductFilter creates a product filter for Secret Manager's Secret
// product.
func (r *SecretManagerSecretVersion) buildProductFilter(description string) *schema.ProductFilter {
	return &schema.ProductFilter{
		VendorName:    strPtr("gcp"),
		Region:        strPtr(r.Region),
		Service:       strPtr("Secret Manager"),
		ProductFamily: strPtr("ApplicationServices"),
		AttributeFilters: []*schema.AttributeFilter{
			{Key: "description", ValueRegex: strPtr(fmt.Sprintf("/^%s$/i", description))},
		},
	}
}

// buildPriceFilter creates a price filter based on start usage amount to ignore
// free tier pricing.
func (r *SecretManagerSecretVersion) buildPriceFilter(startUsageAmount string) *schema.PriceFilter {
	return &schema.PriceFilter{
		PurchaseOption:   strPtr("OnDemand"),
		StartUsageAmount: strPtr(startUsageAmount),
	}
}

################################################################################
# FILE: internal/resources/google/sql_database_instance.go
# RESOURCE: google_sql_database_instance
# SIZE: 12520 bytes | LINES: 349
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type SQLDatabaseInstance struct {
	Address              string
	DiskSize             int64
	UseIPV4              bool
	ReplicaConfiguration string
	Tier                 string
	Edition              string
	AvailabilityType     string
	Region               string
	DatabaseVersion      string
	DiskType             string
	BackupStorageGB      *float64 `infracost_usage:"backup_storage_gb"`
}

func (r *SQLDatabaseInstance) CoreType() string {
	return "SQLDatabaseInstance"
}

func (r *SQLDatabaseInstance) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "backup_storage_gb", ValueType: schema.Float64, DefaultValue: 0},
	}
}

var lightweightRAM = decimal.NewFromInt(3840)
var standardRAMRatio = decimal.NewFromInt(3840)
var highmemRAMRatio = decimal.NewFromInt(6656)

func (r *SQLDatabaseInstance) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *SQLDatabaseInstance) BuildResource() *schema.Resource {
	var resource *schema.Resource

	if strings.EqualFold(r.Edition, "enterprise_plus") {
		logging.Logger.Warn().Msgf("edition %s of %s is not yet supported", r.Edition, r.Address)
		return nil
	}

	replica := false
	if r.ReplicaConfiguration != "" {
		replica = true
	}

	resource = r.costComponents(false)
	if replica {
		resource.SubResources = append(resource.SubResources, r.costComponents(true))
	}

	return resource
}

type SQLInstanceDBType int

const (
	MySQL SQLInstanceDBType = iota
	PostgreSQL
	SQLServer
)

func (r *SQLDatabaseInstance) costComponents(replica bool) *schema.Resource {
	var costComponents []*schema.CostComponent

	if r.AvailabilityType == "" || replica {
		r.AvailabilityType = "ZONAL"
	}

	if r.DiskType == "" {
		r.DiskType = "PD_SSD"
	}

	if r.DiskSize == 0 {
		r.DiskSize = 10
	}

	if r.IsShared() {
		costComponents = append(costComponents, r.sharedInstanceCostComponent())
	} else if r.IsLegacy() && r.dbType() == MySQL {
		costComponents = append(costComponents, r.legacyMySQLInstanceCostComponent())
	} else {
		costComponents = append(costComponents, r.instanceCostComponents()...)
	}

	costComponents = append(costComponents, r.storageCostComponent())

	if !replica {
		var backupGB *decimal.Decimal
		if r.BackupStorageGB != nil {
			backupGB = decimalPtr(decimal.NewFromFloat(*r.BackupStorageGB))
		}
		costComponents = append(costComponents, r.backupCostComponent(backupGB))

		if r.UseIPV4 {
			costComponents = append(costComponents, r.ipv4CostComponent())
		}
	}

	name := r.Address
	if replica {
		name = "Replica"
	}

	return &schema.Resource{
		Name:           name,
		CostComponents: costComponents,
	}
}

func (r *SQLDatabaseInstance) sharedInstanceCostComponent() *schema.CostComponent {
	var resourceGroup string
	if strings.EqualFold(r.Tier, "db-f1-micro") {
		resourceGroup = "SQLGen2InstancesF1Micro"
	} else if strings.EqualFold(r.Tier, "db-g1-small") {
		resourceGroup = "SQLGen2InstancesG1Small"
	} else {
		logging.Logger.Warn().Msgf("tier %s of %s is not supported", r.Tier, r.Address)
		return nil
	}

	descriptionRegex := fmt.Sprintf("Cloud SQL for %s: %s(?! - Extended).*", r.dbTypeDescName(), r.availabilityTypeDescName())

	return &schema.CostComponent{
		Name:           fmt.Sprintf("SQL instance (%s, %s)", r.Tier, strings.ToLower(r.AvailabilityType)),
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("gcp"),
			Region:     strPtr(r.Region),
			Service:    strPtr("Cloud SQL"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "resourceGroup", Value: strPtr(resourceGroup)},
				{Key: "description", ValueRegex: regexPtr(descriptionRegex)},
			},
		},
	}
}

func (r *SQLDatabaseInstance) legacyMySQLInstanceCostComponent() *schema.CostComponent {
	var resourceGroup string
	if r.IsStandard() {
		resourceGroup = "SQLGen2InstancesN1Standard"
	} else if r.IsHighMem() {
		resourceGroup = "SQLGen2InstancesN1Highmem"
	}

	vCPUs, err := r.vCPUs()
	if err != nil {
		logging.Logger.Warn().Msgf("vCPU of tier %s of %s is not parsable", r.Tier, r.Address)
		return nil
	}

	descriptionRegex := fmt.Sprintf("Cloud SQL for %s: %s - %s vCPU", r.dbTypeDescName(), r.availabilityTypeDescName(), vCPUs)

	return &schema.CostComponent{
		Name:           fmt.Sprintf("SQL instance (%s, %s)", r.Tier, strings.ToLower(r.AvailabilityType)),
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("gcp"),
			Region:     strPtr(r.Region),
			Service:    strPtr("Cloud SQL"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "resourceGroup", Value: strPtr(resourceGroup)},
				{Key: "description", ValueRegex: regexPtr(descriptionRegex)},
			},
		},
	}
}

func (r *SQLDatabaseInstance) instanceCostComponents() []*schema.CostComponent {
	cpuDescRegex := fmt.Sprintf("%s: %s - vCPU", r.dbTypeDescName(), r.availabilityTypeDescName())
	memDescRegex := fmt.Sprintf("%s: %s - RAM", r.dbTypeDescName(), r.availabilityTypeDescName())

	vCPUs, err := r.vCPUs()
	if err != nil {
		logging.Logger.Warn().Msgf("vCPU of tier %s of %s is not parsable: %s", r.Tier, r.Address, err)
		return nil
	}

	mem, err := r.memory()
	if err != nil {
		logging.Logger.Warn().Msgf("memory of tier %s of %s is not parsable: %s", r.Tier, r.Address, err)
		return nil
	}

	return []*schema.CostComponent{
		{
			Name:           fmt.Sprintf("vCPUs (%s, %s)", vCPUs, strings.ToLower(r.AvailabilityType)),
			Unit:           "hours",
			UnitMultiplier: decimal.NewFromInt(1),
			HourlyQuantity: decimalPtr(vCPUs),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("gcp"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cloud SQL"),
				ProductFamily: strPtr("ApplicationServices"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "description", ValueRegex: regexPtr(cpuDescRegex)},
				},
			},
		},
		{
			Name:           fmt.Sprintf("Memory (%s GB, %s)", mem, strings.ToLower(r.AvailabilityType)),
			Unit:           "GB",
			UnitMultiplier: schema.HourToMonthUnitMultiplier,
			HourlyQuantity: decimalPtr(mem),
			ProductFilter: &schema.ProductFilter{
				VendorName:    strPtr("gcp"),
				Region:        strPtr(r.Region),
				Service:       strPtr("Cloud SQL"),
				ProductFamily: strPtr("ApplicationServices"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "description", ValueRegex: regexPtr(memDescRegex)},
				},
			},
		},
	}
}

func (r *SQLDatabaseInstance) dbType() SQLInstanceDBType {
	if strings.HasPrefix(strings.ToLower(r.DatabaseVersion), "postgres") {
		return PostgreSQL
	} else if strings.HasPrefix(strings.ToLower(r.DatabaseVersion), "mysql") {
		return MySQL
	} else if strings.HasPrefix(strings.ToLower(r.DatabaseVersion), "sqlserver") {
		return SQLServer
	} else {
		return MySQL
	}
}

func (r *SQLDatabaseInstance) dbTypeDescName() string {
	dbTypeNames := map[SQLInstanceDBType]string{
		MySQL:      "MySQL",
		PostgreSQL: "PostgreSQL",
		SQLServer:  "SQL Server",
	}

	return dbTypeNames[r.dbType()]
}

func (r *SQLDatabaseInstance) availabilityTypeDescName() string {
	availabilityTypeNames := map[string]string{
		"REGIONAL": "Regional",
		"ZONAL":    "Zonal",
	}

	return availabilityTypeNames[r.AvailabilityType]
}

func (r *SQLDatabaseInstance) diskTypeDescName() string {
	diskTypeDescs := map[string]string{
		"PD_SSD": "Standard storage",
		"PD_HDD": "Low cost storage",
	}

	return diskTypeDescs[r.DiskType]
}

func (r *SQLDatabaseInstance) vCPUs() (decimal.Decimal, error) {
	p := strings.Split(r.Tier, "-")

	if len(p) < 3 {
		return decimal.Decimal{}, fmt.Errorf("tier %s has no vCPU data", r.Tier)
	}

	if r.IsCustom() {
		return decimal.NewFromString(p[2])
	}

	return decimal.NewFromString(p[len(p)-1])
}

func (r *SQLDatabaseInstance) memory() (decimal.Decimal, error) {
	if r.IsCustom() {
		p := strings.Split(r.Tier, "-")

		if len(p) < 4 {
			return decimal.Decimal{}, fmt.Errorf("tier %s has no RAM data", r.Tier)
		}

		v, err := decimal.NewFromString(p[len(p)-1])
		if err != nil {
			return decimal.Decimal{}, err
		}

		return v.Div(decimal.NewFromInt(1024)), nil
	} else if r.IsStandard() || r.IsHighMem() {
		vCPUs, err := r.vCPUs()
		if err != nil {
			return decimal.Decimal{}, err
		}

		if r.IsStandard() {
			return vCPUs.Mul(standardRAMRatio).Div(decimal.NewFromInt(1024)), nil
		} else if r.IsHighMem() {
			return vCPUs.Mul(highmemRAMRatio).Div(decimal.NewFromInt(1024)), nil
		}
	} else if r.isLightweight() {
		return lightweightRAM.Div(decimal.NewFromInt(1024)), nil
	}

	return decimal.Decimal{}, fmt.Errorf("tier %s has no RAM data", r.Tier)
}

func (r *SQLDatabaseInstance) storageCostComponent() *schema.CostComponent {
	diskType := r.DiskType
	diskTypeHumanReadableNames := map[string]string{
		"PD_SSD": "SSD",
		"PD_HDD": "HDD",
	}

	diskTypeAPIResourceGroup := map[string]string{
		"PD_SSD": "SSD",
		"PD_HDD": "PDStandard",
	}

	if r.dbType() == SQLServer {
		diskType = "PD_SSD"
	}

	return &schema.CostComponent{
		Name:            fmt.Sprintf("Storage (%s, %s)", diskTypeHumanReadableNames[diskType], strings.ToLower(r.AvailabilityType)),
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: decimalPtr(decimal.NewFromInt(r.DiskSize)),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("gcp"),
			Region:     strPtr(r.Region),
			Service:    strPtr("Cloud SQL"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "resourceGroup", Value: strPtr(diskTypeAPIResourceGroup[diskType])},
				{Key: "description", ValueRegex: regexPtr(fmt.Sprintf("%s: %s - %s", r.dbTypeDescName(), r.availabilityTypeDescName(), r.diskTypeDescName()))},
			},
		},
	}
}

func (r *SQLDatabaseInstance) backupCostComponent(quantity *decimal.Decimal) *schema.CostComponent {
	return &schema.CostComponent{
		Name:            "Backups",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("gcp"),
			Region:     strPtr(r.Region),
			Service:    strPtr("Cloud SQL"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "resourceGroup", Value: strPtr("PDSnapshot")},
				{Key: "description", ValueRegex: strPtr("/Cloud SQL: Backups/")},
			},
		},
		UsageBased: true,
	}
}

func (r *SQLDatabaseInstance) ipv4CostComponent() *schema.CostComponent {
	return &schema.CostComponent{
		Name:           "IP address (if unused)",
		Unit:           "hours",
		UnitMultiplier: decimal.NewFromInt(1),
		HourlyQuantity: decimalPtr(decimal.NewFromInt(1)),
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("gcp"),
			Region:     strPtr("global"),
			Service:    strPtr("Cloud SQL"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "resourceGroup", Value: strPtr("IpAddress")},
				{Key: "description", ValueRegex: strPtr("/IP address idling - hour/")},
			},
		},
	}
}

func (r *SQLDatabaseInstance) IsCustom() bool {
	return strings.HasPrefix(strings.ToLower(r.Tier), "db-custom-")
}

func (r *SQLDatabaseInstance) IsShared() bool {
	return strings.EqualFold(r.Tier, "db-f1-micro") || strings.EqualFold(r.Tier, "db-g1-small")
}

func (r *SQLDatabaseInstance) IsLegacy() bool {
	return strings.HasPrefix(strings.ToLower(r.Tier), "db-n1-")
}

func (r *SQLDatabaseInstance) IsStandard() bool {
	return strings.HasPrefix(strings.ToLower(r.Tier), "db-n1-standard") || strings.HasPrefix(strings.ToLower(r.Tier), "db-standard")
}

func (r *SQLDatabaseInstance) IsHighMem() bool {
	return strings.HasPrefix(strings.ToLower(r.Tier), "db-n1-highmem") || strings.HasPrefix(strings.ToLower(r.Tier), "db-highmem")
}

func (r *SQLDatabaseInstance) isLightweight() bool {
	return strings.HasPrefix(strings.ToLower(r.Tier), "db-lightweight")
}

################################################################################
# FILE: internal/resources/google/storage_bucket.go
# RESOURCE: google_storage_bucket
# SIZE: 8183 bytes | LINES: 224
################################################################################
package google

import (
	"github.com/infracost/infracost/internal/resources"
	"github.com/infracost/infracost/internal/schema"
	"github.com/infracost/infracost/internal/usage"

	"fmt"
	"strings"

	"github.com/shopspring/decimal"
)

type StorageBucket struct {
	Address                     string
	Region                      string
	Location                    string
	StorageClass                string
	StorageGB                   *float64                         `infracost_usage:"storage_gb"`
	MonthlyClassAOperations     *int64                           `infracost_usage:"monthly_class_a_operations"`
	MonthlyClassBOperations     *int64                           `infracost_usage:"monthly_class_b_operations"`
	MonthlyDataRetrievalGB      *float64                         `infracost_usage:"monthly_data_retrieval_gb"`
	MonthlyEgressDataTransferGB *StorageBucketNetworkEgressUsage `infracost_usage:"monthly_egress_data_transfer_gb"`
}

func (r *StorageBucket) CoreType() string {
	return "StorageBucket"
}

func (r *StorageBucket) UsageSchema() []*schema.UsageItem {
	return []*schema.UsageItem{
		{Key: "storage_gb", ValueType: schema.Float64, DefaultValue: 0},
		{Key: "monthly_class_a_operations", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_class_b_operations", ValueType: schema.Int64, DefaultValue: 0},
		{Key: "monthly_data_retrieval_gb", ValueType: schema.Float64, DefaultValue: 0},
		{
			Key:          "monthly_egress_data_transfer_gb",
			ValueType:    schema.SubResourceUsage,
			DefaultValue: &usage.ResourceUsage{Name: "monthly_egress_data_transfer_gb", Items: StorageBucketNetworkEgressUsageSchema},
		},
	}
}

func (r *StorageBucket) PopulateUsage(u *schema.UsageData) {
	resources.PopulateArgsWithUsage(r, u)
}

func (r *StorageBucket) BuildResource() *schema.Resource {
	if r.MonthlyEgressDataTransferGB == nil {
		r.MonthlyEgressDataTransferGB = &StorageBucketNetworkEgressUsage{}
	}
	region := r.Region
	components := []*schema.CostComponent{
		dataStorageCostComponent(r.Location, r.StorageClass, r.StorageGB),
	}
	data := dataRetrievalCostComponent(r)
	if data != nil {
		components = append(components, data)
	}
	components = append(components, operationsCostComponents(r.StorageClass, r.MonthlyClassAOperations, r.MonthlyClassBOperations)...)

	r.MonthlyEgressDataTransferGB.Region = region
	r.MonthlyEgressDataTransferGB.Address = "Network egress"
	r.MonthlyEgressDataTransferGB.PrefixName = "Data transfer"
	return &schema.Resource{
		Name:           r.Address,
		CostComponents: components,
		SubResources: []*schema.Resource{
			r.MonthlyEgressDataTransferGB.BuildResource(),
		}, UsageSchema: r.UsageSchema(),
	}
}

func getDSRegionResourceGroup(location, storageClass string) (string, string) {

	region := strings.ToLower(location)

	var resourceGroup string
	switch strings.ToLower(storageClass) {
	case "nearline":
		resourceGroup = "NearlineStorage"
	case "coldline":
		resourceGroup = "ColdlineStorage"
	case "archive":
		resourceGroup = "ArchiveStorage"
	default:
		resourceGroup = "RegionalStorage"
	}

	if strings.ToLower(resourceGroup) == "regionalstorage" {
		switch region {

		case "asia", "eu", "us":
			resourceGroup = "MultiRegionalStorage"

		case "asia1", "eur4", "nam4":

			resourceGroup = "MultiRegionalStorage"
		}
	}

	if region == "eu" && strings.ToLower(resourceGroup) == "multiregionalstorage" {
		region = "europe"
	}

	return region, resourceGroup
}

func dataStorageCostComponent(location, storageClass string, storageGB *float64) *schema.CostComponent {
	if location == "" {
		location = "US"
	}

	var quantity *decimal.Decimal
	if storageGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*storageGB))
	}
	if storageClass == "" {
		storageClass = "STANDARD"
	}

	region, resourceGroup := getDSRegionResourceGroup(location, storageClass)
	return &schema.CostComponent{
		Name:            fmt.Sprintf("Storage (%s)", strings.ToLower(storageClass)),
		Unit:            "GiB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("gcp"),
			Region:     strPtr(region),
			Service:    strPtr("Cloud Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "resourceGroup", Value: strPtr(resourceGroup)},
				{Key: "description", ValueRegex: strPtr("/^(?!.*?\\(Early Delete\\))/")},
			},
		},
		PriceFilter: &schema.PriceFilter{
			EndUsageAmount: strPtr(""),
		},
		UsageBased: true,
	}
}

func operationsCostComponents(storageClass string, monthlyClassAOperations, monthlyClassBOperations *int64) []*schema.CostComponent {
	var classAQuantity *decimal.Decimal
	if monthlyClassAOperations != nil {
		classAQuantity = decimalPtr(decimal.NewFromInt(*monthlyClassAOperations))
	}
	var classBQuantity *decimal.Decimal
	if monthlyClassBOperations != nil {
		classBQuantity = decimalPtr(decimal.NewFromInt(*monthlyClassBOperations))
	}
	if storageClass == "" {
		storageClass = "STANDARD"
	}

	storageClassResourceGroupMap := map[string]string{
		"STANDARD":       "RegionalOps",
		"REGIONAL":       "RegionalOps",
		"MULTI_REGIONAL": "MultiRegionalOps",
		"NEARLINE":       "NearlineOps",
		"COLDLINE":       "ColdlineOps",
		"ARCHIVE":        "ArchiveOps",
	}

	resourceGroup := storageClassResourceGroupMap[storageClass]

	var descriptionRegex string
	switch resourceGroup {
	case "RegionalOps":
		descriptionRegex = "^(?!Multi-Region|Dual-Region)(?:(?!Tagging).)*"
	case "MultiRegionalOps":
		descriptionRegex = "^(?:(?!Tagging).)*"
	default:
		descriptionRegex = "^(?!Regional|Multi-Region|Dual-Region|Region)(?:(?!Tagging).)*"
	}

	return []*schema.CostComponent{
		{
			Name:            "Object adds, bucket/object list (class A)",
			Unit:            "10k operations",
			UnitMultiplier:  decimal.NewFromInt(10000),
			MonthlyQuantity: classAQuantity,
			ProductFilter: &schema.ProductFilter{
				VendorName: strPtr("gcp"),
				Service:    strPtr("Cloud Storage"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "resourceGroup", Value: strPtr(resourceGroup)},
					{Key: "description", ValueRegex: regexPtr(fmt.Sprintf("%sClass A", descriptionRegex))},
				},
			},
			PriceFilter: &schema.PriceFilter{
				EndUsageAmount: strPtr(""),
			},
			UsageBased: true,
		},
		{
			Name:            "Object gets, retrieve bucket/object metadata (class B)",
			Unit:            "10k operations",
			UnitMultiplier:  decimal.NewFromInt(10000),
			MonthlyQuantity: classBQuantity,
			ProductFilter: &schema.ProductFilter{
				VendorName: strPtr("gcp"),
				Service:    strPtr("Cloud Storage"),
				AttributeFilters: []*schema.AttributeFilter{
					{Key: "resourceGroup", Value: strPtr(resourceGroup)},
					{Key: "description", ValueRegex: regexPtr(fmt.Sprintf("%sClass B", descriptionRegex))},
				},
			},
			PriceFilter: &schema.PriceFilter{
				EndUsageAmount: strPtr(""),
			},
			UsageBased: true,
		},
	}
}

func dataRetrievalCostComponent(r *StorageBucket) *schema.CostComponent {
	var quantity *decimal.Decimal
	if r.MonthlyDataRetrievalGB != nil {
		quantity = decimalPtr(decimal.NewFromFloat(*r.MonthlyDataRetrievalGB))
	}

	storageClass := "STANDARD"
	if r.StorageClass != "" {
		storageClass = r.StorageClass
	}

	storageClassResourceGroupMap := map[string]string{
		"NEARLINE": "NearlineOps",
		"COLDLINE": "ColdlineOps",
		"ARCHIVE":  "ArchiveOps",
	}
	resourceGroup := storageClassResourceGroupMap[storageClass]

	if resourceGroup == "" {
		return nil
	}

	return &schema.CostComponent{
		Name:            "Data retrieval",
		Unit:            "GB",
		UnitMultiplier:  decimal.NewFromInt(1),
		MonthlyQuantity: quantity,
		ProductFilter: &schema.ProductFilter{
			VendorName: strPtr("gcp"),
			Service:    strPtr("Cloud Storage"),
			AttributeFilters: []*schema.AttributeFilter{
				{Key: "resourceGroup", Value: strPtr(resourceGroup)},
				{Key: "description", ValueRegex: strPtr("/Retrieval/")},
			},
		},
		UsageBased: true,
	}
}

################################################################################
# FILE: internal/resources/google/util.go
# RESOURCE: google_util
# SIZE: 9268 bytes | LINES: 236
################################################################################
package google

import (
	"fmt"
	"reflect"
	"regexp"
	"strings"

	"github.com/shopspring/decimal"

	"github.com/infracost/infracost/internal/schema"
)

var (
	vendorName = strPtr("gcp")
	underscore = regexp.MustCompile(`_`)
)

func strPtr(s string) *string {
	return &s
}

// nolint:deadcode,unused
func regexPtr(regex string) *string {
	return strPtr(fmt.Sprintf("/%s/i", regex))
}

func decimalPtr(d decimal.Decimal) *decimal.Decimal {
	return &d
}

func intPtrToDecimalPtr(i *int64) *decimal.Decimal {
	if i == nil {
		return nil
	}
	return decimalPtr(decimal.NewFromInt(*i))
}

// nolint:deadcode,unused
func floatPtrToDecimalPtr(f *float64) *decimal.Decimal {
	if f == nil {
		return nil
	}
	return decimalPtr(decimal.NewFromFloat(*f))
}

// nolint:deadcode,unused
func contains(a []string, x string) bool {
	for _, n := range a {
		if x == n {
			return true
		}
	}
	return false
}

// RegionsUsage is a reusable type that represents a usage cost map.
// This can be used in resources that define a usage parameter that's changed on a per-region basis, e.g:
//
// monthly_data_processed_gb:
//
//	asia_northeast1: 188
//	asia_east2: 78
//
// can be handled by adding a usage cost property to your resource like so:
//
//	type MyResource struct {
//	   ...
//	   MonthlyDataProcessedGB *RegionsUsage `infracost_usage:"monthly_processed_gb"`
//	}
type RegionsUsage struct {
	AsiaEast1              *float64 `infracost_usage:"asia_east1"`
	AsiaEast2              *float64 `infracost_usage:"asia_east2"`
	AsiaNortheast1         *float64 `infracost_usage:"asia_northeast1"`
	AsiaNortheast2         *float64 `infracost_usage:"asia_northeast2"`
	AsiaNortheast3         *float64 `infracost_usage:"asia_northeast3"`
	AsiaSouth1             *float64 `infracost_usage:"asia_south1"`
	AsiaSouth2             *float64 `infracost_usage:"asia_south2"`
	AsiaSoutheast1         *float64 `infracost_usage:"asia_southeast1"`
	AsiaSoutheast2         *float64 `infracost_usage:"asia_southeast2"`
	AustraliaSoutheast1    *float64 `infracost_usage:"australia_southeast1"`
	AustraliaSoutheast2    *float64 `infracost_usage:"australia_southeast2"`
	EuropeCentral2         *float64 `infracost_usage:"europe_central2"`
	EuropeNorth1           *float64 `infracost_usage:"europe_north1"`
	EuropeWest1            *float64 `infracost_usage:"europe_west1"`
	EuropeWest2            *float64 `infracost_usage:"europe_west2"`
	EuropeWest3            *float64 `infracost_usage:"europe_west3"`
	EuropeWest4            *float64 `infracost_usage:"europe_west4"`
	EuropeWest6            *float64 `infracost_usage:"europe_west6"`
	NorthAmericaNortheast1 *float64 `infracost_usage:"northamerica_northeast1"`
	NorthAmericaNortheast2 *float64 `infracost_usage:"northamerica_northeast2"`
	SouthAmericaEast1      *float64 `infracost_usage:"southamerica_east1"`
	SouthAmericaWest1      *float64 `infracost_usage:"southamerica_west1"`
	USCentral1             *float64 `infracost_usage:"us_central1"`
	USEast1                *float64 `infracost_usage:"us_east1"`
	USEast4                *float64 `infracost_usage:"us_east4"`
	USWest1                *float64 `infracost_usage:"us_west1"`
	USWest2                *float64 `infracost_usage:"us_west2"`
	USWest3                *float64 `infracost_usage:"us_west3"`
	USWest4                *float64 `infracost_usage:"us_west4"`
}

// RegionUsageSchema is the schema representation of the RegionsUsage type.
// This can be used as a schema.SubResourceUsage to define a structure that's
// commonly used with resources that vary on a per region basis.
var RegionUsageSchema = []*schema.UsageItem{
	{ValueType: schema.Float64, DefaultValue: 0, Key: "asia_east1"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "asia_east2"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "asia_northeast1"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "asia_northeast2"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "asia_northeast3"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "asia_south1"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "asia_south2"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "asia_southeast1"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "asia_southeast2"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "australia_southeast1"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "australia_southeast2"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "europe_central2"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "europe_north1"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "europe_west1"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "europe_west2"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "europe_west3"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "europe_west4"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "europe_west6"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "northamerica_northeast1"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "northamerica_northeast2"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "southamerica_east1"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "southamerica_west1"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "us_central1"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "us_east1"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "us_east4"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "us_west1"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "us_west2"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "us_west3"},
	{ValueType: schema.Float64, DefaultValue: 0, Key: "us_west4"},
}

// RegionUsage defines a hard definition in the regions map.
type RegionUsage struct {
	Key   string
	Value float64
}

// Values returns RegionUsage as a slice which can be iterated over
// to create cost components. The keys of the regions returned have
// their underscores replaced with hypens so they can be used in
// product filters and cost lookups.
func (r RegionsUsage) Values() []RegionUsage {
	s := reflect.ValueOf(r)
	t := reflect.TypeOf(r)

	var regions []RegionUsage
	for i := 0; i < s.NumField(); i++ {
		f := s.Field(i)

		if f.IsNil() {
			continue
		}

		regions = append(regions, RegionUsage{
			Key:   underscore.ReplaceAllString(t.Field(i).Tag.Get("infracost_usage"), "-"),
			Value: *f.Interface().(*float64),
		})
	}

	return regions
}

func GetFloatFieldValueByUsageTag(tagValue string, s interface{}) float64 {
	rt := reflect.TypeOf(s)
	if rt.Kind() != reflect.Struct {
		return 0
	}
	for i := 0; i < rt.NumField(); i++ {
		f := rt.Field(i)
		v := strings.Split(f.Tag.Get("infracost_usage"), ",")[0] // use split to ignore tag "options" like omitempty, etc.
		if v == tagValue {
			r := reflect.ValueOf(s)
			field := reflect.Indirect(r).FieldByName(f.Name)
			if !field.Elem().IsValid() {
				return 0
			}
			return field.Elem().Float()
		}
	}
	return 0
}

func regionToContinent(region string) string {
	gcpRegionPrefixToContinent := map[string]string{
		"asia":         "Asia",
		"europe":       "Europe",
		"northamerica": "Northern America",
		"southamerica": "Latin America",
		"us":           "Northern America",
		"australia":    "Oceania",
	}

	pieces := strings.Split(region, "-")
	if len(pieces) == 0 {
		return "Northern America"
	}

	continent, ok := gcpRegionPrefixToContinent[pieces[0]]
	if !ok {
		return "Northern America"
	}

	return continent
}

func GetRegionTier(region string) string {
	tier, ok := regionTierMapping[region]
	if !ok {
		return "Tier Unknown"
	}
	return tier
}

var regionTierMapping = map[string]string{
	"asia-east1":        "Tier 1",
	"asia-northeast1":   "Tier 1",
	"asia-northeast2":   "Tier 1",
	"europe-north1":     "Tier 1",
	"europe-southwest1": "Tier 1",
	"europe-west1":      "Tier 1",
	"europe-west4":      "Tier 1",
	"europe-west8":      "Tier 1",
	"europe-west9":      "Tier 1",
	"me-west1":          "Tier 1",
	"us-central1":       "Tier 1",
	"us-east1":          "Tier 1",
	"us-east4":          "Tier 1",
	"us-east5":          "Tier 1",
	"us-south1":         "Tier 1",
	"us-west1":          "Tier 1",

	"africa-south1":           "Tier 2",
	"asia-east2":              "Tier 2",
	"asia-northeast3":         "Tier 2",
	"asia-southeast1":         "Tier 2",
	"asia-southeast2":         "Tier 2",
	"asia-south1":             "Tier 2",
	"asia-south2":             "Tier 2",
	"australia-southeast1":    "Tier 2",
	"australia-southeast2":    "Tier 2",
	"europe-central2":         "Tier 2",
	"europe-west10":           "Tier 2",
	"europe-west12":           "Tier 2",
	"europe-west2":            "Tier 2",
	"europe-west3":            "Tier 2",
	"europe-west6":            "Tier 2",
	"me-central1":             "Tier 2",
	"me-central2":             "Tier 2",
	"northamerica-northeast1": "Tier 2",
	"northamerica-northeast2": "Tier 2",
	"southamerica-east1":      "Tier 2",
	"southamerica-west1":      "Tier 2",
	"us-west2":                "Tier 2",
	"us-west3":                "Tier 2",
	"us-west4":                "Tier 2",
}

################################################################################
#                              END OF FILE                                     #
################################################################################

================================================================================
                              SUMMARY
================================================================================

Total Resource Mappers Combined: 258
Generated: 2026-01-16 20:43:54

Resources by Cloud Provider:  AWS : 113 mappers
  AZURE : 106 mappers
  GOOGLE : 39 mappers

Resource Types Included:  - aws_acm_certificate
  - aws_acmpca_certificate_authority
  - aws_api_gateway_rest_api
  - aws_api_gateway_stage
  - aws_apigatewayv2_api
  - aws_app_autoscaling_target
  - aws_autoscaling_group
  - aws_backup_vault
  - aws_cloudformation_stack
  - aws_cloudformation_stack_set
  - aws_cloudfront_distribution
  - aws_cloudfront_function
  - aws_cloudhsm_v2_hsm
  - aws_cloudtrail
  - aws_cloudwatch_dashboard
  - aws_cloudwatch_event_bus
  - aws_cloudwatch_log_group
  - aws_cloudwatch_metric_alarm
  - aws_codebuild_project
  - aws_config_config_rule
  - aws_config_configuration_recorder
  - aws_db_instance
  - aws_directory_service_directory
  - aws_dms_replication_instance
  - aws_docdb_cluster
  - aws_docdb_cluster_instance
  - aws_docdb_cluster_snapshot
  - aws_dx_connection
  - aws_dx_gateway_association
  - aws_dynamodb_table
  - aws_ebs_snapshot
  - aws_ebs_snapshot_copy
  - aws_ebs_volume
  - aws_ec2_client_vpn_endpoint
  - aws_ec2_client_vpn_network_association
  - aws_ec2_host
  - aws_ec2_traffic_mirror_session
  - aws_ec2_transit_gateway_peering_attachment
  - aws_ec2_transit_gateway_vpc_attachment
  - aws_ecr_repository
  - aws_ecs_service
  - aws_efs_file_system
  - aws_eip
  - aws_eks_cluster
  - aws_eks_fargate_profile
  - aws_eks_node_group
  - aws_elastic_beanstalk_environment
  - aws_elasticache_cluster
  - aws_elasticache_replication_group
  - aws_elb
  - aws_fsx_openzfs_file_system
  - aws_fsx_windows_file_system
  - aws_global_accelerator
  - aws_global_accelerator_endpoint_group
  - aws_glue_catalog_database
  - aws_glue_crawler
  - aws_glue_job
  - aws_grafana_workspace
  - aws_instance
  - aws_kinesis_firehose_delivery_stream
  - aws_kinesis_stream
  - aws_kinesisanalytics_application
  - aws_kinesisanalyticsv2_application
  - aws_kinesisanalyticsv2_application_snapshot
  - aws_kms_external_key
  - aws_kms_key
  - aws_lambda_function
  - aws_lambda_provisioned_concurrency_config
  - aws_launch_configuration
  - aws_launch_template
  - aws_lb
  - aws_lightsail_instance
  - aws_mq_broker
  - aws_msk_cluster
  - aws_mwaa_environment
  - aws_nat_gateway
  - aws_neptune_cluster
  - aws_neptune_cluster_instance
  - aws_neptune_cluster_snapshot
  - aws_networkfirewall_firewall
  - aws_rds_cluster
  - aws_rds_cluster_instance
  - aws_redshift_cluster
  - aws_route53_health_check
  - aws_route53_record
  - aws_route53_resolver_endpoint
  - aws_route53_zone
  - aws_s3_bucket
  - aws_s3_bucket_analytics_configuration
  - aws_s3_bucket_inventory
  - aws_s3_glacier_deep_archive_storage_class
  - aws_s3_glacier_flexible_retrieval_storage_class
  - aws_s3_intelligent_tiering_storage_class
  - aws_s3_one_zone_infrequent_access_storage_class
  - aws_s3_standard_infrequent_access_storage_class
  - aws_s3_standard_storage_class
  - aws_s3_storage_class_helpers
  - aws_search_domain
  - aws_secretsmanager_secret
  - aws_sfn_state_machine
  - aws_sns_topic
  - aws_sns_topic_subscription
  - aws_sqs_queue
  - aws_ssm_activation
  - aws_ssm_parameter
  - aws_transfer_server
  - aws_vpc_endpoint
  - aws_vpn_connection
  - aws_waf_web_acl
  - aws_wafv2_web_acl
  - azure_active_directory_domain_service
  - azure_active_directory_domain_service_replica_set
  - azure_api_management
  - azure_app_configuration
  - azure_app_service_certificate_binding
  - azure_app_service_certificate_order
  - azure_app_service_custom_hostname_binding
  - azure_app_service_environment
  - azure_app_service_plan
  - azure_application_gateway
  - azure_application_insights
  - azure_application_insights_standard_web_t
  - azure_application_insights_web_t
  - azure_automation_account
  - azure_automation_dsc_configuration
  - azure_automation_dsc_nodeconfiguration
  - azure_automation_job_schedule
  - azure_backup_protected_vm
  - azure_bastion_host
  - azure_cognitive_account_language
  - azure_cognitive_account_luis
  - azure_cognitive_account_speech
  - azure_cognitive_deployment
  - azure_container_registry
  - azure_data_factory
  - azure_data_factory_integration_runtime_azure
  - azure_data_factory_integration_runtime_azure_ssis
  - azure_data_factory_integration_runtime_managed
  - azure_data_factory_integration_runtime_self_hosted
  - azure_databricks_workspace
  - azure_dns_a_record
  - azure_dns_aaaa_record
  - azure_dns_caa_record
  - azure_dns_cname_record
  - azure_dns_mx_record
  - azure_dns_ns_record
  - azure_dns_ptr_record
  - azure_dns_srv_record
  - azure_dns_txt_record
  - azure_dns_zone
  - azure_eventgrid_topic
  - azure_express_route_connection
  - azure_express_route_gateway
  - azure_federated_identity_credential
  - azure_frontdoor
  - azure_frontdoor_firewall_policy
  - azure_function_app
  - azure_image
  - azure_iothub
  - azure_kubernetes_cluster
  - azure_kubernetes_cluster_node_pool
  - azure_lb
  - azure_linux_virtual_machine
  - azure_linux_virtual_machine_scale_set
  - azure_log_analytics_workspace
  - azure_logic_app_integration_account
  - azure_logic_app_standard
  - azure_machine_learning_compute_cluster
  - azure_machine_learning_compute_instance
  - azure_managed_disk
  - azure_monitor_action_group
  - azure_monitor_data_collection_rule
  - azure_monitor_diagnostic_setting
  - azure_monitor_metric_alert
  - azure_monitor_scheduled_query_rules_alert
  - azure_mssql_elasticpool
  - azure_mssql_managed_instance
  - azure_mysql_flexible_server
  - azure_network_connection_monitor
  - azure_network_ddos_protection_plan
  - azure_network_watcher
  - azure_network_watcher_flow_log
  - azure_postgresql_flexible_server
  - azure_powerbi_embedded
  - azure_private_dns_a_record
  - azure_private_dns_aaaa_record
  - azure_private_dns_cname_record
  - azure_private_dns_mx_record
  - azure_private_dns_ptr_record
  - azure_private_dns_resolver_dns_forwarding_ruleset
  - azure_private_dns_resolver_inbound_endpoint
  - azure_private_dns_resolver_outbound_endpoint
  - azure_private_dns_srv_record
  - azure_private_dns_txt_record
  - azure_private_dns_zone
  - azure_recovery_services_vault
  - azure_security_center_subscription_pricing
  - azure_service_plan
  - azure_servicebus_namespace
  - azure_signalr_service
  - azure_sql_database
  - azure_sql_managed_instance
  - azure_storage_account
  - azure_storage_queue
  - azure_storage_share
  - azure_traffic_manager_endpoint
  - azure_traffic_manager_profile
  - azure_virtual_hub
  - azure_virtual_machine
  - azure_virtual_machine_scale_set
  - azure_virtual_network_peering
  - azure_vpn_gateway
  - azure_vpn_gateway_connection
  - azure_windows_virtual_machine
  - azure_windows_virtual_machine_scale_set
  - google_artifact_registry_repository
  - google_bigquery_dataset
  - google_bigquery_table
  - google_cloud_run_v2_job
  - google_cloud_run_v2_service
  - google_cloudfunctions_function
  - google_compute_address
  - google_compute_cost_component_helpers
  - google_compute_disk
  - google_compute_external_vpn_gateway
  - google_compute_forwarding_rule
  - google_compute_image
  - google_compute_instance
  - google_compute_instance_group_manager
  - google_compute_machine_image
  - google_compute_region_instance_group_manager
  - google_compute_router_nat
  - google_compute_snapshot
  - google_compute_target_grpc_proxy
  - google_compute_vpn_gateway
  - google_compute_vpn_tunnel
  - google_container_cluster
  - google_container_node_pool
  - google_container_registry
  - google_dns_managed_zone
  - google_dns_record_set
  - google_kms_crypto_key
  - google_logging
  - google_monitoring_metric_descriptor
  - google_network_egress_internal
  - google_pubsub_subscription
  - google_pubsub_topic
  - google_redis_cluster
  - google_redis_instance
  - google_secret_manager_secret
  - google_secret_manager_secret_version
  - google_sql_database_instance
  - google_storage_bucket

================================================================================
