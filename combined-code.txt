################################################################################
#                                                                              #
#                    TERRAFORM COST ESTIMATION SYSTEM                          #
#                         Combined Source Code                                 #
#                                                                              #
#                    Generated: 2026-01-16 14:06:11                          #
#                                                                              #
################################################################################

================================================================================
                           DIRECTORY STRUCTURE
================================================================================
cost estimation/
|-- adapters/
|   |-- cli/
|   |   +-- adapter.go
|   |-- git/
|   |-- terraform/
|   |   |-- hcl/
|   |   |   |-- cty_safe.go
|   |   |   +-- scanner.go
|   |   +-- plan/
|   +-- terragrunt/
|-- api/
|   +-- handlers/
|-- clouds/
|   |-- aws/
|   |   |-- assets/
|   |   |   |-- compute.go
|   |   |   |-- database.go
|   |   |   |-- ec2.go
|   |   |   |-- network.go
|   |   |   |-- other.go
|   |   |   +-- storage.go
|   |   |-- pricing/
|   |   |   +-- source.go
|   |   |-- usage/
|   |   |   +-- estimators.go
|   |   +-- plugin.go
|   |-- azure/
|   |-- gcp/
|   +-- registry.go
|-- cmd/
|   |-- cli/
|   |   |-- cmd/
|   |   |   |-- estimate.go
|   |   |   +-- root.go
|   |   +-- main.go
|   +-- server/
|-- core/
|   |-- asset/
|   |   |-- builder.go
|   |   +-- registry.go
|   |-- confidence/
|   |   |-- pessimistic.go
|   |   +-- propagation.go
|   |-- cost/
|   |   |-- confidence.go
|   |   |-- engine.go
|   |   +-- graph.go
|   |-- detection/
|   |   +-- detector.go
|   |-- determinism/
|   |   +-- stable.go
|   |-- diff/
|   |   |-- dependency_diff.go
|   |   +-- differ.go
|   |-- enforcement/
|   |   +-- pipeline.go
|   |-- engine/
|   |   |-- engine.go
|   |   +-- orchestrator.go
|   |-- expansion/
|   |   |-- expander.go
|   |   +-- expander_test.go
|   |-- expression/
|   |   |-- context.go
|   |   |-- reference.go
|   |   +-- value.go
|   |-- graph/
|   |   |-- bypass_prevention.go
|   |   |-- canonical_graph.go
|   |   |-- concurrent.go
|   |   |-- dependency_cost.go
|   |   |-- derived_cost.go
|   |   |-- enforced_asset.go
|   |   |-- enforced_cost.go
|   |   |-- expansion_guard.go
|   |   |-- infrastructure.go
|   |   |-- invariant_checker.go
|   |   +-- invariant_test.go
|   |-- guards/
|   |   +-- invariants.go
|   |-- input/
|   |   +-- envelope.go
|   |-- model/
|   |   |-- definition.go
|   |   |-- enforced_identity.go
|   |   +-- identity.go
|   |-- output/
|   |   |-- formats/
|   |   +-- formatter.go
|   |-- policy/
|   |   |-- deep_policy.go
|   |   |-- diff_policy.go
|   |   |-- evaluator.go
|   |   |-- explanation.go
|   |   +-- full_lineage.go
|   |-- pricing/
|   |   |-- alias_rate_key.go
|   |   |-- cache_governance.go
|   |   |-- enforcer.go
|   |   |-- immutable_store.go
|   |   |-- pricing_gate.go
|   |   |-- resolver.go
|   |   +-- snapshot.go
|   |-- scanner/
|   |   |-- registry.go
|   |   +-- scanner.go
|   |-- terraform/
|   |   |-- data_barrier.go
|   |   |-- dependencies.go
|   |   |-- determinism_class.go
|   |   |-- dynamic.go
|   |   |-- function_class.go
|   |   |-- module_outputs.go
|   |   |-- phased_expansion.go
|   |   |-- pipeline.go
|   |   |-- provider.go
|   |   |-- provider_binding.go
|   |   |-- provider_context.go
|   |   |-- provider_finalization.go
|   |   |-- safe_expansion.go
|   |   |-- strict_mode.go
|   |   |-- strict_module_output.go
|   |   |-- strict_unknown.go
|   |   +-- unknown.go
|   |-- types/
|   |   |-- asset.go
|   |   |-- cost.go
|   |   |-- pricing.go
|   |   |-- project.go
|   |   |-- types.go
|   |   +-- usage.go
|   |-- ui/
|   |   |-- runner.go
|   |   +-- terminal.go
|   +-- usage/
|       |-- assumptions.go
|       |-- estimator.go
|       |-- registry.go
|       +-- strict_defaults.go
|-- examples/
|   +-- aws-simple/
|       +-- main.tf
|-- internal/
|   |-- config/
|   |   +-- config.go
|   |-- errors/
|   |   +-- errors.go
|   +-- logging/
|       +-- logging.go
|-- pkg/
|   +-- client/
|-- storage/
|   |-- estimates/
|   +-- pricing/
|-- testdata/
|   |-- expected_outputs/
|   |-- pricing/
|   |   +-- snapshots/
|   +-- terraform/
|       |-- bad_configs/
|       |   |-- circular_dependency.tf
|       |   |-- duplicate_resource.tf
|       |   |-- invalid_for_each.tf
|       |   |-- missing_required.tf
|       |   |-- syntax_error.tf
|       |   +-- type_mismatch.tf
|       |-- basic/
|       |   |-- high_cost.tf
|       |   |-- mixed_resources.tf
|       |   |-- multiple_resources.tf
|       |   +-- single_resource.tf
|       |-- dynamic_blocks/
|       |   |-- conditional_dynamic.tf
|       |   |-- multiple_dynamic.tf
|       |   |-- nested_dynamic.tf
|       |   +-- single_dynamic.tf
|       |-- edge_cases/
|       |   |-- circular_reference.tf
|       |   |-- complex_locals.tf
|       |   |-- conditional_resource.tf
|       |   |-- data_source_dependency.tf
|       |   |-- lifecycle.tf
|       |   |-- moved_import.tf
|       |   |-- null_optional.tf
|       |   |-- self_reference.tf
|       |   |-- sensitive_values.tf
|       |   |-- splat_expression.tf
|       |   |-- terraform_functions.tf
|       |   |-- unknown_count.tf
|       |   +-- workspaces.tf
|       |-- expansion/
|       |   |-- complex_for_each.tf
|       |   |-- count_from_length.tf
|       |   |-- count_variable.tf
|       |   |-- count_zero.tf
|       |   |-- for_each_fileset.tf
|       |   |-- for_each_map.tf
|       |   |-- for_each_set.tf
|       |   |-- for_each_toset.tf
|       |   |-- nested_count_for_each.tf
|       |   +-- triple_nested.tf
|       |-- modules/
|       |   |-- local_module.tf
|       |   |-- module_count.tf
|       |   |-- module_with_outputs.tf
|       |   +-- nested_modules.tf
|       +-- providers/
|           |-- alias_basic.tf
|           |-- alias_module_inherit.tf
|           |-- multi_region_modules.tf
|           +-- multiple_same_type.tf
|-- .gitignore
|-- combine-code.ps1
|-- docker-compose.yml
|-- Dockerfile
|-- go.mod
|-- go.sum
|-- infracost-code.txt
+-- README.md

================================================================================
                              SOURCE FILES
================================================================================

################################################################################
# FILE: :\good projects\cost estimation\.gitignore
# TYPE: text
# SIZE: 2585 bytes
################################################################################
# =========================
# Go
# =========================
# Binaries
*.exe
*.exe~
*.dll
*.so
*.dylib
terraform-cost
terraform-cost-server

# Test binary
*.test

# Output of go coverage tool
*.out

# Go workspace file
go.work

# Vendor directory (if not using modules)
# vendor/

# =========================
# IDE / Editor
# =========================
# VS Code
.vscode/
*.code-workspace

# JetBrains (GoLand, IntelliJ)
.idea/
*.iml
*.iws
*.ipr

# Vim
*.swp
*.swo
*~

# Emacs
*~
\#*\#
/.emacs.desktop
/.emacs.desktop.lock
*.elc

# Sublime Text
*.sublime-workspace
*.sublime-project

# =========================
# OS Generated
# =========================
# macOS
.DS_Store
.AppleDouble
.LSOverride
._*
.Spotlight-V100
.Trashes

# Windows
Thumbs.db
Thumbs.db:encryptable
ehthumbs.db
ehthumbs_vista.db
*.stackdump
Desktop.ini
$RECYCLE.BIN/
*.lnk

# Linux
*~

# =========================
# Terraform (test files)
# =========================
*.tfstate
*.tfstate.*
*.tfstate.backup
.terraform/
.terraform.lock.hcl
crash.log
crash.*.log
override.tf
override.tf.json
*_override.tf
*_override.tf.json
.terraformrc
terraform.rc

# =========================
# Application Specific
# =========================
# Local config
.terraform-cost.json
.terraform-cost.yaml
.terraform-cost.yml
config.local.json
config.local.yaml

# Cache
.cache/
cache/
*.cache

# Data directory
data/
*.db
*.sqlite
*.sqlite3

# Pricing data exports
pricing-*.json
pricing-*.csv

# Logs
logs/
*.log

# Temp files
tmp/
temp/
*.tmp

# Build artifacts
dist/
build/

# Coverage reports
coverage/
coverage.html
coverage.txt

# Secrets (NEVER commit these)
secrets/
*.pem
*.key
*.crt
*.p12
*.pfx
.env
.env.*
!.env.example

# =========================
# Docker
# =========================
# Ignore local docker overrides
docker-compose.override.yml
docker-compose.local.yml
.docker/

# =========================
# CI/CD
# =========================
# GitHub Actions local testing
.act/

# =========================
# Testing
# =========================
# Test output
testdata/output/
*.test.json

# Benchmarks
*.bench

# =========================
# Documentation
# =========================
# Generated docs
docs/_build/
site/

# =========================
# Project directories to ignore
# =========================
# User's terraform projects mounted in docker
projects/

# Local examples with real data
examples/local/
examples/private/

################################################################################
# FILE: :\good projects\cost estimation\combine-code.ps1
# TYPE: powershell
# SIZE: 10256 bytes
################################################################################
<#
.SYNOPSIS
    Combines all source code files into a single combined-code.txt file.

.DESCRIPTION
    This script:
    1. Generates a directory tree structure
    2. Combines all relevant source files into a single file
    3. Excludes binary files, dependencies, and build artifacts
    4. Includes file separators with full paths for easy navigation

.PARAMETER OutputFile
    The output file path. Default: combined-code.txt

.PARAMETER ProjectPath
    The project root path. Default: current directory

.EXAMPLE
    .\combine-code.ps1
    .\combine-code.ps1 -OutputFile "all-code.txt" -ProjectPath "D:\my-project"
#>

param(
    [string]$OutputFile = "combined-code.txt",
    [string]$ProjectPath = "."
)

# Resolve to absolute path
$ProjectPath = Resolve-Path $ProjectPath

Write-Host "==================================" -ForegroundColor Cyan
Write-Host "  Code Combiner Script" -ForegroundColor Cyan
Write-Host "==================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "Project Path: $ProjectPath" -ForegroundColor Yellow
Write-Host "Output File:  $OutputFile" -ForegroundColor Yellow
Write-Host ""

# File extensions to include
$IncludeExtensions = @(
    "*.go",
    "*.mod",
    "*.sum",
    "*.tf",
    "*.tfvars",
    "*.json",
    "*.yaml",
    "*.yml",
    "*.toml",
    "*.md",
    "*.txt",
    "*.sh",
    "*.ps1",
    "*.sql",
    "*.hcl",
    "Dockerfile*",
    "docker-compose*",
    "Makefile",
    ".gitignore",
    ".dockerignore"
)

# Directories to exclude
$ExcludeDirectories = @(
    ".git",
    ".idea",
    ".vscode",
    "node_modules",
    "vendor",
    ".terraform",
    "dist",
    "build",
    "bin",
    "__pycache__",
    ".cache",
    "cache",
    "tmp",
    "temp",
    "logs",
    "coverage"
)

# Files to exclude
$ExcludeFiles = @(
    "combined-code.txt",
    "*.exe",
    "*.dll",
    "*.so",
    "*.dylib",
    "*.zip",
    "*.tar",
    "*.gz",
    "*.db",
    "*.sqlite",
    "*.log",
    "*.tfstate",
    "*.tfstate.backup",
    "go.sum",
    "infracost-code.txt"
)

# Create output file and clear if exists
$OutputFullPath = Join-Path $ProjectPath $OutputFile
if (Test-Path $OutputFullPath) {
    Remove-Item $OutputFullPath -Force
}

# =================================
# Section 1: Directory Structure
# =================================
Write-Host "Generating directory structure..." -ForegroundColor Green

$timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
$content = @"
################################################################################
#                                                                              #
#                    TERRAFORM COST ESTIMATION SYSTEM                          #
#                         Combined Source Code                                 #
#                                                                              #
#                    Generated: $timestamp                          #
#                                                                              #
################################################################################

================================================================================
                           DIRECTORY STRUCTURE
================================================================================

"@

# Generate directory tree using ASCII characters
function Get-DirectoryTree {
    param(
        [string]$Path,
        [string]$Prefix = "",
        [int]$MaxDepth = 10,
        [int]$CurrentDepth = 0
    )

    if ($CurrentDepth -ge $MaxDepth) { return "" }

    $output = ""
    $items = Get-ChildItem -Path $Path -Force | Where-Object {
        $item = $_
        $isExcluded = $false
        
        # Check if directory should be excluded
        if ($item.PSIsContainer) {
            foreach ($exclude in $ExcludeDirectories) {
                if ($item.Name -eq $exclude) {
                    $isExcluded = $true
                    break
                }
            }
        }
        
        -not $isExcluded
    } | Sort-Object { -not $_.PSIsContainer }, Name

    $count = $items.Count
    $index = 0

    foreach ($item in $items) {
        $index++
        $isLast = ($index -eq $count)
        
        # Use ASCII characters instead of Unicode
        if ($isLast) {
            $connector = "+-- "
            $extension = "    "
        } else {
            $connector = "|-- "
            $extension = "|   "
        }

        if ($item.PSIsContainer) {
            $output += "$Prefix$connector$($item.Name)/`n"
            $output += Get-DirectoryTree -Path $item.FullName -Prefix "$Prefix$extension" -MaxDepth $MaxDepth -CurrentDepth ($CurrentDepth + 1)
        } else {
            $output += "$Prefix$connector$($item.Name)`n"
        }
    }

    return $output
}

$projectName = Split-Path $ProjectPath -Leaf
$content += "$projectName/`n"
$content += Get-DirectoryTree -Path $ProjectPath

$content += @"

================================================================================
                              SOURCE FILES
================================================================================

"@

# =================================
# Section 2: Combine Source Files
# =================================
Write-Host "Collecting source files..." -ForegroundColor Green

# Collect all files matching our patterns
$allFiles = @()

foreach ($pattern in $IncludeExtensions) {
    $files = Get-ChildItem -Path $ProjectPath -Filter $pattern -Recurse -File -ErrorAction SilentlyContinue | Where-Object {
        $file = $_
        $include = $true
        
        # Check if in excluded directory
        foreach ($excludeDir in $ExcludeDirectories) {
            if ($file.FullName -like "*\$excludeDir\*" -or $file.FullName -like "*/$excludeDir/*") {
                $include = $false
                break
            }
        }
        
        # Check if file should be excluded
        foreach ($excludeFile in $ExcludeFiles) {
            if ($file.Name -like $excludeFile) {
                $include = $false
                break
            }
        }
        
        $include
    }
    
    $allFiles += $files
}

# Remove duplicates and sort
$allFiles = $allFiles | Sort-Object FullName -Unique

Write-Host "Found $($allFiles.Count) files to combine" -ForegroundColor Yellow

# Group files by directory for better organization
$filesByDir = $allFiles | Group-Object { Split-Path $_.FullName -Parent }

$processedCount = 0
foreach ($group in $filesByDir | Sort-Object Name) {
    foreach ($file in $group.Group | Sort-Object Name) {
        $relativePath = $file.FullName.Substring($ProjectPath.Path.Length + 1)
        $processedCount++
        
        Write-Host "  [$processedCount/$($allFiles.Count)] $relativePath" -ForegroundColor Gray
        
        # Determine file type for syntax highlighting hint
        $fileType = switch -Regex ($file.Extension) {
            "\.go$" { "go" }
            "\.tf$|\.hcl$" { "hcl" }
            "\.json$" { "json" }
            "\.ya?ml$" { "yaml" }
            "\.md$" { "markdown" }
            "\.ps1$" { "powershell" }
            "\.sh$" { "bash" }
            "\.sql$" { "sql" }
            default { "text" }
        }
        
        $fileSize = $file.Length
        $separator = @"

################################################################################
# FILE: $relativePath
# TYPE: $fileType
# SIZE: $fileSize bytes
################################################################################

"@
        $content += $separator
        
        try {
            $fileContent = Get-Content -Path $file.FullName -Raw -ErrorAction Stop
            if ($fileContent) {
                $content += $fileContent
                # Ensure file ends with newline
                if (-not $fileContent.EndsWith("`n")) {
                    $content += "`n"
                }
            }
        } catch {
            $content += "# ERROR: Could not read file - $($_.Exception.Message)`n"
        }
    }
}

# =================================
# Section 3: Summary
# =================================
$summaryTimestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
$content += @"

################################################################################
#                              END OF FILE                                     #
################################################################################

================================================================================
                                SUMMARY
================================================================================

Total Files Combined: $($allFiles.Count)
Generated: $summaryTimestamp
Project: $projectName

Files by Type:
"@

# Count files by extension
$extensionCounts = $allFiles | Group-Object Extension | Sort-Object Count -Descending
foreach ($ext in $extensionCounts) {
    $extName = if ($ext.Name) { $ext.Name } else { "(no extension)" }
    $content += "  $extName : $($ext.Count) files`n"
}

$content += @"

================================================================================
"@

# Write to output file
Write-Host ""
Write-Host "Writing output file..." -ForegroundColor Green
$content | Out-File -FilePath $OutputFullPath -Encoding UTF8

# Get output file size
$outputSize = (Get-Item $OutputFullPath).Length
$outputSizeMB = [math]::Round($outputSize / 1MB, 2)
$outputSizeKB = [math]::Round($outputSize / 1KB, 2)

Write-Host ""
Write-Host "==================================" -ForegroundColor Cyan
Write-Host "  Complete!" -ForegroundColor Green
Write-Host "==================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "Output: $OutputFullPath" -ForegroundColor Yellow
Write-Host "Size:   $outputSizeKB KB ($outputSizeMB MB)" -ForegroundColor Yellow
Write-Host "Files:  $($allFiles.Count) combined" -ForegroundColor Yellow
Write-Host ""

################################################################################
# FILE: :\good projects\cost estimation\docker-compose.yml
# TYPE: yaml
# SIZE: 3175 bytes
################################################################################
version: "3.9"

services:
  # =========================
  # CLI Service (for batch jobs)
  # =========================
  terraform-cost:
    build:
      context: .
      dockerfile: Dockerfile
    image: terraform-cost:latest
    container_name: terraform-cost-cli
    volumes:
      # Mount your Terraform projects here
      - ./projects:/projects:ro
      # Persist cache and data
      - terraform-cost-cache:/app/cache
      - terraform-cost-data:/app/data
      # Custom config (optional)
      - ./config:/app/config:ro
    environment:
      - TERRAFORM_COST_LOG_LEVEL=info
      - TERRAFORM_COST_DEFAULT_REGION=us-east-1
    # Override command for different operations
    command: ["estimate", "/projects"]
    networks:
      - terraform-cost-network

  # =========================
  # API Server (future)
  # =========================
  # terraform-cost-api:
  #   build:
  #     context: .
  #     dockerfile: Dockerfile.server
  #   image: terraform-cost-api:latest
  #   container_name: terraform-cost-api
  #   ports:
  #     - "8080:8080"
  #   volumes:
  #     - terraform-cost-cache:/app/cache
  #     - terraform-cost-data:/app/data
  #   environment:
  #     - TERRAFORM_COST_API_PORT=8080
  #     - TERRAFORM_COST_LOG_LEVEL=info
  #   healthcheck:
  #     test: ["CMD", "wget", "-q", "--spider", "http://localhost:8080/health"]
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #     start_period: 10s
  #   networks:
  #     - terraform-cost-network
  #   restart: unless-stopped

  # =========================
  # Pricing Database (future)
  # =========================
  # pricing-db:
  #   image: postgres:16-alpine
  #   container_name: terraform-cost-db
  #   environment:
  #     - POSTGRES_DB=terraform_cost
  #     - POSTGRES_USER=terraform_cost
  #     - POSTGRES_PASSWORD_FILE=/run/secrets/db_password
  #   volumes:
  #     - pricing-db-data:/var/lib/postgresql/data
  #     - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql:ro
  #   secrets:
  #     - db_password
  #   healthcheck:
  #     test: ["CMD-SHELL", "pg_isready -U terraform_cost -d terraform_cost"]
  #     interval: 10s
  #     timeout: 5s
  #     retries: 5
  #   networks:
  #     - terraform-cost-network
  #   restart: unless-stopped

  # =========================
  # Redis Cache (future)
  # =========================
  # cache:
  #   image: redis:7-alpine
  #   container_name: terraform-cost-cache
  #   command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
  #   volumes:
  #     - redis-data:/data
  #   healthcheck:
  #     test: ["CMD", "redis-cli", "ping"]
  #     interval: 10s
  #     timeout: 5s
  #     retries: 5
  #   networks:
  #     - terraform-cost-network
  #   restart: unless-stopped

volumes:
  terraform-cost-cache:
    driver: local
  terraform-cost-data:
    driver: local
  # pricing-db-data:
  #   driver: local
  # redis-data:
  #   driver: local

networks:
  terraform-cost-network:
    driver: bridge

# secrets:
#   db_password:
#     file: ./secrets/db_password.txt

################################################################################
# FILE: :\good projects\cost estimation\Dockerfile
# TYPE: text
# SIZE: 1805 bytes
################################################################################
# =========================
# Build Stage
# =========================
FROM golang:1.22-alpine AS builder

# Install build dependencies
RUN apk add --no-cache git ca-certificates tzdata

# Create non-root user for security
RUN adduser -D -g '' appuser

WORKDIR /build

# Copy go mod files first for better caching
COPY go.mod go.sum ./
RUN go mod download && go mod verify

# Copy source code
COPY . .

# Build the CLI binary
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags='-w -s -extldflags "-static"' \
    -o /build/terraform-cost \
    ./cmd/cli

# Build the server binary (if exists)
# RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
#     -ldflags='-w -s -extldflags "-static"' \
#     -o /build/terraform-cost-server \
#     ./cmd/server

# =========================
# Production Stage
# =========================
FROM alpine:3.19

# Install runtime dependencies
RUN apk add --no-cache ca-certificates tzdata

# Import user from builder
COPY --from=builder /etc/passwd /etc/passwd
COPY --from=builder /etc/group /etc/group

# Create directories
RUN mkdir -p /app/data /app/cache /app/config && \
    chown -R appuser:appuser /app

WORKDIR /app

# Copy binary from builder
COPY --from=builder /build/terraform-cost /app/terraform-cost

# Copy examples for testing
COPY --from=builder /build/examples /app/examples

# Use non-root user
USER appuser

# Environment variables
ENV HOME=/app \
    TERRAFORM_COST_CACHE_DIR=/app/cache \
    TERRAFORM_COST_DATA_DIR=/app/data

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD ["/app/terraform-cost", "version"]

# Default entrypoint
ENTRYPOINT ["/app/terraform-cost"]

# Default command (show help)
CMD ["--help"]

################################################################################
# FILE: :\good projects\cost estimation\go.mod
# TYPE: text
# SIZE: 730 bytes
################################################################################
module terraform-cost

go 1.25.5

require (
	github.com/hashicorp/hcl/v2 v2.24.0
	github.com/shopspring/decimal v1.4.0
	github.com/spf13/cobra v1.10.2
	go.uber.org/zap v1.27.1
)

require (
	github.com/agext/levenshtein v1.2.1 // indirect
	github.com/apparentlymart/go-textseg/v15 v15.0.0 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/mitchellh/go-wordwrap v1.0.1 // indirect
	github.com/spf13/pflag v1.0.9 // indirect
	github.com/zclconf/go-cty v1.16.3 // indirect
	go.uber.org/multierr v1.10.0 // indirect
	golang.org/x/mod v0.17.0 // indirect
	golang.org/x/sync v0.14.0 // indirect
	golang.org/x/text v0.25.0 // indirect
	golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d // indirect
)

################################################################################
# FILE: :\good projects\cost estimation\README.md
# TYPE: markdown
# SIZE: 3871 bytes
################################################################################
# Terraform Cost Estimation System

A production-grade, cloud-agnostic infrastructure cost estimation tool for Terraform configurations.

## Features

- **Cloud-Agnostic Core**: Support for AWS, Azure, and GCP (AWS fully implemented)
- **Asset Graph**: Provider-agnostic infrastructure DAG for diff and explainability
- **Cost Graph**: Full lineage tracking for every cost calculation
- **Reproducible Estimates**: Versioned pricing snapshots
- **Policy Engine**: Budget limits, thresholds, and guardrails
- **Multiple Outputs**: CLI tables, JSON, HTML, PR comments

## Quick Start

### Using Docker (Recommended)

```bash
# Build the image
docker build -t terraform-cost .

# Run estimation on a Terraform project
docker run -v /path/to/your/terraform:/projects terraform-cost estimate /projects

# Using docker-compose
docker-compose run terraform-cost estimate /projects
```

### Building from Source

```bash
# Clone the repository
git clone https://github.com/your-org/terraform-cost.git
cd terraform-cost

# Install dependencies
go mod download

# Build
go build -o terraform-cost ./cmd/cli

# Run
./terraform-cost estimate ./your-terraform-project
```

## Usage

```bash
# Basic estimation
terraform-cost estimate ./my-terraform-project

# JSON output
terraform-cost estimate --format json ./infrastructure

# With custom usage file
terraform-cost estimate --usage usage.yml ./infrastructure

# Show version
terraform-cost version
```

## Project Structure

```
terraform-cost/
â”œâ”€â”€ cmd/                    # CLI and server entry points
â”‚   â”œâ”€â”€ cli/
â”‚   â””â”€â”€ server/
â”œâ”€â”€ core/                   # Cloud-agnostic core engine
â”‚   â”œâ”€â”€ types/              # Domain types
â”‚   â”œâ”€â”€ scanner/            # Infrastructure scanning
â”‚   â”œâ”€â”€ asset/              # Asset graph
â”‚   â”œâ”€â”€ usage/              # Usage estimation
â”‚   â”œâ”€â”€ cost/               # Cost calculation
â”‚   â”œâ”€â”€ pricing/            # Pricing resolution
â”‚   â”œâ”€â”€ policy/             # Policy evaluation
â”‚   â””â”€â”€ output/             # Output formatting
â”œâ”€â”€ clouds/                 # Cloud provider plugins
â”‚   â”œâ”€â”€ aws/
â”‚   â”œâ”€â”€ azure/
â”‚   â””â”€â”€ gcp/
â”œâ”€â”€ adapters/               # External system adapters
â”‚   â””â”€â”€ terraform/
â”œâ”€â”€ internal/               # Internal utilities
â””â”€â”€ examples/               # Example Terraform configs
```

## Supported AWS Resources

| Category   | Resources |
|------------|-----------|
| Compute    | EC2, Auto Scaling, Lambda, ECS, EKS |
| Storage    | S3, EBS, EFS |
| Database   | RDS, DynamoDB, ElastiCache |
| Network    | NAT Gateway, VPC Endpoints, ALB/NLB/ELB |
| Security   | KMS, Secrets Manager |
| Monitoring | CloudWatch Log Groups |

## Architecture

```
Input â†’ Scanner â†’ Asset Graph â†’ Usage Estimation â†’ Cost Graph â†’ Pricing â†’ Policy â†’ Output
```

### Key Design Principles

1. **Hard Separation of Concerns**: Scanners don't know about pricing
2. **Cloud Providers are Plugins**: Core engine is cloud-agnostic
3. **Deterministic & Reproducible**: Every estimate uses versioned pricing
4. **Everything is a Graph**: Enables diff, lineage, and explainability

## Configuration

Create `.terraform-cost.json` in your home directory or project root:

```json
{
  "pricing": {
    "default_currency": "USD",
    "cache_enabled": true
  },
  "output": {
    "default_format": "cli",
    "show_details": true
  },
  "aws": {
    "default_region": "us-east-1"
  }
}
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Run tests: `go test ./...`
5. Submit a pull request

## License

MIT License - see [LICENSE](LICENSE) for details.

################################################################################
# FILE: :\good projects\cost estimation\adapters\cli\adapter.go
# TYPE: go
# SIZE: 10369 bytes
################################################################################
// Package adapter provides thin adapters over the core engine.
// CLI, HTTP, and CI adapters are all thin wrappers.
package adapter

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"time"

	"terraform-cost/core/engine"
	"terraform-cost/core/model"
	"terraform-cost/core/pricing"
	"terraform-cost/core/terraform"
)

// CLIAdapter is a THIN wrapper around the core engine.
// It handles input/output only - all logic is in the engine.
type CLIAdapter struct {
	engine   *engine.Engine
	pipeline *terraform.Pipeline
	output   io.Writer
	format   OutputFormat
}

// OutputFormat specifies the output format
type OutputFormat int

const (
	FormatTable OutputFormat = iota
	FormatJSON
	FormatMarkdown
)

// NewCLIAdapter creates a new CLI adapter
func NewCLIAdapter(eng *engine.Engine, pipeline *terraform.Pipeline) *CLIAdapter {
	return &CLIAdapter{
		engine:   eng,
		pipeline: pipeline,
		output:   os.Stdout,
		format:   FormatTable,
	}
}

// SetOutput sets the output writer
func (a *CLIAdapter) SetOutput(w io.Writer) {
	a.output = w
}

// SetFormat sets the output format
func (a *CLIAdapter) SetFormat(f OutputFormat) {
	a.format = f
}

// CLIRequest is the CLI input
type CLIRequest struct {
	// Path to Terraform project
	Path string

	// Variables from CLI
	Variables map[string]any

	// Snapshot specification
	SnapshotID string
	Provider   string
	Region     string

	// Usage overrides file
	UsageFile string

	// Output options
	Format     string
	ShowLineage bool
}

// Run executes the estimation
func (a *CLIAdapter) Run(ctx context.Context, req *CLIRequest) error {
	// 1. Run Terraform pipeline
	scanInput := &terraform.ScanInput{
		RootPath:  req.Path,
		Workspace: "default",
	}

	pipelineResult, err := a.pipeline.Execute(ctx, scanInput)
	if err != nil {
		return fmt.Errorf("failed to scan terraform: %w", err)
	}

	// 2. Build estimation request
	snapshotReq := engine.SnapshotRequest{
		Provider: req.Provider,
		Region:   req.Region,
	}
	if req.SnapshotID != "" {
		snapshotReq.SnapshotID = pricing.SnapshotID(req.SnapshotID)
	}

	// Load usage overrides if provided
	overrides := make(map[model.InstanceID]map[string]float64)
	if req.UsageFile != "" {
		var err error
		overrides, err = a.loadUsageOverrides(req.UsageFile)
		if err != nil {
			fmt.Fprintf(a.output, "Warning: could not load usage file: %v\n", err)
		}
	}

	// 3. Delegate to engine
	estimateReq := &engine.EstimateRequest{
		Graph:           pipelineResult.Graph,
		SnapshotRequest: snapshotReq,
		UsageOverrides:  overrides,
	}

	result, err := a.engine.Estimate(ctx, estimateReq)
	if err != nil {
		return fmt.Errorf("estimation failed: %w", err)
	}

	// 4. Format and output
	switch a.format {
	case FormatJSON:
		return a.outputJSON(result)
	case FormatMarkdown:
		return a.outputMarkdown(result)
	default:
		return a.outputTable(result, req.ShowLineage)
	}
}

func (a *CLIAdapter) loadUsageOverrides(path string) (map[model.InstanceID]map[string]float64, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var raw map[string]map[string]float64
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, err
	}

	result := make(map[model.InstanceID]map[string]float64)
	for k, v := range raw {
		result[model.InstanceID(k)] = v
	}
	return result, nil
}

func (a *CLIAdapter) outputTable(result *engine.EstimationResult, showLineage bool) error {
	fmt.Fprintln(a.output, "")
	fmt.Fprintln(a.output, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	fmt.Fprintln(a.output, "â•‘                     COST ESTIMATION REPORT                        â•‘")
	fmt.Fprintln(a.output, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	fmt.Fprintln(a.output, "")

	// Snapshot info
	fmt.Fprintf(a.output, "Pricing Snapshot: %s (verified: %s)\n",
		result.Snapshot.ID, result.Snapshot.ContentHash.String())
	fmt.Fprintf(a.output, "Effective Date:   %s\n", result.Snapshot.EffectiveAt.Format(time.RFC3339))
	fmt.Fprintf(a.output, "Provider/Region:  %s / %s\n", result.Snapshot.Provider, result.Snapshot.Region)
	fmt.Fprintln(a.output, "")

	// Instance costs
	fmt.Fprintln(a.output, "COSTS BY INSTANCE")
	fmt.Fprintln(a.output, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
	fmt.Fprintf(a.output, "%-40s %12s %10s\n", "INSTANCE", "MONTHLY", "CONFIDENCE")
	fmt.Fprintln(a.output, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

	result.InstanceCosts.Range(func(id model.InstanceID, cost *engine.InstanceCost) bool {
		confStr := fmt.Sprintf("%.0f%%", cost.Confidence.Score*100)
		if cost.Confidence.Score < 0.7 {
			confStr += " âš "
		}
		fmt.Fprintf(a.output, "%-40s %12s %10s\n",
			truncate(string(cost.Address), 40),
			cost.MonthlyCost.String(),
			confStr)

		// Show components if requested
		if showLineage {
			for _, comp := range cost.Components {
				fmt.Fprintf(a.output, "  â””â”€ %-36s %12s\n",
					comp.Name, comp.MonthlyCost.String())
			}
		}
		return true
	})

	fmt.Fprintln(a.output, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
	fmt.Fprintf(a.output, "%-40s %12s %10s\n",
		"TOTAL",
		result.TotalMonthlyCost.String(),
		fmt.Sprintf("%.0f%%", result.Confidence.Score*100))
	fmt.Fprintln(a.output, "")

	// Warnings
	if len(result.Warnings) > 0 {
		fmt.Fprintln(a.output, "WARNINGS")
		fmt.Fprintln(a.output, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
		for _, w := range result.Warnings {
			fmt.Fprintf(a.output, "âš  %s\n", w)
		}
		fmt.Fprintln(a.output, "")
	}

	// Policy results
	if result.PolicyResult != nil {
		fmt.Fprintln(a.output, "POLICY RESULTS")
		fmt.Fprintln(a.output, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
		for _, p := range result.PolicyResult.Policies {
			status := "âœ“ PASS"
			if !p.Passed {
				status = "âœ— FAIL"
			}
			fmt.Fprintf(a.output, "%s  %s: %s\n", status, p.Name, p.Message)
		}
		fmt.Fprintln(a.output, "")
	}

	return nil
}

func (a *CLIAdapter) outputJSON(result *engine.EstimationResult) error {
	// Convert to JSON-friendly structure
	output := map[string]interface{}{
		"snapshot": map[string]interface{}{
			"id":           result.Snapshot.ID,
			"content_hash": result.Snapshot.ContentHash.Hex(),
			"effective_at": result.Snapshot.EffectiveAt,
			"provider":     result.Snapshot.Provider,
			"region":       result.Snapshot.Region,
		},
		"total_monthly_cost": result.TotalMonthlyCost.StringRaw(),
		"total_hourly_cost":  result.TotalHourlyCost.StringRaw(),
		"confidence":         result.Confidence.Score,
		"instance_count":     result.InstanceCosts.Len(),
		"estimated_at":       result.EstimatedAt,
		"duration_ms":        result.Duration.Milliseconds(),
		"warnings":           result.Warnings,
		"degraded":           result.Degraded,
	}

	// Add instance costs
	instances := make(map[string]interface{})
	result.InstanceCosts.Range(func(id model.InstanceID, cost *engine.InstanceCost) bool {
		components := make([]map[string]interface{}, len(cost.Components))
		for i, c := range cost.Components {
			components[i] = map[string]interface{}{
				"name":         c.Name,
				"monthly_cost": c.MonthlyCost.StringRaw(),
				"hourly_cost":  c.HourlyCost.StringRaw(),
				"usage_value":  c.UsageValue,
				"usage_unit":   c.UsageUnit,
				"confidence":   c.Confidence,
			}
		}

		instances[string(id)] = map[string]interface{}{
			"address":       cost.Address,
			"definition_id": cost.DefinitionID,
			"monthly_cost":  cost.MonthlyCost.StringRaw(),
			"hourly_cost":   cost.HourlyCost.StringRaw(),
			"confidence":    cost.Confidence.Score,
			"components":    components,
		}
		return true
	})
	output["instances"] = instances

	encoder := json.NewEncoder(a.output)
	encoder.SetIndent("", "  ")
	return encoder.Encode(output)
}

func (a *CLIAdapter) outputMarkdown(result *engine.EstimationResult) error {
	fmt.Fprintln(a.output, "# Cost Estimation Report")
	fmt.Fprintln(a.output, "")
	fmt.Fprintf(a.output, "**Total Monthly Cost:** %s\n", result.TotalMonthlyCost.String())
	fmt.Fprintf(a.output, "**Confidence:** %.0f%%\n", result.Confidence.Score*100)
	fmt.Fprintln(a.output, "")

	fmt.Fprintln(a.output, "## Summary")
	fmt.Fprintln(a.output, "")
	fmt.Fprintln(a.output, "| Instance | Monthly Cost | Confidence |")
	fmt.Fprintln(a.output, "|----------|-------------|------------|")

	result.InstanceCosts.Range(func(id model.InstanceID, cost *engine.InstanceCost) bool {
		fmt.Fprintf(a.output, "| `%s` | %s | %.0f%% |\n",
			cost.Address, cost.MonthlyCost.String(), cost.Confidence.Score*100)
		return true
	})

	fmt.Fprintln(a.output, "")
	fmt.Fprintf(a.output, "| **Total** | **%s** | **%.0f%%** |\n",
		result.TotalMonthlyCost.String(), result.Confidence.Score*100)

	return nil
}

func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}

// HTTPAdapter would be similar - thin wrapper delegating to engine
// type HTTPAdapter struct { ... }

// CIAdapter would be similar - outputs in CI-friendly format
// type CIAdapter struct { ... }

################################################################################
# FILE: :\good projects\cost estimation\adapters\terraform\hcl\cty_safe.go
# TYPE: go
# SIZE: 5911 bytes
################################################################################
// Package hcl - Safe CTY value conversion
// CTY values are NEVER blindly passed through.
// Unknown values MUST be explicitly handled.
package hcl

import (
	"fmt"

	"github.com/zclconf/go-cty/cty"
)

// SafeValue represents a safely-converted CTY value
type SafeValue struct {
	// The Go value (if known)
	Value interface{}

	// Is this value known?
	IsKnown bool

	// Is this value null?
	IsNull bool

	// Type information
	Type SafeValueType

	// Original CTY type name
	CtyType string

	// Why is this unknown?
	UnknownReason string

	// Confidence impact for using this value
	ConfidenceImpact float64
}

// SafeValueType indicates the type of value
type SafeValueType int

const (
	SafeTypeUnknown SafeValueType = iota
	SafeTypeNull
	SafeTypeString
	SafeTypeNumber
	SafeTypeBool
	SafeTypeList
	SafeTypeMap
	SafeTypeTuple
	SafeTypeObject
)

// String returns the type name
func (t SafeValueType) String() string {
	switch t {
	case SafeTypeString:
		return "string"
	case SafeTypeNumber:
		return "number"
	case SafeTypeBool:
		return "bool"
	case SafeTypeList:
		return "list"
	case SafeTypeMap:
		return "map"
	case SafeTypeTuple:
		return "tuple"
	case SafeTypeObject:
		return "object"
	case SafeTypeNull:
		return "null"
	default:
		return "unknown"
	}
}

// CtyToSafe safely converts a cty.Value to a SafeValue
// This NEVER loses type information or unknown status
func CtyToSafe(val cty.Value) SafeValue {
	result := SafeValue{
		CtyType: val.Type().FriendlyName(),
	}

	// Check for unknown FIRST - this is critical
	if !val.IsKnown() {
		result.IsKnown = false
		result.Type = SafeTypeUnknown
		result.UnknownReason = "value not yet known (computed at apply time)"
		result.ConfidenceImpact = 0.3 // Significant impact
		return result
	}

	// Check for null
	if val.IsNull() {
		result.IsNull = true
		result.IsKnown = true
		result.Type = SafeTypeNull
		result.Value = nil
		return result
	}

	result.IsKnown = true

	// Convert based on type
	switch {
	case val.Type() == cty.String:
		result.Type = SafeTypeString
		result.Value = val.AsString()

	case val.Type() == cty.Number:
		result.Type = SafeTypeNumber
		f, _ := val.AsBigFloat().Float64()
		result.Value = f

	case val.Type() == cty.Bool:
		result.Type = SafeTypeBool
		result.Value = val.True()

	case val.Type().IsListType() || val.Type().IsSetType():
		result.Type = SafeTypeList
		result.Value = convertList(val)

	case val.Type().IsTupleType():
		result.Type = SafeTypeTuple
		result.Value = convertTuple(val)

	case val.Type().IsMapType():
		result.Type = SafeTypeMap
		result.Value = convertMap(val)

	case val.Type().IsObjectType():
		result.Type = SafeTypeObject
		result.Value = convertObject(val)

	default:
		// Unknown type - mark as unknown
		result.IsKnown = false
		result.Type = SafeTypeUnknown
		result.UnknownReason = fmt.Sprintf("unhandled CTY type: %s", val.Type().FriendlyName())
		result.ConfidenceImpact = 0.2
	}

	return result
}

func convertList(val cty.Value) []interface{} {
	if !val.CanIterateElements() {
		return nil
	}

	result := make([]interface{}, 0, val.LengthInt())
	iter := val.ElementIterator()
	for iter.Next() {
		_, v := iter.Element()
		safe := CtyToSafe(v)
		if safe.IsKnown && !safe.IsNull {
			result = append(result, safe.Value)
		} else {
			// Include placeholder for unknown elements
			result = append(result, nil)
		}
	}
	return result
}

func convertTuple(val cty.Value) []interface{} {
	return convertList(val) // Same logic
}

func convertMap(val cty.Value) map[string]interface{} {
	if !val.CanIterateElements() {
		return nil
	}

	result := make(map[string]interface{})
	iter := val.ElementIterator()
	for iter.Next() {
		k, v := iter.Element()
		safe := CtyToSafe(v)
		if safe.IsKnown && !safe.IsNull {
			result[k.AsString()] = safe.Value
		} else {
			result[k.AsString()] = nil
		}
	}
	return result
}

func convertObject(val cty.Value) map[string]interface{} {
	return convertMap(val) // Same logic for objects
}

// AsString returns the value as a string, or empty if not a string
func (v SafeValue) AsString() string {
	if !v.IsKnown || v.IsNull || v.Type != SafeTypeString {
		return ""
	}
	if s, ok := v.Value.(string); ok {
		return s
	}
	return ""
}

// AsFloat returns the value as a float64, or 0 if not a number
func (v SafeValue) AsFloat() float64 {
	if !v.IsKnown || v.IsNull || v.Type != SafeTypeNumber {
		return 0
	}
	if f, ok := v.Value.(float64); ok {
		return f
	}
	return 0
}

// AsInt returns the value as an int
func (v SafeValue) AsInt() int {
	return int(v.AsFloat())
}

// AsBool returns the value as a bool
func (v SafeValue) AsBool() bool {
	if !v.IsKnown || v.IsNull || v.Type != SafeTypeBool {
		return false
	}
	if b, ok := v.Value.(bool); ok {
		return b
	}
	return false
}

// AsList returns the value as a slice
func (v SafeValue) AsList() []interface{} {
	if !v.IsKnown || v.IsNull {
		return nil
	}
	if l, ok := v.Value.([]interface{}); ok {
		return l
	}
	return nil
}

// AsMap returns the value as a map
func (v SafeValue) AsMap() map[string]interface{} {
	if !v.IsKnown || v.IsNull {
		return nil
	}
	if m, ok := v.Value.(map[string]interface{}); ok {
		return m
	}
	return nil
}

// MustBeKnown returns an error if the value is unknown
func (v SafeValue) MustBeKnown(context string) error {
	if !v.IsKnown {
		return &UnknownValueError{
			Context: context,
			Reason:  v.UnknownReason,
		}
	}
	return nil
}

// UnknownValueError indicates a value that should be known is unknown
type UnknownValueError struct {
	Context string
	Reason  string
}

func (e *UnknownValueError) Error() string {
	return fmt.Sprintf("unknown value in %s: %s", e.Context, e.Reason)
}

################################################################################
# FILE: :\good projects\cost estimation\adapters\terraform\hcl\scanner.go
# TYPE: go
# SIZE: 12019 bytes
################################################################################
// Package hcl provides Terraform HCL parsing with DEFERRED evaluation.
// Expressions are NOT evaluated immediately - they are captured as unevaluated
// and resolved only after variables, locals, and references are available.
package hcl

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/hashicorp/hcl/v2"
	"github.com/hashicorp/hcl/v2/hclparse"
	"github.com/hashicorp/hcl/v2/hclsyntax"

	"terraform-cost/core/scanner"
	"terraform-cost/core/types"
)

// Scanner implements the scanner.Scanner interface for Terraform HCL
// CRITICAL: This scanner does NOT evaluate expressions.
// It captures expressions as unevaluated for later resolution.
type Scanner struct {
	parser *hclparse.Parser
}

// NewScanner creates a new HCL scanner
func NewScanner() *Scanner {
	return &Scanner{
		parser: hclparse.NewParser(),
	}
}

// Name returns the scanner name
func (s *Scanner) Name() string {
	return "terraform-hcl"
}

// CanScan determines if this scanner can handle the input
func (s *Scanner) CanScan(ctx context.Context, input *types.ProjectInput) (bool, error) {
	// Look for .tf files
	hasTfFiles := false
	err := filepath.Walk(input.Path, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(path, ".tf") {
			hasTfFiles = true
			return filepath.SkipAll // Found one, that's enough
		}
		return nil
	})

	if err != nil && err != filepath.SkipAll {
		return false, err
	}

	return hasTfFiles, nil
}

// Scan parses HCL files and returns raw assets with UNEVALUATED expressions
func (s *Scanner) Scan(ctx context.Context, input *types.ProjectInput) (*scanner.ScanResult, error) {
	result := &scanner.ScanResult{
		Assets:    make([]types.RawAsset, 0),
		Modules:   make([]scanner.ModuleReference, 0),
		Variables: make(map[string]interface{}),
		Warnings:  make([]scanner.ScanWarning, 0),
		Errors:    make([]scanner.ScanError, 0),
	}

	// Find all .tf files
	var tfFiles []string
	err := filepath.Walk(input.Path, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(path, ".tf") {
			tfFiles = append(tfFiles, path)
		}
		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to walk directory: %w", err)
	}

	// Parse each file - DO NOT EVALUATE
	for _, file := range tfFiles {
		assets, modules, warnings, errs := s.parseFile(ctx, file, input.Path)
		result.Assets = append(result.Assets, assets...)
		result.Modules = append(result.Modules, modules...)
		result.Warnings = append(result.Warnings, warnings...)
		result.Errors = append(result.Errors, errs...)
	}

	// Load tfvars if present
	result.Variables = s.loadVariables(input.Path)

	return result, nil
}

func (s *Scanner) parseFile(ctx context.Context, file, basePath string) ([]types.RawAsset, []scanner.ModuleReference, []scanner.ScanWarning, []scanner.ScanError) {
	var assets []types.RawAsset
	var modules []scanner.ModuleReference
	var warnings []scanner.ScanWarning
	var errors []scanner.ScanError

	src, err := os.ReadFile(file)
	if err != nil {
		errors = append(errors, scanner.ScanError{
			File:    file,
			Message: fmt.Sprintf("failed to read file: %v", err),
			Err:     err,
		})
		return assets, modules, warnings, errors
	}

	hclFile, diags := s.parser.ParseHCL(src, file)
	if diags.HasErrors() {
		for _, diag := range diags {
			if diag.Severity == hcl.DiagError {
				line := 0
				if diag.Subject != nil {
					line = diag.Subject.Start.Line
				}
				errors = append(errors, scanner.ScanError{
					File:    file,
					Line:    line,
					Message: diag.Summary + ": " + diag.Detail,
				})
			}
		}
		return assets, modules, warnings, errors
	}

	// Extract blocks from the file body
	body := hclFile.Body
	content, _, _ := body.PartialContent(&hcl.BodySchema{
		Blocks: []hcl.BlockHeaderSchema{
			{Type: "resource", LabelNames: []string{"type", "name"}},
			{Type: "data", LabelNames: []string{"type", "name"}},
			{Type: "module", LabelNames: []string{"name"}},
			{Type: "variable", LabelNames: []string{"name"}},
			{Type: "locals"},
			{Type: "provider", LabelNames: []string{"name"}},
		},
	})

	relPath, _ := filepath.Rel(basePath, file)

	for _, block := range content.Blocks {
		switch block.Type {
		case "resource":
			asset := s.parseResourceDeferred(block, relPath, false)
			if asset != nil {
				assets = append(assets, *asset)
			}
		case "data":
			asset := s.parseResourceDeferred(block, relPath, true)
			if asset != nil {
				assets = append(assets, *asset)
			}
		case "module":
			mod := s.parseModuleDeferred(block)
			if mod != nil {
				modules = append(modules, *mod)
			}
		}
	}

	return assets, modules, warnings, errors
}

// parseResourceDeferred captures expressions WITHOUT evaluating them
func (s *Scanner) parseResourceDeferred(block *hcl.Block, file string, isDataSource bool) *types.RawAsset {
	if len(block.Labels) < 2 {
		return nil
	}

	resourceType := block.Labels[0]
	resourceName := block.Labels[1]

	// Determine provider from resource type
	provider := types.ProviderUnknown
	if strings.HasPrefix(resourceType, "aws_") {
		provider = types.ProviderAWS
	} else if strings.HasPrefix(resourceType, "azurerm_") {
		provider = types.ProviderAzure
	} else if strings.HasPrefix(resourceType, "google_") {
		provider = types.ProviderGCP
	}

	// Extract attributes as UNEVALUATED expressions
	attrs := s.extractAttributesDeferred(block.Body)

	address := types.ResourceAddress(fmt.Sprintf("%s.%s", resourceType, resourceName))
	if isDataSource {
		address = types.ResourceAddress(fmt.Sprintf("data.%s.%s", resourceType, resourceName))
	}

	line := 0
	if block.DefRange.Start.Line > 0 {
		line = block.DefRange.Start.Line
	}

	return &types.RawAsset{
		Address:      address,
		Provider:     provider,
		Type:         resourceType,
		Name:         resourceName,
		Attributes:   attrs,
		IsDataSource: isDataSource,
		SourceFile:   file,
		SourceLine:   line,
	}
}

func (s *Scanner) parseModuleDeferred(block *hcl.Block) *scanner.ModuleReference {
	if len(block.Labels) < 1 {
		return nil
	}

	name := block.Labels[0]
	attrs := s.extractAttributesDeferred(block.Body)

	source := ""
	if src := attrs.Get("source"); src != nil {
		if attr, ok := src.(types.Attribute); ok && !attr.IsComputed && !attr.IsUnknown {
			if srcStr, ok := attr.Value.(string); ok {
				source = srcStr
			}
		}
	}

	version := ""
	if ver := attrs.Get("version"); ver != nil {
		if attr, ok := ver.(types.Attribute); ok && !attr.IsComputed && !attr.IsUnknown {
			if verStr, ok := attr.Value.(string); ok {
				version = verStr
			}
		}
	}

	return &scanner.ModuleReference{
		Key:     name,
		Source:  source,
		Version: version,
	}
}

// extractAttributesDeferred captures expressions WITHOUT evaluating them
// This is the CRITICAL fix - we do NOT call attr.Expr.Value(nil)
func (s *Scanner) extractAttributesDeferred(body hcl.Body) types.Attributes {
	attrs := make(types.Attributes)

	// Get all attributes from the body
	content, _, _ := body.PartialContent(&hcl.BodySchema{})

	for name, attr := range content.Attributes {
		// Analyze the expression to determine if it needs context
		exprInfo := s.analyzeExpression(attr.Expr)

		if exprInfo.IsLiteral {
			// Safe to evaluate literals immediately
			val, diags := attr.Expr.Value(nil)
			if !diags.HasErrors() {
				attrs[name] = types.Attribute{
					Value:      s.ctyToGo(val),
					IsComputed: false,
					IsUnknown:  false,
				}
				continue
			}
		}

		// Expression requires context - mark as unevaluated
		attrs[name] = types.Attribute{
			Value:             nil,
			IsComputed:        exprInfo.RequiresContext,
			IsUnknown:         exprInfo.HasUnknownRefs,
			Expression:        s.expressionToString(attr.Expr),
			ExpressionType:    exprInfo.Type,
			References:        exprInfo.References,
			ConfidenceImpact:  exprInfo.ConfidenceImpact,
		}
	}

	return attrs
}

// ExpressionInfo describes an unevaluated expression
type ExpressionInfo struct {
	IsLiteral        bool
	RequiresContext  bool
	HasUnknownRefs   bool
	Type             string   // "literal", "variable", "local", "reference", "function", "conditional"
	References       []string // Referenced addresses
	ConfidenceImpact float64  // How much this reduces confidence (0.0 - 1.0)
}

// analyzeExpression determines what kind of expression this is
func (s *Scanner) analyzeExpression(expr hcl.Expression) ExpressionInfo {
	info := ExpressionInfo{
		IsLiteral:        true,
		RequiresContext:  false,
		HasUnknownRefs:   false,
		Type:             "literal",
		References:       []string{},
		ConfidenceImpact: 0.0,
	}

	// Get all variable references
	refs := expr.Variables()
	if len(refs) > 0 {
		info.IsLiteral = false
		info.RequiresContext = true
		info.ConfidenceImpact = 0.1 // Base impact for having references

		for _, ref := range refs {
			refStr := formatTraversal(ref)
			info.References = append(info.References, refStr)

			// Classify reference type
			if len(ref) > 0 {
				root := ref.RootName()
				switch root {
				case "var":
					info.Type = "variable"
					info.ConfidenceImpact += 0.1 // Variable adds uncertainty
				case "local":
					info.Type = "local"
					// Locals are resolvable
				case "count":
					info.Type = "count_reference"
					info.ConfidenceImpact += 0.2 // Count adds more uncertainty
				case "each":
					info.Type = "for_each_reference"
					info.ConfidenceImpact += 0.2
				case "data":
					info.Type = "data_source"
					info.HasUnknownRefs = true // Data sources are runtime
					info.ConfidenceImpact += 0.3
				default:
					// Resource reference
					info.Type = "resource_reference"
					info.HasUnknownRefs = true
					info.ConfidenceImpact += 0.3
				}
			}
		}
	}

	// Check for function calls
	if synExpr, ok := expr.(*hclsyntax.FunctionCallExpr); ok {
		info.IsLiteral = false
		info.RequiresContext = true
		info.Type = "function:" + synExpr.Name
		info.ConfidenceImpact += 0.1
	}

	// Check for conditional
	if _, ok := expr.(*hclsyntax.ConditionalExpr); ok {
		info.IsLiteral = false
		info.RequiresContext = true
		info.Type = "conditional"
		info.ConfidenceImpact += 0.15
	}

	// Cap confidence impact
	if info.ConfidenceImpact > 0.5 {
		info.ConfidenceImpact = 0.5
	}

	return info
}

func formatTraversal(traversal hcl.Traversal) string {
	parts := make([]string, 0, len(traversal))
	for _, t := range traversal {
		switch tt := t.(type) {
		case hcl.TraverseRoot:
			parts = append(parts, tt.Name)
		case hcl.TraverseAttr:
			parts = append(parts, "."+tt.Name)
		case hcl.TraverseIndex:
			parts = append(parts, "[...]")
		}
	}
	return strings.Join(parts, "")
}

func (s *Scanner) expressionToString(expr hcl.Expression) string {
	// Get the source range and extract the text
	rng := expr.Range()
	return fmt.Sprintf("<%s:%d-%d>", rng.Filename, rng.Start.Line, rng.End.Line)
}

func (s *Scanner) ctyToGo(val interface{}) interface{} {
	// This is a simplified conversion
	// In production, use cty.Value methods properly
	return val
}

func (s *Scanner) loadVariables(basePath string) map[string]interface{} {
	vars := make(map[string]interface{})

	// Look for terraform.tfvars
	tfvarsPath := filepath.Join(basePath, "terraform.tfvars")
	if _, err := os.Stat(tfvarsPath); err == nil {
		// Parse tfvars file
		// Simplified - in production, properly parse HCL
	}

	// Look for *.auto.tfvars
	matches, _ := filepath.Glob(filepath.Join(basePath, "*.auto.tfvars"))
	for range matches {
		// Parse each file
	}

	return vars
}

func init() {
	// Register this scanner
	scanner.Register(NewScanner())
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\registry.go
# TYPE: go
# SIZE: 4155 bytes
################################################################################
// Package clouds provides the cloud plugin system.
// Cloud providers are modular plugins that can be added without modifying core.
package clouds

import (
	"fmt"
	"sync"

	"terraform-cost/core/asset"
	"terraform-cost/core/pricing"
	"terraform-cost/core/types"
	"terraform-cost/core/usage"
)

// Plugin defines the interface for a cloud provider plugin
type Plugin interface {
	// Provider returns the cloud provider identifier
	Provider() types.Provider

	// Name returns a human-readable name
	Name() string

	// Description returns a description of the plugin
	Description() string

	// Initialize sets up the plugin
	Initialize() error

	// AssetBuilders returns asset builders for this provider
	AssetBuilders() []asset.Builder

	// UsageEstimators returns usage estimators for this provider
	UsageEstimators() []usage.Estimator

	// PricingSource returns the pricing source for this provider
	PricingSource() pricing.Source

	// SupportedResourceTypes returns all supported resource types
	SupportedResourceTypes() []string

	// SupportedRegions returns all supported regions
	SupportedRegions() []string
}

// Registry manages cloud plugin registration
type Registry struct {
	mu      sync.RWMutex
	plugins map[types.Provider]Plugin
}

// NewRegistry creates a new plugin registry
func NewRegistry() *Registry {
	return &Registry{
		plugins: make(map[types.Provider]Plugin),
	}
}

// Register adds a plugin to the registry
func (r *Registry) Register(plugin Plugin) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.plugins[plugin.Provider()]; exists {
		return fmt.Errorf("plugin already registered: %s", plugin.Provider())
	}

	// Initialize the plugin
	if err := plugin.Initialize(); err != nil {
		return fmt.Errorf("failed to initialize plugin %s: %w", plugin.Provider(), err)
	}

	r.plugins[plugin.Provider()] = plugin
	return nil
}

// GetPlugin returns a plugin by provider
func (r *Registry) GetPlugin(provider types.Provider) (Plugin, bool) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	plugin, ok := r.plugins[provider]
	return plugin, ok
}

// GetAll returns all registered plugins
func (r *Registry) GetAll() []Plugin {
	r.mu.RLock()
	defer r.mu.RUnlock()

	plugins := make([]Plugin, 0, len(r.plugins))
	for _, plugin := range r.plugins {
		plugins = append(plugins, plugin)
	}
	return plugins
}

// Providers returns all registered provider IDs
func (r *Registry) Providers() []types.Provider {
	r.mu.RLock()
	defer r.mu.RUnlock()

	providers := make([]types.Provider, 0, len(r.plugins))
	for p := range r.plugins {
		providers = append(providers, p)
	}
	return providers
}

// RegisterAll registers all components from a plugin to the core registries
func (r *Registry) RegisterAll(
	assetRegistry asset.BuilderRegistry,
	usageRegistry usage.EstimatorRegistry,
	pricingRegistry pricing.SourceRegistry,
) error {
	r.mu.RLock()
	defer r.mu.RUnlock()

	for _, plugin := range r.plugins {
		// Register asset builders
		for _, builder := range plugin.AssetBuilders() {
			if err := assetRegistry.Register(builder); err != nil {
				return fmt.Errorf("failed to register asset builder from %s: %w", plugin.Provider(), err)
			}
		}

		// Register usage estimators
		for _, estimator := range plugin.UsageEstimators() {
			if err := usageRegistry.Register(estimator); err != nil {
				return fmt.Errorf("failed to register usage estimator from %s: %w", plugin.Provider(), err)
			}
		}

		// Register pricing source
		if source := plugin.PricingSource(); source != nil {
			if err := pricingRegistry.Register(source); err != nil {
				return fmt.Errorf("failed to register pricing source from %s: %w", plugin.Provider(), err)
			}
		}
	}

	return nil
}

// Global default registry
var defaultRegistry = NewRegistry()

// RegisterPlugin adds a plugin to the default registry
func RegisterPlugin(plugin Plugin) error {
	return defaultRegistry.Register(plugin)
}

// GetDefaultRegistry returns the default registry
func GetDefaultRegistry() *Registry {
	return defaultRegistry
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\plugin.go
# TYPE: go
# SIZE: 3925 bytes
################################################################################
// Package aws provides the AWS cloud plugin.
package aws

import (
	"terraform-cost/clouds/aws/assets"
	"terraform-cost/clouds/aws/pricing"
	"terraform-cost/clouds/aws/usage"
	"terraform-cost/core/asset"
	corePricing "terraform-cost/core/pricing"
	coreUsage "terraform-cost/core/usage"
	"terraform-cost/core/types"
)

// Plugin implements the AWS cloud plugin
type Plugin struct {
	initialized bool
	region      string
}

// New creates a new AWS plugin
func New() *Plugin {
	return &Plugin{
		region: "us-east-1",
	}
}

// NewWithRegion creates a new AWS plugin with a specific default region
func NewWithRegion(region string) *Plugin {
	return &Plugin{
		region: region,
	}
}

// Provider returns the cloud provider identifier
func (p *Plugin) Provider() types.Provider {
	return types.ProviderAWS
}

// Name returns a human-readable name
func (p *Plugin) Name() string {
	return "Amazon Web Services"
}

// Description returns a description of the plugin
func (p *Plugin) Description() string {
	return "Cost estimation for AWS infrastructure including EC2, RDS, S3, Lambda, and more"
}

// Initialize sets up the plugin
func (p *Plugin) Initialize() error {
	p.initialized = true
	return nil
}

// AssetBuilders returns asset builders for AWS resources
func (p *Plugin) AssetBuilders() []asset.Builder {
	return []asset.Builder{
		// Compute
		assets.NewEC2InstanceBuilder(),
		assets.NewEC2AutoScalingGroupBuilder(),
		assets.NewLambdaFunctionBuilder(),
		assets.NewECSServiceBuilder(),
		assets.NewEKSClusterBuilder(),

		// Storage
		assets.NewS3BucketBuilder(),
		assets.NewEBSVolumeBuilder(),
		assets.NewEFSFileSystemBuilder(),

		// Database
		assets.NewRDSInstanceBuilder(),
		assets.NewRDSClusterBuilder(),
		assets.NewDynamoDBTableBuilder(),
		assets.NewElastiCacheClusterBuilder(),

		// Network
		assets.NewNATGatewayBuilder(),
		assets.NewVPCEndpointBuilder(),
		assets.NewELBBuilder(),
		assets.NewALBBuilder(),
		assets.NewNLBBuilder(),

		// Other
		assets.NewCloudWatchLogGroupBuilder(),
		assets.NewKMSKeyBuilder(),
		assets.NewSecretsManagerSecretBuilder(),
	}
}

// UsageEstimators returns usage estimators for AWS resources
func (p *Plugin) UsageEstimators() []coreUsage.Estimator {
	return []coreUsage.Estimator{
		usage.NewEC2InstanceEstimator(),
		usage.NewS3BucketEstimator(),
		usage.NewRDSInstanceEstimator(),
		usage.NewLambdaFunctionEstimator(),
		usage.NewDynamoDBTableEstimator(),
		usage.NewNATGatewayEstimator(),
		usage.NewEBSVolumeEstimator(),
	}
}

// PricingSource returns the pricing source for AWS
func (p *Plugin) PricingSource() corePricing.Source {
	return pricing.NewAWSPricingSource(p.region)
}

// SupportedResourceTypes returns all supported AWS resource types
func (p *Plugin) SupportedResourceTypes() []string {
	return []string{
		// Compute
		"aws_instance",
		"aws_autoscaling_group",
		"aws_lambda_function",
		"aws_ecs_service",
		"aws_eks_cluster",
		"aws_eks_node_group",

		// Storage
		"aws_s3_bucket",
		"aws_ebs_volume",
		"aws_efs_file_system",

		// Database
		"aws_db_instance",
		"aws_rds_cluster",
		"aws_dynamodb_table",
		"aws_elasticache_cluster",
		"aws_elasticache_replication_group",

		// Network
		"aws_nat_gateway",
		"aws_vpc_endpoint",
		"aws_lb", // ALB/NLB
		"aws_elb",

		// Other
		"aws_cloudwatch_log_group",
		"aws_kms_key",
		"aws_secretsmanager_secret",
	}
}

// SupportedRegions returns all supported AWS regions
func (p *Plugin) SupportedRegions() []string {
	return []string{
		"us-east-1",
		"us-east-2",
		"us-west-1",
		"us-west-2",
		"eu-west-1",
		"eu-west-2",
		"eu-west-3",
		"eu-central-1",
		"eu-north-1",
		"ap-northeast-1",
		"ap-northeast-2",
		"ap-northeast-3",
		"ap-southeast-1",
		"ap-southeast-2",
		"ap-south-1",
		"sa-east-1",
		"ca-central-1",
	}
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\assets\compute.go
# TYPE: go
# SIZE: 5050 bytes
################################################################################
// Package assets - AWS compute asset builders
package assets

import (
	"context"
	"fmt"

	"terraform-cost/core/asset"
	"terraform-cost/core/types"
)

// EC2AutoScalingGroupBuilder builds assets for aws_autoscaling_group
type EC2AutoScalingGroupBuilder struct {
	baseBuilder
}

// NewEC2AutoScalingGroupBuilder creates a new ASG builder
func NewEC2AutoScalingGroupBuilder() asset.Builder {
	return &EC2AutoScalingGroupBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_autoscaling_group",
			category:     types.CategoryCompute,
		},
	}
}

// Build converts a raw ASG into an asset
func (b *EC2AutoScalingGroupBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	return &types.Asset{
		ID:       fmt.Sprintf("aws_autoscaling_group.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryCompute,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"min_size":              raw.Attributes["min_size"],
			"max_size":              raw.Attributes["max_size"],
			"desired_capacity":      raw.Attributes["desired_capacity"],
			"launch_configuration":  raw.Attributes["launch_configuration"],
			"launch_template":       raw.Attributes["launch_template"],
			"mixed_instances_policy": raw.Attributes["mixed_instances_policy"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
	}, nil
}

// LambdaFunctionBuilder builds assets for aws_lambda_function
type LambdaFunctionBuilder struct {
	baseBuilder
}

// NewLambdaFunctionBuilder creates a new Lambda builder
func NewLambdaFunctionBuilder() asset.Builder {
	return &LambdaFunctionBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_lambda_function",
			category:     types.CategoryServerless,
		},
	}
}

// Build converts a raw Lambda function into an asset
func (b *LambdaFunctionBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	memorySize := raw.Attributes.GetInt("memory_size")
	if memorySize == 0 {
		memorySize = 128 // Default
	}

	timeout := raw.Attributes.GetInt("timeout")
	if timeout == 0 {
		timeout = 3 // Default
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_lambda_function.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryServerless,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"memory_size":       {Value: memorySize},
			"timeout":           {Value: timeout},
			"runtime":           raw.Attributes["runtime"],
			"architectures":     raw.Attributes["architectures"],
			"ephemeral_storage": raw.Attributes["ephemeral_storage"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
	}, nil
}

// ECSServiceBuilder builds assets for aws_ecs_service
type ECSServiceBuilder struct {
	baseBuilder
}

// NewECSServiceBuilder creates a new ECS service builder
func NewECSServiceBuilder() asset.Builder {
	return &ECSServiceBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_ecs_service",
			category:     types.CategoryContainer,
		},
	}
}

// Build converts a raw ECS service into an asset
func (b *ECSServiceBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	desiredCount := raw.Attributes.GetInt("desired_count")
	if desiredCount == 0 {
		desiredCount = 1
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_ecs_service.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryContainer,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"desired_count":   {Value: desiredCount},
			"task_definition": raw.Attributes["task_definition"],
			"launch_type":     raw.Attributes["launch_type"],
			"capacity_provider_strategy": raw.Attributes["capacity_provider_strategy"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
	}, nil
}

// EKSClusterBuilder builds assets for aws_eks_cluster
type EKSClusterBuilder struct {
	baseBuilder
}

// NewEKSClusterBuilder creates a new EKS cluster builder
func NewEKSClusterBuilder() asset.Builder {
	return &EKSClusterBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_eks_cluster",
			category:     types.CategoryContainer,
		},
	}
}

// Build converts a raw EKS cluster into an asset
func (b *EKSClusterBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	return &types.Asset{
		ID:       fmt.Sprintf("aws_eks_cluster.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryContainer,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"version": raw.Attributes["version"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
	}, nil
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\assets\database.go
# TYPE: go
# SIZE: 6530 bytes
################################################################################
// Package assets - AWS database asset builders
package assets

import (
	"context"
	"fmt"

	"terraform-cost/core/asset"
	"terraform-cost/core/types"
)

// RDSInstanceBuilder builds assets for aws_db_instance
type RDSInstanceBuilder struct {
	baseBuilder
}

// NewRDSInstanceBuilder creates a new RDS instance builder
func NewRDSInstanceBuilder() asset.Builder {
	return &RDSInstanceBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_db_instance",
			category:     types.CategoryDatabase,
		},
	}
}

// Build converts a raw RDS instance into an asset
func (b *RDSInstanceBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	instanceClass := raw.Attributes.GetString("instance_class")
	if instanceClass == "" {
		instanceClass = "db.t3.micro"
	}

	engine := raw.Attributes.GetString("engine")
	storageType := raw.Attributes.GetString("storage_type")
	if storageType == "" {
		storageType = "gp2"
	}

	allocatedStorage := raw.Attributes.GetInt("allocated_storage")
	if allocatedStorage == 0 {
		allocatedStorage = 20
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_db_instance.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryDatabase,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"instance_class":              {Value: instanceClass},
			"engine":                      {Value: engine},
			"engine_version":              raw.Attributes["engine_version"],
			"storage_type":                {Value: storageType},
			"allocated_storage":           {Value: allocatedStorage},
			"max_allocated_storage":       raw.Attributes["max_allocated_storage"],
			"iops":                        raw.Attributes["iops"],
			"storage_throughput":          raw.Attributes["storage_throughput"],
			"multi_az":                    raw.Attributes["multi_az"],
			"storage_encrypted":           raw.Attributes["storage_encrypted"],
			"performance_insights_enabled": raw.Attributes["performance_insights_enabled"],
			"backup_retention_period":     raw.Attributes["backup_retention_period"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// RDSClusterBuilder builds assets for aws_rds_cluster
type RDSClusterBuilder struct {
	baseBuilder
}

// NewRDSClusterBuilder creates a new RDS cluster builder
func NewRDSClusterBuilder() asset.Builder {
	return &RDSClusterBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_rds_cluster",
			category:     types.CategoryDatabase,
		},
	}
}

// Build converts a raw RDS cluster into an asset
func (b *RDSClusterBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	return &types.Asset{
		ID:       fmt.Sprintf("aws_rds_cluster.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryDatabase,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"engine":                  raw.Attributes["engine"],
			"engine_mode":             raw.Attributes["engine_mode"],
			"engine_version":          raw.Attributes["engine_version"],
			"serverlessv2_scaling_configuration": raw.Attributes["serverlessv2_scaling_configuration"],
			"backup_retention_period": raw.Attributes["backup_retention_period"],
			"storage_encrypted":       raw.Attributes["storage_encrypted"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// DynamoDBTableBuilder builds assets for aws_dynamodb_table
type DynamoDBTableBuilder struct {
	baseBuilder
}

// NewDynamoDBTableBuilder creates a new DynamoDB builder
func NewDynamoDBTableBuilder() asset.Builder {
	return &DynamoDBTableBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_dynamodb_table",
			category:     types.CategoryDatabase,
		},
	}
}

// Build converts a raw DynamoDB table into an asset
func (b *DynamoDBTableBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	billingMode := raw.Attributes.GetString("billing_mode")
	if billingMode == "" {
		billingMode = "PROVISIONED"
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_dynamodb_table.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryDatabase,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"billing_mode":           {Value: billingMode},
			"read_capacity":          raw.Attributes["read_capacity"],
			"write_capacity":         raw.Attributes["write_capacity"],
			"global_secondary_index": raw.Attributes["global_secondary_index"],
			"stream_enabled":         raw.Attributes["stream_enabled"],
			"table_class":            raw.Attributes["table_class"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// ElastiCacheClusterBuilder builds assets for aws_elasticache_cluster
type ElastiCacheClusterBuilder struct {
	baseBuilder
}

// NewElastiCacheClusterBuilder creates a new ElastiCache builder
func NewElastiCacheClusterBuilder() asset.Builder {
	return &ElastiCacheClusterBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_elasticache_cluster",
			category:     types.CategoryDatabase,
		},
	}
}

// Build converts a raw ElastiCache cluster into an asset
func (b *ElastiCacheClusterBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	nodeType := raw.Attributes.GetString("node_type")
	if nodeType == "" {
		nodeType = "cache.t3.micro"
	}

	numCacheNodes := raw.Attributes.GetInt("num_cache_nodes")
	if numCacheNodes == 0 {
		numCacheNodes = 1
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_elasticache_cluster.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryDatabase,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"node_type":       {Value: nodeType},
			"num_cache_nodes": {Value: numCacheNodes},
			"engine":          raw.Attributes["engine"],
			"engine_version":  raw.Attributes["engine_version"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\assets\ec2.go
# TYPE: go
# SIZE: 5341 bytes
################################################################################
// Package assets provides AWS asset builders.
package assets

import (
	"context"
	"fmt"

	"terraform-cost/core/asset"
	"terraform-cost/core/types"
)

// baseBuilder provides common functionality for AWS builders
type baseBuilder struct {
	resourceType string
	category     types.AssetCategory
}

func (b *baseBuilder) Provider() types.Provider {
	return types.ProviderAWS
}

func (b *baseBuilder) ResourceType() string {
	return b.resourceType
}

func (b *baseBuilder) Category() types.AssetCategory {
	return b.category
}

// EC2InstanceBuilder builds assets for aws_instance resources
type EC2InstanceBuilder struct {
	baseBuilder
}

// NewEC2InstanceBuilder creates a new EC2 instance builder
func NewEC2InstanceBuilder() asset.Builder {
	return &EC2InstanceBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_instance",
			category:     types.CategoryCompute,
		},
	}
}

// Build converts a raw EC2 instance into an asset
func (b *EC2InstanceBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	instanceType := raw.Attributes.GetString("instance_type")
	if instanceType == "" {
		instanceType = "t3.micro" // Default
	}

	ami := raw.Attributes.GetString("ami")
	az := raw.Attributes.GetString("availability_zone")

	// Extract region from AZ
	region := ""
	if len(az) > 0 {
		region = az[:len(az)-1]
	}

	asset := &types.Asset{
		ID:       fmt.Sprintf("aws_instance.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryCompute,
		Type:     raw.Type,
		Name:     raw.Name,
		Region:   types.Region(region),
		Attributes: types.Attributes{
			"instance_type": {Value: instanceType},
			"ami":           {Value: ami},
			"tenancy":       raw.Attributes["tenancy"],
			"ebs_optimized": raw.Attributes["ebs_optimized"],
			"monitoring":    raw.Attributes["monitoring"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}

	// Add root block device as child
	if rootBlock := raw.Attributes.Get("root_block_device"); rootBlock != nil {
		if rbdList, ok := rootBlock.([]interface{}); ok && len(rbdList) > 0 {
			if rbd, ok := rbdList[0].(map[string]interface{}); ok {
				child := &types.Asset{
					ID:       fmt.Sprintf("%s.root_block_device", asset.ID),
					Address:  types.ResourceAddress(fmt.Sprintf("%s.root_block_device", raw.Address)),
					Provider: types.ProviderAWS,
					Category: types.CategoryStorage,
					Type:     "aws_ebs_volume",
					Name:     "root",
					Parent:   asset,
					Attributes: types.Attributes{
						"volume_type": {Value: getMapString(rbd, "volume_type", "gp3")},
						"volume_size": {Value: getMapInt(rbd, "volume_size", 8)},
						"iops":        {Value: getMapInt(rbd, "iops", 0)},
						"throughput":  {Value: getMapInt(rbd, "throughput", 0)},
						"encrypted":   {Value: getMapBool(rbd, "encrypted", false)},
					},
				}
				asset.Children = append(asset.Children, child)
			}
		}
	}

	// Add additional EBS volumes as children
	if ebsBlocks := raw.Attributes.Get("ebs_block_device"); ebsBlocks != nil {
		if ebsList, ok := ebsBlocks.([]interface{}); ok {
			for i, ebs := range ebsList {
				if ebsMap, ok := ebs.(map[string]interface{}); ok {
					deviceName := getMapString(ebsMap, "device_name", fmt.Sprintf("/dev/sd%c", 'b'+i))
					child := &types.Asset{
						ID:       fmt.Sprintf("%s.ebs_block_device.%d", asset.ID, i),
						Address:  types.ResourceAddress(fmt.Sprintf("%s.ebs_block_device[%d]", raw.Address, i)),
						Provider: types.ProviderAWS,
						Category: types.CategoryStorage,
						Type:     "aws_ebs_volume",
						Name:     deviceName,
						Parent:   asset,
						Attributes: types.Attributes{
							"device_name": {Value: deviceName},
							"volume_type": {Value: getMapString(ebsMap, "volume_type", "gp3")},
							"volume_size": {Value: getMapInt(ebsMap, "volume_size", 8)},
							"iops":        {Value: getMapInt(ebsMap, "iops", 0)},
							"throughput":  {Value: getMapInt(ebsMap, "throughput", 0)},
							"encrypted":   {Value: getMapBool(ebsMap, "encrypted", false)},
						},
					}
					asset.Children = append(asset.Children, child)
				}
			}
		}
	}

	return asset, nil
}

// Helper functions
func extractTags(attrs types.Attributes) map[string]string {
	tags := make(map[string]string)
	if tagsAttr := attrs.Get("tags"); tagsAttr != nil {
		if tagsMap, ok := tagsAttr.(map[string]interface{}); ok {
			for k, v := range tagsMap {
				if s, ok := v.(string); ok {
					tags[k] = s
				}
			}
		}
	}
	return tags
}

func getMapString(m map[string]interface{}, key, defaultVal string) string {
	if v, ok := m[key]; ok {
		if s, ok := v.(string); ok {
			return s
		}
	}
	return defaultVal
}

func getMapInt(m map[string]interface{}, key string, defaultVal int) int {
	if v, ok := m[key]; ok {
		switch n := v.(type) {
		case int:
			return n
		case int64:
			return int(n)
		case float64:
			return int(n)
		}
	}
	return defaultVal
}

func getMapBool(m map[string]interface{}, key string, defaultVal bool) bool {
	if v, ok := m[key]; ok {
		if b, ok := v.(bool); ok {
			return b
		}
	}
	return defaultVal
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\assets\network.go
# TYPE: go
# SIZE: 4609 bytes
################################################################################
// Package assets - AWS network asset builders
package assets

import (
	"context"
	"fmt"

	"terraform-cost/core/asset"
	"terraform-cost/core/types"
)

// NATGatewayBuilder builds assets for aws_nat_gateway
type NATGatewayBuilder struct {
	baseBuilder
}

// NewNATGatewayBuilder creates a new NAT Gateway builder
func NewNATGatewayBuilder() asset.Builder {
	return &NATGatewayBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_nat_gateway",
			category:     types.CategoryNetwork,
		},
	}
}

// Build converts a raw NAT Gateway into an asset
func (b *NATGatewayBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	return &types.Asset{
		ID:       fmt.Sprintf("aws_nat_gateway.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryNetwork,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"connectivity_type": raw.Attributes["connectivity_type"],
			"subnet_id":         raw.Attributes["subnet_id"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// VPCEndpointBuilder builds assets for aws_vpc_endpoint
type VPCEndpointBuilder struct {
	baseBuilder
}

// NewVPCEndpointBuilder creates a new VPC Endpoint builder
func NewVPCEndpointBuilder() asset.Builder {
	return &VPCEndpointBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_vpc_endpoint",
			category:     types.CategoryNetwork,
		},
	}
}

// Build converts a raw VPC Endpoint into an asset
func (b *VPCEndpointBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	vpcEndpointType := raw.Attributes.GetString("vpc_endpoint_type")
	if vpcEndpointType == "" {
		vpcEndpointType = "Gateway"
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_vpc_endpoint.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryNetwork,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"vpc_endpoint_type": {Value: vpcEndpointType},
			"service_name":      raw.Attributes["service_name"],
			"vpc_id":            raw.Attributes["vpc_id"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// ELBBuilder builds assets for aws_elb (Classic)
type ELBBuilder struct {
	baseBuilder
}

// NewELBBuilder creates a new ELB builder
func NewELBBuilder() asset.Builder {
	return &ELBBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_elb",
			category:     types.CategoryNetwork,
		},
	}
}

// Build converts a raw ELB into an asset
func (b *ELBBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	return &types.Asset{
		ID:       fmt.Sprintf("aws_elb.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryNetwork,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"internal": raw.Attributes["internal"],
			"listener": raw.Attributes["listener"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// ALBBuilder builds assets for aws_lb (Application)
type ALBBuilder struct {
	baseBuilder
}

// NewALBBuilder creates a new ALB builder
func NewALBBuilder() asset.Builder {
	return &ALBBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_lb",
			category:     types.CategoryNetwork,
		},
	}
}

// Build converts a raw ALB/NLB into an asset
func (b *ALBBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	loadBalancerType := raw.Attributes.GetString("load_balancer_type")
	if loadBalancerType == "" {
		loadBalancerType = "application"
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_lb.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryNetwork,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"load_balancer_type": {Value: loadBalancerType},
			"internal":           raw.Attributes["internal"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// NLBBuilder builds assets for aws_lb (Network) - alias to ALBBuilder
func NewNLBBuilder() asset.Builder {
	return NewALBBuilder()
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\assets\other.go
# TYPE: go
# SIZE: 3785 bytes
################################################################################
// Package assets - AWS other asset builders
package assets

import (
	"context"
	"fmt"

	"terraform-cost/core/asset"
	"terraform-cost/core/types"
)

// CloudWatchLogGroupBuilder builds assets for aws_cloudwatch_log_group
type CloudWatchLogGroupBuilder struct {
	baseBuilder
}

// NewCloudWatchLogGroupBuilder creates a new CloudWatch Log Group builder
func NewCloudWatchLogGroupBuilder() asset.Builder {
	return &CloudWatchLogGroupBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_cloudwatch_log_group",
			category:     types.CategoryMonitoring,
		},
	}
}

// Build converts a raw CloudWatch Log Group into an asset
func (b *CloudWatchLogGroupBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	retentionDays := raw.Attributes.GetInt("retention_in_days")
	// 0 means never expire

	return &types.Asset{
		ID:       fmt.Sprintf("aws_cloudwatch_log_group.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryMonitoring,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"retention_in_days": {Value: retentionDays},
			"kms_key_id":        raw.Attributes["kms_key_id"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// KMSKeyBuilder builds assets for aws_kms_key
type KMSKeyBuilder struct {
	baseBuilder
}

// NewKMSKeyBuilder creates a new KMS Key builder
func NewKMSKeyBuilder() asset.Builder {
	return &KMSKeyBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_kms_key",
			category:     types.CategorySecurity,
		},
	}
}

// Build converts a raw KMS Key into an asset
func (b *KMSKeyBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	keySpec := raw.Attributes.GetString("customer_master_key_spec")
	if keySpec == "" {
		keySpec = "SYMMETRIC_DEFAULT"
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_kms_key.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategorySecurity,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"customer_master_key_spec": {Value: keySpec},
			"key_usage":                raw.Attributes["key_usage"],
			"is_enabled":               raw.Attributes["is_enabled"],
			"multi_region":              raw.Attributes["multi_region"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// SecretsManagerSecretBuilder builds assets for aws_secretsmanager_secret
type SecretsManagerSecretBuilder struct {
	baseBuilder
}

// NewSecretsManagerSecretBuilder creates a new Secrets Manager builder
func NewSecretsManagerSecretBuilder() asset.Builder {
	return &SecretsManagerSecretBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_secretsmanager_secret",
			category:     types.CategorySecurity,
		},
	}
}

// Build converts a raw Secrets Manager Secret into an asset
func (b *SecretsManagerSecretBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	return &types.Asset{
		ID:       fmt.Sprintf("aws_secretsmanager_secret.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategorySecurity,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"recovery_window_in_days": raw.Attributes["recovery_window_in_days"],
			"kms_key_id":              raw.Attributes["kms_key_id"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\assets\storage.go
# TYPE: go
# SIZE: 4249 bytes
################################################################################
// Package assets - AWS storage asset builders
package assets

import (
	"context"
	"fmt"

	"terraform-cost/core/asset"
	"terraform-cost/core/types"
)

// S3BucketBuilder builds assets for aws_s3_bucket
type S3BucketBuilder struct {
	baseBuilder
}

// NewS3BucketBuilder creates a new S3 bucket builder
func NewS3BucketBuilder() asset.Builder {
	return &S3BucketBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_s3_bucket",
			category:     types.CategoryStorage,
		},
	}
}

// Build converts a raw S3 bucket into an asset
func (b *S3BucketBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	return &types.Asset{
		ID:       fmt.Sprintf("aws_s3_bucket.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryStorage,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"bucket": raw.Attributes["bucket"],
			"acl":    raw.Attributes["acl"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// EBSVolumeBuilder builds assets for aws_ebs_volume
type EBSVolumeBuilder struct {
	baseBuilder
}

// NewEBSVolumeBuilder creates a new EBS volume builder
func NewEBSVolumeBuilder() asset.Builder {
	return &EBSVolumeBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_ebs_volume",
			category:     types.CategoryStorage,
		},
	}
}

// Build converts a raw EBS volume into an asset
func (b *EBSVolumeBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	volumeType := raw.Attributes.GetString("type")
	if volumeType == "" {
		volumeType = "gp3"
	}

	size := raw.Attributes.GetInt("size")
	if size == 0 {
		size = 8
	}

	az := raw.Attributes.GetString("availability_zone")
	region := ""
	if len(az) > 0 {
		region = az[:len(az)-1]
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_ebs_volume.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryStorage,
		Type:     raw.Type,
		Name:     raw.Name,
		Region:   types.Region(region),
		Attributes: types.Attributes{
			"type":              {Value: volumeType},
			"size":              {Value: size},
			"iops":              raw.Attributes["iops"],
			"throughput":        raw.Attributes["throughput"],
			"encrypted":         raw.Attributes["encrypted"],
			"availability_zone": {Value: az},
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// EFSFileSystemBuilder builds assets for aws_efs_file_system
type EFSFileSystemBuilder struct {
	baseBuilder
}

// NewEFSFileSystemBuilder creates a new EFS builder
func NewEFSFileSystemBuilder() asset.Builder {
	return &EFSFileSystemBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_efs_file_system",
			category:     types.CategoryStorage,
		},
	}
}

// Build converts a raw EFS file system into an asset
func (b *EFSFileSystemBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	throughputMode := raw.Attributes.GetString("throughput_mode")
	if throughputMode == "" {
		throughputMode = "bursting"
	}

	performanceMode := raw.Attributes.GetString("performance_mode")
	if performanceMode == "" {
		performanceMode = "generalPurpose"
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_efs_file_system.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryStorage,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"throughput_mode":                  {Value: throughputMode},
			"performance_mode":                 {Value: performanceMode},
			"provisioned_throughput_in_mibps":  raw.Attributes["provisioned_throughput_in_mibps"],
			"encrypted":                        raw.Attributes["encrypted"],
			"lifecycle_policy":                 raw.Attributes["lifecycle_policy"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\pricing\source.go
# TYPE: go
# SIZE: 7230 bytes
################################################################################
// Package pricing provides AWS pricing source.
package pricing

import (
	"context"
	"fmt"
	"time"

	"github.com/shopspring/decimal"

	corePricing "terraform-cost/core/pricing"
	"terraform-cost/core/types"
)

// AWSPricingSource fetches pricing from AWS Pricing API
type AWSPricingSource struct {
	defaultRegion string
	// In production, this would use the AWS SDK
	// client *pricing.Client
}

// NewAWSPricingSource creates a new AWS pricing source
func NewAWSPricingSource(region string) corePricing.Source {
	return &AWSPricingSource{
		defaultRegion: region,
	}
}

// Provider returns AWS
func (s *AWSPricingSource) Provider() types.Provider {
	return types.ProviderAWS
}

// FetchRates retrieves rates for the given keys
func (s *AWSPricingSource) FetchRates(ctx context.Context, keys []types.RateKey) ([]types.Rate, error) {
	rates := make([]types.Rate, 0, len(keys))

	for _, key := range keys {
		rate, err := s.fetchRate(ctx, key)
		if err != nil {
			continue // Skip missing rates
		}
		rates = append(rates, rate)
	}

	return rates, nil
}

// FetchAll retrieves all rates for a region
func (s *AWSPricingSource) FetchAll(ctx context.Context, region string) ([]types.Rate, error) {
	// In production, this would call the AWS Pricing API
	// For now, return common defaults
	return s.getDefaultRates(region), nil
}

// SupportedRegions returns the list of supported AWS regions
func (s *AWSPricingSource) SupportedRegions() []string {
	return []string{
		"us-east-1", "us-east-2", "us-west-1", "us-west-2",
		"eu-west-1", "eu-west-2", "eu-west-3", "eu-central-1",
		"ap-northeast-1", "ap-northeast-2", "ap-southeast-1", "ap-southeast-2",
		"ap-south-1", "sa-east-1", "ca-central-1",
	}
}

func (s *AWSPricingSource) fetchRate(ctx context.Context, key types.RateKey) (types.Rate, error) {
	// In production, this would call the AWS Pricing API
	// For now, return hardcoded defaults for common resources

	switch key.Service {
	case "EC2":
		return s.getEC2Rate(key)
	case "RDS":
		return s.getRDSRate(key)
	case "S3":
		return s.getS3Rate(key)
	case "Lambda":
		return s.getLambdaRate(key)
	case "NAT Gateway":
		return s.getNATGatewayRate(key)
	case "EBS":
		return s.getEBSRate(key)
	default:
		return types.Rate{}, fmt.Errorf("unknown service: %s", key.Service)
	}
}

func (s *AWSPricingSource) getEC2Rate(key types.RateKey) (types.Rate, error) {
	// Instance type pricing (On-Demand, us-east-1)
	instancePricing := map[string]float64{
		"t3.micro":    0.0104,
		"t3.small":    0.0208,
		"t3.medium":   0.0416,
		"t3.large":    0.0832,
		"t3.xlarge":   0.1664,
		"t3.2xlarge":  0.3328,
		"m5.large":    0.096,
		"m5.xlarge":   0.192,
		"m5.2xlarge":  0.384,
		"m5.4xlarge":  0.768,
		"c5.large":    0.085,
		"c5.xlarge":   0.17,
		"c5.2xlarge":  0.34,
		"r5.large":    0.126,
		"r5.xlarge":   0.252,
		"r5.2xlarge":  0.504,
	}

	instanceType := key.Attributes["instance_type"]
	price, ok := instancePricing[instanceType]
	if !ok {
		price = 0.10 // Default
	}

	return types.Rate{
		Key:           key,
		Price:         decimal.NewFromFloat(price),
		Unit:          "hour",
		Currency:      types.CurrencyUSD,
		EffectiveFrom: time.Now().AddDate(0, -1, 0),
	}, nil
}

func (s *AWSPricingSource) getRDSRate(key types.RateKey) (types.Rate, error) {
	// RDS instance pricing (Single-AZ, us-east-1)
	instancePricing := map[string]float64{
		"db.t3.micro":   0.017,
		"db.t3.small":   0.034,
		"db.t3.medium":  0.068,
		"db.t3.large":   0.136,
		"db.m5.large":   0.171,
		"db.m5.xlarge":  0.342,
		"db.m5.2xlarge": 0.684,
		"db.r5.large":   0.24,
		"db.r5.xlarge":  0.48,
		"db.r5.2xlarge": 0.96,
	}

	instanceClass := key.Attributes["instance_class"]
	price, ok := instancePricing[instanceClass]
	if !ok {
		price = 0.10 // Default
	}

	return types.Rate{
		Key:           key,
		Price:         decimal.NewFromFloat(price),
		Unit:          "hour",
		Currency:      types.CurrencyUSD,
		EffectiveFrom: time.Now().AddDate(0, -1, 0),
	}, nil
}

func (s *AWSPricingSource) getS3Rate(key types.RateKey) (types.Rate, error) {
	// S3 pricing (Standard, us-east-1)
	storageClass := key.Attributes["storage_class"]
	if storageClass == "" {
		storageClass = "STANDARD"
	}

	prices := map[string]float64{
		"STANDARD":            0.023,  // per GB-month
		"STANDARD_IA":         0.0125,
		"ONEZONE_IA":          0.01,
		"GLACIER":             0.004,
		"GLACIER_DEEP_ARCHIVE": 0.00099,
	}

	price, ok := prices[storageClass]
	if !ok {
		price = 0.023
	}

	return types.Rate{
		Key:           key,
		Price:         decimal.NewFromFloat(price),
		Unit:          "GB-month",
		Currency:      types.CurrencyUSD,
		EffectiveFrom: time.Now().AddDate(0, -1, 0),
	}, nil
}

func (s *AWSPricingSource) getLambdaRate(key types.RateKey) (types.Rate, error) {
	// Lambda is priced per GB-second and per request
	rateType := key.Attributes["rate_type"]

	switch rateType {
	case "requests":
		return types.Rate{
			Key:           key,
			Price:         decimal.NewFromFloat(0.0000002), // $0.20 per 1M requests
			Unit:          "request",
			Currency:      types.CurrencyUSD,
			EffectiveFrom: time.Now().AddDate(0, -1, 0),
		}, nil
	case "duration":
		return types.Rate{
			Key:           key,
			Price:         decimal.NewFromFloat(0.0000166667), // per GB-second
			Unit:          "GB-second",
			Currency:      types.CurrencyUSD,
			EffectiveFrom: time.Now().AddDate(0, -1, 0),
		}, nil
	default:
		return types.Rate{}, fmt.Errorf("unknown Lambda rate type")
	}
}

func (s *AWSPricingSource) getNATGatewayRate(key types.RateKey) (types.Rate, error) {
	rateType := key.Attributes["rate_type"]

	switch rateType {
	case "hourly":
		return types.Rate{
			Key:           key,
			Price:         decimal.NewFromFloat(0.045), // per hour
			Unit:          "hour",
			Currency:      types.CurrencyUSD,
			EffectiveFrom: time.Now().AddDate(0, -1, 0),
		}, nil
	case "data":
		return types.Rate{
			Key:           key,
			Price:         decimal.NewFromFloat(0.045), // per GB processed
			Unit:          "GB",
			Currency:      types.CurrencyUSD,
			EffectiveFrom: time.Now().AddDate(0, -1, 0),
		}, nil
	default:
		return types.Rate{}, fmt.Errorf("unknown NAT Gateway rate type")
	}
}

func (s *AWSPricingSource) getEBSRate(key types.RateKey) (types.Rate, error) {
	// EBS pricing per GB-month
	volumeType := key.Attributes["volume_type"]

	prices := map[string]float64{
		"gp3":      0.08,
		"gp2":      0.10,
		"io1":      0.125,
		"io2":      0.125,
		"st1":      0.045,
		"sc1":      0.015,
		"standard": 0.05,
	}

	price, ok := prices[volumeType]
	if !ok {
		price = 0.10
	}

	return types.Rate{
		Key:           key,
		Price:         decimal.NewFromFloat(price),
		Unit:          "GB-month",
		Currency:      types.CurrencyUSD,
		EffectiveFrom: time.Now().AddDate(0, -1, 0),
	}, nil
}

func (s *AWSPricingSource) getDefaultRates(region string) []types.Rate {
	// Return a set of common default rates
	// In production, this would be fetched from AWS
	return []types.Rate{}
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\usage\estimators.go
# TYPE: go
# SIZE: 10814 bytes
################################################################################
// Package usage provides AWS usage estimators.
package usage

import (
	"context"

	"terraform-cost/core/types"
	coreUsage "terraform-cost/core/usage"
)

// baseEstimator provides common functionality for AWS estimators
type baseEstimator struct {
	resourceType string
}

func (e *baseEstimator) Provider() types.Provider {
	return types.ProviderAWS
}

func (e *baseEstimator) ResourceType() string {
	return e.resourceType
}

// EC2InstanceEstimator estimates usage for aws_instance
type EC2InstanceEstimator struct {
	baseEstimator
}

// NewEC2InstanceEstimator creates a new EC2 instance estimator
func NewEC2InstanceEstimator() coreUsage.Estimator {
	return &EC2InstanceEstimator{
		baseEstimator: baseEstimator{resourceType: "aws_instance"},
	}
}

// Estimate produces usage vectors for an EC2 instance
func (e *EC2InstanceEstimator) Estimate(ctx context.Context, asset *types.Asset, uctx *coreUsage.Context) ([]types.UsageVector, error) {
	// Default: 24/7 operation = 730 hours/month
	monthlyHours := 730.0
	confidence := 0.8

	// Check for overrides
	if uctx != nil && uctx.Profile != nil {
		if overrides := uctx.Profile.GetOverrides(asset.Address); len(overrides) > 0 {
			return overrides, nil
		}
	}

	// Adjust based on environment
	if uctx != nil && uctx.Environment == "development" {
		// Dev environments typically run 8 hours/day, 5 days/week
		monthlyHours = 8 * 5 * 4 // ~160 hours
		confidence = 0.6
	}

	return []types.UsageVector{
		{
			Metric:      types.MetricMonthlyHours,
			Value:       monthlyHours,
			Confidence:  confidence,
			Source:      types.SourceDefault,
			Description: "Estimated monthly runtime hours",
		},
	}, nil
}

// S3BucketEstimator estimates usage for aws_s3_bucket
type S3BucketEstimator struct {
	baseEstimator
}

// NewS3BucketEstimator creates a new S3 bucket estimator
func NewS3BucketEstimator() coreUsage.Estimator {
	return &S3BucketEstimator{
		baseEstimator: baseEstimator{resourceType: "aws_s3_bucket"},
	}
}

// Estimate produces usage vectors for an S3 bucket
func (e *S3BucketEstimator) Estimate(ctx context.Context, asset *types.Asset, uctx *coreUsage.Context) ([]types.UsageVector, error) {
	// Check for overrides
	if uctx != nil && uctx.Profile != nil {
		if overrides := uctx.Profile.GetOverrides(asset.Address); len(overrides) > 0 {
			return overrides, nil
		}
	}

	// Default estimates - these should be overridden in production
	return []types.UsageVector{
		{
			Metric:      types.MetricMonthlyGBStorage,
			Value:       100, // 100 GB default
			Confidence:  0.3, // Low confidence - highly variable
			Source:      types.SourceDefault,
			Description: "Estimated monthly storage in GB",
		},
		{
			Metric:      types.MetricMonthlyGetOperations,
			Value:       100000, // 100k GET requests
			Confidence:  0.3,
			Source:      types.SourceDefault,
			Description: "Estimated monthly GET requests",
		},
		{
			Metric:      types.MetricMonthlyPutOperations,
			Value:       10000, // 10k PUT requests
			Confidence:  0.3,
			Source:      types.SourceDefault,
			Description: "Estimated monthly PUT requests",
		},
		{
			Metric:      types.MetricMonthlyGBTransferOut,
			Value:       10, // 10 GB transfer out
			Confidence:  0.3,
			Source:      types.SourceDefault,
			Description: "Estimated monthly data transfer out in GB",
		},
	}, nil
}

// RDSInstanceEstimator estimates usage for aws_db_instance
type RDSInstanceEstimator struct {
	baseEstimator
}

// NewRDSInstanceEstimator creates a new RDS instance estimator
func NewRDSInstanceEstimator() coreUsage.Estimator {
	return &RDSInstanceEstimator{
		baseEstimator: baseEstimator{resourceType: "aws_db_instance"},
	}
}

// Estimate produces usage vectors for an RDS instance
func (e *RDSInstanceEstimator) Estimate(ctx context.Context, asset *types.Asset, uctx *coreUsage.Context) ([]types.UsageVector, error) {
	// Check for overrides
	if uctx != nil && uctx.Profile != nil {
		if overrides := uctx.Profile.GetOverrides(asset.Address); len(overrides) > 0 {
			return overrides, nil
		}
	}

	// Get storage from attributes
	storage := asset.Attributes.GetInt("allocated_storage")
	if storage == 0 {
		storage = 20
	}

	return []types.UsageVector{
		{
			Metric:      types.MetricMonthlyHours,
			Value:       730, // 24/7
			Confidence:  0.9,
			Source:      types.SourceDefault,
			Description: "Database typically runs 24/7",
		},
		{
			Metric:      types.MetricMonthlyGBStorage,
			Value:       float64(storage),
			Confidence:  0.95,
			Source:      types.SourceTerraform,
			Description: "Storage from Terraform configuration",
		},
		{
			Metric:      types.MetricMonthlyBackupStorageGB,
			Value:       float64(storage), // Assume backup equals storage
			Confidence:  0.5,
			Source:      types.SourceDefault,
			Description: "Estimated backup storage",
		},
	}, nil
}

// LambdaFunctionEstimator estimates usage for aws_lambda_function
type LambdaFunctionEstimator struct {
	baseEstimator
}

// NewLambdaFunctionEstimator creates a new Lambda function estimator
func NewLambdaFunctionEstimator() coreUsage.Estimator {
	return &LambdaFunctionEstimator{
		baseEstimator: baseEstimator{resourceType: "aws_lambda_function"},
	}
}

// Estimate produces usage vectors for a Lambda function
func (e *LambdaFunctionEstimator) Estimate(ctx context.Context, asset *types.Asset, uctx *coreUsage.Context) ([]types.UsageVector, error) {
	// Check for overrides
	if uctx != nil && uctx.Profile != nil {
		if overrides := uctx.Profile.GetOverrides(asset.Address); len(overrides) > 0 {
			return overrides, nil
		}
	}

	memorySize := asset.Attributes.GetInt("memory_size")
	if memorySize == 0 {
		memorySize = 128
	}

	timeout := asset.Attributes.GetInt("timeout")
	if timeout == 0 {
		timeout = 3
	}

	// Default: 1 million invocations, average 500ms duration
	invocations := 1000000.0
	avgDurationMs := float64(timeout) * 1000 * 0.5 // 50% of timeout

	return []types.UsageVector{
		{
			Metric:      types.MetricMonthlyInvocations,
			Value:       invocations,
			Confidence:  0.3, // Very variable
			Source:      types.SourceDefault,
			Description: "Estimated monthly invocations",
		},
		{
			Metric:      types.MetricMonthlyDurationMs,
			Value:       avgDurationMs,
			Confidence:  0.3,
			Source:      types.SourceDefault,
			Description: "Average execution duration in ms",
		},
		{
			Metric:      types.MetricMonthlyGBSeconds,
			Value:       (float64(memorySize) / 1024) * (avgDurationMs / 1000) * invocations,
			Confidence:  0.3,
			Source:      types.SourceDefault,
			Description: "Compute GB-seconds",
		},
	}, nil
}

// DynamoDBTableEstimator estimates usage for aws_dynamodb_table
type DynamoDBTableEstimator struct {
	baseEstimator
}

// NewDynamoDBTableEstimator creates a new DynamoDB table estimator
func NewDynamoDBTableEstimator() coreUsage.Estimator {
	return &DynamoDBTableEstimator{
		baseEstimator: baseEstimator{resourceType: "aws_dynamodb_table"},
	}
}

// Estimate produces usage vectors for a DynamoDB table
func (e *DynamoDBTableEstimator) Estimate(ctx context.Context, asset *types.Asset, uctx *coreUsage.Context) ([]types.UsageVector, error) {
	// Check for overrides
	if uctx != nil && uctx.Profile != nil {
		if overrides := uctx.Profile.GetOverrides(asset.Address); len(overrides) > 0 {
			return overrides, nil
		}
	}

	billingMode := asset.Attributes.GetString("billing_mode")

	vectors := []types.UsageVector{
		{
			Metric:      types.MetricMonthlyGBStorage,
			Value:       10, // 10 GB default
			Confidence:  0.3,
			Source:      types.SourceDefault,
			Description: "Estimated table storage",
		},
	}

	if billingMode == "PAY_PER_REQUEST" {
		vectors = append(vectors,
			types.UsageVector{
				Metric:      types.MetricMonthlyReadRequests,
				Value:       1000000,
				Confidence:  0.3,
				Source:      types.SourceDefault,
				Description: "Estimated read request units",
			},
			types.UsageVector{
				Metric:      types.MetricMonthlyWriteRequests,
				Value:       100000,
				Confidence:  0.3,
				Source:      types.SourceDefault,
				Description: "Estimated write request units",
			},
		)
	}

	return vectors, nil
}

// NATGatewayEstimator estimates usage for aws_nat_gateway
type NATGatewayEstimator struct {
	baseEstimator
}

// NewNATGatewayEstimator creates a new NAT Gateway estimator
func NewNATGatewayEstimator() coreUsage.Estimator {
	return &NATGatewayEstimator{
		baseEstimator: baseEstimator{resourceType: "aws_nat_gateway"},
	}
}

// Estimate produces usage vectors for a NAT Gateway
func (e *NATGatewayEstimator) Estimate(ctx context.Context, asset *types.Asset, uctx *coreUsage.Context) ([]types.UsageVector, error) {
	// Check for overrides
	if uctx != nil && uctx.Profile != nil {
		if overrides := uctx.Profile.GetOverrides(asset.Address); len(overrides) > 0 {
			return overrides, nil
		}
	}

	return []types.UsageVector{
		{
			Metric:      types.MetricMonthlyHours,
			Value:       730, // 24/7
			Confidence:  0.95,
			Source:      types.SourceDefault,
			Description: "NAT Gateway runs continuously",
		},
		{
			Metric:      types.MetricMonthlyGB,
			Value:       100, // 100 GB data processed
			Confidence:  0.3,
			Source:      types.SourceDefault,
			Description: "Estimated data processed through NAT",
		},
	}, nil
}

// EBSVolumeEstimator estimates usage for aws_ebs_volume
type EBSVolumeEstimator struct {
	baseEstimator
}

// NewEBSVolumeEstimator creates a new EBS volume estimator
func NewEBSVolumeEstimator() coreUsage.Estimator {
	return &EBSVolumeEstimator{
		baseEstimator: baseEstimator{resourceType: "aws_ebs_volume"},
	}
}

// Estimate produces usage vectors for an EBS volume
func (e *EBSVolumeEstimator) Estimate(ctx context.Context, asset *types.Asset, uctx *coreUsage.Context) ([]types.UsageVector, error) {
	// Check for overrides
	if uctx != nil && uctx.Profile != nil {
		if overrides := uctx.Profile.GetOverrides(asset.Address); len(overrides) > 0 {
			return overrides, nil
		}
	}

	size := asset.Attributes.GetInt("size")
	if size == 0 {
		size = 8
	}

	return []types.UsageVector{
		{
			Metric:      types.MetricMonthlyGBStorage,
			Value:       float64(size),
			Confidence:  0.95,
			Source:      types.SourceTerraform,
			Description: "Volume size from Terraform configuration",
		},
		{
			Metric:      types.MetricMonthlySnapshots,
			Value:       1, // One snapshot per month
			Confidence:  0.5,
			Source:      types.SourceDefault,
			Description: "Estimated monthly snapshots",
		},
	}, nil
}

################################################################################
# FILE: :\good projects\cost estimation\cmd\cli\main.go
# TYPE: go
# SIZE: 207 bytes
################################################################################
// Package main is the entry point for terraform-cost CLI.
package main

import (
	"os"

	"terraform-cost/cmd/cli/cmd"
)

func main() {
	if err := cmd.Execute(); err != nil {
		os.Exit(1)
	}
}

################################################################################
# FILE: :\good projects\cost estimation\cmd\cli\cmd\estimate.go
# TYPE: go
# SIZE: 12916 bytes
################################################################################
// Package cmd - estimate command
package cmd

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/shopspring/decimal"
	"github.com/spf13/cobra"

	"terraform-cost/clouds"
	"terraform-cost/clouds/aws"
	"terraform-cost/core/asset"
	"terraform-cost/core/output"
	"terraform-cost/core/scanner"
	"terraform-cost/core/types"
	"terraform-cost/internal/logging"
)

var (
	outputFormat string
	usageFile    string
	showDetails  bool
	region       string
)

// estimateCmd represents the estimate command
var estimateCmd = &cobra.Command{
	Use:   "estimate [path]",
	Short: "Estimate costs for a Terraform project",
	Long: `Analyze Terraform configurations and produce cost estimates.

The path can be a directory containing .tf files or a Terraform plan JSON file.

Examples:
  terraform-cost estimate .
  terraform-cost estimate ./infrastructure
  terraform-cost estimate --format json ./my-project
  terraform-cost estimate --usage usage.yml ./my-project`,
	Args: cobra.MaximumNArgs(1),
	RunE: runEstimate,
}

func init() {
	estimateCmd.Flags().StringVarP(&outputFormat, "format", "f", "cli", "output format (cli, json, html, markdown)")
	estimateCmd.Flags().StringVarP(&usageFile, "usage", "u", "", "usage file for custom usage estimates")
	estimateCmd.Flags().BoolVarP(&showDetails, "details", "d", true, "show detailed cost breakdown")
	estimateCmd.Flags().StringVarP(&region, "region", "r", "", "default AWS region")
}

func runEstimate(cmd *cobra.Command, args []string) error {
	ctx := context.Background()
	startTime := time.Now()

	// Determine path
	path := "."
	if len(args) > 0 {
		path = args[0]
	}

	// Validate path exists
	if _, err := os.Stat(path); os.IsNotExist(err) {
		return fmt.Errorf("path does not exist: %s", path)
	}

	logging.Info("Starting cost estimation")

	// Initialize cloud plugins
	if err := initializePlugins(); err != nil {
		return fmt.Errorf("failed to initialize plugins: %w", err)
	}

	// Create project input
	input := &types.ProjectInput{
		ID:     fmt.Sprintf("estimate-%d", time.Now().Unix()),
		Path:   path,
		Source: types.SourceCLI,
		Metadata: types.InputMetadata{
			Timestamp: time.Now(),
		},
	}

	// Scan the project
	fmt.Println("Scanning Terraform files...")
	scanResult, err := scanner.GetDefault().DetectAndScan(ctx, input)
	if err != nil {
		return fmt.Errorf("failed to scan project: %w", err)
	}

	if scanResult.HasErrors() {
		fmt.Printf("Warning: %d errors during scanning\n", len(scanResult.Errors))
		for _, e := range scanResult.Errors {
			fmt.Printf("  %s:%d: %s\n", e.File, e.Line, e.Message)
		}
	}

	if len(scanResult.Assets) == 0 {
		fmt.Println("No resources found in the project.")
		return nil
	}

	fmt.Printf("Found %d resources\n\n", len(scanResult.Assets))

	// Build asset graph
	graph := buildAssetGraph(ctx, scanResult.Assets)

	// Calculate costs (simplified)
	costGraph := calculateCosts(graph)

	// Create estimation result
	result := &output.EstimationResult{
		CostGraph:  costGraph,
		AssetGraph: graph,
		Confidence: 0.7,
		Metadata: output.EstimationMetadata{
			Timestamp: time.Now().Format(time.RFC3339),
			Duration:  time.Since(startTime).String(),
			Version:   "0.1.0",
			Source:    types.SourceCLI,
		},
	}

	// Output results
	printResults(result)

	return nil
}

func initializePlugins() error {
	// Register AWS plugin
	awsPlugin := aws.New()
	if region != "" {
		awsPlugin = aws.NewWithRegion(region)
	}
	
	if err := clouds.RegisterPlugin(awsPlugin); err != nil {
		return err
	}

	return nil
}

func buildAssetGraph(ctx context.Context, rawAssets []types.RawAsset) *types.AssetGraph {
	graph := types.NewAssetGraph()
	builderRegistry := asset.GetDefaultBuilderRegistry()

	// Register AWS builders
	awsPlugin := aws.New()
	for _, builder := range awsPlugin.AssetBuilders() {
		builderRegistry.Register(builder)
	}

	for _, raw := range rawAssets {
		builder, ok := builderRegistry.GetBuilder(raw.Provider, raw.Type)
		if !ok {
			// No builder for this resource type - create a generic asset
			asset := &types.Asset{
				ID:         fmt.Sprintf("%s.%s", raw.Type, raw.Name),
				Address:    raw.Address,
				Provider:   raw.Provider,
				Category:   types.CategoryOther,
				Type:       raw.Type,
				Name:       raw.Name,
				Attributes: raw.Attributes,
				Metadata: types.AssetMetadata{
					Source: raw.SourceFile,
					Line:   raw.SourceLine,
				},
			}
			graph.Add(asset)
			continue
		}

		asset, err := builder.Build(ctx, &raw)
		if err != nil {
			fmt.Printf("Warning: failed to build asset %s: %v\n", raw.Address, err)
			continue
		}

		graph.Add(asset)
	}

	return graph
}

func calculateCosts(graph *types.AssetGraph) *types.CostGraph {
	costGraph := types.NewCostGraph(types.CurrencyUSD)

	graph.Walk(func(asset *types.Asset) error {
		// Calculate cost for this asset
		units := calculateAssetCost(asset)
		for _, unit := range units {
			costGraph.AddCostUnit(unit, asset)
		}
		return nil
	})

	costGraph.Summarize()
	return costGraph
}

func calculateAssetCost(asset *types.Asset) []*types.CostUnit {
	var units []*types.CostUnit

	// Simplified cost calculation based on resource type
	switch asset.Type {
	case "aws_instance":
		instanceType := asset.Attributes.GetString("instance_type")
		if instanceType == "" {
			instanceType = "t3.micro"
		}
		hourlyRate := getEC2HourlyRate(instanceType)
		monthlyHours := decimal.NewFromInt(730)
		monthlyCost := hourlyRate.Mul(monthlyHours)

		units = append(units, &types.CostUnit{
			ID:       fmt.Sprintf("%s-compute", asset.ID),
			Label:    fmt.Sprintf("EC2 Instance (%s)", instanceType),
			Measure:  "hours",
			Quantity: monthlyHours,
			Rate:     hourlyRate,
			Amount:   monthlyCost,
			Currency: types.CurrencyUSD,
			Lineage: types.CostLineage{
				AssetID:      asset.ID,
				AssetAddress: asset.Address,
				Formula:      "hourly_rate * 730 hours/month",
			},
		})

	case "aws_db_instance":
		instanceClass := asset.Attributes.GetString("instance_class")
		if instanceClass == "" {
			instanceClass = "db.t3.micro"
		}
		hourlyRate := getRDSHourlyRate(instanceClass)
		monthlyHours := decimal.NewFromInt(730)
		monthlyCost := hourlyRate.Mul(monthlyHours)

		units = append(units, &types.CostUnit{
			ID:       fmt.Sprintf("%s-compute", asset.ID),
			Label:    fmt.Sprintf("RDS Instance (%s)", instanceClass),
			Measure:  "hours",
			Quantity: monthlyHours,
			Rate:     hourlyRate,
			Amount:   monthlyCost,
			Currency: types.CurrencyUSD,
			Lineage: types.CostLineage{
				AssetID:      asset.ID,
				AssetAddress: asset.Address,
				Formula:      "hourly_rate * 730 hours/month",
			},
		})

		// Add storage cost
		storage := asset.Attributes.GetInt("allocated_storage")
		if storage > 0 {
			storageRate := decimal.NewFromFloat(0.115) // gp2 per GB-month
			storageCost := storageRate.Mul(decimal.NewFromInt(int64(storage)))
			units = append(units, &types.CostUnit{
				ID:       fmt.Sprintf("%s-storage", asset.ID),
				Label:    "RDS Storage (gp2)",
				Measure:  "GB-month",
				Quantity: decimal.NewFromInt(int64(storage)),
				Rate:     storageRate,
				Amount:   storageCost,
				Currency: types.CurrencyUSD,
				Lineage: types.CostLineage{
					AssetID:      asset.ID,
					AssetAddress: asset.Address,
					Formula:      "storage_gb * $0.115/GB-month",
				},
			})
		}

	case "aws_nat_gateway":
		hourlyRate := decimal.NewFromFloat(0.045)
		monthlyHours := decimal.NewFromInt(730)
		monthlyCost := hourlyRate.Mul(monthlyHours)

		units = append(units, &types.CostUnit{
			ID:       fmt.Sprintf("%s-hourly", asset.ID),
			Label:    "NAT Gateway",
			Measure:  "hours",
			Quantity: monthlyHours,
			Rate:     hourlyRate,
			Amount:   monthlyCost,
			Currency: types.CurrencyUSD,
			Lineage: types.CostLineage{
				AssetID:      asset.ID,
				AssetAddress: asset.Address,
				Formula:      "$0.045/hour * 730 hours/month",
			},
		})

	case "aws_ebs_volume":
		volumeType := asset.Attributes.GetString("type")
		if volumeType == "" {
			volumeType = "gp3"
		}
		size := asset.Attributes.GetInt("size")
		if size == 0 {
			size = 8
		}
		rate := getEBSRate(volumeType)
		amount := rate.Mul(decimal.NewFromInt(int64(size)))

		units = append(units, &types.CostUnit{
			ID:       fmt.Sprintf("%s-storage", asset.ID),
			Label:    fmt.Sprintf("EBS Volume (%s)", volumeType),
			Measure:  "GB-month",
			Quantity: decimal.NewFromInt(int64(size)),
			Rate:     rate,
			Amount:   amount,
			Currency: types.CurrencyUSD,
			Lineage: types.CostLineage{
				AssetID:      asset.ID,
				AssetAddress: asset.Address,
				Formula:      fmt.Sprintf("$%.3f/GB-month * %d GB", rate.InexactFloat64(), size),
			},
		})

	case "aws_lambda_function":
		// Lambda free tier: 1M requests, 400K GB-seconds
		// Just show a minimal cost for estimation
		units = append(units, &types.CostUnit{
			ID:       fmt.Sprintf("%s-compute", asset.ID),
			Label:    "Lambda Function (usage-based)",
			Measure:  "invocations",
			Quantity: decimal.NewFromInt(1000000),
			Rate:     decimal.NewFromFloat(0.0000002),
			Amount:   decimal.NewFromFloat(0.20),
			Currency: types.CurrencyUSD,
			Lineage: types.CostLineage{
				AssetID:      asset.ID,
				AssetAddress: asset.Address,
				Formula:      "Usage-based pricing (1M requests estimate)",
				Assumptions:  []string{"Estimated 1M invocations/month"},
			},
		})
	}

	return units
}

func getEC2HourlyRate(instanceType string) decimal.Decimal {
	rates := map[string]float64{
		"t3.micro":   0.0104,
		"t3.small":   0.0208,
		"t3.medium":  0.0416,
		"t3.large":   0.0832,
		"t3.xlarge":  0.1664,
		"m5.large":   0.096,
		"m5.xlarge":  0.192,
		"c5.large":   0.085,
		"r5.large":   0.126,
	}
	if rate, ok := rates[instanceType]; ok {
		return decimal.NewFromFloat(rate)
	}
	return decimal.NewFromFloat(0.10) // Default
}

func getRDSHourlyRate(instanceClass string) decimal.Decimal {
	rates := map[string]float64{
		"db.t3.micro":   0.017,
		"db.t3.small":   0.034,
		"db.t3.medium":  0.068,
		"db.m5.large":   0.171,
		"db.r5.large":   0.24,
	}
	if rate, ok := rates[instanceClass]; ok {
		return decimal.NewFromFloat(rate)
	}
	return decimal.NewFromFloat(0.10) // Default
}

func getEBSRate(volumeType string) decimal.Decimal {
	rates := map[string]float64{
		"gp3": 0.08,
		"gp2": 0.10,
		"io1": 0.125,
		"st1": 0.045,
		"sc1": 0.015,
	}
	if rate, ok := rates[volumeType]; ok {
		return decimal.NewFromFloat(rate)
	}
	return decimal.NewFromFloat(0.10) // Default
}

func printResults(result *output.EstimationResult) {
	fmt.Println("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
	fmt.Println("â”‚                        COST ESTIMATION SUMMARY                         â”‚")
	fmt.Println("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")

	// Print by resource
	for assetID, agg := range result.CostGraph.ByAsset {
		if len(agg.Units) == 0 {
			continue
		}
		fmt.Printf("â”‚ %-50s %20s â”‚\n", 
			truncate(assetID, 50), 
			fmt.Sprintf("$%.2f/month", agg.MonthlyCost.InexactFloat64()))
		
		if showDetails {
			for _, unit := range agg.Units {
				fmt.Printf("â”‚   â””â”€ %-46s %20s â”‚\n",
					truncate(unit.Label, 46),
					fmt.Sprintf("$%.2f", unit.Amount.InexactFloat64()))
			}
		}
	}

	fmt.Println("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")
	fmt.Printf("â”‚ %-50s %20s â”‚\n", 
		"TOTAL MONTHLY ESTIMATE",
		fmt.Sprintf("$%.2f", result.CostGraph.TotalMonthlyCost.InexactFloat64()))
	fmt.Printf("â”‚ %-50s %20s â”‚\n",
		"TOTAL HOURLY ESTIMATE",
		fmt.Sprintf("$%.4f", result.CostGraph.TotalHourlyCost.InexactFloat64()))
	fmt.Println("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")

	fmt.Printf("\nEstimation completed in %s\n", result.Metadata.Duration)
	fmt.Printf("Confidence: %.0f%%\n", result.Confidence*100)
}

func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}

################################################################################
# FILE: :\good projects\cost estimation\cmd\cli\cmd\root.go
# TYPE: go
# SIZE: 2116 bytes
################################################################################
// Package cmd provides the CLI commands for terraform-cost.
package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"

	"terraform-cost/internal/config"
	"terraform-cost/internal/logging"
)

var (
	cfgFile string
	verbose bool
)

// rootCmd represents the base command
var rootCmd = &cobra.Command{
	Use:   "terraform-cost",
	Short: "Estimate costs for Terraform infrastructure",
	Long: `terraform-cost is a cloud-agnostic infrastructure cost estimation tool.

It analyzes Terraform configurations and produces accurate, reproducible
cost estimates with full lineage tracking.

Examples:
  terraform-cost estimate ./my-terraform-project
  terraform-cost estimate --format json ./infrastructure
  terraform-cost diff main..feature-branch`,
}

// Execute runs the CLI
func Execute() error {
	return rootCmd.Execute()
}

func init() {
	cobra.OnInitialize(initConfig)

	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is $HOME/.terraform-cost.json)")
	rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "v", false, "enable verbose output")

	// Add subcommands
	rootCmd.AddCommand(estimateCmd)
	rootCmd.AddCommand(versionCmd)
	rootCmd.AddCommand(configCmd)
}

func initConfig() {
	if cfgFile != "" {
		cfg, err := config.Load(cfgFile)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
			os.Exit(1)
		}
		config.Set(cfg)
	}

	// Initialize logging
	cfg := config.Get()
	if verbose {
		cfg.Logging.Level = "debug"
	}
	if err := logging.Initialize(cfg.Logging); err != nil {
		fmt.Fprintf(os.Stderr, "Error initializing logging: %v\n", err)
	}
}

// versionCmd prints version information
var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Print version information",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("terraform-cost version 0.1.0")
	},
}

// configCmd manages configuration
var configCmd = &cobra.Command{
	Use:   "config",
	Short: "Manage configuration",
	Run: func(cmd *cobra.Command, args []string) {
		cmd.Help()
	},
}

################################################################################
# FILE: :\good projects\cost estimation\core\asset\builder.go
# TYPE: go
# SIZE: 2788 bytes
################################################################################
// Package asset provides the asset graph builder interface and types.
// This package builds the provider-agnostic infrastructure DAG.
package asset

import (
	"context"

	"terraform-cost/core/types"
)

// Builder constructs Asset nodes from RawAssets
type Builder interface {
	// Provider returns the cloud provider this builder handles
	Provider() types.Provider

	// ResourceType returns the resource type (e.g., "aws_instance")
	ResourceType() string

	// Build converts a RawAsset into an Asset
	Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error)

	// Category returns the asset category for this resource type
	Category() types.AssetCategory
}

// GraphBuilder builds an AssetGraph from raw assets
type GraphBuilder interface {
	// Build constructs an asset graph from raw assets
	Build(ctx context.Context, raw []types.RawAsset) (*types.AssetGraph, error)
}

// BuilderRegistry manages asset builder registration
type BuilderRegistry interface {
	// Register adds a builder to the registry
	Register(builder Builder) error

	// GetBuilder returns a builder for a specific provider and resource type
	GetBuilder(provider types.Provider, resourceType string) (Builder, bool)

	// GetProviderBuilders returns all builders for a provider
	GetProviderBuilders(provider types.Provider) []Builder

	// GetAllResourceTypes returns all registered resource types
	GetAllResourceTypes() []string
}

// BuildOptions configures asset building behavior
type BuildOptions struct {
	// ExpandCount expands count meta-argument into separate assets
	ExpandCount bool

	// ExpandForEach expands for_each meta-argument into separate assets
	ExpandForEach bool

	// ResolveReferences attempts to resolve resource references
	ResolveReferences bool

	// IncludeDataSources includes data sources in the graph
	IncludeDataSources bool
}

// DefaultBuildOptions returns sensible default build options
func DefaultBuildOptions() BuildOptions {
	return BuildOptions{
		ExpandCount:        true,
		ExpandForEach:      true,
		ResolveReferences:  true,
		IncludeDataSources: false,
	}
}

// BuildContext provides context for asset building
type BuildContext struct {
	// Options are the build options
	Options BuildOptions

	// Variables are resolved Terraform variables
	Variables map[string]interface{}

	// Providers are provider configurations
	Providers map[string]ProviderConfig
}

// ProviderConfig contains provider configuration
type ProviderConfig struct {
	// Name is the provider name
	Name string

	// Alias is the provider alias
	Alias string

	// Region is the provider region
	Region string

	// Config contains provider-specific configuration
	Config map[string]interface{}
}

################################################################################
# FILE: :\good projects\cost estimation\core\asset\registry.go
# TYPE: go
# SIZE: 2613 bytes
################################################################################
// Package asset - Asset builder registry
package asset

import (
	"fmt"
	"sync"

	"terraform-cost/core/types"
)

// DefaultBuilderRegistry is the default implementation of BuilderRegistry
type DefaultBuilderRegistry struct {
	mu       sync.RWMutex
	builders map[string]Builder // key: provider/resource_type
	byType   map[string][]Builder
}

// NewBuilderRegistry creates a new builder registry
func NewBuilderRegistry() *DefaultBuilderRegistry {
	return &DefaultBuilderRegistry{
		builders: make(map[string]Builder),
		byType:   make(map[string][]Builder),
	}
}

// Register adds a builder to the registry
func (r *DefaultBuilderRegistry) Register(builder Builder) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := makeKey(builder.Provider(), builder.ResourceType())
	if _, exists := r.builders[key]; exists {
		return fmt.Errorf("builder already registered: %s", key)
	}

	r.builders[key] = builder
	r.byType[builder.ResourceType()] = append(r.byType[builder.ResourceType()], builder)
	return nil
}

// GetBuilder returns a builder for a specific provider and resource type
func (r *DefaultBuilderRegistry) GetBuilder(provider types.Provider, resourceType string) (Builder, bool) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	key := makeKey(provider, resourceType)
	builder, ok := r.builders[key]
	return builder, ok
}

// GetProviderBuilders returns all builders for a provider
func (r *DefaultBuilderRegistry) GetProviderBuilders(provider types.Provider) []Builder {
	r.mu.RLock()
	defer r.mu.RUnlock()

	var builders []Builder
	prefix := string(provider) + "/"
	for key, builder := range r.builders {
		if len(key) > len(prefix) && key[:len(prefix)] == prefix {
			builders = append(builders, builder)
		}
	}
	return builders
}

// GetAllResourceTypes returns all registered resource types
func (r *DefaultBuilderRegistry) GetAllResourceTypes() []string {
	r.mu.RLock()
	defer r.mu.RUnlock()

	types := make([]string, 0, len(r.byType))
	for t := range r.byType {
		types = append(types, t)
	}
	return types
}

func makeKey(provider types.Provider, resourceType string) string {
	return string(provider) + "/" + resourceType
}

// Global default registry
var defaultBuilderRegistry = NewBuilderRegistry()

// RegisterBuilder adds a builder to the default registry
func RegisterBuilder(builder Builder) error {
	return defaultBuilderRegistry.Register(builder)
}

// GetDefaultBuilderRegistry returns the default builder registry
func GetDefaultBuilderRegistry() *DefaultBuilderRegistry {
	return defaultBuilderRegistry
}

################################################################################
# FILE: :\good projects\cost estimation\core\confidence\pessimistic.go
# TYPE: go
# SIZE: 3620 bytes
################################################################################
// Package confidence - Pessimistic confidence propagation
// Aggregate confidence = MIN(child confidence)
// This ensures low-confidence components are never hidden.
package confidence

// AggregateConfidence returns the minimum confidence (pessimistic)
// This is the REQUIRED behavior for all aggregations.
func AggregateConfidence(values []float64) float64 {
	if len(values) == 0 {
		return 0.0
	}

	min := 1.0
	for _, v := range values {
		if v < min {
			min = v
		}
	}
	return min
}

// AggregateWithWeights returns weighted minimum
// Still pessimistic, but considers weight
func AggregateWithWeights(values []WeightedConfidence) float64 {
	if len(values) == 0 {
		return 0.0
	}

	min := 1.0
	for _, wc := range values {
		// Weight affects how much this drags down the aggregate
		effective := wc.Confidence
		if wc.Weight > 0 && wc.Confidence < 1.0 {
			// Heavier weights have more impact
			penalty := (1.0 - wc.Confidence) * wc.Weight
			effective = 1.0 - penalty
		}
		if effective < min {
			min = effective
		}
	}
	return min
}

// WeightedConfidence is a confidence value with weight
type WeightedConfidence struct {
	Confidence float64
	Weight     float64 // 0.0 to 1.0
}

// ConfidenceTracker tracks confidence across operations
type ConfidenceTracker struct {
	values []float64
	min    float64
}

// NewConfidenceTracker creates a tracker
func NewConfidenceTracker() *ConfidenceTracker {
	return &ConfidenceTracker{
		values: []float64{},
		min:    1.0,
	}
}

// Add adds a confidence value
func (t *ConfidenceTracker) Add(confidence float64) {
	t.values = append(t.values, confidence)
	if confidence < t.min {
		t.min = confidence
	}
}

// AddWithReason adds a confidence value with reason
func (t *ConfidenceTracker) AddWithReason(confidence float64, reason string) {
	t.Add(confidence)
	// Could track reasons if needed
}

// Min returns the minimum confidence
func (t *ConfidenceTracker) Min() float64 {
	return t.min
}

// Apply applies a degradation factor
func (t *ConfidenceTracker) Apply(factor string, reason string) {
	// Apply a default degradation
	t.Add(0.9)
}

// Average returns the average (NOT recommended for production)
func (t *ConfidenceTracker) Average() float64 {
	if len(t.values) == 0 {
		return 0.0
	}
	sum := 0.0
	for _, v := range t.values {
		sum += v
	}
	return sum / float64(len(t.values))
}

// IsDegraded returns true if confidence is below threshold
func (t *ConfidenceTracker) IsDegraded(threshold float64) bool {
	return t.min < threshold
}

// ConfidenceImpact represents what impacts confidence
type ConfidenceImpact struct {
	Source     string  // What caused the impact
	Impact     float64 // How much it reduces confidence (0.0-1.0)
	Reason     string
	IsBlocking bool // If true in strict mode, blocks estimation
}

// ApplyImpacts applies confidence impacts
func ApplyImpacts(base float64, impacts []ConfidenceImpact) float64 {
	result := base
	for _, impact := range impacts {
		result *= (1.0 - impact.Impact)
	}
	if result < 0 {
		result = 0
	}
	return result
}

// REQUIRED confidence thresholds
const (
	ConfidenceHigh   = 0.9
	ConfidenceMedium = 0.7
	ConfidenceLow    = 0.5
	ConfidenceNone   = 0.0
)

// ConfidenceLevel returns a human-readable level
func ConfidenceLevel(confidence float64) string {
	switch {
	case confidence >= ConfidenceHigh:
		return "high"
	case confidence >= ConfidenceMedium:
		return "medium"
	case confidence >= ConfidenceLow:
		return "low"
	default:
		return "unknown"
	}
}

################################################################################
# FILE: :\good projects\cost estimation\core\confidence\propagation.go
# TYPE: go
# SIZE: 7605 bytes
################################################################################
// Package confidence - Pessimistic confidence propagation
// Aggregation MUST NOT mask low-confidence components.
// Confidence propagates pessimistically, never optimistically.
package confidence

import (
	"fmt"
	"sort"
)

// PessimisticPropagator ensures confidence degrades, never improves
type PessimisticPropagator struct {
	// Minimum confidence floor
	floor float64

	// Aggregation rules
	rules PropagationRules
}

// PropagationRules define how confidence propagates
type PropagationRules struct {
	// How to combine multiple confidences
	CombineMethod CombineMethod

	// Weight low-confidence items more heavily
	PessimisticBias float64

	// Minimum items to trigger extra penalty
	MinItemsForPenalty int

	// Penalty per additional low-confidence item
	AdditionalPenalty float64
}

// CombineMethod defines how to combine confidences
type CombineMethod int

const (
	// CombineMinimum takes the minimum confidence
	CombineMinimum CombineMethod = iota

	// CombineProduct multiplies confidences
	CombineProduct

	// CombineWeightedMin uses weighted minimum with bias
	CombineWeightedMin

	// CombineHarmonic uses harmonic mean (penalizes outliers)
	CombineHarmonic
)

// NewPessimisticPropagator creates a propagator
func NewPessimisticPropagator() *PessimisticPropagator {
	return &PessimisticPropagator{
		floor: 0.05, // Never go below 5%
		rules: PropagationRules{
			CombineMethod:      CombineWeightedMin,
			PessimisticBias:    1.5,
			MinItemsForPenalty: 3,
			AdditionalPenalty:  0.05,
		},
	}
}

// ConfidenceItem is an item with confidence
type ConfidenceItem struct {
	ID         string
	Confidence float64
	Reason     string
	Category   string
}

// Propagate calculates aggregate confidence pessimistically
func (p *PessimisticPropagator) Propagate(items []ConfidenceItem) *PropagatedConfidence {
	if len(items) == 0 {
		return &PropagatedConfidence{
			Value:       1.0,
			Method:      p.rules.CombineMethod.String(),
			ItemCount:   0,
			LowItems:    []ConfidenceItem{},
			Explanation: "no items to aggregate",
		}
	}

	result := &PropagatedConfidence{
		Method:    p.rules.CombineMethod.String(),
		ItemCount: len(items),
		LowItems:  []ConfidenceItem{},
	}

	// Find low-confidence items (< 80%)
	lowThreshold := 0.8
	for _, item := range items {
		if item.Confidence < lowThreshold {
			result.LowItems = append(result.LowItems, item)
		}
	}

	// Calculate base confidence
	switch p.rules.CombineMethod {
	case CombineMinimum:
		result.Value = p.combineMinimum(items)
	case CombineProduct:
		result.Value = p.combineProduct(items)
	case CombineWeightedMin:
		result.Value = p.combineWeightedMin(items)
	case CombineHarmonic:
		result.Value = p.combineHarmonic(items)
	default:
		result.Value = p.combineMinimum(items)
	}

	// Apply additional penalty for multiple low-confidence items
	if len(result.LowItems) > p.rules.MinItemsForPenalty {
		extraPenalty := float64(len(result.LowItems)-p.rules.MinItemsForPenalty) * p.rules.AdditionalPenalty
		result.Value -= extraPenalty
	}

	// Apply floor
	if result.Value < p.floor {
		result.Value = p.floor
	}

	// Generate explanation
	result.Explanation = p.explain(result, items)

	return result
}

func (p *PessimisticPropagator) combineMinimum(items []ConfidenceItem) float64 {
	min := 1.0
	for _, item := range items {
		if item.Confidence < min {
			min = item.Confidence
		}
	}
	return min
}

func (p *PessimisticPropagator) combineProduct(items []ConfidenceItem) float64 {
	product := 1.0
	for _, item := range items {
		product *= item.Confidence
	}
	return product
}

func (p *PessimisticPropagator) combineWeightedMin(items []ConfidenceItem) float64 {
	if len(items) == 0 {
		return 1.0
	}

	// Sort by confidence
	sorted := make([]ConfidenceItem, len(items))
	copy(sorted, items)
	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i].Confidence < sorted[j].Confidence
	})

	// Apply pessimistic bias to lowest items
	total := 0.0
	weights := 0.0
	for i, item := range sorted {
		// Lower items get higher weight
		weight := p.rules.PessimisticBias
		if i > 0 {
			weight = 1.0
		}
		total += item.Confidence * weight
		weights += weight
	}

	return total / weights
}

func (p *PessimisticPropagator) combineHarmonic(items []ConfidenceItem) float64 {
	if len(items) == 0 {
		return 1.0
	}

	// Harmonic mean: n / sum(1/x)
	sum := 0.0
	for _, item := range items {
		if item.Confidence > 0 {
			sum += 1.0 / item.Confidence
		} else {
			return p.floor // Zero confidence means floor
		}
	}

	return float64(len(items)) / sum
}

func (p *PessimisticPropagator) explain(result *PropagatedConfidence, items []ConfidenceItem) string {
	if len(result.LowItems) == 0 {
		return fmt.Sprintf("All %d components have high confidence", len(items))
	}

	explanation := fmt.Sprintf("%d of %d components have low confidence: ", 
		len(result.LowItems), len(items))
	
	for i, item := range result.LowItems {
		if i > 0 {
			explanation += ", "
		}
		explanation += fmt.Sprintf("%s (%.0f%%)", item.ID, item.Confidence*100)
	}

	return explanation
}

// PropagatedConfidence is the result of propagation
type PropagatedConfidence struct {
	Value       float64
	Method      string
	ItemCount   int
	LowItems    []ConfidenceItem
	Explanation string
}

// String returns the combine method name
func (m CombineMethod) String() string {
	switch m {
	case CombineMinimum:
		return "minimum"
	case CombineProduct:
		return "product"
	case CombineWeightedMin:
		return "weighted_min"
	case CombineHarmonic:
		return "harmonic"
	default:
		return "unknown"
	}
}

// ConfidenceAggregator aggregates confidence with full visibility
type ConfidenceAggregator struct {
	propagator *PessimisticPropagator
	items      []ConfidenceItem
	result     *PropagatedConfidence
}

// NewConfidenceAggregator creates an aggregator
func NewConfidenceAggregator() *ConfidenceAggregator {
	return &ConfidenceAggregator{
		propagator: NewPessimisticPropagator(),
		items:      []ConfidenceItem{},
	}
}

// Add adds an item
func (a *ConfidenceAggregator) Add(id string, confidence float64, reason, category string) {
	a.items = append(a.items, ConfidenceItem{
		ID:         id,
		Confidence: confidence,
		Reason:     reason,
		Category:   category,
	})
	a.result = nil // Invalidate cached result
}

// Result returns the propagated confidence
func (a *ConfidenceAggregator) Result() *PropagatedConfidence {
	if a.result == nil {
		a.result = a.propagator.Propagate(a.items)
	}
	return a.result
}

// HasLowConfidence returns true if any item is below threshold
func (a *ConfidenceAggregator) HasLowConfidence(threshold float64) bool {
	for _, item := range a.items {
		if item.Confidence < threshold {
			return true
		}
	}
	return false
}

// LowestConfidence returns the item with lowest confidence
func (a *ConfidenceAggregator) LowestConfidence() *ConfidenceItem {
	if len(a.items) == 0 {
		return nil
	}

	lowest := &a.items[0]
	for i := range a.items {
		if a.items[i].Confidence < lowest.Confidence {
			lowest = &a.items[i]
		}
	}
	return lowest
}

// LowConfidenceWarning generates a warning for low confidence
func (a *ConfidenceAggregator) LowConfidenceWarning() string {
	result := a.Result()
	if result.Value >= 0.8 {
		return ""
	}

	return fmt.Sprintf("âš ï¸ Low confidence (%.0f%%): %s", 
		result.Value*100, result.Explanation)
}

################################################################################
# FILE: :\good projects\cost estimation\core\cost\confidence.go
# TYPE: go
# SIZE: 8567 bytes
################################################################################
// Package cost - Confidence-degrading cost calculations
// Every cost unit MUST carry confidence and degradation reasons.
package cost

import (
	"fmt"

	"terraform-cost/core/determinism"
	"terraform-cost/core/model"
	"terraform-cost/core/pricing"
)

// ConfidenceBoundCost is a cost value that ALWAYS carries confidence.
// No cost can exist without explicit confidence tracking.
type ConfidenceBoundCost struct {
	// The cost value
	Monthly determinism.Money
	Hourly  determinism.Money

	// Confidence (0.0 - 1.0)
	Confidence float64

	// Why confidence is what it is
	Factors []ConfidenceFactor

	// Is this degraded from full confidence?
	IsDegraded bool

	// Snapshot reference (for traceability)
	SnapshotID pricing.SnapshotID
}

// ConfidenceFactor explains one contribution to confidence
type ConfidenceFactor struct {
	Source     string  // What affected confidence
	Reason     string  // Why
	Impact     float64 // How much (0.0-1.0, where 1.0 removes all confidence)
	IsUnknown  bool    // Is this due to an unknown value?
	Component  string  // Which component?
}

// NewConfidenceBoundCost creates a new cost with full confidence
func NewConfidenceBoundCost(monthly, hourly determinism.Money, snapshotID pricing.SnapshotID) *ConfidenceBoundCost {
	return &ConfidenceBoundCost{
		Monthly:    monthly,
		Hourly:     hourly,
		Confidence: 1.0,
		Factors:    []ConfidenceFactor{},
		IsDegraded: false,
		SnapshotID: snapshotID,
	}
}

// Zero creates a zero cost
func ZeroCost(snapshotID pricing.SnapshotID) *ConfidenceBoundCost {
	return &ConfidenceBoundCost{
		Monthly:    determinism.Zero("USD"),
		Hourly:     determinism.Zero("USD"),
		Confidence: 1.0,
		SnapshotID: snapshotID,
	}
}

// DegradeForUnknown reduces confidence due to an unknown value
func (c *ConfidenceBoundCost) DegradeForUnknown(source, reason string, impact float64, component string) {
	c.Confidence *= (1.0 - impact)
	c.IsDegraded = true
	c.Factors = append(c.Factors, ConfidenceFactor{
		Source:    source,
		Reason:    reason,
		Impact:    impact,
		IsUnknown: true,
		Component: component,
	})
}

// DegradeForMissing reduces confidence due to missing data
func (c *ConfidenceBoundCost) DegradeForMissing(source, reason string, impact float64, component string) {
	c.Confidence *= (1.0 - impact)
	c.IsDegraded = true
	c.Factors = append(c.Factors, ConfidenceFactor{
		Source:    source,
		Reason:    reason,
		Impact:    impact,
		IsUnknown: false,
		Component: component,
	})
}

// Add adds two costs, combining confidence
func (c *ConfidenceBoundCost) Add(other *ConfidenceBoundCost) *ConfidenceBoundCost {
	return &ConfidenceBoundCost{
		Monthly:    c.Monthly.Add(other.Monthly),
		Hourly:     c.Hourly.Add(other.Hourly),
		Confidence: c.Confidence * other.Confidence, // Compound confidence
		Factors:    append(c.Factors, other.Factors...),
		IsDegraded: c.IsDegraded || other.IsDegraded,
		SnapshotID: c.SnapshotID,
	}
}

// ConfidenceLevel returns a human-readable confidence level
func (c *ConfidenceBoundCost) ConfidenceLevel() string {
	switch {
	case c.Confidence >= 0.9:
		return "high"
	case c.Confidence >= 0.7:
		return "medium"
	case c.Confidence >= 0.5:
		return "low"
	default:
		return "very_low"
	}
}

// UnknownDrivenDegradation tracks degradation from unknown values
type UnknownDrivenDegradation struct {
	// Instance affected
	InstanceID model.InstanceID
	Address    model.CanonicalAddress

	// What was unknown
	UnknownAttribute string
	UnknownReason    string

	// Impact on cost
	ConfidenceImpact float64
	CostImpact       *CostImpactEstimate
}

// CostImpactEstimate estimates how much an unknown affects cost
type CostImpactEstimate struct {
	// Range of possible costs
	MinCost determinism.Money
	MaxCost determinism.Money

	// Most likely cost
	LikelyCost determinism.Money

	// How we estimated
	Method string
}

// CostWithProvenance is a cost with full provenance chain
type CostWithProvenance struct {
	// The cost
	Cost *ConfidenceBoundCost

	// Instance identity
	Identity *model.InstanceIdentity

	// Component name
	Component string

	// Rate used
	Rate *RateProvenance

	// Usage applied
	Usage *UsageProvenance

	// Formula
	Formula *FormulaProvenance
}

// RateProvenance tracks which rate was used
type RateProvenance struct {
	RateID       pricing.RateID
	RateKey      pricing.RateKey
	Price        string
	Unit         string
	Currency     string
	WasFound     bool
	MissingReason string
}

// UsageProvenance tracks where usage came from
type UsageProvenance struct {
	Value       float64
	Unit        string
	Source      UsageSource
	Confidence  float64
	WasUnknown  bool
	Assumptions []string
}

// UsageSource indicates usage data origin
type UsageSource int

const (
	UsageSourceDefault UsageSource = iota
	UsageSourceOverride
	UsageSourceProfile
	UsageSourceHistorical
	UsageSourceUnknown
)

// FormulaProvenance tracks how cost was calculated
type FormulaProvenance struct {
	Name       string
	Expression string
	Inputs     map[string]FormulaInput
	Output     string
}

// FormulaInput is a formula input with source
type FormulaInput struct {
	Value      string
	Source     string // "rate", "usage", "constant"
	Confidence float64
}

// InstanceCostResult is the complete result for one instance
type InstanceCostResult struct {
	// Identity
	Identity *model.InstanceIdentity

	// Total cost with confidence
	Total *ConfidenceBoundCost

	// Per-component costs
	Components []*CostWithProvenance

	// All degradation factors
	Degradations []*UnknownDrivenDegradation

	// Summary
	IsFullConfidence bool
	DegradedCount    int
	UnknownCount     int
}

// NewInstanceCostResult creates a new result
func NewInstanceCostResult(identity *model.InstanceIdentity, snapshotID pricing.SnapshotID) *InstanceCostResult {
	return &InstanceCostResult{
		Identity:         identity,
		Total:            ZeroCost(snapshotID),
		Components:       []*CostWithProvenance{},
		Degradations:     []*UnknownDrivenDegradation{},
		IsFullConfidence: true,
	}
}

// AddComponent adds a component cost
func (r *InstanceCostResult) AddComponent(comp *CostWithProvenance) {
	r.Components = append(r.Components, comp)
	r.Total = r.Total.Add(comp.Cost)

	if comp.Cost.IsDegraded {
		r.IsFullConfidence = false
		r.DegradedCount++
	}

	if comp.Usage != nil && comp.Usage.WasUnknown {
		r.UnknownCount++
		r.Degradations = append(r.Degradations, &UnknownDrivenDegradation{
			InstanceID:       r.Identity.ID,
			Address:          r.Identity.Canonical,
			UnknownAttribute: fmt.Sprintf("%s.usage", comp.Component),
			UnknownReason:    "usage value was unknown",
			ConfidenceImpact: 1.0 - comp.Cost.Confidence,
		})
	}
}

// AggregatedCostResult is the complete estimation result
type AggregatedCostResult struct {
	// Instance results
	Instances []*InstanceCostResult

	// Totals with confidence
	TotalMonthly    determinism.Money
	TotalHourly     determinism.Money
	TotalConfidence float64

	// Aggregated degradation info
	TotalDegraded  int
	TotalUnknowns  int
	DegradedCost   determinism.Money // Amount of cost that's degraded

	// Snapshot
	SnapshotID pricing.SnapshotID
}

// NewAggregatedCostResult creates a new aggregated result
func NewAggregatedCostResult(snapshotID pricing.SnapshotID) *AggregatedCostResult {
	return &AggregatedCostResult{
		Instances:       []*InstanceCostResult{},
		TotalMonthly:    determinism.Zero("USD"),
		TotalHourly:     determinism.Zero("USD"),
		TotalConfidence: 1.0,
		DegradedCost:    determinism.Zero("USD"),
		SnapshotID:      snapshotID,
	}
}

// Add adds an instance result
func (r *AggregatedCostResult) Add(inst *InstanceCostResult) {
	r.Instances = append(r.Instances, inst)
	r.TotalMonthly = r.TotalMonthly.Add(inst.Total.Monthly)
	r.TotalHourly = r.TotalHourly.Add(inst.Total.Hourly)
	r.TotalConfidence *= inst.Total.Confidence

	if !inst.IsFullConfidence {
		r.TotalDegraded++
		r.DegradedCost = r.DegradedCost.Add(inst.Total.Monthly)
	}
	r.TotalUnknowns += inst.UnknownCount
}

// ConfidenceLevel returns overall confidence level
func (r *AggregatedCostResult) ConfidenceLevel() string {
	switch {
	case r.TotalConfidence >= 0.9:
		return "high"
	case r.TotalConfidence >= 0.7:
		return "medium"
	case r.TotalConfidence >= 0.5:
		return "low"
	default:
		return "very_low"
	}
}

################################################################################
# FILE: :\good projects\cost estimation\core\cost\engine.go
# TYPE: go
# SIZE: 2177 bytes
################################################################################
// Package cost provides the cost graph engine interface.
// This package transforms assets + usage into billable cost units.
package cost

import (
	"context"

	"terraform-cost/core/types"
	"terraform-cost/core/usage"
)

// Engine transforms assets and usage into cost graphs
type Engine interface {
	// Calculate produces a cost graph from an asset graph and usage data
	Calculate(ctx context.Context, assets *types.AssetGraph, usage map[string]*usage.EstimationResult, pricing *types.PricingResult) (*types.CostGraph, error)
}

// Calculator calculates costs for a specific resource type
type Calculator interface {
	// Provider returns the cloud provider
	Provider() types.Provider

	// ResourceType returns the resource type this calculator handles
	ResourceType() string

	// Calculate produces cost units for an asset
	Calculate(ctx context.Context, asset *types.Asset, usage []types.UsageVector, pricing *types.PricingResult) ([]*types.CostUnit, error)
}

// CalculatorRegistry manages cost calculator registration
type CalculatorRegistry interface {
	// Register adds a calculator to the registry
	Register(calculator Calculator) error

	// GetCalculator returns a calculator for a provider and resource type
	GetCalculator(provider types.Provider, resourceType string) (Calculator, bool)

	// GetProviderCalculators returns all calculators for a provider
	GetProviderCalculators(provider types.Provider) []Calculator
}

// FormulaContext provides context for cost formula evaluation
type FormulaContext struct {
	// Asset is the asset being priced
	Asset *types.Asset

	// Usage contains usage vectors for the asset
	Usage []types.UsageVector

	// Pricing contains resolved prices
	Pricing *types.PricingResult

	// Region is the deployment region
	Region types.Region
}

// Formula represents a cost calculation formula
type Formula interface {
	// Name returns the formula name
	Name() string

	// Calculate evaluates the formula
	Calculate(ctx *FormulaContext) ([]*types.CostUnit, error)

	// RateKeys returns the rate keys needed for this formula
	RateKeys(ctx *FormulaContext) []types.RateKey
}

################################################################################
# FILE: :\good projects\cost estimation\core\cost\graph.go
# TYPE: go
# SIZE: 10959 bytes
################################################################################
// Package cost - Normalized cost graph
// CostUnit (atomic) â†’ CostNode (grouped by asset) â†’ CostAggregate (service/provider/project)
// No pricing logic exists above CostUnit.
package cost

import (
	"sort"

	"terraform-cost/core/determinism"
	"terraform-cost/core/model"
)

// CostUnit is the atomic unit of cost
// All pricing logic lives here and ONLY here
type CostUnit struct {
	// Identity
	ID       string
	Category CostCategory

	// What this costs
	Amount   determinism.Money
	Hourly   determinism.Money
	Monthly  determinism.Money

	// Pricing derivation (immutable)
	Rate     *RateDerivation
	Usage    *UsageDerivation
	Formula  *FormulaDerivation

	// Confidence
	Confidence float64
	Factors    []CostConfidenceFactor

	// Is this an assumption?
	IsAssumed    bool
	AssumptionID string
}

// CostCategory classifies cost units
type CostCategory int

const (
	CategoryCompute   CostCategory = iota // EC2, Lambda, ECS
	CategoryStorage                        // S3, EBS, RDS storage
	CategoryNetwork                        // NAT, data transfer
	CategoryDatabase                       // RDS, DynamoDB, ElastiCache
	CategoryCache                          // ElastiCache, DAX
	CategoryMessaging                      // SQS, SNS, Kinesis
	CategoryOther                          // Uncategorized
)

// String returns the category name
func (c CostCategory) String() string {
	switch c {
	case CategoryCompute:
		return "compute"
	case CategoryStorage:
		return "storage"
	case CategoryNetwork:
		return "network"
	case CategoryDatabase:
		return "database"
	case CategoryCache:
		return "cache"
	case CategoryMessaging:
		return "messaging"
	default:
		return "other"
	}
}

// RateDerivation records how the rate was determined
type RateDerivation struct {
	RateID       string
	SKU          string
	Price        determinism.Money
	Unit         string
	Region       string
	SnapshotID   string
	SnapshotHash string
}

// UsageDerivation records how usage was determined
type UsageDerivation struct {
	Value     float64
	Unit      string
	Source    CostUsageSource
	IsDefault bool
	DefaultID string
}

// CostUsageSource indicates where usage came from
type CostUsageSource int

const (
	CostUsageFromConfig     CostUsageSource = iota // From Terraform config
	CostUsageFromDefault                            // From default value
	CostUsageFromOverride                           // From usage file
	CostUsageFromHistorical                         // From historical data
)

// FormulaDerivation records the calculation formula
type FormulaDerivation struct {
	Expression string   // e.g., "rate * usage * hours"
	Variables  []string // Variables used
	Result     string   // Result expression
}

// CostConfidenceFactor records a reason for confidence change
type CostConfidenceFactor struct {
	Rule   string
	Reason string
	Impact float64
}

// CostNode groups CostUnits by asset
type CostNode struct {
	// Identity
	InstanceID      model.InstanceID
	InstanceAddress model.InstanceAddress
	ResourceType    string
	Provider        string
	Region          string

	// Cost units for this asset
	Units []*CostUnit

	// Aggregated costs
	TotalMonthly determinism.Money
	TotalHourly  determinism.Money

	// Category breakdown
	ByCategory map[CostCategory]determinism.Money

	// Aggregated confidence (minimum)
	Confidence float64

	// Assumptions made
	Assumptions []string
}

// NewCostNode creates a new cost node
func NewCostNode(id model.InstanceID, address model.InstanceAddress, resourceType, provider, region string) *CostNode {
	return &CostNode{
		InstanceID:      id,
		InstanceAddress: address,
		ResourceType:    resourceType,
		Provider:        provider,
		Region:          region,
		Units:           []*CostUnit{},
		ByCategory:      make(map[CostCategory]determinism.Money),
		Confidence:      1.0,
		Assumptions:     []string{},
	}
}

// AddUnit adds a cost unit and updates aggregates
func (n *CostNode) AddUnit(unit *CostUnit) {
	n.Units = append(n.Units, unit)
	n.TotalMonthly = n.TotalMonthly.Add(unit.Monthly)
	n.TotalHourly = n.TotalHourly.Add(unit.Hourly)

	// Update category breakdown
	if existing, ok := n.ByCategory[unit.Category]; ok {
		n.ByCategory[unit.Category] = existing.Add(unit.Monthly)
	} else {
		n.ByCategory[unit.Category] = unit.Monthly
	}

	// Update confidence (take minimum)
	if unit.Confidence < n.Confidence {
		n.Confidence = unit.Confidence
	}

	// Track assumptions
	if unit.IsAssumed {
		n.Assumptions = append(n.Assumptions, unit.AssumptionID)
	}
}

// CostAggregate groups CostNodes by service/provider/project
type CostAggregate struct {
	// Identity
	Name  string
	Level AggregateLevel

	// Child nodes
	Nodes []*CostNode

	// Child aggregates (for hierarchy)
	Children []*CostAggregate

	// Aggregated costs
	TotalMonthly determinism.Money
	TotalHourly  determinism.Money

	// Breakdowns
	ByCategory map[CostCategory]determinism.Money
	ByProvider map[string]determinism.Money
	ByRegion   map[string]determinism.Money

	// Aggregated confidence
	Confidence float64

	// Assumptions count
	AssumptionCount int
}

// AggregateLevel indicates the level of aggregation
type AggregateLevel int

const (
	LevelComponent AggregateLevel = iota // Single component
	LevelResource                         // Single resource
	LevelService                          // Service (e.g., all EC2)
	LevelProvider                         // Provider (e.g., all AWS)
	LevelProject                          // Entire project
)

// String returns the level name
func (l AggregateLevel) String() string {
	switch l {
	case LevelComponent:
		return "component"
	case LevelResource:
		return "resource"
	case LevelService:
		return "service"
	case LevelProvider:
		return "provider"
	case LevelProject:
		return "project"
	default:
		return "unknown"
	}
}

// NewCostAggregate creates a new aggregate
func NewCostAggregate(name string, level AggregateLevel) *CostAggregate {
	return &CostAggregate{
		Name:       name,
		Level:      level,
		Nodes:      []*CostNode{},
		Children:   []*CostAggregate{},
		ByCategory: make(map[CostCategory]determinism.Money),
		ByProvider: make(map[string]determinism.Money),
		ByRegion:   make(map[string]determinism.Money),
		Confidence: 1.0,
	}
}

// AddNode adds a node and updates aggregates
func (a *CostAggregate) AddNode(node *CostNode) {
	a.Nodes = append(a.Nodes, node)
	a.TotalMonthly = a.TotalMonthly.Add(node.TotalMonthly)
	a.TotalHourly = a.TotalHourly.Add(node.TotalHourly)

	// Update category breakdown
	for cat, amount := range node.ByCategory {
		if existing, ok := a.ByCategory[cat]; ok {
			a.ByCategory[cat] = existing.Add(amount)
		} else {
			a.ByCategory[cat] = amount
		}
	}

	// Update provider breakdown
	if existing, ok := a.ByProvider[node.Provider]; ok {
		a.ByProvider[node.Provider] = existing.Add(node.TotalMonthly)
	} else {
		a.ByProvider[node.Provider] = node.TotalMonthly
	}

	// Update region breakdown
	if existing, ok := a.ByRegion[node.Region]; ok {
		a.ByRegion[node.Region] = existing.Add(node.TotalMonthly)
	} else {
		a.ByRegion[node.Region] = node.TotalMonthly
	}

	// Update confidence
	if node.Confidence < a.Confidence {
		a.Confidence = node.Confidence
	}

	// Track assumptions
	a.AssumptionCount += len(node.Assumptions)
}

// AddChild adds a child aggregate
func (a *CostAggregate) AddChild(child *CostAggregate) {
	a.Children = append(a.Children, child)
	a.TotalMonthly = a.TotalMonthly.Add(child.TotalMonthly)
	a.TotalHourly = a.TotalHourly.Add(child.TotalHourly)

	// Merge breakdowns
	for cat, amount := range child.ByCategory {
		if existing, ok := a.ByCategory[cat]; ok {
			a.ByCategory[cat] = existing.Add(amount)
		} else {
			a.ByCategory[cat] = amount
		}
	}

	// Update confidence
	if child.Confidence < a.Confidence {
		a.Confidence = child.Confidence
	}

	a.AssumptionCount += child.AssumptionCount
}

// CostGraph is the complete cost graph
type CostGraph struct {
	// Root aggregate (project level)
	Root *CostAggregate

	// All nodes indexed by instance ID
	NodesByID map[model.InstanceID]*CostNode

	// Aggregates by level
	ByLevel map[AggregateLevel][]*CostAggregate
}

// NewCostGraph creates a new cost graph
func NewCostGraph(projectName string) *CostGraph {
	return &CostGraph{
		Root:      NewCostAggregate(projectName, LevelProject),
		NodesByID: make(map[model.InstanceID]*CostNode),
		ByLevel:   make(map[AggregateLevel][]*CostAggregate),
	}
}

// AddNode adds a cost node to the graph
func (g *CostGraph) AddNode(node *CostNode) {
	g.NodesByID[node.InstanceID] = node
	g.Root.AddNode(node)
}

// GetNode returns a node by instance ID
func (g *CostGraph) GetNode(id model.InstanceID) *CostNode {
	return g.NodesByID[id]
}

// TopCostNodes returns the n highest cost nodes
func (g *CostGraph) TopCostNodes(n int) []*CostNode {
	nodes := make([]*CostNode, 0, len(g.NodesByID))
	for _, node := range g.NodesByID {
		nodes = append(nodes, node)
	}
	sort.Slice(nodes, func(i, j int) bool {
		return nodes[i].TotalMonthly.Cmp(nodes[j].TotalMonthly) > 0
	})
	if n > len(nodes) {
		n = len(nodes)
	}
	return nodes[:n]
}

// LowConfidenceNodes returns nodes below a confidence threshold
func (g *CostGraph) LowConfidenceNodes(threshold float64) []*CostNode {
	var result []*CostNode
	for _, node := range g.NodesByID {
		if node.Confidence < threshold {
			result = append(result, node)
		}
	}
	return result
}

// BuildServiceAggregates builds service-level aggregates
func (g *CostGraph) BuildServiceAggregates() {
	byService := make(map[string]*CostAggregate)

	for _, node := range g.NodesByID {
		service := extractService(node.ResourceType)
		agg, ok := byService[service]
		if !ok {
			agg = NewCostAggregate(service, LevelService)
			byService[service] = agg
		}
		agg.AddNode(node)
	}

	for _, agg := range byService {
		g.ByLevel[LevelService] = append(g.ByLevel[LevelService], agg)
		g.Root.AddChild(agg)
	}
}

func extractService(resourceType string) string {
	// aws_instance â†’ ec2
	// aws_s3_bucket â†’ s3
	// aws_db_instance â†’ rds
	serviceMap := map[string]string{
		"aws_instance":           "ec2",
		"aws_launch_template":    "ec2",
		"aws_s3_bucket":          "s3",
		"aws_s3_object":          "s3",
		"aws_db_instance":        "rds",
		"aws_rds_cluster":        "rds",
		"aws_lambda_function":    "lambda",
		"aws_ecs_service":        "ecs",
		"aws_ecs_task_definition":"ecs",
		"aws_elasticache_cluster":"elasticache",
		"aws_nat_gateway":        "vpc",
		"aws_lb":                 "elb",
	}
	if service, ok := serviceMap[resourceType]; ok {
		return service
	}
	return "other"
}

################################################################################
# FILE: :\good projects\cost estimation\core\detection\detector.go
# TYPE: go
# SIZE: 1582 bytes
################################################################################
// Package detection provides project detection interfaces.
// This package determines what type of IaC project is being analyzed.
package detection

import (
	"context"

	"terraform-cost/core/types"
)

// Detector identifies project types
type Detector interface {
	// Name returns the detector identifier
	Name() string

	// Detect determines if the input matches this detector's project type
	Detect(ctx context.Context, path string) (*types.DetectedProject, error)

	// ProjectType returns the project type this detector handles
	ProjectType() types.ProjectType

	// Priority returns the detection priority (higher = checked first)
	Priority() int
}

// Registry manages detector registration
type Registry interface {
	// Register adds a detector to the registry
	Register(detector Detector) error

	// GetDetector returns a detector by name
	GetDetector(name string) (Detector, bool)

	// GetAll returns all registered detectors
	GetAll() []Detector

	// Detect finds the first matching detector and returns its result
	Detect(ctx context.Context, path string) (*types.DetectedProject, error)

	// DetectAll runs all detectors and returns all matches
	DetectAll(ctx context.Context, path string) ([]*types.DetectedProject, error)
}

// DetectionResult contains detection output
type DetectionResult struct {
	// Project is the detected project
	Project *types.DetectedProject

	// Detector is the detector that matched
	Detector string

	// Alternatives are other possible matches
	Alternatives []*types.DetectedProject
}

################################################################################
# FILE: :\good projects\cost estimation\core\determinism\stable.go
# TYPE: go
# SIZE: 7581 bytes
################################################################################
// Package determinism provides primitives for guaranteeing deterministic execution.
// All code must use these primitives instead of Go built-ins for maps, IDs, etc.
package determinism

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"sort"
	"sync"

	"github.com/shopspring/decimal"
)

// StableMap is a map that guarantees iteration order (sorted by key).
// Use this instead of map[K]V for all cases where iteration matters.
type StableMap[K comparable, V any] struct {
	mu      sync.RWMutex
	keys    []K
	values  map[K]V
	keyFunc func(K) string // For custom ordering
}

// NewStableMap creates a new StableMap
func NewStableMap[K comparable, V any]() *StableMap[K, V] {
	return &StableMap[K, V]{
		values: make(map[K]V),
	}
}

// NewStableMapWithKeyFunc creates a StableMap with custom key ordering
func NewStableMapWithKeyFunc[K comparable, V any](keyFunc func(K) string) *StableMap[K, V] {
	return &StableMap[K, V]{
		values:  make(map[K]V),
		keyFunc: keyFunc,
	}
}

// Set adds or updates a key-value pair
func (m *StableMap[K, V]) Set(key K, value V) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if _, exists := m.values[key]; !exists {
		m.keys = append(m.keys, key)
		m.sortKeys()
	}
	m.values[key] = value
}

// Get retrieves a value by key
func (m *StableMap[K, V]) Get(key K) (V, bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	val, ok := m.values[key]
	return val, ok
}

// Delete removes a key
func (m *StableMap[K, V]) Delete(key K) {
	m.mu.Lock()
	defer m.mu.Unlock()

	delete(m.values, key)
	// Remove from keys slice
	for i, k := range m.keys {
		if any(k) == any(key) {
			m.keys = append(m.keys[:i], m.keys[i+1:]...)
			break
		}
	}
}

// Range iterates in stable sorted order
func (m *StableMap[K, V]) Range(fn func(K, V) bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	for _, k := range m.keys {
		if !fn(k, m.values[k]) {
			break
		}
	}
}

// Keys returns all keys in sorted order
func (m *StableMap[K, V]) Keys() []K {
	m.mu.RLock()
	defer m.mu.RUnlock()
	result := make([]K, len(m.keys))
	copy(result, m.keys)
	return result
}

// Len returns the number of entries
func (m *StableMap[K, V]) Len() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return len(m.values)
}

func (m *StableMap[K, V]) sortKeys() {
	sort.Slice(m.keys, func(i, j int) bool {
		if m.keyFunc != nil {
			return m.keyFunc(m.keys[i]) < m.keyFunc(m.keys[j])
		}
		return fmt.Sprint(m.keys[i]) < fmt.Sprint(m.keys[j])
	})
}

// StableID is a hash-based unique identifier that's deterministic
type StableID string

// IDGenerator generates stable, deterministic IDs
type IDGenerator struct {
	namespace string
}

// NewIDGenerator creates an ID generator with a namespace
func NewIDGenerator(namespace string) *IDGenerator {
	return &IDGenerator{namespace: namespace}
}

// Generate creates a stable ID from inputs
func (g *IDGenerator) Generate(parts ...string) StableID {
	h := sha256.New()
	h.Write([]byte(g.namespace))
	h.Write([]byte{0}) // Separator
	for _, part := range parts {
		h.Write([]byte(part))
		h.Write([]byte{0}) // Separator
	}
	return StableID(hex.EncodeToString(h.Sum(nil))[:16])
}

// ContentHash is a SHA-256 hash for content integrity
type ContentHash [32]byte

// ComputeHash computes a content hash from bytes
func ComputeHash(data []byte) ContentHash {
	return sha256.Sum256(data)
}

// Hex returns the hash as a hex string
func (h ContentHash) Hex() string {
	return hex.EncodeToString(h[:])
}

// String implements Stringer
func (h ContentHash) String() string {
	return h.Hex()[:16] + "..."
}

// Money represents a monetary amount with full precision.
// NEVER use float64 for money calculations.
type Money struct {
	amount   decimal.Decimal
	currency string
}

// NewMoney creates a Money from a decimal string
func NewMoney(amount string, currency string) (Money, error) {
	d, err := decimal.NewFromString(amount)
	if err != nil {
		return Money{}, err
	}
	return Money{amount: d, currency: currency}, nil
}

// NewMoneyFromFloat creates Money from float64 (use sparingly)
func NewMoneyFromFloat(amount float64, currency string) Money {
	return Money{amount: decimal.NewFromFloat(amount), currency: currency}
}

// NewMoneyFromDecimal creates Money from decimal
func NewMoneyFromDecimal(amount decimal.Decimal, currency string) Money {
	return Money{amount: amount, currency: currency}
}

// Zero creates zero money
func Zero(currency string) Money {
	return Money{amount: decimal.Zero, currency: currency}
}

// Amount returns the decimal amount
func (m Money) Amount() decimal.Decimal {
	return m.amount
}

// Currency returns the currency code
func (m Money) Currency() string {
	return m.currency
}

// Add adds two monetary amounts
func (m Money) Add(other Money) Money {
	if m.currency != other.currency {
		panic(fmt.Sprintf("cannot add %s and %s", m.currency, other.currency))
	}
	return Money{amount: m.amount.Add(other.amount), currency: m.currency}
}

// Sub subtracts monetary amounts
func (m Money) Sub(other Money) Money {
	if m.currency != other.currency {
		panic(fmt.Sprintf("cannot subtract %s and %s", m.currency, other.currency))
	}
	return Money{amount: m.amount.Sub(other.amount), currency: m.currency}
}

// Mul multiplies by a scalar
func (m Money) Mul(factor decimal.Decimal) Money {
	return Money{amount: m.amount.Mul(factor), currency: m.currency}
}

// MulFloat multiplies by a float64 scalar
func (m Money) MulFloat(factor float64) Money {
	return Money{amount: m.amount.Mul(decimal.NewFromFloat(factor)), currency: m.currency}
}

// Div divides by a scalar
func (m Money) Div(divisor decimal.Decimal) Money {
	return Money{amount: m.amount.Div(divisor), currency: m.currency}
}

// IsZero returns true if amount is zero
func (m Money) IsZero() bool {
	return m.amount.IsZero()
}

// IsNegative returns true if amount is negative
func (m Money) IsNegative() bool {
	return m.amount.IsNegative()
}

// Cmp compares two monetary amounts
func (m Money) Cmp(other Money) int {
	if m.currency != other.currency {
		panic(fmt.Sprintf("cannot compare %s and %s", m.currency, other.currency))
	}
	return m.amount.Cmp(other.amount)
}

// String returns formatted money (2 decimal places)
func (m Money) String() string {
	return fmt.Sprintf("%s %s", m.amount.StringFixed(2), m.currency)
}

// StringRaw returns the raw decimal string (full precision)
func (m Money) StringRaw() string {
	return m.amount.String()
}

// Float64 returns float64 (only for display, never for calculation)
func (m Money) Float64() float64 {
	f, _ := m.amount.Float64()
	return f
}

// SortSlice sorts a slice in a stable, deterministic manner
func SortSlice[T any](slice []T, less func(a, b T) bool) {
	sort.SliceStable(slice, func(i, j int) bool {
		return less(slice[i], slice[j])
	})
}

// SortStrings sorts strings in place
func SortStrings(s []string) {
	sort.Strings(s)
}

// SortedMap returns a sorted copy of map keys
func SortedKeys[K comparable, V any](m map[K]V) []K {
	keys := make([]K, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Slice(keys, func(i, j int) bool {
		return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j])
	})
	return keys
}

// RangeMapSorted iterates over a map in sorted key order
func RangeMapSorted[K comparable, V any](m map[K]V, fn func(K, V) bool) {
	for _, k := range SortedKeys(m) {
		if !fn(k, m[k]) {
			break
		}
	}
}

################################################################################
# FILE: :\good projects\cost estimation\core\diff\dependency_diff.go
# TYPE: go
# SIZE: 7167 bytes
################################################################################
// Package diff - Dependency-closure aware diff engine
// Diff MUST use dependency closure, not just address matching.
package diff

import (
	"terraform-cost/core/determinism"
	"terraform-cost/core/graph"
)

// DependencyClosureDiff computes diffs using dependency closure
type DependencyClosureDiff struct {
	before *graph.EnforcedCostGraph
	after  *graph.EnforcedCostGraph
}

// NewDependencyClosureDiff creates a diff engine
func NewDependencyClosureDiff(before, after *graph.EnforcedCostGraph) *DependencyClosureDiff {
	return &DependencyClosureDiff{
		before: before,
		after:  after,
	}
}

// ComputeDiff computes the diff with full dependency closure awareness
func (d *DependencyClosureDiff) ComputeDiff() *ClosureAwareDiff {
	result := &ClosureAwareDiff{
		ChangedNodes:      []graph.DependencyNodeID{},
		AffectedAssets:    []*graph.EnforcedAsset{},
		AffectedCostUnits: []*graph.EnforcedCostUnit{},
		DirectChanges:     []*CostChange{},
		IndirectChanges:   []*CostChange{},
		SymbolicChanges:   []*SymbolicChange{},
	}

	if d.after == nil {
		return result
	}

	// Find changed nodes by comparing cost units
	changedNodes := d.findChangedNodes()
	result.ChangedNodes = changedNodes

	// Get affected cost units via dependency closure
	result.AffectedCostUnits = d.after.GetAffectedCostUnits(changedNodes)

	// Classify changes
	d.classifyChanges(result)

	// Calculate totals
	result.calculateTotals()

	return result
}

func (d *DependencyClosureDiff) findChangedNodes() []graph.DependencyNodeID {
	changed := make(map[graph.DependencyNodeID]bool)

	afterUnits := d.after.AllCostUnits()
	for _, unit := range afterUnits {
		// Check if this is new or changed
		isNew := d.before == nil
		var beforeCost determinism.Money
		if !isNew {
			// Find corresponding before unit
			// For simplicity, using first node in dependency path
			if len(unit.DependencyPath) > 0 {
				lastNode := unit.DependencyPath[len(unit.DependencyPath)-1]
				changed[lastNode] = true
			}
		}
		_ = beforeCost
	}

	result := make([]graph.DependencyNodeID, 0, len(changed))
	for nodeID := range changed {
		result = append(result, nodeID)
	}
	return result
}

func (d *DependencyClosureDiff) classifyChanges(result *ClosureAwareDiff) {
	for _, unit := range result.AffectedCostUnits {
		if unit.IsSymbolic {
			result.SymbolicChanges = append(result.SymbolicChanges, &SymbolicChange{
				CostUnitID: unit.CostUnitID,
				AssetID:    unit.AssetID,
				Reason:     unit.SymbolicInfo.Reason,
				IsUnbounded: unit.SymbolicInfo.IsUnbounded,
			})
			continue
		}

		// Check if this is a direct or indirect change
		// Direct: last node in path is changed
		// Indirect: upstream node is changed
		isDirect := false
		if len(unit.DependencyPath) > 0 {
			lastNode := unit.DependencyPath[len(unit.DependencyPath)-1]
			for _, changed := range result.ChangedNodes {
				if lastNode == changed {
					isDirect = true
					break
				}
			}
		}

		change := &CostChange{
			CostUnitID:     unit.CostUnitID,
			AssetID:        unit.AssetID,
			DependencyPath: unit.DependencyPath,
			NewCost:        unit.MonthlyCost,
			Confidence:     unit.Confidence,
		}

		if isDirect {
			result.DirectChanges = append(result.DirectChanges, change)
		} else {
			result.IndirectChanges = append(result.IndirectChanges, change)
		}
	}
}

// ClosureAwareDiff is a diff with full dependency closure
type ClosureAwareDiff struct {
	// Changed nodes in dependency graph
	ChangedNodes []graph.DependencyNodeID

	// Affected entities (via dependency closure)
	AffectedAssets    []*graph.EnforcedAsset
	AffectedCostUnits []*graph.EnforcedCostUnit

	// Classified changes
	DirectChanges   []*CostChange   // Node itself changed
	IndirectChanges []*CostChange   // Upstream dependency changed
	SymbolicChanges []*SymbolicChange

	// Totals
	DirectCostDelta   determinism.Money
	IndirectCostDelta determinism.Money
	TotalCostDelta    determinism.Money
	MinConfidence     float64
}

func (d *ClosureAwareDiff) calculateTotals() {
	d.DirectCostDelta = determinism.Zero("USD")
	d.IndirectCostDelta = determinism.Zero("USD")
	d.MinConfidence = 1.0

	for _, change := range d.DirectChanges {
		d.DirectCostDelta = d.DirectCostDelta.Add(change.NewCost)
		if change.Confidence < d.MinConfidence {
			d.MinConfidence = change.Confidence
		}
	}

	for _, change := range d.IndirectChanges {
		d.IndirectCostDelta = d.IndirectCostDelta.Add(change.NewCost)
		if change.Confidence < d.MinConfidence {
			d.MinConfidence = change.Confidence
		}
	}

	// Symbolic changes reduce confidence to 0
	if len(d.SymbolicChanges) > 0 {
		d.MinConfidence = 0
	}

	d.TotalCostDelta = d.DirectCostDelta.Add(d.IndirectCostDelta)
}

// CostChange represents a cost change
type CostChange struct {
	CostUnitID     string
	AssetID        string
	DependencyPath []graph.DependencyNodeID
	OldCost        determinism.Money
	NewCost        determinism.Money
	Confidence     float64
}

// SymbolicChange represents a symbolic (unknown cardinality) change
type SymbolicChange struct {
	CostUnitID  string
	AssetID     string
	Reason      string
	IsUnbounded bool
}

// GetExplanation returns why a cost unit changed
func (d *ClosureAwareDiff) GetExplanation(costUnitID string) string {
	for _, change := range d.DirectChanges {
		if change.CostUnitID == costUnitID {
			return "Direct change to resource"
		}
	}
	for _, change := range d.IndirectChanges {
		if change.CostUnitID == costUnitID {
			if len(change.DependencyPath) > 1 {
				return "Changed because upstream dependency changed"
			}
		}
	}
	for _, change := range d.SymbolicChanges {
		if change.CostUnitID == costUnitID {
			return "Unknown cardinality: " + change.Reason
		}
	}
	return "No change"
}

// PolicyContext is the context passed to policies
// Policies MUST receive dependency-scoped information
type PolicyContext struct {
	// Changed nodes in dependency graph
	ChangedDependencyNodes []graph.DependencyNodeID

	// Affected cost units (via dependency closure)
	AffectedCostUnits []*graph.EnforcedCostUnit

	// The full diff
	Diff *ClosureAwareDiff

	// Mode
	IsStrictMode bool
}

// NewPolicyContext creates a policy context from a diff
func NewPolicyContext(diff *ClosureAwareDiff, isStrict bool) *PolicyContext {
	return &PolicyContext{
		ChangedDependencyNodes: diff.ChangedNodes,
		AffectedCostUnits:      diff.AffectedCostUnits,
		Diff:                   diff,
		IsStrictMode:           isStrict,
	}
}

// HasSymbolicCosts returns true if there are symbolic costs
func (c *PolicyContext) HasSymbolicCosts() bool {
	return len(c.Diff.SymbolicChanges) > 0
}

// NewResourcesOnly returns only new/added resources
func (c *PolicyContext) NewResourcesOnly() []*graph.EnforcedCostUnit {
	// For now, all affected units are considered "changed"
	return c.AffectedCostUnits
}

// GetMinConfidence returns minimum confidence (pessimistic)
func (c *PolicyContext) GetMinConfidence() float64 {
	return c.Diff.MinConfidence
}

################################################################################
# FILE: :\good projects\cost estimation\core\diff\differ.go
# TYPE: go
# SIZE: 11083 bytes
################################################################################
// Package diff provides instance-level cost diffing.
// Compares two cost estimation results at the instance level.
package diff

import (
	"sort"

	"terraform-cost/core/cost"
	"terraform-cost/core/determinism"
	"terraform-cost/core/model"
)

// DiffResult is the complete diff between two estimation results
type DiffResult struct {
	// Overall summary
	TotalBefore    determinism.Money
	TotalAfter     determinism.Money
	TotalDelta     determinism.Money
	DeltaPercent   float64

	// Instance-level changes
	Added      []*InstanceDiff
	Removed    []*InstanceDiff
	Changed    []*InstanceDiff
	Unchanged  []*InstanceDiff

	// Counts
	AddedCount    int
	RemovedCount  int
	ChangedCount  int
	UnchangedCount int

	// Confidence impact
	ConfidenceBefore float64
	ConfidenceAfter  float64
}

// InstanceDiff describes changes to a single instance
type InstanceDiff struct {
	// Identity
	Identity *model.InstanceIdentity
	Address  model.CanonicalAddress

	// Change type
	ChangeType ChangeType

	// Costs
	Before *cost.ConfidenceBoundCost
	After  *cost.ConfidenceBoundCost
	Delta  determinism.Money

	// Component-level changes
	ComponentDiffs []*ComponentDiff

	// What drove the change
	ChangeReasons []ChangeReason
}

// ChangeType indicates the type of change
type ChangeType int

const (
	ChangeAdded    ChangeType = iota // New instance
	ChangeRemoved                     // Instance removed
	ChangeModified                    // Instance cost changed
	ChangeUnchanged                   // No cost change
)

// String returns the change type name
func (c ChangeType) String() string {
	switch c {
	case ChangeAdded:
		return "added"
	case ChangeRemoved:
		return "removed"
	case ChangeModified:
		return "modified"
	case ChangeUnchanged:
		return "unchanged"
	default:
		return "unknown"
	}
}

// ComponentDiff describes changes to a cost component
type ComponentDiff struct {
	ComponentName string
	ChangeType    ChangeType

	Before *cost.CostWithProvenance
	After  *cost.CostWithProvenance
	Delta  determinism.Money

	// What changed
	RateChanged   bool
	UsageChanged  bool
	OldRate       string
	NewRate       string
	OldUsage      float64
	NewUsage      float64
}

// ChangeReason explains why a cost changed
type ChangeReason struct {
	Category string // "rate", "usage", "quantity", "configuration"
	What     string // What changed
	Impact   determinism.Money
}

// Differ computes diffs between estimation results
type Differ struct {
	// Threshold for "unchanged" (e.g., 0.01 = 1%)
	ChangeThreshold float64
}

// NewDiffer creates a new differ
func NewDiffer(changeThreshold float64) *Differ {
	if changeThreshold <= 0 {
		changeThreshold = 0.001 // 0.1% default
	}
	return &Differ{ChangeThreshold: changeThreshold}
}

// Diff computes the diff between before and after
func (d *Differ) Diff(before, after *cost.AggregatedCostResult) *DiffResult {
	result := &DiffResult{
		TotalBefore:      before.TotalMonthly,
		TotalAfter:       after.TotalMonthly,
		ConfidenceBefore: before.TotalConfidence,
		ConfidenceAfter:  after.TotalConfidence,
		Added:            []*InstanceDiff{},
		Removed:          []*InstanceDiff{},
		Changed:          []*InstanceDiff{},
		Unchanged:        []*InstanceDiff{},
	}

	// Calculate delta
	result.TotalDelta = after.TotalMonthly.Sub(before.TotalMonthly)
	if !before.TotalMonthly.IsZero() {
		result.DeltaPercent = (after.TotalMonthly.Float64() - before.TotalMonthly.Float64()) / before.TotalMonthly.Float64() * 100
	}

	// Index before instances
	beforeMap := make(map[model.CanonicalAddress]*cost.InstanceCostResult)
	for _, inst := range before.Instances {
		beforeMap[inst.Identity.Canonical] = inst
	}

	// Index after instances
	afterMap := make(map[model.CanonicalAddress]*cost.InstanceCostResult)
	for _, inst := range after.Instances {
		afterMap[inst.Identity.Canonical] = inst
	}

	// Find added, changed, unchanged
	for addr, afterInst := range afterMap {
		beforeInst, existed := beforeMap[addr]

		if !existed {
			// Added
			diff := d.createInstanceDiff(nil, afterInst, ChangeAdded)
			result.Added = append(result.Added, diff)
			result.AddedCount++
		} else {
			// Existed before - check if changed
			diff := d.compareInstances(beforeInst, afterInst)
			if diff.ChangeType == ChangeModified {
				result.Changed = append(result.Changed, diff)
				result.ChangedCount++
			} else {
				result.Unchanged = append(result.Unchanged, diff)
				result.UnchangedCount++
			}
		}
	}

	// Find removed
	for addr, beforeInst := range beforeMap {
		if _, exists := afterMap[addr]; !exists {
			diff := d.createInstanceDiff(beforeInst, nil, ChangeRemoved)
			result.Removed = append(result.Removed, diff)
			result.RemovedCount++
		}
	}

	// Sort all lists by address for determinism
	d.sortDiffs(result.Added)
	d.sortDiffs(result.Removed)
	d.sortDiffs(result.Changed)
	d.sortDiffs(result.Unchanged)

	return result
}

func (d *Differ) createInstanceDiff(before, after *cost.InstanceCostResult, changeType ChangeType) *InstanceDiff {
	diff := &InstanceDiff{
		ChangeType:     changeType,
		ComponentDiffs: []*ComponentDiff{},
		ChangeReasons:  []ChangeReason{},
	}

	switch changeType {
	case ChangeAdded:
		diff.Identity = after.Identity
		diff.Address = after.Identity.Canonical
		diff.After = after.Total
		diff.Delta = after.Total.Monthly
		diff.ChangeReasons = append(diff.ChangeReasons, ChangeReason{
			Category: "quantity",
			What:     "new instance",
			Impact:   after.Total.Monthly,
		})

	case ChangeRemoved:
		diff.Identity = before.Identity
		diff.Address = before.Identity.Canonical
		diff.Before = before.Total
		diff.Delta = determinism.Zero("USD").Sub(before.Total.Monthly)
		diff.ChangeReasons = append(diff.ChangeReasons, ChangeReason{
			Category: "quantity",
			What:     "instance removed",
			Impact:   diff.Delta,
		})
	}

	return diff
}

func (d *Differ) compareInstances(before, after *cost.InstanceCostResult) *InstanceDiff {
	diff := &InstanceDiff{
		Identity:       after.Identity,
		Address:        after.Identity.Canonical,
		Before:         before.Total,
		After:          after.Total,
		Delta:          after.Total.Monthly.Sub(before.Total.Monthly),
		ComponentDiffs: []*ComponentDiff{},
		ChangeReasons:  []ChangeReason{},
	}

	// Check if cost changed significantly
	beforeCost := before.Total.Monthly.Float64()
	afterCost := after.Total.Monthly.Float64()

	if beforeCost == 0 && afterCost == 0 {
		diff.ChangeType = ChangeUnchanged
		return diff
	}

	var percentChange float64
	if beforeCost > 0 {
		percentChange = (afterCost - beforeCost) / beforeCost
	} else {
		percentChange = 1.0 // Infinite increase from 0
	}

	if abs(percentChange) <= d.ChangeThreshold {
		diff.ChangeType = ChangeUnchanged
		return diff
	}

	diff.ChangeType = ChangeModified

	// Compare components
	beforeComponents := make(map[string]*cost.CostWithProvenance)
	for _, c := range before.Components {
		beforeComponents[c.Component] = c
	}

	for _, afterComp := range after.Components {
		beforeComp, existed := beforeComponents[afterComp.Component]

		compDiff := &ComponentDiff{
			ComponentName: afterComp.Component,
			After:         afterComp,
		}

		if !existed {
			compDiff.ChangeType = ChangeAdded
			compDiff.Delta = afterComp.Cost.Monthly
			diff.ChangeReasons = append(diff.ChangeReasons, ChangeReason{
				Category: "configuration",
				What:     "new component: " + afterComp.Component,
				Impact:   afterComp.Cost.Monthly,
			})
		} else {
			compDiff.Before = beforeComp
			compDiff.Delta = afterComp.Cost.Monthly.Sub(beforeComp.Cost.Monthly)

			if !compDiff.Delta.IsZero() {
				compDiff.ChangeType = ChangeModified

				// What changed?
				if beforeComp.Rate != nil && afterComp.Rate != nil {
					if beforeComp.Rate.Price != afterComp.Rate.Price {
						compDiff.RateChanged = true
						compDiff.OldRate = beforeComp.Rate.Price
						compDiff.NewRate = afterComp.Rate.Price
						diff.ChangeReasons = append(diff.ChangeReasons, ChangeReason{
							Category: "rate",
							What:     afterComp.Component + " rate changed",
							Impact:   compDiff.Delta,
						})
					}
				}

				if beforeComp.Usage != nil && afterComp.Usage != nil {
					if beforeComp.Usage.Value != afterComp.Usage.Value {
						compDiff.UsageChanged = true
						compDiff.OldUsage = beforeComp.Usage.Value
						compDiff.NewUsage = afterComp.Usage.Value
						diff.ChangeReasons = append(diff.ChangeReasons, ChangeReason{
							Category: "usage",
							What:     afterComp.Component + " usage changed",
							Impact:   compDiff.Delta,
						})
					}
				}
			} else {
				compDiff.ChangeType = ChangeUnchanged
			}
		}

		diff.ComponentDiffs = append(diff.ComponentDiffs, compDiff)
	}

	// Check for removed components
	for name, beforeComp := range beforeComponents {
		found := false
		for _, afterComp := range after.Components {
			if afterComp.Component == name {
				found = true
				break
			}
		}
		if !found {
			compDiff := &ComponentDiff{
				ComponentName: name,
				ChangeType:    ChangeRemoved,
				Before:        beforeComp,
				Delta:         determinism.Zero("USD").Sub(beforeComp.Cost.Monthly),
			}
			diff.ComponentDiffs = append(diff.ComponentDiffs, compDiff)
			diff.ChangeReasons = append(diff.ChangeReasons, ChangeReason{
				Category: "configuration",
				What:     "component removed: " + name,
				Impact:   compDiff.Delta,
			})
		}
	}

	return diff
}

func (d *Differ) sortDiffs(diffs []*InstanceDiff) {
	sort.Slice(diffs, func(i, j int) bool {
		return diffs[i].Address < diffs[j].Address
	})
}

func abs(x float64) float64 {
	if x < 0 {
		return -x
	}
	return x
}

// DiffSummary provides a human-readable summary
func (r *DiffResult) Summary() string {
	var summary string

	// Overall change
	if r.TotalDelta.IsZero() {
		summary = "No cost change\n"
	} else if r.TotalDelta.IsNegative() {
		summary = "Cost decreased by " + r.TotalDelta.String() + "\n"
	} else {
		summary = "Cost increased by " + r.TotalDelta.String() + "\n"
	}

	// Instance changes
	if r.AddedCount > 0 {
		summary += "  + " + string(rune('0'+r.AddedCount)) + " instances added\n"
	}
	if r.RemovedCount > 0 {
		summary += "  - " + string(rune('0'+r.RemovedCount)) + " instances removed\n"
	}
	if r.ChangedCount > 0 {
		summary += "  ~ " + string(rune('0'+r.ChangedCount)) + " instances changed\n"
	}

	return summary
}

// TopChanges returns the instances with largest cost impact
func (r *DiffResult) TopChanges(n int) []*InstanceDiff {
	all := append(r.Added, r.Removed...)
	all = append(all, r.Changed...)

	sort.Slice(all, func(i, j int) bool {
		iAbs := abs(all[i].Delta.Float64())
		jAbs := abs(all[j].Delta.Float64())
		return iAbs > jAbs
	})

	if n > len(all) {
		n = len(all)
	}
	return all[:n]
}

################################################################################
# FILE: :\good projects\cost estimation\core\enforcement\pipeline.go
# TYPE: go
# SIZE: 10129 bytes
################################################################################
// Package enforcement - Unified architectural enforcement
// This is the ONLY entry point for estimation.
// All other paths are blocked by package visibility.
package enforcement

import (
	"context"
	"fmt"

	"terraform-cost/core/determinism"
	"terraform-cost/core/graph"
	"terraform-cost/core/guards"
	"terraform-cost/core/pricing"
	"terraform-cost/core/terraform"
)

// EstimationPipeline is the ONLY way to perform estimation.
// It enforces all architectural invariants at each step.
type EstimationPipeline struct {
	enforcer        *guards.InvariantEnforcer
	guardedExpand   *guards.GuardedExpansion
	mode            terraform.EvaluationMode
	
	// State - each becomes non-nil only after its phase
	depGraph        *graph.InfrastructureGraph
	providerFinal   *terraform.ProviderFinalizer
	costGraph       *graph.DerivedCostGraph
	pricingSnapshot *pricing.PricingSnapshot
	
	// Accumulated warnings and errors
	warnings        []string
	symbolicCosts   []*graph.SymbolicCost
}

// NewEstimationPipeline creates the pipeline
func NewEstimationPipeline(mode terraform.EvaluationMode) *EstimationPipeline {
	enforcer := guards.NewInvariantEnforcer()
	return &EstimationPipeline{
		enforcer:      enforcer,
		guardedExpand: guards.NewGuardedExpansion(enforcer),
		mode:          mode,
		warnings:      []string{},
		symbolicCosts: []*graph.SymbolicCost{},
	}
}

// Step1_BuildDependencyGraph builds the authoritative dependency graph
// This MUST be called first.
func (p *EstimationPipeline) Step1_BuildDependencyGraph(ctx context.Context, parsed *graph.ParsedInfra) error {
	builder := graph.NewInfraGraphBuilder()
	depGraph, err := builder.Build(parsed)
	if err != nil {
		return fmt.Errorf("failed to build dependency graph: %w", err)
	}

	p.depGraph = depGraph
	p.enforcer.MarkDependencyGraphBuilt(depGraph)
	return nil
}

// Step2_FreezeProviders freezes all provider configurations
// This MUST be called after Step1.
func (p *EstimationPipeline) Step2_FreezeProviders(ctx context.Context, providers []*terraform.ProviderContext) error {
	p.enforcer.AssertDependencyGraphBuilt()

	p.providerFinal = terraform.NewProviderFinalizer()
	for _, prov := range providers {
		if _, err := p.providerFinal.Freeze(prov); err != nil {
			return fmt.Errorf("failed to freeze provider %s: %w", prov.ProviderKey(), err)
		}
	}
	p.providerFinal.Finalize()
	p.enforcer.MarkProvidersFrozen(p.providerFinal)
	return nil
}

// Step3_ExpandAssets expands assets using guarded expansion
// This MUST be called after Step2.
// Unknown cardinality is NEVER expanded - it becomes a SymbolicCost.
func (p *EstimationPipeline) Step3_ExpandAssets(ctx context.Context, definitions []ResourceDefinition) (*ExpandedAssets, error) {
	p.enforcer.AssertProvidersFrozen()

	expanded := &ExpandedAssets{
		Instances:     []ExpandedInstance{},
		SymbolicCosts: []*graph.SymbolicCost{},
	}

	for _, def := range definitions {
		// Verify resource is in dependency graph
		p.enforcer.AssertNodeInDependencyGraph(def.Address)

		// Get frozen provider
		providerKey := def.ProviderKey
		if providerKey == "" {
			providerKey = extractProvider(def.ResourceType)
		}
		frozenProvider, ok := p.providerFinal.Get(providerKey)
		if !ok && p.mode == terraform.ModeStrict {
			return nil, fmt.Errorf("no provider for %s in strict mode", def.Address)
		}

		// Handle expansion
		if def.Count != nil {
			instances, err := p.guardedExpand.ExpandResource(def.Address, def.Count.Value, def.Count.IsKnown)
			if err != nil {
				// Unknown cardinality - create symbolic cost
				symbolic := &graph.SymbolicCost{
					Address:      def.Address,
					Expression:   def.Count.Expression,
					MinInstances: 0,
					MaxInstances: -1, // Unbounded
					IsUnbounded:  true,
					Confidence:   0.3,
					Warning:      fmt.Sprintf("count at %s is unknown - cost is unbounded", def.Address),
				}
				expanded.SymbolicCosts = append(expanded.SymbolicCosts, symbolic)
				p.symbolicCosts = append(p.symbolicCosts, symbolic)
				continue
			}
			for _, addr := range instances {
				expanded.Instances = append(expanded.Instances, ExpandedInstance{
					Address:        addr,
					DefinitionAddr: def.Address,
					Provider:       frozenProvider,
				})
			}
			continue
		}

		if def.ForEach != nil {
			instances, err := p.guardedExpand.ExpandForEach(def.Address, def.ForEach.Keys, def.ForEach.IsKnown)
			if err != nil {
				// Unknown cardinality - create symbolic cost
				symbolic := &graph.SymbolicCost{
					Address:      def.Address,
					Expression:   def.ForEach.Expression,
					MinInstances: 0,
					MaxInstances: -1,
					IsUnbounded:  true,
					Confidence:   0.3,
					Warning:      fmt.Sprintf("for_each at %s is unknown - cost is unbounded", def.Address),
				}
				expanded.SymbolicCosts = append(expanded.SymbolicCosts, symbolic)
				p.symbolicCosts = append(p.symbolicCosts, symbolic)
				continue
			}
			for _, addr := range instances {
				expanded.Instances = append(expanded.Instances, ExpandedInstance{
					Address:        addr,
					DefinitionAddr: def.Address,
					Provider:       frozenProvider,
				})
			}
			continue
		}

		// Single instance
		expanded.Instances = append(expanded.Instances, ExpandedInstance{
			Address:        def.Address,
			DefinitionAddr: def.Address,
			Provider:       frozenProvider,
		})
	}

	p.enforcer.MarkExpansionComplete()
	p.warnings = append(p.warnings, p.guardedExpand.GetWarnings()...)
	return expanded, nil
}

// Step4_BuildCostGraph builds the cost graph FROM the dependency graph
// This MUST be called after Step3.
// The cost graph MUST derive from the dependency graph.
func (p *EstimationPipeline) Step4_BuildCostGraph(ctx context.Context, expanded *ExpandedAssets) error {
	p.enforcer.AssertExpansionComplete()

	// Cost graph MUST be derived from dependency graph
	costGraph, err := graph.NewDerivedCostGraph(p.depGraph)
	if err != nil {
		return fmt.Errorf("failed to create cost graph: %w", err)
	}

	// Add symbolic costs for unknown cardinality
	for _, symbolic := range expanded.SymbolicCosts {
		costGraph.AddSymbolicCost(
			symbolic.Address,
			determinism.Zero("USD"), // Cost per unit unknown
			symbolic.MinInstances,
			symbolic.MaxInstances,
			symbolic.Expression,
		)
	}

	p.costGraph = costGraph
	p.enforcer.MarkCostGraphBuilt()
	return nil
}

// Step5_ApplyPricing applies pricing to the cost graph
// This MUST be called after Step4.
// Provider alias MUST be in every rate key.
func (p *EstimationPipeline) Step5_ApplyPricing(ctx context.Context, expanded *ExpandedAssets, calculator PricingCalculator) error {
	p.enforcer.AssertCostGraphBuilt()

	if p.pricingSnapshot == nil {
		return fmt.Errorf("pricing snapshot not set")
	}

	resolver := pricing.NewAliasAwareRateResolver()

	for _, inst := range expanded.Instances {
		// Provider alias MUST be in rate key
		rateKey := pricing.NewAliasAwareRateKey(
			inst.Provider.Type,
			inst.Provider.Alias,
			inst.Provider.Region,
			extractResourceType(inst.Address),
			"compute",
		)

		rate, err := resolver.ResolveRate(p.pricingSnapshot, rateKey)
		if err != nil {
			if p.mode == terraform.ModeStrict {
				return fmt.Errorf("rate not found for %s: %w", inst.Address, err)
			}
			p.warnings = append(p.warnings, fmt.Sprintf("rate not found for %s", inst.Address))
			continue
		}

		// Calculate cost
		monthly := determinism.NewMoneyFromDecimal(rate.Price, rate.Currency)
		hourly := monthly.Div(determinism.NewMoneyFromFloat(730, "USD").Amount())

		if err := p.costGraph.SetNodeCost(inst.DefinitionAddr, monthly, hourly, 1.0); err != nil {
			p.warnings = append(p.warnings, fmt.Sprintf("could not set cost for %s: %v", inst.Address, err))
		}
	}

	p.costGraph.CalculateTransitiveCosts()
	p.enforcer.MarkPricingComplete()
	return nil
}

// SetPricingSnapshot sets the pricing snapshot to use
func (p *EstimationPipeline) SetPricingSnapshot(snapshot *pricing.PricingSnapshot) {
	p.pricingSnapshot = snapshot
}

// GetResult returns the estimation result
func (p *EstimationPipeline) GetResult() *EstimationResult {
	costRange := p.costGraph.GetTotalCostRange()

	return &EstimationResult{
		CostGraph:       p.costGraph,
		TotalCostRange:  costRange,
		SymbolicCosts:   p.symbolicCosts,
		HasUnbounded:    p.costGraph.HasUnboundedCosts(),
		Warnings:        p.warnings,
	}
}

// ResourceDefinition is input to expansion
type ResourceDefinition struct {
	Address      string
	ResourceType string
	ProviderKey  string
	Count        *CountValue
	ForEach      *ForEachValue
}

// CountValue represents a count expression
type CountValue struct {
	Value      int
	IsKnown    bool
	Expression string
}

// ForEachValue represents a for_each expression
type ForEachValue struct {
	Keys       []string
	IsKnown    bool
	Expression string
}

// ExpandedAssets is the result of expansion
type ExpandedAssets struct {
	Instances     []ExpandedInstance
	SymbolicCosts []*graph.SymbolicCost
}

// ExpandedInstance is a single expanded instance
type ExpandedInstance struct {
	Address        string
	DefinitionAddr string
	Provider       *terraform.FrozenProviderContext
}

// PricingCalculator calculates pricing
type PricingCalculator interface {
	Calculate(resourceType string, attrs map[string]string) (determinism.Money, error)
}

// EstimationResult is the final result
type EstimationResult struct {
	CostGraph      *graph.DerivedCostGraph
	TotalCostRange *graph.CostBounds
	SymbolicCosts  []*graph.SymbolicCost
	HasUnbounded   bool
	Warnings       []string
}

func extractProvider(resourceType string) string {
	for i, c := range resourceType {
		if c == '_' {
			return resourceType[:i]
		}
	}
	return resourceType
}

func extractResourceType(address string) string {
	// aws_instance.foo[0] â†’ aws_instance
	for i, c := range address {
		if c == '.' {
			return address[:i]
		}
	}
	return address
}

################################################################################
# FILE: :\good projects\cost estimation\core\engine\engine.go
# TYPE: go
# SIZE: 13444 bytes
################################################################################
// Package engine provides the API-primary estimation engine.
// CLI is a thin wrapper around this engine.
package engine

import (
	"context"
	"fmt"
	"time"

	"terraform-cost/core/determinism"
	"terraform-cost/core/model"
	"terraform-cost/core/pricing"
)

// Engine is the primary API for cost estimation.
// All other interfaces (CLI, HTTP, CI) are thin wrappers.
type Engine struct {
	// Required dependencies
	pricingResolver PricingResolver
	usageEstimator  UsageEstimator
	policyEvaluator PolicyEvaluator

	// Plugin registry
	cloudPlugins map[string]CloudPlugin

	// Configuration
	config EngineConfig
}

// EngineConfig configures the estimation engine
type EngineConfig struct {
	// Default region for pricing
	DefaultRegion string

	// Unknown handling
	UnknownCountDefault int
	UnknownBehavior     UnknownBehavior

	// Confidence thresholds
	MinConfidenceForEstimate float64
}

// UnknownBehavior defines how to handle unknown values
type UnknownBehavior int

const (
	// UnknownPropagate marks results as uncertain (correct behavior)
	UnknownPropagate UnknownBehavior = iota
	// UnknownFail returns an error on unknowns
	UnknownFail
)

// PricingResolver resolves pricing - MUST use snapshots
type PricingResolver interface {
	// GetSnapshot returns a pricing snapshot - never "latest" implicitly
	GetSnapshot(ctx context.Context, req SnapshotRequest) (*pricing.PricingSnapshot, error)

	// LookupRate finds a rate within a snapshot
	LookupRate(snapshot *pricing.PricingSnapshot, resourceType, component string, attrs map[string]string) (*pricing.RateEntry, error)
}

// SnapshotRequest specifies which snapshot to retrieve
type SnapshotRequest struct {
	// SnapshotID is preferred if known
	SnapshotID pricing.SnapshotID

	// Otherwise, specify provider and region
	Provider string
	Region   string

	// AsOf specifies point-in-time (nil = latest known)
	AsOf *time.Time
}

// UsageEstimator estimates usage for instances
type UsageEstimator interface {
	Estimate(ctx context.Context, instance *model.AssetInstance) (*UsageResult, error)
}

// UsageResult contains estimated usage with confidence
type UsageResult struct {
	Metrics    map[string]UsageMetric
	Source     pricing.UsageSource
	Confidence float64
}

// UsageMetric is a single usage estimate
type UsageMetric struct {
	Name       string
	Value      float64
	Unit       string
	Confidence float64
	IsUnknown  bool
}

// PolicyEvaluator evaluates cost policies
type PolicyEvaluator interface {
	Evaluate(ctx context.Context, result *EstimationResult) (*PolicyResult, error)
}

// CloudPlugin provides cloud-specific cost mapping
type CloudPlugin interface {
	Provider() string
	MapInstance(instance *model.AssetInstance) ([]CostComponent, error)
}

// CostComponent is a billable component of an instance
type CostComponent struct {
	Name         string
	ResourceType string
	Unit         string
	Attributes   map[string]string
}

// NewEngine creates a new estimation engine
func NewEngine(
	pricingResolver PricingResolver,
	usageEstimator UsageEstimator,
	policyEvaluator PolicyEvaluator,
	config EngineConfig,
) *Engine {
	return &Engine{
		pricingResolver: pricingResolver,
		usageEstimator:  usageEstimator,
		policyEvaluator: policyEvaluator,
		cloudPlugins:    make(map[string]CloudPlugin),
		config:          config,
	}
}

// RegisterPlugin registers a cloud plugin
func (e *Engine) RegisterPlugin(plugin CloudPlugin) {
	e.cloudPlugins[plugin.Provider()] = plugin
}

// EstimateRequest is the input to estimation
type EstimateRequest struct {
	// REQUIRED: Instance graph to estimate
	Graph *model.InstanceGraph

	// REQUIRED: Pricing snapshot to use
	SnapshotRequest SnapshotRequest

	// Optional: Usage overrides per instance
	UsageOverrides map[model.InstanceID]map[string]float64

	// Optional: Policy configuration
	PolicyConfig map[string]any
}

// EstimationResult is the output of estimation
type EstimationResult struct {
	// Pricing snapshot used (for reproducibility)
	Snapshot *SnapshotReference

	// Costs per INSTANCE (not definition)
	InstanceCosts *determinism.StableMap[model.InstanceID, *InstanceCost]

	// Aggregated totals
	TotalMonthlyCost determinism.Money
	TotalHourlyCost  determinism.Money

	// Overall confidence
	Confidence CostConfidence

	// Warnings and degradations
	Warnings []string
	Degraded bool

	// Policy results (if evaluated)
	PolicyResult *PolicyResult

	// Timing
	EstimatedAt time.Time
	Duration    time.Duration
}

// SnapshotReference is an immutable reference to the pricing snapshot used
type SnapshotReference struct {
	ID          pricing.SnapshotID
	ContentHash determinism.ContentHash
	EffectiveAt time.Time
	Provider    string
	Region      string
}

// InstanceCost is the cost for a SINGLE INSTANCE (not definition)
type InstanceCost struct {
	// Instance identity
	InstanceID model.InstanceID
	Address    model.InstanceAddress

	// Link to definition (for grouping)
	DefinitionID model.DefinitionID

	// Cost components
	Components []*ComponentCost

	// Roll-ups
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money

	// Confidence for THIS instance
	Confidence CostConfidence

	// Full lineage for explainability
	Lineage []*pricing.CostLineage
}

// ComponentCost is a single cost component
type ComponentCost struct {
	Name        string
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money

	// Rate used
	RateID  pricing.RateID
	RateKey pricing.RateKey

	// Usage applied
	UsageValue float64
	UsageUnit  string

	// Formula
	Formula pricing.FormulaApplication

	// Confidence
	Confidence float64
}

// CostConfidence tracks estimation confidence
type CostConfidence struct {
	Score   float64 // 0.0 - 1.0
	Factors []ConfidenceFactor
}

// ConfidenceFactor explains why confidence is reduced
type ConfidenceFactor struct {
	Reason      string
	Impact      float64 // How much this reduces confidence
	Component   string  // Which component affected
	IsUnknown   bool    // Is this due to an unknown value?
}

// PolicyResult is the output of policy evaluation
type PolicyResult struct {
	Passed   bool
	Policies []PolicyOutcome
}

// PolicyOutcome is the result of a single policy
type PolicyOutcome struct {
	Name    string
	Passed  bool
	Message string

	// Deep context for explainability
	AffectedInstances []model.InstanceID
	CostImpact        determinism.Money
	LineageRefs       []*pricing.CostLineage
}

// Estimate performs the estimation
func (e *Engine) Estimate(ctx context.Context, req *EstimateRequest) (*EstimationResult, error) {
	start := time.Now()

	// REQUIRED: Validate inputs
	if req.Graph == nil {
		return nil, fmt.Errorf("instance graph is required")
	}

	// REQUIRED: Get pricing snapshot
	snapshot, err := e.pricingResolver.GetSnapshot(ctx, req.SnapshotRequest)
	if err != nil {
		return nil, fmt.Errorf("failed to get pricing snapshot: %w", err)
	}

	// Verify snapshot integrity
	if !snapshot.Verify() {
		return nil, fmt.Errorf("pricing snapshot failed integrity check")
	}

	result := &EstimationResult{
		Snapshot: &SnapshotReference{
			ID:          snapshot.ID,
			ContentHash: snapshot.ContentHash,
			EffectiveAt: snapshot.EffectiveAt,
			Provider:    snapshot.Provider,
			Region:      snapshot.Region,
		},
		InstanceCosts:    determinism.NewStableMap[model.InstanceID, *InstanceCost](),
		TotalMonthlyCost: determinism.Zero("USD"),
		TotalHourlyCost:  determinism.Zero("USD"),
		Confidence:       CostConfidence{Score: 1.0},
		EstimatedAt:      time.Now().UTC(),
	}

	// Process each INSTANCE (not definition)
	for _, inst := range req.Graph.Instances() {
		instanceCost, err := e.estimateInstance(ctx, inst, snapshot, req.UsageOverrides)
		if err != nil {
			result.Warnings = append(result.Warnings,
				fmt.Sprintf("%s: %v", inst.Address, err))
			result.Degraded = true
			continue
		}

		result.InstanceCosts.Set(inst.ID, instanceCost)
		result.TotalMonthlyCost = result.TotalMonthlyCost.Add(instanceCost.MonthlyCost)
		result.TotalHourlyCost = result.TotalHourlyCost.Add(instanceCost.HourlyCost)

		// Compound confidence
		result.Confidence.Score *= instanceCost.Confidence.Score
	}

	// Evaluate policies with full context
	if e.policyEvaluator != nil {
		policyResult, err := e.policyEvaluator.Evaluate(ctx, result)
		if err != nil {
			result.Warnings = append(result.Warnings,
				fmt.Sprintf("policy evaluation failed: %v", err))
		} else {
			result.PolicyResult = policyResult
		}
	}

	result.Duration = time.Since(start)
	return result, nil
}

func (e *Engine) estimateInstance(
	ctx context.Context,
	inst *model.AssetInstance,
	snapshot *pricing.PricingSnapshot,
	overrides map[model.InstanceID]map[string]float64,
) (*InstanceCost, error) {
	result := &InstanceCost{
		InstanceID:   inst.ID,
		Address:      inst.Address,
		DefinitionID: inst.DefinitionID,
		Components:   []*ComponentCost{},
		MonthlyCost:  determinism.Zero("USD"),
		HourlyCost:   determinism.Zero("USD"),
		Confidence:   CostConfidence{Score: 1.0},
		Lineage:      []*pricing.CostLineage{},
	}

	// Get cloud plugin
	plugin, ok := e.cloudPlugins[inst.Provider.Type]
	if !ok {
		return result, fmt.Errorf("no plugin for provider %s", inst.Provider.Type)
	}

	// Map instance to cost components
	components, err := plugin.MapInstance(inst)
	if err != nil {
		return result, err
	}

	// Get usage estimates
	usage, err := e.usageEstimator.Estimate(ctx, inst)
	if err != nil {
		result.Confidence.Factors = append(result.Confidence.Factors, ConfidenceFactor{
			Reason: "usage estimation failed",
			Impact: 0.3,
		})
		usage = &UsageResult{Confidence: 0.5}
	}

	// Apply overrides if present
	instanceOverrides := overrides[inst.ID]

	// Price each component
	for _, comp := range components {
		compCost, lineage := e.priceComponent(comp, inst, snapshot, usage, instanceOverrides)
		result.Components = append(result.Components, compCost)
		result.MonthlyCost = result.MonthlyCost.Add(compCost.MonthlyCost)
		result.HourlyCost = result.HourlyCost.Add(compCost.HourlyCost)
		result.Lineage = append(result.Lineage, lineage)

		// Track confidence factors
		if compCost.Confidence < 1.0 {
			result.Confidence.Factors = append(result.Confidence.Factors, ConfidenceFactor{
				Reason:    "reduced component confidence",
				Impact:    1.0 - compCost.Confidence,
				Component: comp.Name,
			})
		}
	}

	// Calculate overall confidence
	result.Confidence.Score = e.calculateConfidence(result)

	return result, nil
}

func (e *Engine) priceComponent(
	comp CostComponent,
	inst *model.AssetInstance,
	snapshot *pricing.PricingSnapshot,
	usage *UsageResult,
	overrides map[string]float64,
) (*ComponentCost, *pricing.CostLineage) {
	result := &ComponentCost{
		Name:       comp.Name,
		Confidence: 1.0,
	}

	lineage := &pricing.CostLineage{
		InstanceID: string(inst.ID),
		Component:  comp.Name,
		SnapshotID: snapshot.ID,
		Timestamp:  time.Now().UTC(),
	}

	// Look up rate
	rate, ok := snapshot.LookupRate(comp.ResourceType, comp.Name, comp.Attributes)
	if !ok {
		// Rate not found - degraded estimation
		result.Confidence = 0.0
		lineage.Confidence = 0.0
		return result, lineage
	}

	result.RateID = rate.ID
	result.RateKey = rate.Key
	lineage.RateID = rate.ID
	lineage.RateKey = rate.Key

	// Get usage value
	usageValue := 730.0 // Default monthly hours
	usageUnit := "hours"
	usageConfidence := 1.0

	if metric, ok := usage.Metrics[comp.Name]; ok {
		if metric.IsUnknown {
			// UNKNOWN: propagate, don't guess
			result.Confidence *= 0.5
			usageConfidence = 0.5
			lineage.Confidence = 0.5
		} else {
			usageValue = metric.Value
			usageUnit = metric.Unit
			usageConfidence = metric.Confidence
		}
	}

	// Apply override if present
	if override, ok := overrides[comp.Name]; ok {
		usageValue = override
		usageConfidence = 1.0 // User-provided is trusted
	}

	result.UsageValue = usageValue
	result.UsageUnit = usageUnit

	// Calculate cost
	monthlyCost := determinism.NewMoneyFromDecimal(
		rate.Price.Mul(determinism.NewMoneyFromFloat(usageValue, "USD").Amount()),
		rate.Currency,
	)
	hourlyCost := monthlyCost.Div(determinism.NewMoneyFromFloat(730.0, "USD").Amount())

	result.MonthlyCost = monthlyCost
	result.HourlyCost = hourlyCost
	result.Confidence *= usageConfidence

	// Record formula
	result.Formula = pricing.FormulaApplication{
		Name:       "usage_based",
		Expression: fmt.Sprintf("%s * %s", rate.Price.String(), usageUnit),
		Inputs: map[string]string{
			"rate":  rate.Price.String(),
			"usage": fmt.Sprintf("%.2f", usageValue),
			"unit":  usageUnit,
		},
		Output: monthlyCost.StringRaw(),
	}
	lineage.Formula = result.Formula
	lineage.Usage = pricing.UsageLineage{
		Source:     usage.Source,
		Confidence: usageConfidence,
	}
	lineage.Confidence = result.Confidence

	return result, lineage
}

func (e *Engine) calculateConfidence(ic *InstanceCost) float64 {
	if len(ic.Components) == 0 {
		return 0.0
	}

	total := 0.0
	for _, c := range ic.Components {
		total += c.Confidence
	}
	return total / float64(len(ic.Components))
}

################################################################################
# FILE: :\good projects\cost estimation\core\engine\orchestrator.go
# TYPE: go
# SIZE: 14209 bytes
################################################################################
// Package engine - Authoritative estimation orchestrator
// ENFORCES the correct execution flow:
// 1. Terraform Dependency Graph (authoritative)
// 2. Provider Binding (frozen)
// 3. Expanded Asset Graph (instances)
// 4. Cost Graph (derived from asset graph)
// 5. Policy Evaluation (on full context)
package engine

import (
	"context"
	"fmt"
	"time"

	"terraform-cost/core/cost"
	"terraform-cost/core/graph"
	"terraform-cost/core/model"
	"terraform-cost/core/policy"
	"terraform-cost/core/terraform"
)

// AuthoritativeOrchestrator enforces the correct execution order
type AuthoritativeOrchestrator struct {
	// Current phase - can only move forward
	phase OrchestrationPhase

	// Mode
	mode terraform.EvaluationMode

	// Components - each is nil until its phase
	infraGraph       *graph.InfrastructureGraph
	providerFinal    *terraform.ProviderFinalizer
	bindingRegistry  *terraform.BindingRegistry
	assetGraph       *AssetGraph
	costGraph        *graph.DependencyAwareCostGraph
	policyEngine     *policy.DiffPolicyEngine

	// Cardinality warnings
	cardinalityWarns *terraform.CardinalityWarnings

	// Errors
	errors []OrchestrationError
}

// OrchestrationPhase represents execution phases
type OrchestrationPhase int

const (
	PhaseUninitialized OrchestrationPhase = iota
	PhaseParsed                            // Terraform parsed
	PhaseGraphBuilt                        // Dependency graph built
	PhaseProvidersFrozen                   // Providers finalized
	PhaseExpanded                          // Assets expanded
	PhaseCosted                            // Costs calculated
	PhasePolicyEvaluated                   // Policies run
	PhaseComplete
)

// String returns the phase name
func (p OrchestrationPhase) String() string {
	names := []string{
		"uninitialized", "parsed", "graph_built", "providers_frozen",
		"expanded", "costed", "policy_evaluated", "complete",
	}
	if int(p) < len(names) {
		return names[p]
	}
	return "unknown"
}

// OrchestrationError is an error during orchestration
type OrchestrationError struct {
	Phase   OrchestrationPhase
	Message string
	Cause   error
	Fatal   bool
}

// NewAuthoritativeOrchestrator creates an orchestrator
func NewAuthoritativeOrchestrator(mode terraform.EvaluationMode) *AuthoritativeOrchestrator {
	return &AuthoritativeOrchestrator{
		phase:            PhaseUninitialized,
		mode:             mode,
		providerFinal:    terraform.NewProviderFinalizer(),
		bindingRegistry:  terraform.NewBindingRegistry(),
		cardinalityWarns: terraform.NewCardinalityWarnings(),
		policyEngine:     policy.NewDiffPolicyEngine(),
		errors:           []OrchestrationError{},
	}
}

// PhaseGuard ensures a phase has been completed
func (o *AuthoritativeOrchestrator) PhaseGuard(required OrchestrationPhase) error {
	if o.phase < required {
		return &PhaseOrderError{
			Required: required,
			Current:  o.phase,
		}
	}
	return nil
}

// PhaseOrderError indicates phases executed out of order
type PhaseOrderError struct {
	Required OrchestrationPhase
	Current  OrchestrationPhase
}

func (e *PhaseOrderError) Error() string {
	return fmt.Sprintf("phase %s required, but current phase is %s", e.Required, e.Current)
}

// BuildDependencyGraph builds the authoritative dependency graph
func (o *AuthoritativeOrchestrator) BuildDependencyGraph(ctx context.Context, parsed *graph.ParsedInfra) error {
	if o.phase >= PhaseGraphBuilt {
		return fmt.Errorf("dependency graph already built")
	}

	builder := graph.NewInfraGraphBuilder()
	infraGraph, err := builder.Build(parsed)
	if err != nil {
		o.recordError(PhaseGraphBuilt, "failed to build dependency graph", err, true)
		return err
	}

	o.infraGraph = infraGraph
	o.phase = PhaseGraphBuilt
	return nil
}

// FreezeProviders freezes all provider configurations
func (o *AuthoritativeOrchestrator) FreezeProviders(ctx context.Context, providers []*terraform.ProviderContext) error {
	if err := o.PhaseGuard(PhaseGraphBuilt); err != nil {
		return err
	}
	if o.phase >= PhaseProvidersFrozen {
		return fmt.Errorf("providers already frozen")
	}

	for _, p := range providers {
		if _, err := o.providerFinal.Freeze(p); err != nil {
			o.recordError(PhaseProvidersFrozen, "failed to freeze provider", err, true)
			return err
		}
	}

	o.providerFinal.Finalize()
	o.phase = PhaseProvidersFrozen
	return nil
}

// ExpandAssets expands all assets with frozen providers
func (o *AuthoritativeOrchestrator) ExpandAssets(ctx context.Context, definitions []*terraform.ResourceDefinition) error {
	if err := o.PhaseGuard(PhaseProvidersFrozen); err != nil {
		return err
	}
	if o.phase >= PhaseExpanded {
		return fmt.Errorf("assets already expanded")
	}

	// Ensure providers are finalized
	if !o.providerFinal.IsFinalized() {
		return fmt.Errorf("cannot expand assets: providers not finalized")
	}

	o.assetGraph = NewAssetGraph()
	forEachEval := terraform.NewSafeForEachEvaluator(o.mode)
	countEval := terraform.NewSafeCountEvaluator(o.mode)

	for _, def := range definitions {
		// Get frozen provider
		providerKey := def.Provider
		if providerKey == "" {
			providerKey = extractProviderType(def.Type)
		}

		frozenProvider, ok := o.providerFinal.Get(providerKey)
		if !ok {
			if o.mode == terraform.ModeStrict {
				o.recordError(PhaseExpanded, "no frozen provider for "+def.Address, nil, true)
				return fmt.Errorf("no frozen provider for %s", def.Address)
			}
			// Use default in permissive mode
		}

		// Handle for_each
		if def.ForEach != nil {
			result := forEachEval.Evaluate(def.Address, def.ForEach)
			o.cardinalityWarns.AddForEach(def.Address, result)

			if result.BlocksEstimation {
				o.recordError(PhaseExpanded, result.Warning, nil, true)
				return fmt.Errorf("for_each blocked: %s", result.Warning)
			}

			if result.IsKnown {
				// Expand with known keys
				for _, key := range result.Keys {
					o.addAssetInstance(def, key, frozenProvider)
				}
			} else {
				// DO NOT EXPAND - add symbolic placeholder
				o.addSymbolicAsset(def, result.SymbolicRange, frozenProvider)
			}
			continue
		}

		// Handle count
		if def.Count != nil {
			result := countEval.Evaluate(def.Address, def.Count)
			o.cardinalityWarns.AddCount(def.Address, result)

			if result.BlocksEstimation {
				o.recordError(PhaseExpanded, result.Warning, nil, true)
				return fmt.Errorf("count blocked: %s", result.Warning)
			}

			if result.IsKnown {
				for i := 0; i < result.Value; i++ {
					o.addAssetInstance(def, i, frozenProvider)
				}
			} else {
				// DO NOT EXPAND - add symbolic placeholder
				o.addSymbolicAsset(def, result.SymbolicRange, frozenProvider)
			}
			continue
		}

		// Single instance
		o.addAssetInstance(def, nil, frozenProvider)
	}

	o.phase = PhaseExpanded
	return nil
}

func (o *AuthoritativeOrchestrator) addAssetInstance(def *terraform.ResourceDefinition, key interface{}, provider *terraform.FrozenProviderContext) {
	address := def.Address
	if key != nil {
		switch k := key.(type) {
		case int:
			address = fmt.Sprintf("%s[%d]", def.Address, k)
		case string:
			address = fmt.Sprintf("%s[%q]", def.Address, k)
		}
	}

	asset := &AssetInstance{
		ID:           model.InstanceID(address),
		Address:      model.InstanceAddress(address),
		DefinitionID: def.Address,
		ResourceType: def.Type,
		Provider:     provider,
		InstanceKey:  key,
		IsSymbolic:   false,
	}

	o.assetGraph.AddInstance(asset)

	// Bind to provider
	if provider != nil {
		o.bindingRegistry.Bind(address, key, provider)
	}
}

func (o *AuthoritativeOrchestrator) addSymbolicAsset(def *terraform.ResourceDefinition, symRange *terraform.SymbolicRange, provider *terraform.FrozenProviderContext) {
	asset := &AssetInstance{
		ID:            model.InstanceID(def.Address + "[*]"),
		Address:       model.InstanceAddress(def.Address + "[*]"),
		DefinitionID:  def.Address,
		ResourceType:  def.Type,
		Provider:      provider,
		IsSymbolic:    true,
		SymbolicRange: symRange,
	}

	o.assetGraph.AddInstance(asset)
}

// CalculateCosts calculates costs from expanded assets
func (o *AuthoritativeOrchestrator) CalculateCosts(ctx context.Context, calculator CostCalculator) error {
	if err := o.PhaseGuard(PhaseExpanded); err != nil {
		return err
	}
	if o.phase >= PhaseCosted {
		return fmt.Errorf("costs already calculated")
	}

	// Pricing gate enforces provider binding
	gate := terraform.NewProviderPricingGate(o.providerFinal, o.bindingRegistry)

	// Create cost graph
	rawCostGraph := cost.NewCostGraph("project")

	for _, asset := range o.assetGraph.AllInstances() {
		// Skip symbolic assets - they represent unknown cardinality
		if asset.IsSymbolic {
			continue
		}

		// Verify pricing is allowed
		if err := gate.CanPrice(string(asset.Address)); err != nil {
			if o.mode == terraform.ModeStrict {
				return err
			}
			o.recordError(PhaseCosted, err.Error(), err, false)
			continue
		}

		// Calculate cost
		costNode, err := calculator.Calculate(asset)
		if err != nil {
			o.recordError(PhaseCosted, "failed to calculate cost for "+string(asset.Address), err, false)
			continue
		}

		rawCostGraph.AddNode(costNode)
	}

	// Build service aggregates
	rawCostGraph.BuildServiceAggregates()

	// Create dependency-aware cost graph
	o.costGraph = graph.NewDependencyAwareCostGraph(o.infraGraph, rawCostGraph)

	o.phase = PhaseCosted
	return nil
}

// EvaluatePolicies evaluates policies on the cost graph
func (o *AuthoritativeOrchestrator) EvaluatePolicies(ctx context.Context, diffCtx *policy.DiffPolicyContext) (*policy.DiffPolicyEngineResult, error) {
	if err := o.PhaseGuard(PhaseCosted); err != nil {
		return nil, err
	}

	// Policies operate on full context
	result := o.policyEngine.Evaluate(diffCtx)
	o.phase = PhasePolicyEvaluated

	return result, nil
}

// AddPolicy adds a policy to evaluate
func (o *AuthoritativeOrchestrator) AddPolicy(p policy.DiffAwarePolicy) {
	o.policyEngine.AddPolicy(p)
}

func (o *AuthoritativeOrchestrator) recordError(phase OrchestrationPhase, msg string, cause error, fatal bool) {
	o.errors = append(o.errors, OrchestrationError{
		Phase:   phase,
		Message: msg,
		Cause:   cause,
		Fatal:   fatal,
	})
}

// GetErrors returns all errors
func (o *AuthoritativeOrchestrator) GetErrors() []OrchestrationError {
	return o.errors
}

// GetCardinalityWarnings returns cardinality warnings
func (o *AuthoritativeOrchestrator) GetCardinalityWarnings() []terraform.CardinalityWarning {
	return o.cardinalityWarns.All()
}

// GetCostGraph returns the dependency-aware cost graph
func (o *AuthoritativeOrchestrator) GetCostGraph() *graph.DependencyAwareCostGraph {
	return o.costGraph
}

// GetAssetGraph returns the asset graph
func (o *AuthoritativeOrchestrator) GetAssetGraph() *AssetGraph {
	return o.assetGraph
}

// GetPhase returns current phase
func (o *AuthoritativeOrchestrator) GetPhase() OrchestrationPhase {
	return o.phase
}

func extractProviderType(resourceType string) string {
	// aws_instance â†’ aws
	for i, c := range resourceType {
		if c == '_' {
			return resourceType[:i]
		}
	}
	return resourceType
}

// AssetGraph holds expanded asset instances
type AssetGraph struct {
	instances map[model.InstanceID]*AssetInstance
	order     []model.InstanceID
}

// NewAssetGraph creates an asset graph
func NewAssetGraph() *AssetGraph {
	return &AssetGraph{
		instances: make(map[model.InstanceID]*AssetInstance),
		order:     []model.InstanceID{},
	}
}

// AddInstance adds an instance
func (g *AssetGraph) AddInstance(inst *AssetInstance) {
	g.instances[inst.ID] = inst
	g.order = append(g.order, inst.ID)
}

// GetInstance returns an instance
func (g *AssetGraph) GetInstance(id model.InstanceID) *AssetInstance {
	return g.instances[id]
}

// AllInstances returns all instances in order
func (g *AssetGraph) AllInstances() []*AssetInstance {
	result := make([]*AssetInstance, 0, len(g.order))
	for _, id := range g.order {
		result = append(result, g.instances[id])
	}
	return result
}

// Count returns the number of instances
func (g *AssetGraph) Count() int {
	return len(g.instances)
}

// SymbolicCount returns count of symbolic (unknown cardinality) assets
func (g *AssetGraph) SymbolicCount() int {
	count := 0
	for _, inst := range g.instances {
		if inst.IsSymbolic {
			count++
		}
	}
	return count
}

// AssetInstance is an expanded asset
type AssetInstance struct {
	ID            model.InstanceID
	Address       model.InstanceAddress
	DefinitionID  string
	ResourceType  string
	Provider      *terraform.FrozenProviderContext
	InstanceKey   interface{}
	IsSymbolic    bool
	SymbolicRange *terraform.SymbolicRange
}

// CostCalculator calculates cost for an asset
type CostCalculator interface {
	Calculate(asset *AssetInstance) (*cost.CostNode, error)
}

// OrchestrationResult is the final result
type OrchestrationResult struct {
	Phase             OrchestrationPhase
	CostGraph         *graph.DependencyAwareCostGraph
	TotalMonthly      float64
	TotalHourly       float64
	Confidence        float64
	ResourceCount     int
	SymbolicCount     int
	CardinalityWarns  []terraform.CardinalityWarning
	PolicyResult      *policy.DiffPolicyEngineResult
	Errors            []OrchestrationError
	Duration          time.Duration
}

// NewOrchestrationResult creates a result from orchestrator
func NewOrchestrationResult(o *AuthoritativeOrchestrator, duration time.Duration) *OrchestrationResult {
	result := &OrchestrationResult{
		Phase:            o.GetPhase(),
		CostGraph:        o.GetCostGraph(),
		CardinalityWarns: o.GetCardinalityWarnings(),
		Errors:           o.GetErrors(),
		Duration:         duration,
	}

	if o.assetGraph != nil {
		result.ResourceCount = o.assetGraph.Count()
		result.SymbolicCount = o.assetGraph.SymbolicCount()
	}

	// Calculate aggregates from cost graph
	// No field access needed here

	return result
}

################################################################################
# FILE: :\good projects\cost estimation\core\expansion\expander.go
# TYPE: go
# SIZE: 10260 bytes
################################################################################
// Package expansion provides instance expansion for count and for_each.
// This is a clean-room implementation based on Terraform semantics.
package expansion

import (
	"fmt"
	"sort"

	"terraform-cost/core/expression"
	"terraform-cost/core/types"
)

// InstanceKey represents the index/key for an expanded instance
type InstanceKey struct {
	// Type indicates whether this is a numeric or string key
	Type KeyType
	// NumValue is set for count-based expansion
	NumValue int
	// StrValue is set for for_each-based expansion
	StrValue string
}

// KeyType indicates the type of instance key
type KeyType int

const (
	KeyTypeNone KeyType = iota
	KeyTypeInt
	KeyTypeString
)

// String returns the key as an address suffix
func (k InstanceKey) String() string {
	switch k.Type {
	case KeyTypeInt:
		return fmt.Sprintf("[%d]", k.NumValue)
	case KeyTypeString:
		return fmt.Sprintf("[%q]", k.StrValue)
	default:
		return ""
	}
}

// Value returns the key as an expression Value
func (k InstanceKey) Value() expression.Value {
	switch k.Type {
	case KeyTypeInt:
		return expression.NumberFromInt(int64(k.NumValue))
	case KeyTypeString:
		return expression.String(k.StrValue)
	default:
		return expression.Null()
	}
}

// AssetInstance represents an expanded instance of an asset
type AssetInstance struct {
	// Base is the original asset definition
	Base *types.Asset

	// Key is the instance index/key (from count or for_each)
	Key InstanceKey

	// Address is the full address including index
	Address types.ResourceAddress

	// EachValue is the element value for for_each (nil for count)
	EachValue expression.Value

	// Attributes are the resolved attributes for this instance
	Attributes types.Attributes

	// Metadata about the expansion
	Metadata InstanceMetadata
}

// InstanceMetadata contains information about how the instance was created
type InstanceMetadata struct {
	// ExpansionType indicates how this instance was created
	ExpansionType ExpansionType

	// OriginalAddress is the address before expansion
	OriginalAddress types.ResourceAddress

	// IsKnown indicates whether the expansion count was deterministic
	IsKnown bool

	// Warning is set if expansion produced a warning
	Warning string
}

// ExpansionType indicates the type of expansion
type ExpansionType int

const (
	ExpansionNone     ExpansionType = iota // No expansion (single instance)
	ExpansionCount                         // count meta-argument
	ExpansionForEach                       // for_each meta-argument
	ExpansionUnknown                       // Expansion couldn't be determined
)

// Expander expands assets with count/for_each into instances
type Expander struct {
	// DefaultCountOnUnknown is the count to assume when count is unknown
	DefaultCountOnUnknown int
}

// NewExpander creates a new instance expander
func NewExpander() *Expander {
	return &Expander{
		DefaultCountOnUnknown: 1,
	}
}

// Expand expands a single asset into instances
func (e *Expander) Expand(asset *types.Asset, ctx *expression.Context) ([]*AssetInstance, error) {
	// Check for count meta-argument
	if countAttr := asset.Attributes.Get("count"); countAttr != nil {
		return e.expandCount(asset, countAttr, ctx)
	}

	// Check for for_each meta-argument
	if forEachAttr := asset.Attributes.Get("for_each"); forEachAttr != nil {
		return e.expandForEach(asset, forEachAttr, ctx)
	}

	// No expansion - return single instance
	return []*AssetInstance{
		{
			Base:       asset,
			Key:        InstanceKey{Type: KeyTypeNone},
			Address:    asset.Address,
			Attributes: asset.Attributes,
			Metadata: InstanceMetadata{
				ExpansionType:   ExpansionNone,
				OriginalAddress: asset.Address,
				IsKnown:         true,
			},
		},
	}, nil
}

// expandCount handles count-based expansion
func (e *Expander) expandCount(asset *types.Asset, countVal interface{}, ctx *expression.Context) ([]*AssetInstance, error) {
	count, isKnown := e.resolveCount(countVal, ctx)

	if count == 0 {
		// count = 0 means no instances
		return []*AssetInstance{}, nil
	}

	instances := make([]*AssetInstance, count)
	for i := 0; i < count; i++ {
		key := InstanceKey{Type: KeyTypeInt, NumValue: i}
		addr := types.ResourceAddress(fmt.Sprintf("%s[%d]", asset.Address, i))

		// Create evaluation context for this instance
		instanceCtx := ctx.Clone()
		instanceCtx.SetCountIndex(i)

		instances[i] = &AssetInstance{
			Base:       asset,
			Key:        key,
			Address:    addr,
			Attributes: asset.Attributes,
			Metadata: InstanceMetadata{
				ExpansionType:   ExpansionCount,
				OriginalAddress: asset.Address,
				IsKnown:         isKnown,
			},
		}

		if !isKnown {
			instances[i].Metadata.Warning = "count could not be determined; assuming 1"
		}
	}

	return instances, nil
}

// resolveCount attempts to resolve a count value to an integer
func (e *Expander) resolveCount(countVal interface{}, ctx *expression.Context) (int, bool) {
	// If it's already an int, use it
	if n, ok := countVal.(int); ok {
		return n, true
	}

	// If it's a float, convert
	if f, ok := countVal.(float64); ok {
		return int(f), true
	}

	// If it's an expression.Value, extract
	if v, ok := countVal.(expression.Value); ok {
		if v.IsUnknown() {
			return e.DefaultCountOnUnknown, false
		}
		if n, err := v.AsInt(); err == nil {
			return int(n), true
		}
	}

	// If it's a string reference, try to resolve
	if s, ok := countVal.(string); ok {
		ref, err := expression.ParseReference(s)
		if err == nil && ctx != nil {
			resolved, err := ctx.Resolve(ref)
			if err == nil && !resolved.IsUnknown() {
				if n, err := resolved.AsInt(); err == nil {
					return int(n), true
				}
			}
		}
	}

	// Cannot determine count
	return e.DefaultCountOnUnknown, false
}

// expandForEach handles for_each-based expansion
func (e *Expander) expandForEach(asset *types.Asset, forEachVal interface{}, ctx *expression.Context) ([]*AssetInstance, error) {
	keys, values, isKnown := e.resolveForEach(forEachVal, ctx)

	if len(keys) == 0 {
		return []*AssetInstance{}, nil
	}

	instances := make([]*AssetInstance, len(keys))
	for i, key := range keys {
		instanceKey := InstanceKey{Type: KeyTypeString, StrValue: key}
		addr := types.ResourceAddress(fmt.Sprintf("%s[%q]", asset.Address, key))

		// Create evaluation context for this instance
		instanceCtx := ctx.Clone()
		instanceCtx.SetEach(key, values[key])

		instances[i] = &AssetInstance{
			Base:       asset,
			Key:        instanceKey,
			Address:    addr,
			EachValue:  values[key],
			Attributes: asset.Attributes,
			Metadata: InstanceMetadata{
				ExpansionType:   ExpansionForEach,
				OriginalAddress: asset.Address,
				IsKnown:         isKnown,
			},
		}

		if !isKnown {
			instances[i].Metadata.Warning = "for_each could not be determined"
		}
	}

	return instances, nil
}

// resolveForEach attempts to resolve a for_each value to keys and values
func (e *Expander) resolveForEach(forEachVal interface{}, ctx *expression.Context) ([]string, map[string]expression.Value, bool) {
	values := make(map[string]expression.Value)

	// If it's already a map
	if m, ok := forEachVal.(map[string]interface{}); ok {
		keys := make([]string, 0, len(m))
		for k, v := range m {
			keys = append(keys, k)
			values[k] = expression.FromGo(v)
		}
		sort.Strings(keys)
		return keys, values, true
	}

	// If it's a set/list of strings
	if list, ok := forEachVal.([]interface{}); ok {
		keys := make([]string, 0, len(list))
		for _, item := range list {
			if s, ok := item.(string); ok {
				keys = append(keys, s)
				values[s] = expression.String(s)
			}
		}
		sort.Strings(keys)
		return keys, values, true
	}

	// If it's an expression.Value
	if v, ok := forEachVal.(expression.Value); ok {
		if v.IsUnknown() {
			return nil, nil, false
		}

		// Try as map
		if m, err := v.AsMap(); err == nil {
			keys := make([]string, 0, len(m))
			for k := range m {
				keys = append(keys, k)
				values[k] = m[k]
			}
			sort.Strings(keys)
			return keys, values, true
		}

		// Try as list
		if list, err := v.AsList(); err == nil {
			keys := make([]string, 0, len(list))
			for _, item := range list {
				if s, err := item.AsString(); err == nil {
					keys = append(keys, s)
					values[s] = expression.String(s)
				}
			}
			sort.Strings(keys)
			return keys, values, true
		}
	}

	// Cannot determine for_each
	return nil, nil, false
}

// ExpandAll expands all assets in a graph
func (e *Expander) ExpandAll(assets []*types.Asset, ctx *expression.Context) ([]*AssetInstance, error) {
	var allInstances []*AssetInstance

	for _, asset := range assets {
		instances, err := e.Expand(asset, ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to expand %s: %w", asset.Address, err)
		}
		allInstances = append(allInstances, instances...)
	}

	return allInstances, nil
}

// ExpandedGraph represents an asset graph with all instances expanded
type ExpandedGraph struct {
	// Instances is the list of all expanded instances
	Instances []*AssetInstance

	// ByAddress indexes instances by their full address
	ByAddress map[types.ResourceAddress]*AssetInstance

	// ByBaseAddress groups instances by their base address (before expansion)
	ByBaseAddress map[types.ResourceAddress][]*AssetInstance

	// Warnings collects expansion warnings
	Warnings []string
}

// NewExpandedGraph creates an expanded graph from instances
func NewExpandedGraph(instances []*AssetInstance) *ExpandedGraph {
	g := &ExpandedGraph{
		Instances:     instances,
		ByAddress:     make(map[types.ResourceAddress]*AssetInstance),
		ByBaseAddress: make(map[types.ResourceAddress][]*AssetInstance),
	}

	for _, inst := range instances {
		g.ByAddress[inst.Address] = inst
		g.ByBaseAddress[inst.Metadata.OriginalAddress] = append(
			g.ByBaseAddress[inst.Metadata.OriginalAddress], inst,
		)

		if inst.Metadata.Warning != "" {
			g.Warnings = append(g.Warnings, fmt.Sprintf("%s: %s", inst.Address, inst.Metadata.Warning))
		}
	}

	return g
}

################################################################################
# FILE: :\good projects\cost estimation\core\expansion\expander_test.go
# TYPE: go
# SIZE: 8167 bytes
################################################################################
package expansion

import (
	"testing"

	"terraform-cost/core/expression"
	"terraform-cost/core/types"
)

// TestCountExpansion tests count-based expansion behavior
func TestCountExpansion(t *testing.T) {
	expander := NewExpander()
	ctx := expression.NewContext()

	tests := []struct {
		name          string
		countValue    interface{}
		expectedCount int
		isKnown       bool
	}{
		{
			name:          "count=0 produces nothing",
			countValue:    0,
			expectedCount: 0,
			isKnown:       true,
		},
		{
			name:          "count=1 produces one instance",
			countValue:    1,
			expectedCount: 1,
			isKnown:       true,
		},
		{
			name:          "count=3 produces three instances",
			countValue:    3,
			expectedCount: 3,
			isKnown:       true,
		},
		{
			name:          "count=5 produces five instances",
			countValue:    5,
			expectedCount: 5,
			isKnown:       true,
		},
		{
			name:          "unknown count produces default with warning",
			countValue:    expression.Unknown(),
			expectedCount: 1,
			isKnown:       false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			asset := &types.Asset{
				Address: "aws_instance.test",
				Type:    "aws_instance",
				Name:    "test",
				Attributes: types.Attributes{
					"count": {Value: tt.countValue},
				},
			}

			instances, err := expander.Expand(asset, ctx)
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			if len(instances) != tt.expectedCount {
				t.Errorf("expected %d instances, got %d", tt.expectedCount, len(instances))
			}

			// Verify instance addresses
			for i, inst := range instances {
				expectedKey := i
				if inst.Key.NumValue != expectedKey {
					t.Errorf("instance %d: expected key %d, got %d", i, expectedKey, inst.Key.NumValue)
				}

				if inst.Metadata.IsKnown != tt.isKnown {
					t.Errorf("instance %d: expected isKnown=%v, got %v", i, tt.isKnown, inst.Metadata.IsKnown)
				}

				if !tt.isKnown && inst.Metadata.Warning == "" {
					t.Errorf("instance %d: expected warning for unknown count", i)
				}
			}
		})
	}
}

// TestForEachExpansion tests for_each-based expansion behavior
func TestForEachExpansion(t *testing.T) {
	expander := NewExpander()
	ctx := expression.NewContext()

	tests := []struct {
		name         string
		forEachValue interface{}
		expectedKeys []string
		isKnown      bool
	}{
		{
			name:         "empty map produces nothing",
			forEachValue: map[string]interface{}{},
			expectedKeys: []string{},
			isKnown:      true,
		},
		{
			name: "map with one key",
			forEachValue: map[string]interface{}{
				"web": "value1",
			},
			expectedKeys: []string{"web"},
			isKnown:      true,
		},
		{
			name: "map with multiple keys",
			forEachValue: map[string]interface{}{
				"a": 1,
				"b": 2,
				"c": 3,
			},
			expectedKeys: []string{"a", "b", "c"}, // sorted
			isKnown:      true,
		},
		{
			name:         "set as list of strings",
			forEachValue: []interface{}{"alpha", "beta", "gamma"},
			expectedKeys: []string{"alpha", "beta", "gamma"},
			isKnown:      true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			asset := &types.Asset{
				Address: "aws_instance.multi",
				Type:    "aws_instance",
				Name:    "multi",
				Attributes: types.Attributes{
					"for_each": {Value: tt.forEachValue},
				},
			}

			instances, err := expander.Expand(asset, ctx)
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			if len(instances) != len(tt.expectedKeys) {
				t.Errorf("expected %d instances, got %d", len(tt.expectedKeys), len(instances))
			}

			// Verify instance keys (they should be sorted)
			for i, inst := range instances {
				if i >= len(tt.expectedKeys) {
					break
				}
				expectedKey := tt.expectedKeys[i]
				if inst.Key.StrValue != expectedKey {
					t.Errorf("instance %d: expected key %q, got %q", i, expectedKey, inst.Key.StrValue)
				}

				if inst.Key.Type != KeyTypeString {
					t.Errorf("instance %d: expected string key type, got %v", i, inst.Key.Type)
				}
			}
		})
	}
}

// TestNoExpansion tests that assets without count/for_each produce single instance
func TestNoExpansion(t *testing.T) {
	expander := NewExpander()
	ctx := expression.NewContext()

	asset := &types.Asset{
		Address: "aws_instance.single",
		Type:    "aws_instance",
		Name:    "single",
		Attributes: types.Attributes{
			"instance_type": {Value: "t3.micro"},
		},
	}

	instances, err := expander.Expand(asset, ctx)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if len(instances) != 1 {
		t.Errorf("expected 1 instance, got %d", len(instances))
	}

	if instances[0].Key.Type != KeyTypeNone {
		t.Errorf("expected no key type, got %v", instances[0].Key.Type)
	}

	if instances[0].Address != asset.Address {
		t.Errorf("expected address %s, got %s", asset.Address, instances[0].Address)
	}

	if instances[0].Metadata.ExpansionType != ExpansionNone {
		t.Errorf("expected ExpansionNone, got %v", instances[0].Metadata.ExpansionType)
	}
}

// TestInstanceAddresses tests that addresses are correctly formatted
func TestInstanceAddresses(t *testing.T) {
	expander := NewExpander()
	ctx := expression.NewContext()

	// Test count addresses
	countAsset := &types.Asset{
		Address:    "aws_instance.counted",
		Type:       "aws_instance",
		Name:       "counted",
		Attributes: types.Attributes{"count": {Value: 2}},
	}

	countInstances, _ := expander.Expand(countAsset, ctx)
	expectedAddrs := []types.ResourceAddress{
		"aws_instance.counted[0]",
		"aws_instance.counted[1]",
	}

	for i, inst := range countInstances {
		if inst.Address != expectedAddrs[i] {
			t.Errorf("count instance %d: expected address %s, got %s", i, expectedAddrs[i], inst.Address)
		}
	}

	// Test for_each addresses
	forEachAsset := &types.Asset{
		Address: "aws_instance.named",
		Type:    "aws_instance",
		Name:    "named",
		Attributes: types.Attributes{
			"for_each": {Value: map[string]interface{}{"web": 1, "api": 2}},
		},
	}

	forEachInstances, _ := expander.Expand(forEachAsset, ctx)

	// Check that addresses are quoted correctly
	for _, inst := range forEachInstances {
		addrStr := string(inst.Address)
		if inst.Key.StrValue == "api" {
			if addrStr != `aws_instance.named["api"]` {
				t.Errorf("expected address aws_instance.named[\"api\"], got %s", addrStr)
			}
		}
		if inst.Key.StrValue == "web" {
			if addrStr != `aws_instance.named["web"]` {
				t.Errorf("expected address aws_instance.named[\"web\"], got %s", addrStr)
			}
		}
	}
}

// TestExpandedGraph tests the expanded graph construction
func TestExpandedGraph(t *testing.T) {
	instances := []*AssetInstance{
		{
			Address: "aws_instance.test[0]",
			Key:     InstanceKey{Type: KeyTypeInt, NumValue: 0},
			Metadata: InstanceMetadata{
				OriginalAddress: "aws_instance.test",
				ExpansionType:   ExpansionCount,
			},
		},
		{
			Address: "aws_instance.test[1]",
			Key:     InstanceKey{Type: KeyTypeInt, NumValue: 1},
			Metadata: InstanceMetadata{
				OriginalAddress: "aws_instance.test",
				ExpansionType:   ExpansionCount,
			},
		},
		{
			Address: "aws_s3_bucket.single",
			Key:     InstanceKey{Type: KeyTypeNone},
			Metadata: InstanceMetadata{
				OriginalAddress: "aws_s3_bucket.single",
				ExpansionType:   ExpansionNone,
			},
		},
	}

	graph := NewExpandedGraph(instances)

	if len(graph.Instances) != 3 {
		t.Errorf("expected 3 instances, got %d", len(graph.Instances))
	}

	// Test ByAddress lookup
	inst, ok := graph.ByAddress["aws_instance.test[0]"]
	if !ok {
		t.Error("ByAddress lookup failed for aws_instance.test[0]")
	}
	if inst.Key.NumValue != 0 {
		t.Errorf("expected key value 0, got %d", inst.Key.NumValue)
	}

	// Test ByBaseAddress grouping
	baseInstances := graph.ByBaseAddress["aws_instance.test"]
	if len(baseInstances) != 2 {
		t.Errorf("expected 2 instances for base address, got %d", len(baseInstances))
	}
}

################################################################################
# FILE: :\good projects\cost estimation\core\expression\context.go
# TYPE: go
# SIZE: 9151 bytes
################################################################################
// Package expression - Evaluation context
package expression

import (
	"fmt"
	"sync"
)

// Context provides values for expression evaluation
type Context struct {
	mu sync.RWMutex

	// Variables from tfvars, defaults, CLI
	variables map[string]Value

	// Locals computed from local blocks
	locals map[string]Value

	// Resources indexed by address
	resources map[string]Value

	// Data sources indexed by address
	dataSources map[string]Value

	// Modules indexed by key
	modules map[string]*Context

	// Parent context for nested modules
	parent *Context

	// Module path for this context
	modulePath string

	// Workspace name
	workspace string

	// Path values
	pathModule string
	pathRoot   string
	pathCwd    string

	// Count/for_each context (when evaluating inside a resource)
	countIndex *int
	eachKey    *string
	eachValue  Value

	// Self reference (when evaluating provisioners)
	self Value
}

// NewContext creates a new evaluation context
func NewContext() *Context {
	return &Context{
		variables:   make(map[string]Value),
		locals:      make(map[string]Value),
		resources:   make(map[string]Value),
		dataSources: make(map[string]Value),
		modules:     make(map[string]*Context),
		workspace:   "default",
	}
}

// NewChildContext creates a child context for a module
func (c *Context) NewChildContext(modulePath string) *Context {
	child := NewContext()
	child.parent = c
	child.modulePath = modulePath
	child.workspace = c.workspace
	child.pathRoot = c.pathRoot
	child.pathCwd = c.pathCwd
	return child
}

// SetVariable sets a variable value
func (c *Context) SetVariable(name string, value Value) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.variables[name] = value
}

// SetVariables sets multiple variables
func (c *Context) SetVariables(vars map[string]Value) {
	c.mu.Lock()
	defer c.mu.Unlock()
	for k, v := range vars {
		c.variables[k] = v
	}
}

// SetLocal sets a local value
func (c *Context) SetLocal(name string, value Value) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.locals[name] = value
}

// SetResource sets a resource's computed values
func (c *Context) SetResource(address string, value Value) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.resources[address] = value
}

// SetDataSource sets a data source's values
func (c *Context) SetDataSource(address string, value Value) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.dataSources[address] = value
}

// SetModule adds a child module context
func (c *Context) SetModule(key string, child *Context) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.modules[key] = child
}

// SetWorkspace sets the workspace name
func (c *Context) SetWorkspace(name string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.workspace = name
}

// SetPaths sets the path.module, path.root, path.cwd values
func (c *Context) SetPaths(module, root, cwd string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.pathModule = module
	c.pathRoot = root
	c.pathCwd = cwd
}

// SetCountIndex sets the count.index value for resource evaluation
func (c *Context) SetCountIndex(index int) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.countIndex = &index
}

// SetEach sets the each.key and each.value for for_each evaluation
func (c *Context) SetEach(key string, value Value) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.eachKey = &key
	c.eachValue = value
}

// SetSelf sets the self reference value
func (c *Context) SetSelf(value Value) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.self = value
}

// ClearIterators clears count/for_each context
func (c *Context) ClearIterators() {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.countIndex = nil
	c.eachKey = nil
	c.eachValue = Null()
}

// Resolve resolves a reference to a value
func (c *Context) Resolve(ref *Reference) (Value, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	switch ref.Kind {
	case RefVariable:
		return c.resolveVariable(ref)
	case RefLocal:
		return c.resolveLocal(ref)
	case RefResource:
		return c.resolveResource(ref)
	case RefData:
		return c.resolveDataSource(ref)
	case RefModule:
		return c.resolveModule(ref)
	case RefSelf:
		return c.resolveSelf(ref)
	case RefCount:
		return c.resolveCount(ref)
	case RefEach:
		return c.resolveEach(ref)
	case RefPath:
		return c.resolvePath(ref)
	case RefTerraform:
		return c.resolveTerraform(ref)
	default:
		return Unknown(), fmt.Errorf("unknown reference kind: %v", ref.Kind)
	}
}

func (c *Context) resolveVariable(ref *Reference) (Value, error) {
	val, ok := c.variables[ref.Key]
	if !ok {
		return Unknown(), fmt.Errorf("undefined variable: %s", ref.Key)
	}
	return c.traverseValue(val, ref)
}

func (c *Context) resolveLocal(ref *Reference) (Value, error) {
	val, ok := c.locals[ref.Key]
	if !ok {
		return Unknown(), fmt.Errorf("undefined local: %s", ref.Key)
	}
	return c.traverseValue(val, ref)
}

func (c *Context) resolveResource(ref *Reference) (Value, error) {
	// Build address with optional index
	addr := ref.Subject
	if ref.Index != nil {
		addr = ref.ResourceAddress()
	}

	val, ok := c.resources[addr]
	if !ok {
		// Resource not yet computed - return unknown
		return Unknown(), nil
	}
	return c.traverseValue(val, ref)
}

func (c *Context) resolveDataSource(ref *Reference) (Value, error) {
	addr := ref.ResourceAddress()
	val, ok := c.dataSources[addr]
	if !ok {
		// Data source not yet computed - return unknown
		return Unknown(), nil
	}
	return c.traverseValue(val, ref)
}

func (c *Context) resolveModule(ref *Reference) (Value, error) {
	child, ok := c.modules[ref.Key]
	if !ok {
		return Unknown(), fmt.Errorf("undefined module: %s", ref.Key)
	}

	// Module references access outputs
	if ref.Attribute != "" {
		// Look for output in child context
		// Outputs would be stored in a special location
		outputVal, ok := child.locals["__output_"+ref.Attribute]
		if !ok {
			return Unknown(), nil
		}
		return outputVal, nil
	}

	// Return the whole module context as an object
	return Unknown(), nil
}

func (c *Context) resolveSelf(ref *Reference) (Value, error) {
	if c.self.IsNull() {
		return Unknown(), fmt.Errorf("self is not available in this context")
	}
	return c.traverseValue(c.self, ref)
}

func (c *Context) resolveCount(ref *Reference) (Value, error) {
	if ref.Attribute != "index" {
		return Unknown(), fmt.Errorf("count only has 'index' attribute")
	}
	if c.countIndex == nil {
		return Unknown(), fmt.Errorf("count.index not available in this context")
	}
	return NumberFromInt(int64(*c.countIndex)), nil
}

func (c *Context) resolveEach(ref *Reference) (Value, error) {
	switch ref.Attribute {
	case "key":
		if c.eachKey == nil {
			return Unknown(), fmt.Errorf("each.key not available in this context")
		}
		return String(*c.eachKey), nil
	case "value":
		if c.eachKey == nil {
			return Unknown(), fmt.Errorf("each.value not available in this context")
		}
		return c.eachValue, nil
	default:
		return Unknown(), fmt.Errorf("each only has 'key' and 'value' attributes")
	}
}

func (c *Context) resolvePath(ref *Reference) (Value, error) {
	switch ref.Attribute {
	case "module":
		return String(c.pathModule), nil
	case "root":
		return String(c.pathRoot), nil
	case "cwd":
		return String(c.pathCwd), nil
	default:
		return Unknown(), fmt.Errorf("path.%s is not a valid path reference", ref.Attribute)
	}
}

func (c *Context) resolveTerraform(ref *Reference) (Value, error) {
	switch ref.Attribute {
	case "workspace":
		return String(c.workspace), nil
	default:
		return Unknown(), fmt.Errorf("terraform.%s is not a valid terraform reference", ref.Attribute)
	}
}

// traverseValue follows attribute access path through a value
func (c *Context) traverseValue(val Value, ref *Reference) (Value, error) {
	// If we have an attribute to access, traverse
	if ref.Attribute != "" {
		attr, err := val.GetAttr(ref.Attribute)
		if err != nil {
			return Unknown(), nil // Unknown attributes
		}
		val = attr
	}

	// Traverse remaining path
	for _, seg := range ref.Remaining {
		attr, err := val.GetAttr(seg)
		if err != nil {
			return Unknown(), nil
		}
		val = attr
	}

	return val, nil
}

// Clone creates a copy of the context
func (c *Context) Clone() *Context {
	c.mu.RLock()
	defer c.mu.RUnlock()

	clone := NewContext()
	clone.parent = c.parent
	clone.modulePath = c.modulePath
	clone.workspace = c.workspace
	clone.pathModule = c.pathModule
	clone.pathRoot = c.pathRoot
	clone.pathCwd = c.pathCwd

	for k, v := range c.variables {
		clone.variables[k] = v
	}
	for k, v := range c.locals {
		clone.locals[k] = v
	}
	for k, v := range c.resources {
		clone.resources[k] = v
	}
	for k, v := range c.dataSources {
		clone.dataSources[k] = v
	}
	for k, v := range c.modules {
		clone.modules[k] = v
	}

	if c.countIndex != nil {
		idx := *c.countIndex
		clone.countIndex = &idx
	}
	if c.eachKey != nil {
		key := *c.eachKey
		clone.eachKey = &key
		clone.eachValue = c.eachValue
	}
	clone.self = c.self

	return clone
}

################################################################################
# FILE: :\good projects\cost estimation\core\expression\reference.go
# TYPE: go
# SIZE: 7976 bytes
################################################################################
// Package expression - Reference parsing and resolution
package expression

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
)

// ReferenceKind identifies the type of reference
type ReferenceKind int

const (
	RefUnknown ReferenceKind = iota
	RefVariable      // var.name
	RefLocal         // local.name
	RefResource      // resource_type.name or resource_type.name[index]
	RefData          // data.type.name
	RefModule        // module.name
	RefOutput        // output.name (within modules)
	RefSelf          // self.attr
	RefCount         // count.index
	RefEach          // each.key or each.value
	RefPath          // path.module, path.root, path.cwd
	RefTerraform     // terraform.workspace
)

// Reference represents a reference to another value in HCL
type Reference struct {
	Kind       ReferenceKind
	Subject    string   // The full subject (e.g., "aws_instance.web")
	Key        string   // Primary key (e.g., "web" for aws_instance.web)
	Type       string   // Resource type (e.g., "aws_instance")
	Attribute  string   // Attribute being accessed (e.g., "id")
	Index      *Index   // Optional index for count/for_each
	Remaining  []string // Remaining path segments
	RawString  string   // Original reference string
}

// Index represents a count or for_each index
type Index struct {
	IsNumeric bool
	NumValue  int
	StrValue  string
	IsUnknown bool
}

// NewNumericIndex creates a numeric index
func NewNumericIndex(n int) *Index {
	return &Index{IsNumeric: true, NumValue: n}
}

// NewStringIndex creates a string index
func NewStringIndex(s string) *Index {
	return &Index{IsNumeric: false, StrValue: s}
}

// UnknownIndex creates an unknown index
func UnknownIndex() *Index {
	return &Index{IsUnknown: true}
}

// String returns the index as a string
func (idx *Index) String() string {
	if idx == nil {
		return ""
	}
	if idx.IsUnknown {
		return "[?]"
	}
	if idx.IsNumeric {
		return fmt.Sprintf("[%d]", idx.NumValue)
	}
	return fmt.Sprintf("[%q]", idx.StrValue)
}

// ParseReference parses a reference string into structured form
func ParseReference(ref string) (*Reference, error) {
	ref = strings.TrimSpace(ref)
	if ref == "" {
		return nil, fmt.Errorf("empty reference")
	}

	result := &Reference{RawString: ref}

	// Split by dots, but handle indices specially
	parts := splitReference(ref)
	if len(parts) == 0 {
		return nil, fmt.Errorf("invalid reference: %s", ref)
	}

	// Determine reference kind from first part
	switch parts[0] {
	case "var":
		result.Kind = RefVariable
		if len(parts) < 2 {
			return nil, fmt.Errorf("variable reference requires name: %s", ref)
		}
		result.Key = parts[1]
		result.Subject = "var." + result.Key
		if len(parts) > 2 {
			result.Remaining = parts[2:]
		}

	case "local":
		result.Kind = RefLocal
		if len(parts) < 2 {
			return nil, fmt.Errorf("local reference requires name: %s", ref)
		}
		result.Key = parts[1]
		result.Subject = "local." + result.Key
		if len(parts) > 2 {
			result.Remaining = parts[2:]
		}

	case "data":
		result.Kind = RefData
		if len(parts) < 3 {
			return nil, fmt.Errorf("data reference requires type and name: %s", ref)
		}
		result.Type = parts[1]
		result.Key, result.Index = parseKeyAndIndex(parts[2])
		result.Subject = fmt.Sprintf("data.%s.%s", result.Type, result.Key)
		if len(parts) > 3 {
			result.Remaining = parts[3:]
		}

	case "module":
		result.Kind = RefModule
		if len(parts) < 2 {
			return nil, fmt.Errorf("module reference requires name: %s", ref)
		}
		result.Key, result.Index = parseKeyAndIndex(parts[1])
		result.Subject = "module." + result.Key
		if len(parts) > 2 {
			result.Remaining = parts[2:]
		}

	case "self":
		result.Kind = RefSelf
		result.Subject = "self"
		if len(parts) > 1 {
			result.Attribute = parts[1]
			result.Remaining = parts[2:]
		}

	case "count":
		result.Kind = RefCount
		result.Subject = "count"
		if len(parts) > 1 && parts[1] == "index" {
			result.Attribute = "index"
		}

	case "each":
		result.Kind = RefEach
		result.Subject = "each"
		if len(parts) > 1 {
			result.Attribute = parts[1] // key or value
		}

	case "path":
		result.Kind = RefPath
		result.Subject = "path"
		if len(parts) > 1 {
			result.Attribute = parts[1] // module, root, cwd
		}

	case "terraform":
		result.Kind = RefTerraform
		result.Subject = "terraform"
		if len(parts) > 1 {
			result.Attribute = parts[1] // workspace
		}

	default:
		// Assume it's a resource reference: type.name
		result.Kind = RefResource
		result.Type = parts[0]
		if len(parts) < 2 {
			return nil, fmt.Errorf("resource reference requires name: %s", ref)
		}
		result.Key, result.Index = parseKeyAndIndex(parts[1])
		result.Subject = fmt.Sprintf("%s.%s", result.Type, result.Key)
		if len(parts) > 2 {
			result.Remaining = parts[2:]
		}
	}

	// Extract attribute from remaining if present
	if len(result.Remaining) > 0 {
		result.Attribute = result.Remaining[0]
		result.Remaining = result.Remaining[1:]
	}

	return result, nil
}

// splitReference splits a reference by dots, handling index brackets
func splitReference(ref string) []string {
	var parts []string
	var current strings.Builder
	inBracket := 0

	for _, ch := range ref {
		switch ch {
		case '[':
			inBracket++
			current.WriteRune(ch)
		case ']':
			inBracket--
			current.WriteRune(ch)
		case '.':
			if inBracket > 0 {
				current.WriteRune(ch)
			} else {
				if current.Len() > 0 {
					parts = append(parts, current.String())
					current.Reset()
				}
			}
		default:
			current.WriteRune(ch)
		}
	}

	if current.Len() > 0 {
		parts = append(parts, current.String())
	}

	return parts
}

// indexPattern matches [0], [1], ["key"], etc.
var indexPattern = regexp.MustCompile(`^([^[]+)\[(.+)\]$`)

// parseKeyAndIndex extracts key and optional index from "name[index]"
func parseKeyAndIndex(s string) (string, *Index) {
	matches := indexPattern.FindStringSubmatch(s)
	if matches == nil {
		return s, nil
	}

	key := matches[1]
	indexStr := matches[2]

	// Try numeric index
	if n, err := strconv.Atoi(indexStr); err == nil {
		return key, NewNumericIndex(n)
	}

	// Try string index (quoted)
	if strings.HasPrefix(indexStr, "\"") && strings.HasSuffix(indexStr, "\"") {
		return key, NewStringIndex(indexStr[1 : len(indexStr)-1])
	}

	// Unknown/computed index
	return key, UnknownIndex()
}

// Address returns the full address including index
func (r *Reference) Address() string {
	addr := r.Subject
	if r.Index != nil {
		addr += r.Index.String()
	}
	if r.Attribute != "" {
		addr += "." + r.Attribute
	}
	for _, rem := range r.Remaining {
		addr += "." + rem
	}
	return addr
}

// ResourceAddress returns just the resource address without attribute
func (r *Reference) ResourceAddress() string {
	addr := r.Subject
	if r.Index != nil {
		addr += r.Index.String()
	}
	return addr
}

// String returns the reference as a string
func (r *Reference) String() string {
	return r.Address()
}

// ExtractReferences finds all references in a string (simple heuristic)
func ExtractReferences(s string) []*Reference {
	// Pattern for common reference formats
	patterns := []string{
		`var\.[a-zA-Z_][a-zA-Z0-9_]*`,
		`local\.[a-zA-Z_][a-zA-Z0-9_]*`,
		`data\.[a-zA-Z_][a-zA-Z0-9_]*\.[a-zA-Z_][a-zA-Z0-9_]*`,
		`module\.[a-zA-Z_][a-zA-Z0-9_]*`,
		`[a-zA-Z_][a-zA-Z0-9_]*\.[a-zA-Z_][a-zA-Z0-9_]*(\[[^\]]+\])?(\.[a-zA-Z_][a-zA-Z0-9_]*)*`,
	}

	var refs []*Reference
	seen := make(map[string]bool)

	for _, pat := range patterns {
		re := regexp.MustCompile(pat)
		matches := re.FindAllString(s, -1)
		for _, m := range matches {
			if seen[m] {
				continue
			}
			seen[m] = true

			ref, err := ParseReference(m)
			if err == nil {
				refs = append(refs, ref)
			}
		}
	}

	return refs
}

################################################################################
# FILE: :\good projects\cost estimation\core\expression\value.go
# TYPE: go
# SIZE: 9189 bytes
################################################################################
// Package expression provides HCL expression evaluation.
// This is a clean-room implementation based on Terraform semantics.
package expression

import (
	"fmt"
	"math/big"
	"reflect"
	"strings"
)

// ValueKind represents the type of a value
type ValueKind int

const (
	KindNull ValueKind = iota
	KindBool
	KindNumber
	KindString
	KindList
	KindMap
	KindObject
	KindUnknown   // Value exists but is not yet known
	KindSensitive // Value is marked sensitive
)

// Value represents a Terraform/HCL value with type information
type Value struct {
	kind      ValueKind
	boolVal   bool
	numberVal *big.Float
	stringVal string
	listVal   []Value
	mapVal    map[string]Value
	marks     []ValueMark
}

// ValueMark represents metadata about a value
type ValueMark int

const (
	MarkNone ValueMark = iota
	MarkSensitive
	MarkUnknown
	MarkDynamic
)

// Null creates a null value
func Null() Value {
	return Value{kind: KindNull}
}

// Bool creates a boolean value
func Bool(v bool) Value {
	return Value{kind: KindBool, boolVal: v}
}

// Number creates a numeric value
func Number(v float64) Value {
	return Value{kind: KindNumber, numberVal: big.NewFloat(v)}
}

// NumberFromInt creates a numeric value from an integer
func NumberFromInt(v int64) Value {
	return Value{kind: KindNumber, numberVal: big.NewFloat(float64(v))}
}

// String creates a string value
func String(v string) Value {
	return Value{kind: KindString, stringVal: v}
}

// List creates a list value
func List(elements ...Value) Value {
	return Value{kind: KindList, listVal: elements}
}

// Map creates a map value
func Map(elements map[string]Value) Value {
	return Value{kind: KindMap, mapVal: elements}
}

// Unknown creates an unknown value (computed at runtime)
func Unknown() Value {
	return Value{kind: KindUnknown}
}

// UnknownWithType creates an unknown value with a type hint
func UnknownWithType(kind ValueKind) Value {
	v := Value{kind: kind, marks: []ValueMark{MarkUnknown}}
	return v
}

// FromGo converts a Go value to a Value
func FromGo(v interface{}) Value {
	if v == nil {
		return Null()
	}

	switch val := v.(type) {
	case bool:
		return Bool(val)
	case int:
		return NumberFromInt(int64(val))
	case int64:
		return NumberFromInt(val)
	case float64:
		return Number(val)
	case string:
		return String(val)
	case []interface{}:
		elements := make([]Value, len(val))
		for i, e := range val {
			elements[i] = FromGo(e)
		}
		return List(elements...)
	case map[string]interface{}:
		elements := make(map[string]Value)
		for k, e := range val {
			elements[k] = FromGo(e)
		}
		return Map(elements)
	default:
		// Try reflection for other types
		rv := reflect.ValueOf(v)
		switch rv.Kind() {
		case reflect.Slice, reflect.Array:
			elements := make([]Value, rv.Len())
			for i := 0; i < rv.Len(); i++ {
				elements[i] = FromGo(rv.Index(i).Interface())
			}
			return List(elements...)
		case reflect.Map:
			elements := make(map[string]Value)
			iter := rv.MapRange()
			for iter.Next() {
				k := fmt.Sprintf("%v", iter.Key().Interface())
				elements[k] = FromGo(iter.Value().Interface())
			}
			return Map(elements)
		}
		// Fallback to string representation
		return String(fmt.Sprintf("%v", v))
	}
}

// Kind returns the value kind
func (v Value) Kind() ValueKind {
	return v.kind
}

// IsNull returns true if value is null
func (v Value) IsNull() bool {
	return v.kind == KindNull
}

// IsUnknown returns true if value is unknown
func (v Value) IsUnknown() bool {
	if v.kind == KindUnknown {
		return true
	}
	for _, m := range v.marks {
		if m == MarkUnknown {
			return true
		}
	}
	return false
}

// IsSensitive returns true if value is sensitive
func (v Value) IsSensitive() bool {
	for _, m := range v.marks {
		if m == MarkSensitive {
			return true
		}
	}
	return false
}

// IsKnown returns true if value is not unknown and not null
func (v Value) IsKnown() bool {
	return !v.IsUnknown() && !v.IsNull()
}

// AsBool returns the boolean value
func (v Value) AsBool() (bool, error) {
	if v.kind != KindBool {
		return false, fmt.Errorf("value is %v, not bool", v.kind)
	}
	return v.boolVal, nil
}

// AsNumber returns the numeric value as float64
func (v Value) AsNumber() (float64, error) {
	if v.kind != KindNumber {
		return 0, fmt.Errorf("value is %v, not number", v.kind)
	}
	f, _ := v.numberVal.Float64()
	return f, nil
}

// AsInt returns the numeric value as int64
func (v Value) AsInt() (int64, error) {
	if v.kind != KindNumber {
		return 0, fmt.Errorf("value is %v, not number", v.kind)
	}
	f, _ := v.numberVal.Float64()
	return int64(f), nil
}

// AsString returns the string value
func (v Value) AsString() (string, error) {
	if v.kind != KindString {
		return "", fmt.Errorf("value is %v, not string", v.kind)
	}
	return v.stringVal, nil
}

// AsList returns the list elements
func (v Value) AsList() ([]Value, error) {
	if v.kind != KindList {
		return nil, fmt.Errorf("value is %v, not list", v.kind)
	}
	return v.listVal, nil
}

// AsMap returns the map elements
func (v Value) AsMap() (map[string]Value, error) {
	if v.kind != KindMap && v.kind != KindObject {
		return nil, fmt.Errorf("value is %v, not map", v.kind)
	}
	return v.mapVal, nil
}

// Length returns the length for lists/maps/strings
func (v Value) Length() (int, error) {
	switch v.kind {
	case KindString:
		return len(v.stringVal), nil
	case KindList:
		return len(v.listVal), nil
	case KindMap, KindObject:
		return len(v.mapVal), nil
	default:
		return 0, fmt.Errorf("cannot get length of %v", v.kind)
	}
}

// Index gets an element by index (for lists)
func (v Value) Index(i int) (Value, error) {
	if v.kind != KindList {
		return Null(), fmt.Errorf("cannot index %v", v.kind)
	}
	if i < 0 || i >= len(v.listVal) {
		return Null(), fmt.Errorf("index %d out of range [0, %d)", i, len(v.listVal))
	}
	return v.listVal[i], nil
}

// GetAttr gets an attribute by name (for maps/objects)
func (v Value) GetAttr(name string) (Value, error) {
	if v.kind != KindMap && v.kind != KindObject {
		return Null(), fmt.Errorf("cannot get attribute of %v", v.kind)
	}
	val, ok := v.mapVal[name]
	if !ok {
		return Null(), nil // Missing attributes are null
	}
	return val, nil
}

// Equals compares values for equality
func (v Value) Equals(other Value) bool {
	if v.kind != other.kind {
		return false
	}

	switch v.kind {
	case KindNull:
		return true
	case KindBool:
		return v.boolVal == other.boolVal
	case KindNumber:
		return v.numberVal.Cmp(other.numberVal) == 0
	case KindString:
		return v.stringVal == other.stringVal
	case KindList:
		if len(v.listVal) != len(other.listVal) {
			return false
		}
		for i := range v.listVal {
			if !v.listVal[i].Equals(other.listVal[i]) {
				return false
			}
		}
		return true
	case KindMap, KindObject:
		if len(v.mapVal) != len(other.mapVal) {
			return false
		}
		for k, val := range v.mapVal {
			otherVal, ok := other.mapVal[k]
			if !ok || !val.Equals(otherVal) {
				return false
			}
		}
		return true
	case KindUnknown:
		return false // Unknowns are never equal
	default:
		return false
	}
}

// ToGo converts the value to a Go interface{}
func (v Value) ToGo() interface{} {
	switch v.kind {
	case KindNull:
		return nil
	case KindBool:
		return v.boolVal
	case KindNumber:
		f, _ := v.numberVal.Float64()
		return f
	case KindString:
		return v.stringVal
	case KindList:
		result := make([]interface{}, len(v.listVal))
		for i, e := range v.listVal {
			result[i] = e.ToGo()
		}
		return result
	case KindMap, KindObject:
		result := make(map[string]interface{})
		for k, e := range v.mapVal {
			result[k] = e.ToGo()
		}
		return result
	case KindUnknown:
		return nil // Unknown converts to nil
	default:
		return nil
	}
}

// String returns a string representation
func (v Value) String() string {
	switch v.kind {
	case KindNull:
		return "null"
	case KindBool:
		if v.boolVal {
			return "true"
		}
		return "false"
	case KindNumber:
		return v.numberVal.Text('f', -1)
	case KindString:
		return fmt.Sprintf("%q", v.stringVal)
	case KindList:
		parts := make([]string, len(v.listVal))
		for i, e := range v.listVal {
			parts[i] = e.String()
		}
		return "[" + strings.Join(parts, ", ") + "]"
	case KindMap, KindObject:
		parts := make([]string, 0, len(v.mapVal))
		for k, e := range v.mapVal {
			parts = append(parts, fmt.Sprintf("%q = %s", k, e.String()))
		}
		return "{" + strings.Join(parts, ", ") + "}"
	case KindUnknown:
		return "(unknown)"
	default:
		return "(invalid)"
	}
}

// MarkAsSensitive returns a copy of the value marked as sensitive
func (v Value) MarkAsSensitive() Value {
	newVal := v
	newVal.marks = append(newVal.marks, MarkSensitive)
	return newVal
}

// MarkAsUnknown returns a copy of the value marked as unknown
func (v Value) MarkAsUnknown() Value {
	newVal := v
	newVal.marks = append(newVal.marks, MarkUnknown)
	return newVal
}

################################################################################
# FILE: :\good projects\cost estimation\core\graph\bypass_prevention.go
# TYPE: go
# SIZE: 2292 bytes
################################################################################
// Package graph - Bypass prevention
// These functions exist SOLELY to prevent incorrect usage patterns.
// They panic immediately to ensure bypass attempts are caught in development.
package graph

// DEPRECATED CONSTRUCTORS - DO NOT USE
// These exist only to provide clear error messages if someone tries to bypass

// NewCostUnitFromAssetDirect is BLOCKED - use NewEnforcedCostUnit
func NewCostUnitFromAssetDirect(assetID string) {
	BlockBypassAttempt("NewCostUnitFromAssetDirect - cost units must be created via NewEnforcedCostUnit with dependency path")
}

// NewCostGraphWithoutDepGraph is BLOCKED - use NewEnforcedCostGraph
func NewCostGraphWithoutDepGraph() {
	BlockBypassAttempt("NewCostGraphWithoutDepGraph - cost graphs must derive from EnforcedAssetGraph with canonical dependency graph")
}

// ExpandWithoutCardinalityCheck is BLOCKED - use ExpansionGuard.MustExpand
func ExpandWithoutCardinalityCheck(address string, count int) {
	BlockBypassAttempt("ExpandWithoutCardinalityCheck - expansion must verify cardinality via ExpansionGuard")
}

// PriceWithoutProviderFreeze is BLOCKED - use PricingGate.MustGetProvider
func PriceWithoutProviderFreeze(resourceType string) {
	BlockBypassAttempt("PriceWithoutProviderFreeze - pricing must occur after provider finalization via PricingGate")
}

// AggregateConfidenceByAverage is BLOCKED - use confidence.AggregateConfidence
func AggregateConfidenceByAverage(values []float64) {
	BlockBypassAttempt("AggregateConfidenceByAverage - confidence must propagate pessimistically (MIN)")
}

// CreateNumericCostForUnknown is BLOCKED - use NewSymbolicCostUnit
func CreateNumericCostForUnknown(address string, cost float64) {
	BlockBypassAttempt("CreateNumericCostForUnknown - unknown cardinality must use symbolic costs only")
}

// SkipDependencyClosureForDiff is BLOCKED - use DependencyClosureDiff
func SkipDependencyClosureForDiff(addresses []string) {
	BlockBypassAttempt("SkipDependencyClosureForDiff - diffs must use dependency closure, not address matching")
}

// AcceptAssetWithoutDepNode is BLOCKED - assets must have dependency nodes
func AcceptAssetWithoutDepNode(assetID string) {
	BlockBypassAttempt("AcceptAssetWithoutDepNode - all assets must reference a DependencyNodeID")
}

################################################################################
# FILE: :\good projects\cost estimation\core\graph\canonical_graph.go
# TYPE: go
# SIZE: 8410 bytes
################################################################################
// Package graph - Canonical dependency graph
// This is THE authoritative source of truth for all dependencies.
// Everything downstream MUST reference this graph.
package graph

// DependencyNodeID uniquely identifies a node in the dependency graph
type DependencyNodeID string

// EdgeType indicates the type of dependency edge
type EdgeType int

const (
	EdgeReference    EdgeType = iota // Expression reference (e.g., aws_instance.web.id)
	EdgeDependsOn                    // Explicit depends_on
	EdgeModuleInput                  // Module input variable
	EdgeModuleOutput                 // Module output reference
	EdgeProviderBinding              // Provider configuration binding
	EdgeDataSource                   // Data source dependency
)

// String returns edge type name
func (t EdgeType) String() string {
	names := []string{"reference", "depends_on", "module_input", "module_output", "provider_binding", "data_source"}
	if int(t) < len(names) {
		return names[t]
	}
	return "unknown"
}

// DependencyEdge represents a directed edge in the dependency graph
type DependencyEdge struct {
	From      DependencyNodeID
	To        DependencyNodeID
	Type      EdgeType
	Attribute string // Which attribute caused this edge (for reference edges)
}

// NodeType indicates what kind of node this is
type CanonicalNodeType int

const (
	CanonicalResource   CanonicalNodeType = iota // resource block
	CanonicalData                                 // data source
	CanonicalModule                               // module call
	CanonicalProvider                             // provider configuration
	CanonicalVariable                             // input variable
	CanonicalLocal                                // local value
	CanonicalOutput                               // output value
)

// NodeMeta contains metadata about a dependency node
type NodeMeta struct {
	ID           DependencyNodeID
	Type         CanonicalNodeType
	Address      string // Terraform address (e.g., aws_instance.web)
	ModulePath   string // Module path (empty for root)
	ResourceType string // For resources/data: aws_instance
	Provider     string // Provider key
	SourceFile   string
	SourceLine   int
}

// CanonicalDependencyGraph is THE authoritative dependency graph
// All downstream systems MUST derive from this graph.
type CanonicalDependencyGraph struct {
	// Nodes indexed by ID
	nodes map[DependencyNodeID]*NodeMeta

	// Forward edges (from â†’ to)
	edges map[DependencyNodeID][]DependencyEdge

	// Reverse edges (to â†’ from) for upstream lookups
	reverseEdges map[DependencyNodeID][]DependencyEdge

	// Root nodes (no incoming edges)
	roots []DependencyNodeID

	// Sealed flag - no modifications after sealing
	sealed bool
}

// NewCanonicalDependencyGraph creates a new graph
func NewCanonicalDependencyGraph() *CanonicalDependencyGraph {
	return &CanonicalDependencyGraph{
		nodes:        make(map[DependencyNodeID]*NodeMeta),
		edges:        make(map[DependencyNodeID][]DependencyEdge),
		reverseEdges: make(map[DependencyNodeID][]DependencyEdge),
		roots:        []DependencyNodeID{},
		sealed:       false,
	}
}

// AddNode adds a node to the graph
func (g *CanonicalDependencyGraph) AddNode(meta *NodeMeta) {
	if g.sealed {
		panic("INVARIANT VIOLATED: cannot modify sealed dependency graph")
	}
	g.nodes[meta.ID] = meta
}

// AddEdge adds an edge to the graph
func (g *CanonicalDependencyGraph) AddEdge(edge DependencyEdge) {
	if g.sealed {
		panic("INVARIANT VIOLATED: cannot modify sealed dependency graph")
	}
	
	// Validate nodes exist
	if _, ok := g.nodes[edge.From]; !ok {
		panic("INVARIANT VIOLATED: edge from non-existent node: " + string(edge.From))
	}
	if _, ok := g.nodes[edge.To]; !ok {
		panic("INVARIANT VIOLATED: edge to non-existent node: " + string(edge.To))
	}

	g.edges[edge.From] = append(g.edges[edge.From], edge)
	g.reverseEdges[edge.To] = append(g.reverseEdges[edge.To], edge)
}

// Seal seals the graph - no more modifications allowed
func (g *CanonicalDependencyGraph) Seal() {
	// Compute roots
	g.roots = []DependencyNodeID{}
	for id := range g.nodes {
		if len(g.reverseEdges[id]) == 0 {
			g.roots = append(g.roots, id)
		}
	}
	g.sealed = true
}

// IsSealed returns whether the graph is sealed
func (g *CanonicalDependencyGraph) IsSealed() bool {
	return g.sealed
}

// IsTransitivelyClosed checks if graph is transitively closed
// A graph is closed if all referenced nodes exist
func (g *CanonicalDependencyGraph) IsTransitivelyClosed() bool {
	for _, edges := range g.edges {
		for _, edge := range edges {
			if _, ok := g.nodes[edge.To]; !ok {
				return false
			}
		}
	}
	return true
}

// MustBeClosed panics if graph is not closed
// CALL THIS BEFORE ASSET EXPANSION
func (g *CanonicalDependencyGraph) MustBeClosed() {
	if !g.sealed {
		panic("INVARIANT VIOLATED: dependency graph must be sealed before use")
	}
	if !g.IsTransitivelyClosed() {
		panic("INVARIANT VIOLATED: dependency graph is not transitively closed")
	}
}

// GetNode returns a node by ID
func (g *CanonicalDependencyGraph) GetNode(id DependencyNodeID) (*NodeMeta, bool) {
	node, ok := g.nodes[id]
	return node, ok
}

// MustGetNode returns a node or panics
func (g *CanonicalDependencyGraph) MustGetNode(id DependencyNodeID) *NodeMeta {
	node, ok := g.nodes[id]
	if !ok {
		panic("INVARIANT VIOLATED: node not found: " + string(id))
	}
	return node
}

// GetDependencies returns direct dependencies of a node
func (g *CanonicalDependencyGraph) GetDependencies(id DependencyNodeID) []DependencyEdge {
	return g.edges[id]
}

// GetDependents returns nodes that depend on this node
func (g *CanonicalDependencyGraph) GetDependents(id DependencyNodeID) []DependencyEdge {
	return g.reverseEdges[id]
}

// GetDependencyPath returns the transitive closure from roots to this node
// This is REQUIRED for CostUnit lineage
func (g *CanonicalDependencyGraph) GetDependencyPath(id DependencyNodeID) []DependencyNodeID {
	if !g.sealed {
		panic("INVARIANT VIOLATED: cannot compute dependency path on unsealed graph")
	}

	visited := make(map[DependencyNodeID]bool)
	path := []DependencyNodeID{}
	g.collectUpstream(id, visited, &path)
	
	// Reverse to get root â†’ target order
	for i, j := 0, len(path)-1; i < j; i, j = i+1, j-1 {
		path[i], path[j] = path[j], path[i]
	}
	
	return path
}

func (g *CanonicalDependencyGraph) collectUpstream(id DependencyNodeID, visited map[DependencyNodeID]bool, path *[]DependencyNodeID) {
	if visited[id] {
		return
	}
	visited[id] = true

	// First collect upstream
	for _, edge := range g.reverseEdges[id] {
		g.collectUpstream(edge.From, visited, path)
	}

	// Then add self
	*path = append(*path, id)
}

// GetTransitiveDependents returns all nodes affected by changes to this node
func (g *CanonicalDependencyGraph) GetTransitiveDependents(id DependencyNodeID) []DependencyNodeID {
	if !g.sealed {
		panic("INVARIANT VIOLATED: cannot compute transitive dependents on unsealed graph")
	}

	visited := make(map[DependencyNodeID]bool)
	result := []DependencyNodeID{}
	g.collectDownstream(id, visited, &result)
	return result
}

func (g *CanonicalDependencyGraph) collectDownstream(id DependencyNodeID, visited map[DependencyNodeID]bool, result *[]DependencyNodeID) {
	for _, edge := range g.edges[id] {
		if !visited[edge.To] {
			visited[edge.To] = true
			*result = append(*result, edge.To)
			g.collectDownstream(edge.To, visited, result)
		}
	}
}

// GetRoots returns root nodes
func (g *CanonicalDependencyGraph) GetRoots() []DependencyNodeID {
	return g.roots
}

// Size returns node count
func (g *CanonicalDependencyGraph) Size() int {
	return len(g.nodes)
}

// EdgeCount returns edge count
func (g *CanonicalDependencyGraph) EdgeCount() int {
	count := 0
	for _, edges := range g.edges {
		count += len(edges)
	}
	return count
}

// AllNodes returns all nodes
func (g *CanonicalDependencyGraph) AllNodes() map[DependencyNodeID]*NodeMeta {
	return g.nodes
}

// ValidateNode asserts a node exists
func (g *CanonicalDependencyGraph) ValidateNode(id DependencyNodeID) {
	if _, ok := g.nodes[id]; !ok {
		panic("INVARIANT VIOLATED: node not in canonical dependency graph: " + string(id))
	}
}

################################################################################
# FILE: :\good projects\cost estimation\core\graph\concurrent.go
# TYPE: go
# SIZE: 7747 bytes
################################################################################
// Package graph - Concurrent graph execution
// Resources are processed in parallel respecting dependency order.
package graph

import (
	"context"
	"fmt"
	"sync"
	"sync/atomic"
	"time"
)

// ConcurrentExecutor executes graph nodes in parallel with dependency respect
type ConcurrentExecutor struct {
	// Max concurrent workers
	maxWorkers int

	// Execution stats
	stats *ExecutionStats

	// Error handling
	stopOnError bool
	errors      []ExecutionError

	// Progress tracking
	progress *ExecutionProgress

	mu sync.Mutex
}

// ExecutionStats tracks execution statistics
type ExecutionStats struct {
	TotalNodes       int64
	CompletedNodes   int64
	FailedNodes      int64
	SkippedNodes     int64
	StartTime        time.Time
	EndTime          time.Time
	MaxConcurrency   int
	AverageDuration  time.Duration
	nodeDurations    []time.Duration
	mu               sync.Mutex
}

// ExecutionError records an execution error
type ExecutionError struct {
	NodeID   string
	Phase    string
	Message  string
	Cause    error
	Duration time.Duration
}

// ExecutionProgress tracks live progress
type ExecutionProgress struct {
	Total      int64
	Completed  int64
	InProgress int64
	Failed     int64
	Percent    float64
	ETA        time.Duration
	mu         sync.RWMutex
}

// NodeExecutor is a function that processes a single node
type NodeExecutor func(ctx context.Context, nodeID string) error

// NewConcurrentExecutor creates a new executor
func NewConcurrentExecutor(maxWorkers int) *ConcurrentExecutor {
	if maxWorkers <= 0 {
		maxWorkers = 4
	}
	return &ConcurrentExecutor{
		maxWorkers:  maxWorkers,
		stats:       &ExecutionStats{},
		stopOnError: false,
		errors:      []ExecutionError{},
		progress:    &ExecutionProgress{},
	}
}

// SetStopOnError configures error handling
func (e *ConcurrentExecutor) SetStopOnError(stop bool) {
	e.stopOnError = stop
}

// Execute runs the executor on a graph
func (e *ConcurrentExecutor) Execute(ctx context.Context, graph *InfrastructureGraph, executor NodeExecutor) error {
	// Get topological order
	order, err := graph.TopologicalSort()
	if err != nil {
		return fmt.Errorf("failed to sort graph: %w", err)
	}

	if len(order) == 0 {
		return nil
	}

	// Initialize stats
	e.stats.TotalNodes = int64(len(order))
	e.stats.StartTime = time.Now()
	e.progress.Total = int64(len(order))

	// Group nodes by level (nodes at same level can run in parallel)
	levels := e.groupByLevel(graph, order)

	// Execute level by level
	for levelNum, level := range levels {
		if err := e.executeLevel(ctx, level, levelNum, executor); err != nil {
			if e.stopOnError {
				return err
			}
		}
	}

	e.stats.EndTime = time.Now()
	e.calculateAverageDuration()

	return nil
}

// groupByLevel groups nodes into dependency levels
func (e *ConcurrentExecutor) groupByLevel(graph *InfrastructureGraph, order []string) [][]string {
	levels := [][]string{}
	processed := make(map[string]int) // node -> level

	for _, nodeID := range order {
		// Find the maximum level of dependencies
		maxDepLevel := -1
		deps := graph.GetDependencies(nodeID)
		for _, dep := range deps {
			if level, ok := processed[dep]; ok {
				if level > maxDepLevel {
					maxDepLevel = level
				}
			}
		}

		// This node goes in the next level
		nodeLevel := maxDepLevel + 1
		processed[nodeID] = nodeLevel

		// Ensure we have enough levels
		for len(levels) <= nodeLevel {
			levels = append(levels, []string{})
		}
		levels[nodeLevel] = append(levels[nodeLevel], nodeID)
	}

	return levels
}

// executeLevel executes all nodes in a level concurrently
func (e *ConcurrentExecutor) executeLevel(ctx context.Context, nodes []string, levelNum int, executor NodeExecutor) error {
	if len(nodes) == 0 {
		return nil
	}

	// Create worker pool
	workers := e.maxWorkers
	if len(nodes) < workers {
		workers = len(nodes)
	}

	// Track concurrency
	if workers > e.stats.MaxConcurrency {
		e.stats.MaxConcurrency = workers
	}

	// Channel for work items
	work := make(chan string, len(nodes))
	for _, node := range nodes {
		work <- node
	}
	close(work)

	// Error channel
	errChan := make(chan ExecutionError, len(nodes))

	// WaitGroup for workers
	var wg sync.WaitGroup

	// Start workers
	for i := 0; i < workers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for nodeID := range work {
				select {
				case <-ctx.Done():
					return
				default:
					e.executeNode(ctx, nodeID, executor, errChan)
				}
			}
		}()
	}

	// Wait for completion
	wg.Wait()
	close(errChan)

	// Collect errors
	for err := range errChan {
		e.mu.Lock()
		e.errors = append(e.errors, err)
		e.mu.Unlock()
	}

	return nil
}

func (e *ConcurrentExecutor) executeNode(ctx context.Context, nodeID string, executor NodeExecutor, errChan chan<- ExecutionError) {
	// Update progress
	atomic.AddInt64(&e.progress.InProgress, 1)
	e.updateProgress()

	start := time.Now()
	err := executor(ctx, nodeID)
	duration := time.Since(start)

	// Record duration
	e.stats.mu.Lock()
	e.stats.nodeDurations = append(e.stats.nodeDurations, duration)
	e.stats.mu.Unlock()

	atomic.AddInt64(&e.progress.InProgress, -1)

	if err != nil {
		atomic.AddInt64(&e.stats.FailedNodes, 1)
		atomic.AddInt64(&e.progress.Failed, 1)
		errChan <- ExecutionError{
			NodeID:   nodeID,
			Message:  err.Error(),
			Cause:    err,
			Duration: duration,
		}
	} else {
		atomic.AddInt64(&e.stats.CompletedNodes, 1)
		atomic.AddInt64(&e.progress.Completed, 1)
	}

	e.updateProgress()
}

func (e *ConcurrentExecutor) updateProgress() {
	e.progress.mu.Lock()
	defer e.progress.mu.Unlock()

	if e.progress.Total > 0 {
		e.progress.Percent = float64(e.progress.Completed+e.progress.Failed) / float64(e.progress.Total) * 100
	}

	// Estimate ETA
	elapsed := time.Since(e.stats.StartTime)
	if e.progress.Completed > 0 {
		avgDuration := elapsed / time.Duration(e.progress.Completed)
		remaining := e.progress.Total - e.progress.Completed - e.progress.Failed
		e.progress.ETA = avgDuration * time.Duration(remaining)
	}
}

func (e *ConcurrentExecutor) calculateAverageDuration() {
	e.stats.mu.Lock()
	defer e.stats.mu.Unlock()

	if len(e.stats.nodeDurations) == 0 {
		return
	}

	var total time.Duration
	for _, d := range e.stats.nodeDurations {
		total += d
	}
	e.stats.AverageDuration = total / time.Duration(len(e.stats.nodeDurations))
}

// GetProgress returns current progress
func (e *ConcurrentExecutor) GetProgress() ExecutionProgress {
	e.progress.mu.RLock()
	defer e.progress.mu.RUnlock()
	return *e.progress
}

// GetStats returns execution stats
func (e *ConcurrentExecutor) GetStats() ExecutionStats {
	return *e.stats
}

// GetErrors returns all errors
func (e *ConcurrentExecutor) GetErrors() []ExecutionError {
	e.mu.Lock()
	defer e.mu.Unlock()
	return e.errors
}

// ProgressCallback is called with progress updates
type ProgressCallback func(progress ExecutionProgress)

// ExecuteWithProgress runs with progress callbacks
func (e *ConcurrentExecutor) ExecuteWithProgress(ctx context.Context, graph *InfrastructureGraph, executor NodeExecutor, callback ProgressCallback, interval time.Duration) error {
	// Start progress reporter
	done := make(chan struct{})
	go func() {
		ticker := time.NewTicker(interval)
		defer ticker.Stop()
		for {
			select {
			case <-done:
				return
			case <-ticker.C:
				callback(e.GetProgress())
			}
		}
	}()

	// Execute
	err := e.Execute(ctx, graph, executor)
	close(done)

	// Final callback
	callback(e.GetProgress())

	return err
}

################################################################################
# FILE: :\good projects\cost estimation\core\graph\dependency_cost.go
# TYPE: go
# SIZE: 7926 bytes
################################################################################
// Package graph - Dependency-aware cost graph
// Cost graph MUST consume dependency graph authoritatively.
// Every CostUnit is traceable through the asset dependency chain.
package graph

import (
	"terraform-cost/core/cost"
	"terraform-cost/core/model"
)

// DependencyAwareCostGraph integrates cost with dependency semantics
type DependencyAwareCostGraph struct {
	// Infrastructure graph (authoritative)
	infra *InfrastructureGraph

	// Cost graph (derived)
	costs *cost.CostGraph

	// Mapping: instance ID â†’ node ID
	instanceToNode map[model.InstanceID]string

	// Dependency costs: how much each node contributes to dependents
	dependencyCosts map[string]*DependencyCost
}

// DependencyCost tracks cost through dependency chains
type DependencyCost struct {
	NodeID          string
	DirectCost      float64 // This node's cost
	DependentCost   float64 // Cost of nodes depending on this
	TransitiveCost  float64 // Full transitive dependent cost
	DependencyDepth int     // How deep in dependency chain
	AffectedNodes   []string
}

// NewDependencyAwareCostGraph creates an integrated graph
func NewDependencyAwareCostGraph(infra *InfrastructureGraph, costs *cost.CostGraph) *DependencyAwareCostGraph {
	g := &DependencyAwareCostGraph{
		infra:           infra,
		costs:           costs,
		instanceToNode:  make(map[model.InstanceID]string),
		dependencyCosts: make(map[string]*DependencyCost),
	}

	// Build mappings
	g.buildMappings()

	// Calculate dependency costs
	g.calculateDependencyCosts()

	return g
}

func (g *DependencyAwareCostGraph) buildMappings() {
	for nodeID, node := range g.infra.nodes {
		if node.IsExpanded {
			// Map expanded instances to their node
			// Instance ID is derived from definition + key
			instID := model.InstanceID(nodeID)
			g.instanceToNode[instID] = nodeID
		}
	}
}

func (g *DependencyAwareCostGraph) calculateDependencyCosts() {
	// Get topological order (dependencies first)
	order, err := g.infra.TopologicalSort()
	if err != nil {
		return
	}

	// Process in reverse order (dependents first)
	for i := len(order) - 1; i >= 0; i-- {
		nodeID := order[i]
		g.calculateNodeDependencyCost(nodeID)
	}
}

func (g *DependencyAwareCostGraph) calculateNodeDependencyCost(nodeID string) {
	// Get this node's direct cost
	instID := model.InstanceID(nodeID)
	costNode := g.costs.GetNode(instID)

	directCost := 0.0
	if costNode != nil {
		directCost = costNode.TotalMonthly.Float64()
	}

	// Get dependents
	dependents := g.infra.GetDependents(nodeID)

	dependentCost := 0.0
	transitiveCost := 0.0
	maxDepth := 0
	affected := []string{}

	for _, depID := range dependents {
		affected = append(affected, depID)

		// Get dependent's cost info
		if depCost, ok := g.dependencyCosts[depID]; ok {
			dependentCost += depCost.DirectCost
			transitiveCost += depCost.DirectCost + depCost.TransitiveCost
			if depCost.DependencyDepth+1 > maxDepth {
				maxDepth = depCost.DependencyDepth + 1
			}
			affected = append(affected, depCost.AffectedNodes...)
		}
	}

	g.dependencyCosts[nodeID] = &DependencyCost{
		NodeID:          nodeID,
		DirectCost:      directCost,
		DependentCost:   dependentCost,
		TransitiveCost:  transitiveCost,
		DependencyDepth: maxDepth,
		AffectedNodes:   affected,
	}
}

// GetBlastRadius returns the cost impact if a node changes
func (g *DependencyAwareCostGraph) GetBlastRadius(nodeID string) *BlastRadius {
	depCost := g.dependencyCosts[nodeID]
	if depCost == nil {
		return nil
	}

	return &BlastRadius{
		NodeID:              nodeID,
		DirectCost:          depCost.DirectCost,
		AffectedNodesCost:   depCost.TransitiveCost,
		TotalPotentialCost:  depCost.DirectCost + depCost.TransitiveCost,
		AffectedNodesCount:  len(depCost.AffectedNodes),
		MaxDependencyDepth:  depCost.DependencyDepth,
		AffectedNodes:       depCost.AffectedNodes,
	}
}

// BlastRadius describes the cost impact of a change
type BlastRadius struct {
	NodeID              string
	DirectCost          float64
	AffectedNodesCost   float64
	TotalPotentialCost  float64
	AffectedNodesCount  int
	MaxDependencyDepth  int
	AffectedNodes       []string
}

// GetCostLineage returns the full lineage of a cost
func (g *DependencyAwareCostGraph) GetCostLineage(instID model.InstanceID) *CostLineage {
	nodeID := string(instID)
	node := g.infra.GetNode(nodeID)
	costNode := g.costs.GetNode(instID)

	if node == nil || costNode == nil {
		return nil
	}

	lineage := &CostLineage{
		InstanceID:     instID,
		InstanceAddress: string(costNode.InstanceAddress),
		ResourceType:   costNode.ResourceType,
		DirectCost:     costNode.TotalMonthly.Float64(),
		Dependencies:   []DependencyLink{},
		Dependents:     []DependencyLink{},
	}

	// Get dependencies
	for _, depID := range g.infra.GetDependencies(nodeID) {
		depInstID := model.InstanceID(depID)
		depCostNode := g.costs.GetNode(depInstID)
		cost := 0.0
		if depCostNode != nil {
			cost = depCostNode.TotalMonthly.Float64()
		}
		lineage.Dependencies = append(lineage.Dependencies, DependencyLink{
			NodeID:   depID,
			Cost:     cost,
			Relation: "depends_on",
		})
	}

	// Get dependents
	for _, depID := range g.infra.GetDependents(nodeID) {
		depInstID := model.InstanceID(depID)
		depCostNode := g.costs.GetNode(depInstID)
		cost := 0.0
		if depCostNode != nil {
			cost = depCostNode.TotalMonthly.Float64()
		}
		lineage.Dependents = append(lineage.Dependents, DependencyLink{
			NodeID:   depID,
			Cost:     cost,
			Relation: "required_by",
		})
	}

	return lineage
}

// CostLineage is the full lineage of a cost
type CostLineage struct {
	InstanceID      model.InstanceID
	InstanceAddress string
	ResourceType    string
	DirectCost      float64
	Dependencies    []DependencyLink
	Dependents      []DependencyLink
}

// DependencyLink is a link in the dependency chain
type DependencyLink struct {
	NodeID   string
	Cost     float64
	Relation string
}

// CalculateChangeCost calculates cost change for a set of changed nodes
func (g *DependencyAwareCostGraph) CalculateChangeCost(changedNodes []string) *ChangeCostAnalysis {
	analysis := &ChangeCostAnalysis{
		ChangedNodes:    changedNodes,
		DirectChanges:   []NodeCostChange{},
		IndirectChanges: []NodeCostChange{},
		TotalDirect:     0,
		TotalIndirect:   0,
	}

	affected := make(map[string]bool)

	// Process each changed node
	for _, nodeID := range changedNodes {
		affected[nodeID] = true

		// Get this node's cost
		instID := model.InstanceID(nodeID)
		costNode := g.costs.GetNode(instID)
		cost := 0.0
		if costNode != nil {
			cost = costNode.TotalMonthly.Float64()
		}

		analysis.DirectChanges = append(analysis.DirectChanges, NodeCostChange{
			NodeID: nodeID,
			Cost:   cost,
			Type:   "direct",
		})
		analysis.TotalDirect += cost

		// Get transitive dependents
		for _, depID := range g.infra.GetTransitiveDependents(nodeID) {
			if !affected[depID] {
				affected[depID] = true

				depInstID := model.InstanceID(depID)
				depCostNode := g.costs.GetNode(depInstID)
				depCost := 0.0
				if depCostNode != nil {
					depCost = depCostNode.TotalMonthly.Float64()
				}

				analysis.IndirectChanges = append(analysis.IndirectChanges, NodeCostChange{
					NodeID: depID,
					Cost:   depCost,
					Type:   "indirect",
				})
				analysis.TotalIndirect += depCost
			}
		}
	}

	return analysis
}

// ChangeCostAnalysis is the result of change cost calculation
type ChangeCostAnalysis struct {
	ChangedNodes    []string
	DirectChanges   []NodeCostChange
	IndirectChanges []NodeCostChange
	TotalDirect     float64
	TotalIndirect   float64
}

// NodeCostChange is a cost change for a node
type NodeCostChange struct {
	NodeID string
	Cost   float64
	Type   string
}

################################################################################
# FILE: :\good projects\cost estimation\core\graph\derived_cost.go
# TYPE: go
# SIZE: 8660 bytes
################################################################################
// Package graph - Derived cost graph
// Costs MUST be derived from the dependency graph.
// This is not optional - diffs are meaningless without it.
package graph

import (
	"terraform-cost/core/determinism"
)

// DerivedCostGraph is a cost graph that MUST be derived from a dependency graph
type DerivedCostGraph struct {
	// Source dependency graph (required)
	sourceGraph *InfrastructureGraph

	// Cost nodes indexed by address
	nodes map[string]*DerivedCostNode

	// Dependency edges (from â†’ to) with cost impact
	edges map[string][]*CostEdge

	// Symbolic costs (unknown cardinality)
	symbolicCosts map[string]*SymbolicCost
}

// DerivedCostNode is a cost node with dependency lineage
type DerivedCostNode struct {
	Address         string
	InfraNodeID     string
	DependencyDepth int

	MonthlyCost     determinism.Money
	HourlyCost      determinism.Money
	DirectCost      determinism.Money
	TransitiveCost  determinism.Money
	BlastRadiusCost determinism.Money

	DependsOn  []string
	DependedBy []string

	Confidence float64
}

// CostEdge is a cost-aware dependency edge
type CostEdge struct {
	From     string
	To       string
	CostFrom determinism.Money
	CostTo   determinism.Money
	Relation string
}

// SymbolicCost represents cost for unknown cardinality
type SymbolicCost struct {
	Address      string
	Expression   string
	MinInstances int
	MaxInstances int
	CostPerUnit  determinism.Money
	MinCost      determinism.Money
	MaxCost      determinism.Money
	IsUnbounded  bool
	Confidence   float64
	Warning      string
}

// NewDerivedCostGraph creates a cost graph from a dependency graph
// THIS IS THE ONLY WAY TO CREATE A COST GRAPH
func NewDerivedCostGraph(depGraph *InfrastructureGraph) (*DerivedCostGraph, error) {
	if depGraph == nil {
		return nil, &NoDependencyGraphError{}
	}

	g := &DerivedCostGraph{
		sourceGraph:   depGraph,
		nodes:         make(map[string]*DerivedCostNode),
		edges:         make(map[string][]*CostEdge),
		symbolicCosts: make(map[string]*SymbolicCost),
	}

	// Initialize nodes from dependency graph
	for nodeID := range depGraph.nodes {
		g.nodes[nodeID] = &DerivedCostNode{
			Address:         nodeID,
			InfraNodeID:     nodeID,
			DependencyDepth: 0, // Computed later
			DependsOn:       depGraph.GetDependencies(nodeID),
			DependedBy:      depGraph.GetDependents(nodeID),
			MonthlyCost:     determinism.Zero("USD"),
			HourlyCost:      determinism.Zero("USD"),
			DirectCost:      determinism.Zero("USD"),
			TransitiveCost:  determinism.Zero("USD"),
			BlastRadiusCost: determinism.Zero("USD"),
			Confidence:      1.0,
		}
	}

	// Create cost edges from dependency edges
	for nodeID := range g.nodes {
		for _, depID := range depGraph.GetDependencies(nodeID) {
			edge := &CostEdge{
				From:     nodeID,
				To:       depID,
				CostFrom: determinism.Zero("USD"),
				CostTo:   determinism.Zero("USD"),
				Relation: "depends_on",
			}
			g.edges[nodeID] = append(g.edges[nodeID], edge)
		}
	}

	return g, nil
}

// NoDependencyGraphError indicates cost graph was created without dependency graph
type NoDependencyGraphError struct{}

func (e *NoDependencyGraphError) Error() string {
	return "cost graph MUST be derived from dependency graph"
}

// SetNodeCost sets the cost for a node
func (g *DerivedCostGraph) SetNodeCost(address string, monthly, hourly determinism.Money, confidence float64) error {
	node, ok := g.nodes[address]
	if !ok {
		return &NodeNotInGraphError{Address: address}
	}

	node.MonthlyCost = monthly
	node.HourlyCost = hourly
	node.DirectCost = monthly
	node.Confidence = confidence

	for _, edge := range g.edges[address] {
		edge.CostFrom = monthly
	}

	return nil
}

// NodeNotInGraphError indicates a node doesn't exist
type NodeNotInGraphError struct {
	Address string
}

func (e *NodeNotInGraphError) Error() string {
	return "node " + e.Address + " not in dependency graph"
}

// AddSymbolicCost adds a symbolic cost for unknown cardinality
func (g *DerivedCostGraph) AddSymbolicCost(address string, costPerUnit determinism.Money, minInst, maxInst int, expr string) {
	minCost := costPerUnit.MulFloat(float64(minInst))

	maxCost := determinism.Zero("USD")
	isUnbounded := maxInst < 0
	if !isUnbounded {
		maxCost = costPerUnit.MulFloat(float64(maxInst))
	}

	warning := ""
	if isUnbounded {
		warning = "cardinality is unbounded"
	} else if maxInst > minInst {
		warning = "cardinality is uncertain - cost is a range"
	}

	g.symbolicCosts[address] = &SymbolicCost{
		Address:      address,
		Expression:   expr,
		MinInstances: minInst,
		MaxInstances: maxInst,
		CostPerUnit:  costPerUnit,
		MinCost:      minCost,
		MaxCost:      maxCost,
		IsUnbounded:  isUnbounded,
		Confidence:   0.3,
		Warning:      warning,
	}
}

// CalculateTransitiveCosts calculates costs through the dependency chain
func (g *DerivedCostGraph) CalculateTransitiveCosts() {
	order, err := g.sourceGraph.TopologicalSort()
	if err != nil {
		return
	}

	for i := len(order) - 1; i >= 0; i-- {
		nodeID := order[i]
		node := g.nodes[nodeID]
		if node == nil {
			continue
		}

		transitive := determinism.Zero("USD")
		for _, depByID := range node.DependedBy {
			if depBy := g.nodes[depByID]; depBy != nil {
				transitive = transitive.Add(depBy.DirectCost)
				transitive = transitive.Add(depBy.TransitiveCost)
			}
		}
		node.TransitiveCost = transitive
		node.BlastRadiusCost = node.DirectCost.Add(transitive)
	}
}

// GetChangeImpact calculates the cost impact of changing nodes
func (g *DerivedCostGraph) GetChangeImpact(changedAddresses []string) *CostChangeImpact {
	impact := &CostChangeImpact{
		DirectCost:       determinism.Zero("USD"),
		IndirectCost:     determinism.Zero("USD"),
		TotalCost:        determinism.Zero("USD"),
		AffectedNodes:    []string{},
		DependencyChains: [][]string{},
	}

	affected := make(map[string]bool)

	for _, addr := range changedAddresses {
		node := g.nodes[addr]
		if node == nil {
			continue
		}

		impact.DirectCost = impact.DirectCost.Add(node.DirectCost)
		affected[addr] = true

		dependents := g.sourceGraph.GetTransitiveDependents(addr)
		chain := []string{addr}
		for _, dep := range dependents {
			if !affected[dep] {
				affected[dep] = true
				if depNode := g.nodes[dep]; depNode != nil {
					impact.IndirectCost = impact.IndirectCost.Add(depNode.DirectCost)
				}
				chain = append(chain, dep)
			}
		}
		impact.DependencyChains = append(impact.DependencyChains, chain)
	}

	for addr := range affected {
		impact.AffectedNodes = append(impact.AffectedNodes, addr)
	}

	impact.TotalCost = impact.DirectCost.Add(impact.IndirectCost)
	return impact
}

// CostChangeImpact describes the cost impact of changes
type CostChangeImpact struct {
	DirectCost       determinism.Money
	IndirectCost     determinism.Money
	TotalCost        determinism.Money
	AffectedNodes    []string
	DependencyChains [][]string
}

// GetSymbolicCosts returns all symbolic costs
func (g *DerivedCostGraph) GetSymbolicCosts() []*SymbolicCost {
	result := make([]*SymbolicCost, 0, len(g.symbolicCosts))
	for _, sc := range g.symbolicCosts {
		result = append(result, sc)
	}
	return result
}

// HasUnboundedCosts returns true if any costs are unbounded
func (g *DerivedCostGraph) HasUnboundedCosts() bool {
	for _, sc := range g.symbolicCosts {
		if sc.IsUnbounded {
			return true
		}
	}
	return false
}

// GetTotalCostRange returns the total cost as a range
func (g *DerivedCostGraph) GetTotalCostRange() *CostBounds {
	minTotal := determinism.Zero("USD")
	maxTotal := determinism.Zero("USD")
	hasUnbounded := false

	for _, node := range g.nodes {
		minTotal = minTotal.Add(node.DirectCost)
		maxTotal = maxTotal.Add(node.DirectCost)
	}

	for _, sc := range g.symbolicCosts {
		minTotal = minTotal.Add(sc.MinCost)
		if sc.IsUnbounded {
			hasUnbounded = true
		} else {
			maxTotal = maxTotal.Add(sc.MaxCost)
		}
	}

	return &CostBounds{
		Min:         minTotal,
		Max:         maxTotal,
		IsUnbounded: hasUnbounded,
	}
}

// CostBounds represents a cost range for uncertain cardinality
type CostBounds struct {
	Min         determinism.Money
	Max         determinism.Money
	IsUnbounded bool
}

// String returns the range as a string
func (r *CostBounds) String() string {
	if r.IsUnbounded {
		return r.Min.String() + " - âˆž"
	}
	if r.Min.Cmp(r.Max) == 0 {
		return r.Min.String()
	}
	return r.Min.String() + " - " + r.Max.String()
}

################################################################################
# FILE: :\good projects\cost estimation\core\graph\enforced_asset.go
# TYPE: go
# SIZE: 4703 bytes
################################################################################
// Package graph - Enforced assets with dependency lineage
// Every Asset MUST reference a DependencyNodeID.
// This is not optional - assets without lineage cannot exist.
package graph

import (
	"fmt"
)

// EnforcedAsset is an asset that MUST have dependency lineage
type EnforcedAsset struct {
	// Identity
	AssetID string

	// REQUIRED: Link to canonical dependency graph
	DependencyNodeID DependencyNodeID

	// REQUIRED: Upstream dependencies (transitive closure)
	UpstreamDeps []DependencyNodeID

	// Asset metadata
	Address      string
	ResourceType string
	Provider     string
	Region       string

	// Expansion info
	IsExpanded   bool
	ExpandedFrom string
	InstanceKey  interface{}
}

// NewEnforcedAsset creates an asset with REQUIRED dependency linkage
// Panics if dependency graph doesn't contain the node
func NewEnforcedAsset(
	assetID string,
	depNodeID DependencyNodeID,
	graph *CanonicalDependencyGraph,
) *EnforcedAsset {
	// ASSERTION: Node MUST exist in canonical graph
	graph.ValidateNode(depNodeID)

	// Get dependency path
	upstreamDeps := graph.GetDependencyPath(depNodeID)

	return &EnforcedAsset{
		AssetID:          assetID,
		DependencyNodeID: depNodeID,
		UpstreamDeps:     upstreamDeps,
	}
}

// ValidateLineage ensures the asset has proper dependency lineage
func (a *EnforcedAsset) ValidateLineage() error {
	if a.DependencyNodeID == "" {
		return fmt.Errorf("INVARIANT VIOLATED: asset %s has no DependencyNodeID", a.AssetID)
	}
	return nil
}

// EnforcedAssetGraph is a graph of assets with enforced dependency lineage
type EnforcedAssetGraph struct {
	// Source canonical graph (REQUIRED)
	canonical *CanonicalDependencyGraph

	// Assets indexed by ID
	assets map[string]*EnforcedAsset

	// Mapping from DependencyNodeID to assets (one-to-many for expanded resources)
	nodeToAssets map[DependencyNodeID][]*EnforcedAsset
}

// NewEnforcedAssetGraph creates an asset graph from a canonical dependency graph
// The canonical graph is REQUIRED
func NewEnforcedAssetGraph(canonical *CanonicalDependencyGraph) (*EnforcedAssetGraph, error) {
	if canonical == nil {
		return nil, fmt.Errorf("INVARIANT VIOLATED: cannot create asset graph without canonical dependency graph")
	}
	if !canonical.IsSealed() {
		return nil, fmt.Errorf("INVARIANT VIOLATED: canonical graph must be sealed before creating asset graph")
	}

	return &EnforcedAssetGraph{
		canonical:    canonical,
		assets:       make(map[string]*EnforcedAsset),
		nodeToAssets: make(map[DependencyNodeID][]*EnforcedAsset),
	}, nil
}

// AddAsset adds an asset with dependency validation
func (g *EnforcedAssetGraph) AddAsset(asset *EnforcedAsset) error {
	// ASSERTION: Asset must have DependencyNodeID
	if asset.DependencyNodeID == "" {
		panic(fmt.Sprintf("INVARIANT VIOLATED: asset %s has no DependencyNodeID", asset.AssetID))
	}

	// ASSERTION: DependencyNodeID must exist in canonical graph
	g.canonical.ValidateNode(asset.DependencyNodeID)

	g.assets[asset.AssetID] = asset
	g.nodeToAssets[asset.DependencyNodeID] = append(g.nodeToAssets[asset.DependencyNodeID], asset)
	return nil
}

// GetAsset returns an asset by ID
func (g *EnforcedAssetGraph) GetAsset(assetID string) (*EnforcedAsset, bool) {
	asset, ok := g.assets[assetID]
	return asset, ok
}

// GetAssetsByNode returns all assets for a dependency node
func (g *EnforcedAssetGraph) GetAssetsByNode(nodeID DependencyNodeID) []*EnforcedAsset {
	return g.nodeToAssets[nodeID]
}

// GetAffectedAssets returns assets affected by changes to specified nodes
func (g *EnforcedAssetGraph) GetAffectedAssets(changedNodes []DependencyNodeID) []*EnforcedAsset {
	affected := make(map[string]*EnforcedAsset)

	for _, nodeID := range changedNodes {
		// Direct assets
		for _, asset := range g.nodeToAssets[nodeID] {
			affected[asset.AssetID] = asset
		}

		// Transitive dependents
		dependents := g.canonical.GetTransitiveDependents(nodeID)
		for _, depID := range dependents {
			for _, asset := range g.nodeToAssets[depID] {
				affected[asset.AssetID] = asset
			}
		}
	}

	result := make([]*EnforcedAsset, 0, len(affected))
	for _, asset := range affected {
		result = append(result, asset)
	}
	return result
}

// AllAssets returns all assets
func (g *EnforcedAssetGraph) AllAssets() []*EnforcedAsset {
	result := make([]*EnforcedAsset, 0, len(g.assets))
	for _, asset := range g.assets {
		result = append(result, asset)
	}
	return result
}

// GetCanonicalGraph returns the canonical dependency graph
func (g *EnforcedAssetGraph) GetCanonicalGraph() *CanonicalDependencyGraph {
	return g.canonical
}

################################################################################
# FILE: :\good projects\cost estimation\core\graph\enforced_cost.go
# TYPE: go
# SIZE: 6630 bytes
################################################################################
// Package graph - Enforced cost units with dependency path
// Every CostUnit MUST carry its dependency path.
// If the path cannot be constructed, estimation is blocked.
package graph

import (
	"fmt"

	"terraform-cost/core/determinism"
)

// EnforcedCostUnit represents a single unit of cost with REQUIRED dependency lineage
type EnforcedCostUnit struct {
	// Identity
	CostUnitID string
	AssetID    string

	// REQUIRED: Dependency path from root to this cost unit
	DependencyPath []DependencyNodeID

	// Cost values
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money

	// Components
	Components []*EnforcedCostComponent

	// Confidence
	Confidence float64

	// Symbolic (for unknown cardinality)
	IsSymbolic   bool
	SymbolicInfo *SymbolicInfo
}

// EnforcedCostComponent is a component of a cost unit
type EnforcedCostComponent struct {
	Name        string
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money
	Confidence  float64
}

// SymbolicInfo represents cost when cardinality is unknown
type SymbolicInfo struct {
	Reason           string
	MinCost          *determinism.Money
	MaxCost          *determinism.Money
	IsUnbounded      bool
	Expression       string
	CardinalityState CardinalityStateType
}

// CardinalityStateType indicates the cardinality knowledge state
type CardinalityStateType int

const (
	CardinalityKnown   CardinalityStateType = iota
	CardinalityUnknown
	CardinalityRange
)

// String returns the state name
func (s CardinalityStateType) String() string {
	names := []string{"known", "unknown", "range"}
	if int(s) < len(names) {
		return names[s]
	}
	return "invalid"
}

// NewEnforcedCostUnit creates a cost unit with REQUIRED dependency path
func NewEnforcedCostUnit(
	costUnitID string,
	asset *EnforcedAsset,
) *EnforcedCostUnit {
	// ASSERTION: Asset must have dependency lineage
	if err := asset.ValidateLineage(); err != nil {
		panic(err.Error())
	}

	return &EnforcedCostUnit{
		CostUnitID:     costUnitID,
		AssetID:        asset.AssetID,
		DependencyPath: asset.UpstreamDeps,
		MonthlyCost:    determinism.Zero("USD"),
		HourlyCost:     determinism.Zero("USD"),
		Components:     []*EnforcedCostComponent{},
		Confidence:     1.0,
		IsSymbolic:     false,
	}
}

// NewSymbolicCostUnit creates a cost unit for unknown cardinality
func NewSymbolicCostUnit(
	costUnitID string,
	asset *EnforcedAsset,
	reason string,
	state CardinalityStateType,
) *EnforcedCostUnit {
	if err := asset.ValidateLineage(); err != nil {
		panic(err.Error())
	}

	return &EnforcedCostUnit{
		CostUnitID:     costUnitID,
		AssetID:        asset.AssetID,
		DependencyPath: asset.UpstreamDeps,
		MonthlyCost:    determinism.Zero("USD"),
		HourlyCost:     determinism.Zero("USD"),
		Confidence:     0.0,
		IsSymbolic:     true,
		SymbolicInfo: &SymbolicInfo{
			Reason:           reason,
			IsUnbounded:      state == CardinalityUnknown,
			CardinalityState: state,
		},
	}
}

// ValidateDependencyPath ensures the cost unit has a dependency path
func (c *EnforcedCostUnit) ValidateDependencyPath() error {
	if len(c.DependencyPath) == 0 {
		return fmt.Errorf("INVARIANT VIOLATED: CostUnit %s has no dependency path", c.CostUnitID)
	}
	return nil
}

// EnforcedCostGraph is a cost graph with REQUIRED dependency lineage
type EnforcedCostGraph struct {
	assetGraph    *EnforcedAssetGraph
	costUnits     map[string]*EnforcedCostUnit
	assetToCosts  map[string][]*EnforcedCostUnit
	nodeToCosts   map[DependencyNodeID][]*EnforcedCostUnit
	symbolicCosts []*EnforcedCostUnit
}

// NewEnforcedCostGraph creates a cost graph from an asset graph
func NewEnforcedCostGraph(assetGraph *EnforcedAssetGraph) (*EnforcedCostGraph, error) {
	if assetGraph == nil {
		return nil, fmt.Errorf("INVARIANT VIOLATED: cannot create cost graph without asset graph")
	}

	return &EnforcedCostGraph{
		assetGraph:    assetGraph,
		costUnits:     make(map[string]*EnforcedCostUnit),
		assetToCosts:  make(map[string][]*EnforcedCostUnit),
		nodeToCosts:   make(map[DependencyNodeID][]*EnforcedCostUnit),
		symbolicCosts: []*EnforcedCostUnit{},
	}, nil
}

// AddCostUnit adds a cost unit with dependency validation
func (g *EnforcedCostGraph) AddCostUnit(unit *EnforcedCostUnit) error {
	if err := unit.ValidateDependencyPath(); err != nil {
		panic(err.Error())
	}

	g.costUnits[unit.CostUnitID] = unit
	g.assetToCosts[unit.AssetID] = append(g.assetToCosts[unit.AssetID], unit)

	for _, nodeID := range unit.DependencyPath {
		g.nodeToCosts[nodeID] = append(g.nodeToCosts[nodeID], unit)
	}

	if unit.IsSymbolic {
		g.symbolicCosts = append(g.symbolicCosts, unit)
	}

	return nil
}

// GetAffectedCostUnits returns cost units affected by changes to specified nodes
func (g *EnforcedCostGraph) GetAffectedCostUnits(changedNodes []DependencyNodeID) []*EnforcedCostUnit {
	affected := make(map[string]*EnforcedCostUnit)
	canonical := g.assetGraph.GetCanonicalGraph()

	for _, nodeID := range changedNodes {
		for _, unit := range g.nodeToCosts[nodeID] {
			affected[unit.CostUnitID] = unit
		}

		dependents := canonical.GetTransitiveDependents(nodeID)
		for _, depID := range dependents {
			for _, unit := range g.nodeToCosts[depID] {
				affected[unit.CostUnitID] = unit
			}
		}
	}

	result := make([]*EnforcedCostUnit, 0, len(affected))
	for _, unit := range affected {
		result = append(result, unit)
	}
	return result
}

// GetSymbolicCosts returns all symbolic costs
func (g *EnforcedCostGraph) GetSymbolicCosts() []*EnforcedCostUnit {
	return g.symbolicCosts
}

// HasSymbolicCosts returns true if there are symbolic costs
func (g *EnforcedCostGraph) HasSymbolicCosts() bool {
	return len(g.symbolicCosts) > 0
}

// AllCostUnits returns all cost units
func (g *EnforcedCostGraph) AllCostUnits() []*EnforcedCostUnit {
	result := make([]*EnforcedCostUnit, 0, len(g.costUnits))
	for _, unit := range g.costUnits {
		result = append(result, unit)
	}
	return result
}

// GetTotalCost returns total cost (excludes symbolic)
func (g *EnforcedCostGraph) GetTotalCost() determinism.Money {
	total := determinism.Zero("USD")
	for _, unit := range g.costUnits {
		if !unit.IsSymbolic {
			total = total.Add(unit.MonthlyCost)
		}
	}
	return total
}

// GetMinConfidence returns minimum confidence (pessimistic)
func (g *EnforcedCostGraph) GetMinConfidence() float64 {
	min := 1.0
	for _, unit := range g.costUnits {
		if unit.Confidence < min {
			min = unit.Confidence
		}
	}
	return min
}

################################################################################
# FILE: :\good projects\cost estimation\core\graph\expansion_guard.go
# TYPE: go
# SIZE: 3210 bytes
################################################################################
// Package graph - Hard expansion blocking
// Unknown cardinality NEVER expands. This is non-negotiable.
package graph

import (
	"fmt"
)

// ErrUnknownCardinality is returned when expansion is blocked
var ErrUnknownCardinality = fmt.Errorf("BLOCKED: unknown cardinality - cannot expand")

// CardinalityKind indicates cardinality knowledge state
type CardinalityKind int

const (
	CardinalityKnownKind   CardinalityKind = iota
	CardinalityUnknownKind
	CardinalityRangeKind
)

// String returns the kind name
func (k CardinalityKind) String() string {
	names := []string{"known", "unknown", "range"}
	if int(k) < len(names) {
		return names[k]
	}
	return "invalid"
}

// ExpansionGuard prevents expansion of unknown cardinality
type ExpansionGuard struct {
	strictMode bool
	blocked    []BlockedExpansion
}

// BlockedExpansion records a blocked expansion
type BlockedExpansion struct {
	Address     string
	Reason      string
	Cardinality CardinalityKind
}

// NewExpansionGuard creates a guard
func NewExpansionGuard(strictMode bool) *ExpansionGuard {
	return &ExpansionGuard{
		strictMode: strictMode,
		blocked:    []BlockedExpansion{},
	}
}

// MustExpand expands if cardinality is known, blocks otherwise
// In strict mode: panics
// In permissive mode: returns error
func (g *ExpansionGuard) MustExpand(address string, cardinality CardinalityKind, count int) ([]string, error) {
	if cardinality != CardinalityKnownKind {
		blocked := BlockedExpansion{
			Address:     address,
			Reason:      fmt.Sprintf("cardinality is %s", cardinality),
			Cardinality: cardinality,
		}
		g.blocked = append(g.blocked, blocked)

		if g.strictMode {
			panic(fmt.Sprintf("STRICT MODE: cannot expand %s - %s", address, blocked.Reason))
		}
		return nil, ErrUnknownCardinality
	}

	// Known cardinality - expand
	instances := make([]string, count)
	for i := 0; i < count; i++ {
		instances[i] = fmt.Sprintf("%s[%d]", address, i)
	}
	return instances, nil
}

// MustExpandForEach expands for_each if keys are known, blocks otherwise
func (g *ExpansionGuard) MustExpandForEach(address string, cardinality CardinalityKind, keys []string) ([]string, error) {
	if cardinality != CardinalityKnownKind {
		blocked := BlockedExpansion{
			Address:     address,
			Reason:      fmt.Sprintf("for_each cardinality is %s", cardinality),
			Cardinality: cardinality,
		}
		g.blocked = append(g.blocked, blocked)

		if g.strictMode {
			panic(fmt.Sprintf("STRICT MODE: cannot expand %s - %s", address, blocked.Reason))
		}
		return nil, ErrUnknownCardinality
	}

	// Known keys - expand
	instances := make([]string, len(keys))
	for i, key := range keys {
		instances[i] = fmt.Sprintf("%s[%q]", address, key)
	}
	return instances, nil
}

// GetBlocked returns all blocked expansions
func (g *ExpansionGuard) GetBlocked() []BlockedExpansion {
	return g.blocked
}

// HasBlocked returns true if any expansions were blocked
func (g *ExpansionGuard) HasBlocked() bool {
	return len(g.blocked) > 0
}

// IsStrictMode returns whether strict mode is enabled
func (g *ExpansionGuard) IsStrictMode() bool {
	return g.strictMode
}

################################################################################
# FILE: :\good projects\cost estimation\core\graph\infrastructure.go
# TYPE: go
# SIZE: 12673 bytes
################################################################################
// Package graph - Real infrastructure dependency graph
// Resources ARE connected via actual Terraform dependencies.
// depends_on, implicit references, module outputs are ALL modeled.
package graph

import (
	"fmt"
	"sort"
	"strings"

	"terraform-cost/core/model"
)

// InfrastructureGraph is the real dependency graph modeling Terraform semantics
type InfrastructureGraph struct {
	// Nodes by address
	nodes map[string]*InfraNode

	// Edges (from â†’ to)
	edges map[string][]string

	// Reverse edges (to â†’ from) for upstream lookups
	reverseEdges map[string][]string

	// Module hierarchy
	modules map[string]*ModuleNode

	// Topologically sorted order (computed lazily)
	topoOrder []string
	topoValid bool
}

// InfraNode is a node in the infrastructure graph
type InfraNode struct {
	// Identity
	Address    string
	Type       NodeType
	ModulePath string

	// Source definition
	DefinitionID model.DefinitionID
	SourceFile   string
	SourceLine   int

	// Dependencies
	ExplicitDeps   []string // depends_on
	ImplicitDeps   []string // expression references
	ProviderDep    string   // provider binding
	ModuleOutputs  []string // if this is a module output

	// Expansion state
	IsExpanded    bool
	ExpandedFrom  string   // parent definition address
	InstanceKey   interface{}
	SiblingCount  int

	// Lineage
	Lineage *NodeLineage
}

// NodeType indicates the type of infrastructure node
type NodeType int

const (
	NodeResource   NodeType = iota // resource block
	NodeDataSource                  // data block
	NodeModule                      // module block
	NodeVariable                    // variable
	NodeLocal                       // local value
	NodeOutput                      // output
	NodeProvider                    // provider config
)

// String returns the node type name
func (t NodeType) String() string {
	switch t {
	case NodeResource:
		return "resource"
	case NodeDataSource:
		return "data"
	case NodeModule:
		return "module"
	case NodeVariable:
		return "variable"
	case NodeLocal:
		return "local"
	case NodeOutput:
		return "output"
	case NodeProvider:
		return "provider"
	default:
		return "unknown"
	}
}

// NodeLineage tracks the complete derivation of a node
type NodeLineage struct {
	// Expression references that led to this node
	ExpressionRefs []ExpressionRef

	// Module call chain
	ModuleChain []string

	// Provider inheritance chain
	ProviderChain []string

	// Count/for_each expansion path
	ExpansionPath []ExpansionStep
}

// ExpressionRef is a reference from an expression
type ExpressionRef struct {
	FromAttribute string  // e.g., "subnet_id"
	ToAddress     string  // e.g., "aws_subnet.main"
	RefType       RefType
}

// RefType indicates the type of reference
type RefType int

const (
	RefDirect     RefType = iota // Direct resource reference
	RefAttribute                  // Attribute reference (resource.attr)
	RefSplat                      // Splat reference (resource[*].attr)
	RefIndex                      // Index reference (resource[0].attr)
	RefEach                       // each.value reference
	RefCount                      // count.index reference
)

// ExpansionStep records a single expansion step
type ExpansionStep struct {
	Type  string      // "count" or "for_each"
	Key   interface{} // index or key
	From  string      // parent address
}

// ModuleNode represents a module in the hierarchy
type ModuleNode struct {
	Path       string
	Source     string
	ParentPath string
	Inputs     map[string]string // input variable â†’ source expression
	Outputs    map[string]string // output name â†’ expression
	Providers  map[string]string // provider mapping
	Children   []string          // child module paths
}

// NewInfrastructureGraph creates a new graph
func NewInfrastructureGraph() *InfrastructureGraph {
	return &InfrastructureGraph{
		nodes:        make(map[string]*InfraNode),
		edges:        make(map[string][]string),
		reverseEdges: make(map[string][]string),
		modules:      make(map[string]*ModuleNode),
		topoValid:    false,
	}
}

// AddNode adds a node to the graph
func (g *InfrastructureGraph) AddNode(node *InfraNode) {
	g.nodes[node.Address] = node
	g.topoValid = false
}

// AddEdge adds a dependency edge (from depends on to)
func (g *InfrastructureGraph) AddEdge(from, to string) {
	g.edges[from] = append(g.edges[from], to)
	g.reverseEdges[to] = append(g.reverseEdges[to], from)
	g.topoValid = false
}

// AddModule registers a module
func (g *InfrastructureGraph) AddModule(module *ModuleNode) {
	g.modules[module.Path] = module
}

// GetNode returns a node by address
func (g *InfrastructureGraph) GetNode(address string) *InfraNode {
	return g.nodes[address]
}

// GetDependencies returns direct dependencies of a node
func (g *InfrastructureGraph) GetDependencies(address string) []string {
	return g.edges[address]
}

// GetDependents returns nodes that depend on this node
func (g *InfrastructureGraph) GetDependents(address string) []string {
	return g.reverseEdges[address]
}

// GetTransitiveDependencies returns all dependencies (recursive)
func (g *InfrastructureGraph) GetTransitiveDependencies(address string) []string {
	visited := make(map[string]bool)
	result := []string{}
	g.collectDeps(address, visited, &result)
	return result
}

func (g *InfrastructureGraph) collectDeps(address string, visited map[string]bool, result *[]string) {
	for _, dep := range g.edges[address] {
		if !visited[dep] {
			visited[dep] = true
			*result = append(*result, dep)
			g.collectDeps(dep, visited, result)
		}
	}
}

// GetTransitiveDependents returns all dependents (recursive)
func (g *InfrastructureGraph) GetTransitiveDependents(address string) []string {
	visited := make(map[string]bool)
	result := []string{}
	g.collectDependents(address, visited, &result)
	return result
}

func (g *InfrastructureGraph) collectDependents(address string, visited map[string]bool, result *[]string) {
	for _, dep := range g.reverseEdges[address] {
		if !visited[dep] {
			visited[dep] = true
			*result = append(*result, dep)
			g.collectDependents(dep, visited, result)
		}
	}
}

// TopologicalSort returns nodes in dependency order
func (g *InfrastructureGraph) TopologicalSort() ([]string, error) {
	if g.topoValid {
		return g.topoOrder, nil
	}

	visited := make(map[string]bool)
	temp := make(map[string]bool)
	order := []string{}

	var visit func(n string) error
	visit = func(n string) error {
		if temp[n] {
			return &CycleError{Node: n}
		}
		if visited[n] {
			return nil
		}
		temp[n] = true
		for _, dep := range g.edges[n] {
			if err := visit(dep); err != nil {
				return err
			}
		}
		temp[n] = false
		visited[n] = true
		order = append(order, n)
		return nil
	}

	// Sort nodes for determinism
	nodes := make([]string, 0, len(g.nodes))
	for addr := range g.nodes {
		nodes = append(nodes, addr)
	}
	sort.Strings(nodes)

	for _, n := range nodes {
		if err := visit(n); err != nil {
			return nil, err
		}
	}

	// Reverse for correct order
	for i, j := 0, len(order)-1; i < j; i, j = i+1, j-1 {
		order[i], order[j] = order[j], order[i]
	}

	g.topoOrder = order
	g.topoValid = true
	return order, nil
}

// CycleError indicates a dependency cycle
type CycleError struct {
	Node string
}

func (e *CycleError) Error() string {
	return fmt.Sprintf("dependency cycle detected at %s", e.Node)
}

// GetResourcesInModule returns all resources in a module
func (g *InfrastructureGraph) GetResourcesInModule(modulePath string) []*InfraNode {
	var result []*InfraNode
	for _, node := range g.nodes {
		if node.ModulePath == modulePath && node.Type == NodeResource {
			result = append(result, node)
		}
	}
	return result
}

// Size returns the number of nodes
func (g *InfrastructureGraph) Size() int {
	return len(g.nodes)
}

// EdgeCount returns the number of edges
func (g *InfrastructureGraph) EdgeCount() int {
	count := 0
	for _, deps := range g.edges {
		count += len(deps)
	}
	return count
}

// InfraGraphBuilder builds infrastructure graphs from parsed Terraform
type InfraGraphBuilder struct {
	graph *InfrastructureGraph
}

// NewInfraGraphBuilder creates a builder
func NewInfraGraphBuilder() *InfraGraphBuilder {
	return &InfraGraphBuilder{
		graph: NewInfrastructureGraph(),
	}
}

// Build creates the graph from parsed module
func (b *InfraGraphBuilder) Build(parsed *ParsedInfra) (*InfrastructureGraph, error) {
	// Add all resources
	for _, res := range parsed.Resources {
		node := &InfraNode{
			Address:      res.Address,
			Type:         NodeResource,
			ModulePath:   res.ModulePath,
			DefinitionID: res.DefinitionID,
			SourceFile:   res.SourceFile,
			SourceLine:   res.SourceLine,
			ExplicitDeps: res.DependsOn,
			ImplicitDeps: res.ImplicitRefs,
			ProviderDep:  res.Provider,
			Lineage:      b.buildLineage(res),
		}
		b.graph.AddNode(node)
	}

	// Add data sources
	for _, data := range parsed.DataSources {
		node := &InfraNode{
			Address:      data.Address,
			Type:         NodeDataSource,
			ModulePath:   data.ModulePath,
			ImplicitDeps: data.ImplicitRefs,
		}
		b.graph.AddNode(node)
	}

	// Add modules
	for _, mod := range parsed.Modules {
		moduleNode := &ModuleNode{
			Path:       mod.Path,
			Source:     mod.Source,
			ParentPath: mod.ParentPath,
			Inputs:     mod.Inputs,
			Outputs:    mod.Outputs,
			Providers:  mod.Providers,
		}
		b.graph.AddModule(moduleNode)
	}

	// Build edges from dependencies
	for addr, node := range b.graph.nodes {
		// Explicit depends_on
		for _, dep := range node.ExplicitDeps {
			if _, exists := b.graph.nodes[dep]; exists {
				b.graph.AddEdge(addr, dep)
			}
		}
		// Implicit references
		for _, ref := range node.ImplicitDeps {
			// Normalize reference to resource address
			targetAddr := b.normalizeReference(ref)
			if _, exists := b.graph.nodes[targetAddr]; exists {
				b.graph.AddEdge(addr, targetAddr)
			}
		}
	}

	return b.graph, nil
}

func (b *InfraGraphBuilder) normalizeReference(ref string) string {
	// aws_instance.web.id â†’ aws_instance.web
	// module.vpc.aws_subnet.main[0] â†’ module.vpc.aws_subnet.main
	parts := strings.Split(ref, ".")
	if len(parts) >= 2 {
		// Check for index
		if idx := strings.Index(parts[1], "["); idx != -1 {
			parts[1] = parts[1][:idx]
		}
		return parts[0] + "." + parts[1]
	}
	return ref
}

func (b *InfraGraphBuilder) buildLineage(res *ParsedResource) *NodeLineage {
	lineage := &NodeLineage{
		ExpressionRefs: []ExpressionRef{},
		ModuleChain:    []string{},
		ExpansionPath:  []ExpansionStep{},
	}

	// Build expression refs
	for attr, refs := range res.AttributeRefs {
		for _, ref := range refs {
			lineage.ExpressionRefs = append(lineage.ExpressionRefs, ExpressionRef{
				FromAttribute: attr,
				ToAddress:     ref,
				RefType:       b.classifyRef(ref),
			})
		}
	}

	// Build module chain
	if res.ModulePath != "" {
		parts := strings.Split(res.ModulePath, ".")
		for i := range parts {
			lineage.ModuleChain = append(lineage.ModuleChain, strings.Join(parts[:i+1], "."))
		}
	}

	return lineage
}

func (b *InfraGraphBuilder) classifyRef(ref string) RefType {
	if strings.Contains(ref, "[*]") {
		return RefSplat
	}
	if strings.Contains(ref, "[") {
		return RefIndex
	}
	if strings.Contains(ref, "each.") {
		return RefEach
	}
	if strings.Contains(ref, "count.") {
		return RefCount
	}
	if strings.Count(ref, ".") > 1 {
		return RefAttribute
	}
	return RefDirect
}

// ParsedInfra is the input to the graph builder
type ParsedInfra struct {
	Resources   []*ParsedResource
	DataSources []*ParsedDataSource
	Modules     []*ParsedModule
}

// ParsedResource is a parsed resource block
type ParsedResource struct {
	Address       string
	ModulePath    string
	DefinitionID  model.DefinitionID
	SourceFile    string
	SourceLine    int
	DependsOn     []string
	ImplicitRefs  []string
	Provider      string
	AttributeRefs map[string][]string // attribute â†’ references
}

// ParsedDataSource is a parsed data block
type ParsedDataSource struct {
	Address      string
	ModulePath   string
	ImplicitRefs []string
}

// ParsedModule is a parsed module block
type ParsedModule struct {
	Path       string
	Source     string
	ParentPath string
	Inputs     map[string]string
	Outputs    map[string]string
	Providers  map[string]string
}

################################################################################
# FILE: :\good projects\cost estimation\core\graph\invariant_checker.go
# TYPE: go
# SIZE: 5379 bytes
################################################################################
// Package graph - Invariant assertions and tests
// These assertions verify correctness at boundaries.
// They intentionally try to violate rules to ensure enforcement works.
package graph

import (
	"fmt"
)

// InvariantViolation represents a detected invariant violation
type InvariantViolation struct {
	Invariant string
	Location  string
	Details   string
}

func (v *InvariantViolation) Error() string {
	return fmt.Sprintf("INVARIANT VIOLATED [%s] at %s: %s", v.Invariant, v.Location, v.Details)
}

// InvariantChecker verifies all architectural invariants
type InvariantChecker struct {
	violations []InvariantViolation
	strictMode bool
}

// NewInvariantChecker creates a checker
func NewInvariantChecker(strictMode bool) *InvariantChecker {
	return &InvariantChecker{
		violations: []InvariantViolation{},
		strictMode: strictMode,
	}
}

// AssertDepGraphClosed asserts dependency graph is closed
func (c *InvariantChecker) AssertDepGraphClosed(g *CanonicalDependencyGraph) error {
	if g == nil {
		return c.fail("DEP_GRAPH_EXISTS", "AssertDepGraphClosed", "dependency graph is nil")
	}
	if !g.IsSealed() {
		return c.fail("DEP_GRAPH_SEALED", "AssertDepGraphClosed", "dependency graph not sealed")
	}
	if !g.IsTransitivelyClosed() {
		return c.fail("DEP_GRAPH_CLOSED", "AssertDepGraphClosed", "dependency graph not transitively closed")
	}
	return nil
}

// AssertAssetHasDepNode asserts asset has a dependency node
func (c *InvariantChecker) AssertAssetHasDepNode(asset *EnforcedAsset) error {
	if asset == nil {
		return c.fail("ASSET_EXISTS", "AssertAssetHasDepNode", "asset is nil")
	}
	if asset.DependencyNodeID == "" {
		return c.fail("ASSET_HAS_DEP_NODE", "AssertAssetHasDepNode", 
			fmt.Sprintf("asset %s has no DependencyNodeID", asset.AssetID))
	}
	return nil
}

// AssertCostUnitHasPath asserts cost unit has dependency path
func (c *InvariantChecker) AssertCostUnitHasPath(unit *EnforcedCostUnit) error {
	if unit == nil {
		return c.fail("COST_UNIT_EXISTS", "AssertCostUnitHasPath", "cost unit is nil")
	}
	if len(unit.DependencyPath) == 0 {
		return c.fail("COST_UNIT_HAS_PATH", "AssertCostUnitHasPath",
			fmt.Sprintf("cost unit %s has no dependency path", unit.CostUnitID))
	}
	return nil
}

// AssertNoNumericCostForUnknown asserts unknown cardinality has no numeric cost
func (c *InvariantChecker) AssertNoNumericCostForUnknown(unit *EnforcedCostUnit) error {
	if unit == nil {
		return nil
	}
	if unit.IsSymbolic {
		// Symbolic costs must not have numeric values
		if !unit.MonthlyCost.IsZero() {
			return c.fail("NO_NUMERIC_FOR_UNKNOWN", "AssertNoNumericCostForUnknown",
				fmt.Sprintf("symbolic cost unit %s has non-zero monthly cost", unit.CostUnitID))
		}
	}
	return nil
}

// AssertCardinalityKnownForExpansion asserts cardinality is known before expansion
func (c *InvariantChecker) AssertCardinalityKnownForExpansion(address string, cardinality CardinalityKind) error {
	if cardinality != CardinalityKnownKind {
		return c.fail("CARDINALITY_KNOWN", "AssertCardinalityKnownForExpansion",
			fmt.Sprintf("cannot expand %s with %s cardinality", address, cardinality))
	}
	return nil
}

// AssertConfidencePessimistic asserts confidence is pessimistic (MIN)
func (c *InvariantChecker) AssertConfidencePessimistic(aggregate float64, components []float64) error {
	if len(components) == 0 {
		return nil
	}
	min := 1.0
	for _, v := range components {
		if v < min {
			min = v
		}
	}
	if aggregate > min {
		return c.fail("CONFIDENCE_PESSIMISTIC", "AssertConfidencePessimistic",
			fmt.Sprintf("aggregate confidence %.2f exceeds minimum component %.2f", aggregate, min))
	}
	return nil
}

func (c *InvariantChecker) fail(invariant, location, details string) error {
	v := InvariantViolation{
		Invariant: invariant,
		Location:  location,
		Details:   details,
	}
	c.violations = append(c.violations, v)
	
	if c.strictMode {
		panic(v.Error())
	}
	return &v
}

// GetViolations returns all recorded violations
func (c *InvariantChecker) GetViolations() []InvariantViolation {
	return c.violations
}

// HasViolations returns true if any violations occurred
func (c *InvariantChecker) HasViolations() bool {
	return len(c.violations) > 0
}

// RunFullCheck runs all invariant checks on a cost graph
func (c *InvariantChecker) RunFullCheck(costGraph *EnforcedCostGraph) error {
	if costGraph == nil {
		return c.fail("COST_GRAPH_EXISTS", "RunFullCheck", "cost graph is nil")
	}

	for _, unit := range costGraph.AllCostUnits() {
		if err := c.AssertCostUnitHasPath(unit); err != nil && c.strictMode {
			return err
		}
		if err := c.AssertNoNumericCostForUnknown(unit); err != nil && c.strictMode {
			return err
		}
	}

	// Check pessimistic confidence
	confidences := []float64{}
	for _, unit := range costGraph.AllCostUnits() {
		confidences = append(confidences, unit.Confidence)
	}
	aggregate := costGraph.GetMinConfidence()
	if err := c.AssertConfidencePessimistic(aggregate, confidences); err != nil && c.strictMode {
		return err
	}

	return nil
}

// BlockBypassAttempt blocks any attempt to bypass dependency semantics
func BlockBypassAttempt(description string) {
	panic(fmt.Sprintf("BYPASS BLOCKED: %s - cost logic must go through dependency graph", description))
}

################################################################################
# FILE: :\good projects\cost estimation\core\graph\invariant_test.go
# TYPE: go
# SIZE: 4371 bytes
################################################################################
// Package graph_test - Invariant violation tests
// These tests INTENTIONALLY try to violate rules to ensure enforcement works.
package graph_test

import (
	"testing"

	"terraform-cost/core/graph"
)

// TestBypassAttempts verifies that bypass attempts panic
func TestBypassAttempts(t *testing.T) {
	tests := []struct {
		name     string
		fn       func()
		expected string
	}{
		{
			name: "NewCostUnitFromAssetDirect",
			fn: func() {
				graph.NewCostUnitFromAssetDirect("test-asset")
			},
			expected: "BYPASS BLOCKED",
		},
		{
			name: "NewCostGraphWithoutDepGraph",
			fn: func() {
				graph.NewCostGraphWithoutDepGraph()
			},
			expected: "BYPASS BLOCKED",
		},
		{
			name: "ExpandWithoutCardinalityCheck",
			fn: func() {
				graph.ExpandWithoutCardinalityCheck("aws_instance.test", 5)
			},
			expected: "BYPASS BLOCKED",
		},
		{
			name: "CreateNumericCostForUnknown",
			fn: func() {
				graph.CreateNumericCostForUnknown("aws_instance.test", 100.0)
			},
			expected: "BYPASS BLOCKED",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				r := recover()
				if r == nil {
					t.Errorf("%s did not panic", tt.name)
					return
				}
				msg, ok := r.(string)
				if !ok {
					t.Errorf("%s panicked with non-string: %v", tt.name, r)
					return
				}
				if len(msg) < len(tt.expected) || msg[:len(tt.expected)] != tt.expected {
					t.Errorf("%s panicked with wrong message: %s", tt.name, msg)
				}
			}()
			tt.fn()
		})
	}
}

// TestUnsealedGraphPanics verifies unsealed graph panics
func TestUnsealedGraphPanics(t *testing.T) {
	g := graph.NewCanonicalDependencyGraph()
	g.AddNode(&graph.NodeMeta{
		ID:      "test",
		Address: "aws_instance.test",
	})
	// Don't seal

	defer func() {
		r := recover()
		if r == nil {
			t.Error("MustBeClosed did not panic on unsealed graph")
		}
	}()

	g.MustBeClosed()
}

// TestExpansionGuardStrict verifies strict mode panics on unknown cardinality
func TestExpansionGuardStrict(t *testing.T) {
	guard := graph.NewExpansionGuard(true) // strict mode

	defer func() {
		r := recover()
		if r == nil {
			t.Error("MustExpand did not panic on unknown cardinality in strict mode")
		}
	}()

	_, _ = guard.MustExpand("aws_instance.test", graph.CardinalityUnknownKind, 5)
}

// TestExpansionGuardPermissive verifies permissive mode returns error
func TestExpansionGuardPermissive(t *testing.T) {
	guard := graph.NewExpansionGuard(false) // permissive mode

	instances, err := guard.MustExpand("aws_instance.test", graph.CardinalityUnknownKind, 5)
	if err == nil {
		t.Error("MustExpand should return error on unknown cardinality")
	}
	if instances != nil {
		t.Error("MustExpand should return nil instances on unknown cardinality")
	}
	if !guard.HasBlocked() {
		t.Error("MustExpand should record blocked expansion")
	}
}

// TestInvariantCheckerStrict verifies strict checker panics
func TestInvariantCheckerStrict(t *testing.T) {
	checker := graph.NewInvariantChecker(true) // strict mode

	defer func() {
		r := recover()
		if r == nil {
			t.Error("AssertAssetHasDepNode did not panic on nil asset")
		}
	}()

	_ = checker.AssertAssetHasDepNode(nil)
}

// TestInvariantCheckerPermissive verifies permissive checker records violations
func TestInvariantCheckerPermissive(t *testing.T) {
	checker := graph.NewInvariantChecker(false) // permissive mode

	// Should not panic
	err := checker.AssertAssetHasDepNode(nil)
	if err == nil {
		t.Error("AssertAssetHasDepNode should return error on nil asset")
	}

	if !checker.HasViolations() {
		t.Error("Checker should record violation")
	}
}

// TestConfidencePessimistic verifies confidence aggregation is pessimistic
func TestConfidencePessimistic(t *testing.T) {
	checker := graph.NewInvariantChecker(true)

	// Valid: aggregate equals minimum
	err := checker.AssertConfidencePessimistic(0.5, []float64{0.9, 0.7, 0.5})
	if err != nil {
		t.Errorf("Valid pessimistic confidence rejected: %v", err)
	}

	// Invalid: aggregate exceeds minimum
	defer func() {
		r := recover()
		if r == nil {
			t.Error("AssertConfidencePessimistic did not panic on optimistic aggregation")
		}
	}()

	_ = checker.AssertConfidencePessimistic(0.8, []float64{0.9, 0.7, 0.5})
}

################################################################################
# FILE: :\good projects\cost estimation\core\guards\invariants.go
# TYPE: go
# SIZE: 5607 bytes
################################################################################
// Package guards - Runtime assertion guards
// These assertions PANIC if violated - there is no recovery.
package guards

import (
	"fmt"

	"terraform-cost/core/graph"
	"terraform-cost/core/terraform"
)

// InvariantEnforcer enforces critical architectural invariants
type InvariantEnforcer struct {
	dependencyGraphBuilt bool
	providersFrozen      bool
	expansionComplete    bool
	costGraphBuilt       bool
	pricingComplete      bool
	depGraph            *graph.InfrastructureGraph
	finalizer           *terraform.ProviderFinalizer
}

// NewInvariantEnforcer creates an enforcer
func NewInvariantEnforcer() *InvariantEnforcer {
	return &InvariantEnforcer{}
}

// MarkDependencyGraphBuilt marks the dependency graph as built
func (e *InvariantEnforcer) MarkDependencyGraphBuilt(g *graph.InfrastructureGraph) {
	if g == nil {
		panic("INVARIANT VIOLATED: dependency graph cannot be nil")
	}
	e.depGraph = g
	e.dependencyGraphBuilt = true
}

// MarkProvidersFrozen marks providers as frozen
func (e *InvariantEnforcer) MarkProvidersFrozen(f *terraform.ProviderFinalizer) {
	if !e.dependencyGraphBuilt {
		panic("INVARIANT VIOLATED: providers cannot be frozen before dependency graph is built")
	}
	if f == nil {
		panic("INVARIANT VIOLATED: provider finalizer cannot be nil")
	}
	if !f.IsFinalized() {
		panic("INVARIANT VIOLATED: provider finalizer must be finalized before marking frozen")
	}
	e.finalizer = f
	e.providersFrozen = true
}

// MarkExpansionComplete marks expansion as complete
func (e *InvariantEnforcer) MarkExpansionComplete() {
	if !e.providersFrozen {
		panic("INVARIANT VIOLATED: expansion cannot complete before providers are frozen")
	}
	e.expansionComplete = true
}

// MarkCostGraphBuilt marks cost graph as built
func (e *InvariantEnforcer) MarkCostGraphBuilt() {
	if !e.expansionComplete {
		panic("INVARIANT VIOLATED: cost graph cannot be built before expansion is complete")
	}
	e.costGraphBuilt = true
}

// MarkPricingComplete marks pricing as complete
func (e *InvariantEnforcer) MarkPricingComplete() {
	if !e.costGraphBuilt {
		panic("INVARIANT VIOLATED: pricing cannot complete before cost graph is built")
	}
	e.pricingComplete = true
}

// AssertDependencyGraphBuilt asserts dependency graph is built
func (e *InvariantEnforcer) AssertDependencyGraphBuilt() {
	if !e.dependencyGraphBuilt {
		panic("ASSERTION FAILED: dependency graph not built")
	}
}

// AssertProvidersFrozen asserts providers are frozen
func (e *InvariantEnforcer) AssertProvidersFrozen() {
	if !e.providersFrozen {
		panic("ASSERTION FAILED: providers not frozen")
	}
}

// AssertExpansionComplete asserts expansion is complete
func (e *InvariantEnforcer) AssertExpansionComplete() {
	if !e.expansionComplete {
		panic("ASSERTION FAILED: expansion not complete")
	}
}

// AssertCostGraphBuilt asserts cost graph is built
func (e *InvariantEnforcer) AssertCostGraphBuilt() {
	if !e.costGraphBuilt {
		panic("ASSERTION FAILED: cost graph not built")
	}
}

// AssertCanPrice asserts pricing is allowed for an address
func (e *InvariantEnforcer) AssertCanPrice(address string) {
	e.AssertProvidersFrozen()
	e.AssertExpansionComplete()
	e.AssertCostGraphBuilt()
}

// AssertNodeInDependencyGraph asserts a node exists in the dependency graph
func (e *InvariantEnforcer) AssertNodeInDependencyGraph(address string) {
	e.AssertDependencyGraphBuilt()
	if e.depGraph.GetNode(address) == nil {
		panic(fmt.Sprintf("ASSERTION FAILED: node %s not in dependency graph", address))
	}
}

// GuardedExpansion ensures expansion only happens after providers are frozen
type GuardedExpansion struct {
	enforcer            *InvariantEnforcer
	cardinalityWarnings []string
}

// NewGuardedExpansion creates guarded expansion
func NewGuardedExpansion(enforcer *InvariantEnforcer) *GuardedExpansion {
	return &GuardedExpansion{
		enforcer:            enforcer,
		cardinalityWarnings: []string{},
	}
}

// ExpandResource expands a resource, respecting invariants
func (g *GuardedExpansion) ExpandResource(address string, count int, isCountKnown bool) ([]string, error) {
	g.enforcer.AssertProvidersFrozen()

	if !isCountKnown {
		g.cardinalityWarnings = append(g.cardinalityWarnings,
			fmt.Sprintf("CARDINALITY UNKNOWN: %s - not expanded", address))
		return nil, &UnknownCardinalityError{Address: address, Type: "count"}
	}

	instances := make([]string, count)
	for i := 0; i < count; i++ {
		instances[i] = fmt.Sprintf("%s[%d]", address, i)
	}
	return instances, nil
}

// ExpandForEach expands for_each, respecting invariants
func (g *GuardedExpansion) ExpandForEach(address string, keys []string, isKeysKnown bool) ([]string, error) {
	g.enforcer.AssertProvidersFrozen()

	if !isKeysKnown {
		g.cardinalityWarnings = append(g.cardinalityWarnings,
			fmt.Sprintf("CARDINALITY UNKNOWN: %s - not expanded", address))
		return nil, &UnknownCardinalityError{Address: address, Type: "for_each"}
	}

	instances := make([]string, len(keys))
	for i, key := range keys {
		instances[i] = fmt.Sprintf("%s[%q]", address, key)
	}
	return instances, nil
}

// GetWarnings returns cardinality warnings
func (g *GuardedExpansion) GetWarnings() []string {
	return g.cardinalityWarnings
}

// UnknownCardinalityError indicates expansion was blocked
type UnknownCardinalityError struct {
	Address string
	Type    string
}

func (e *UnknownCardinalityError) Error() string {
	return fmt.Sprintf("%s at %s is unknown - expansion blocked", e.Type, e.Address)
}

################################################################################
# FILE: :\good projects\cost estimation\core\input\envelope.go
# TYPE: go
# SIZE: 8741 bytes
################################################################################
// Package input - Normalized input envelope
// EVERYTHING downstream consumes this only.
// Decouples CLI, Git, API semantics from Terraform parsing.
package input

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"time"
)

// Envelope is the normalized input to the estimation engine
// All sources (CLI, Git, API) produce this format
type Envelope struct {
	// Source information
	Source SourceInfo

	// Normalized filesystem
	FileSystem *NormalizedFS

	// Context
	Workspace  string
	Variables  map[string]interface{}
	VarFiles   []string

	// Metadata
	Metadata EnvelopeMetadata
}

// SourceInfo describes where the input came from
type SourceInfo struct {
	Type      SourceType
	Path      string            // For CLI: local path
	RepoURL   string            // For Git: repository URL
	CommitSHA string            // For Git: commit hash
	Branch    string            // For Git: branch name
	PRNumber  int               // For Git: PR number if applicable
	APISource string            // For API: source identifier
	Tags      map[string]string // Additional tags
}

// SourceType indicates the source of input
type SourceType int

const (
	SourceCLI SourceType = iota // Local CLI invocation
	SourceGit                    // Git repository
	SourceAPI                    // API request
	SourceCI                     // CI/CD pipeline
)

// String returns the source type name
func (t SourceType) String() string {
	switch t {
	case SourceCLI:
		return "cli"
	case SourceGit:
		return "git"
	case SourceAPI:
		return "api"
	case SourceCI:
		return "ci"
	default:
		return "unknown"
	}
}

// NormalizedFS is a normalized representation of the filesystem
type NormalizedFS struct {
	// Root path (virtual)
	Root string

	// Files by path
	Files map[string]*NormalizedFile

	// Content hash of entire FS
	ContentHash string

	// Stats
	TotalFiles int
	TotalBytes int64
}

// NormalizedFile is a normalized file
type NormalizedFile struct {
	Path        string
	Content     []byte
	ContentHash string
	ModTime     time.Time
	Size        int64
}

// EnvelopeMetadata contains metadata about the envelope
type EnvelopeMetadata struct {
	CreatedAt   time.Time
	Version     string
	EngineID    string
	ReplayToken string // For CI reproducibility
}

// NewEnvelope creates a new envelope from a source
func NewEnvelope(source SourceInfo) *Envelope {
	return &Envelope{
		Source:    source,
		Workspace: "default",
		Variables: make(map[string]interface{}),
		VarFiles:  []string{},
		Metadata: EnvelopeMetadata{
			CreatedAt: time.Now().UTC(),
			Version:   "1.0",
		},
	}
}

// NewEnvelopeFromCLI creates an envelope from CLI input
func NewEnvelopeFromCLI(path string, workspace string, vars map[string]interface{}) (*Envelope, error) {
	env := NewEnvelope(SourceInfo{
		Type: SourceCLI,
		Path: path,
	})
	env.Workspace = workspace
	env.Variables = vars

	// Normalize filesystem
	nfs, err := NormalizeDirectory(path)
	if err != nil {
		return nil, fmt.Errorf("failed to normalize filesystem: %w", err)
	}
	env.FileSystem = nfs

	// Generate replay token
	env.Metadata.ReplayToken = generateReplayToken(env)

	return env, nil
}

// NewEnvelopeFromGit creates an envelope from Git input
func NewEnvelopeFromGit(repoURL, commitSHA, branch string) *Envelope {
	return NewEnvelope(SourceInfo{
		Type:      SourceGit,
		RepoURL:   repoURL,
		CommitSHA: commitSHA,
		Branch:    branch,
	})
}

// NormalizeDirectory creates a normalized FS from a directory
func NormalizeDirectory(root string) (*NormalizedFS, error) {
	nfs := &NormalizedFS{
		Root:  root,
		Files: make(map[string]*NormalizedFile),
	}

	err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Skip directories
		if d.IsDir() {
			// Skip hidden directories
			if d.Name()[0] == '.' && d.Name() != "." {
				return filepath.SkipDir
			}
			return nil
		}

		// Only include .tf and .tfvars files
		ext := filepath.Ext(path)
		if ext != ".tf" && ext != ".tfvars" {
			return nil
		}

		// Read file
		content, err := os.ReadFile(path)
		if err != nil {
			return err
		}

		// Get relative path
		relPath, err := filepath.Rel(root, path)
		if err != nil {
			return err
		}

		// Normalize path separators
		relPath = filepath.ToSlash(relPath)

		info, _ := d.Info()
		modTime := time.Time{}
		if info != nil {
			modTime = info.ModTime()
		}

		nfs.Files[relPath] = &NormalizedFile{
			Path:        relPath,
			Content:     content,
			ContentHash: hashContent(content),
			ModTime:     modTime,
			Size:        int64(len(content)),
		}

		nfs.TotalFiles++
		nfs.TotalBytes += int64(len(content))

		return nil
	})

	if err != nil {
		return nil, err
	}

	// Compute overall hash
	nfs.ContentHash = nfs.computeHash()

	return nfs, nil
}

func (nfs *NormalizedFS) computeHash() string {
	h := sha256.New()

	// Sort paths for determinism
	paths := make([]string, 0, len(nfs.Files))
	for p := range nfs.Files {
		paths = append(paths, p)
	}
	sort.Strings(paths)

	for _, p := range paths {
		h.Write([]byte(p))
		h.Write([]byte{0})
		h.Write([]byte(nfs.Files[p].ContentHash))
		h.Write([]byte{0})
	}

	return hex.EncodeToString(h.Sum(nil))
}

func hashContent(content []byte) string {
	h := sha256.Sum256(content)
	return hex.EncodeToString(h[:])
}

func generateReplayToken(env *Envelope) string {
	h := sha256.New()
	h.Write([]byte(env.Source.Type.String()))
	h.Write([]byte(env.Source.Path))
	h.Write([]byte(env.Workspace))
	if env.FileSystem != nil {
		h.Write([]byte(env.FileSystem.ContentHash))
	}
	h.Write([]byte(env.Metadata.CreatedAt.Format(time.RFC3339)))
	return hex.EncodeToString(h.Sum(nil))[:16]
}

// GetFile returns a file by path
func (nfs *NormalizedFS) GetFile(path string) *NormalizedFile {
	return nfs.Files[path]
}

// GetTerraformFiles returns all .tf files
func (nfs *NormalizedFS) GetTerraformFiles() []*NormalizedFile {
	var result []*NormalizedFile
	for path, f := range nfs.Files {
		if filepath.Ext(path) == ".tf" {
			result = append(result, f)
		}
	}
	// Sort for determinism
	sort.Slice(result, func(i, j int) bool {
		return result[i].Path < result[j].Path
	})
	return result
}

// GetVarFiles returns all .tfvars files
func (nfs *NormalizedFS) GetVarFiles() []*NormalizedFile {
	var result []*NormalizedFile
	for path, f := range nfs.Files {
		if filepath.Ext(path) == ".tfvars" {
			result = append(result, f)
		}
	}
	sort.Slice(result, func(i, j int) bool {
		return result[i].Path < result[j].Path
	})
	return result
}

// EnvelopeValidator validates an envelope
type EnvelopeValidator struct {
	errors []string
}

// NewEnvelopeValidator creates a validator
func NewEnvelopeValidator() *EnvelopeValidator {
	return &EnvelopeValidator{
		errors: []string{},
	}
}

// Validate validates an envelope
func (v *EnvelopeValidator) Validate(env *Envelope) []string {
	v.errors = []string{}

	// Must have source type
	if env.Source.Type < SourceCLI || env.Source.Type > SourceCI {
		v.errors = append(v.errors, "invalid source type")
	}

	// CLI must have path
	if env.Source.Type == SourceCLI && env.Source.Path == "" {
		v.errors = append(v.errors, "CLI source must have path")
	}

	// Git must have repo and commit
	if env.Source.Type == SourceGit {
		if env.Source.RepoURL == "" {
			v.errors = append(v.errors, "Git source must have repo URL")
		}
		if env.Source.CommitSHA == "" {
			v.errors = append(v.errors, "Git source must have commit SHA")
		}
	}

	// Must have filesystem
	if env.FileSystem == nil {
		v.errors = append(v.errors, "envelope must have normalized filesystem")
	} else if len(env.FileSystem.Files) == 0 {
		v.errors = append(v.errors, "no Terraform files found")
	}

	return v.errors
}

// IsReplayable returns true if the envelope can be replayed
func (env *Envelope) IsReplayable() bool {
	return env.Metadata.ReplayToken != "" &&
		env.FileSystem != nil &&
		env.FileSystem.ContentHash != ""
}

// GetReplayInfo returns info needed to replay this envelope
func (env *Envelope) GetReplayInfo() map[string]string {
	info := map[string]string{
		"replay_token":  env.Metadata.ReplayToken,
		"content_hash":  "",
		"source_type":   env.Source.Type.String(),
		"workspace":     env.Workspace,
		"created_at":    env.Metadata.CreatedAt.Format(time.RFC3339),
	}
	if env.FileSystem != nil {
		info["content_hash"] = env.FileSystem.ContentHash
	}
	return info
}

################################################################################
# FILE: :\good projects\cost estimation\core\model\definition.go
# TYPE: go
# SIZE: 11788 bytes
################################################################################
// Package model provides the core domain model with strict separation
// between definitions (static) and instances (expanded).
package model

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"sort"
	"time"
)

// DefinitionID uniquely identifies an asset definition (hash-based, stable)
type DefinitionID string

// InstanceID uniquely identifies an expanded instance
type InstanceID string

// InstanceAddress is the full Terraform address with index
// Examples: "aws_instance.web[0]", "module.app.aws_s3_bucket.data[\"logs\"]"
type InstanceAddress string

// DefinitionAddress is the address without index
// Examples: "aws_instance.web", "module.app.aws_s3_bucket.data"
type DefinitionAddress string

// ProviderKey identifies a provider configuration
// Examples: "aws", "aws.west", "google.europe"
type ProviderKey string

// ResourceType is the Terraform resource type
// Examples: "aws_instance", "google_compute_instance"
type ResourceType string

// InstanceKey represents the index for count/for_each
type InstanceKey struct {
	Type     KeyType
	IntValue int
	StrValue string
}

// KeyType indicates how an instance was indexed
type KeyType int

const (
	KeyTypeNone   KeyType = iota // No expansion (single instance)
	KeyTypeInt                   // count expansion: [0], [1], ...
	KeyTypeString                // for_each expansion: ["key"], ...
)

// String returns the key as an address suffix
func (k InstanceKey) String() string {
	switch k.Type {
	case KeyTypeInt:
		return fmt.Sprintf("[%d]", k.IntValue)
	case KeyTypeString:
		return fmt.Sprintf("[%q]", k.StrValue)
	default:
		return ""
	}
}

// SourceLocation tracks where in the source files something was defined
type SourceLocation struct {
	File      string
	StartLine int
	EndLine   int
	Module    string // Module path, empty for root
}

// Expression represents an unevaluated HCL expression
type Expression struct {
	Raw         string   // Original HCL text
	References  []string // Extracted references
	IsLiteral   bool     // True if no references
	LiteralVal  any      // Value if literal
}

// IsStatic returns true if the expression has no dependencies
func (e Expression) IsStatic() bool {
	return e.IsLiteral || len(e.References) == 0
}

// DynamicBlock represents a Terraform dynamic block
type DynamicBlock struct {
	Name      string     // Block type being generated
	ForEach   Expression // Iterator expression
	Iterator  string     // Iterator variable name (default: Name)
	Content   map[string]Expression
	Labels    []Expression
}

// LifecycleConfig holds lifecycle meta-argument values
type LifecycleConfig struct {
	CreateBeforeDestroy bool
	PreventDestroy      bool
	IgnoreChanges       []string
	ReplaceTriggeredBy  []string
}

// AssetDefinition is the STATIC Terraform resource/data block.
// This is what's written in .tf files, before any expansion.
type AssetDefinition struct {
	// Identity
	ID       DefinitionID      // Hash of address + provider + source location
	Address  DefinitionAddress // aws_instance.web
	Provider ProviderKey       // aws, aws.west
	Type     ResourceType      // aws_instance
	Name     string            // web
	Mode     ResourceMode      // managed, data

	// Meta-arguments (unevaluated)
	Count     *Expression   // count meta-argument
	ForEach   *Expression   // for_each meta-argument
	DependsOn []string      // Explicit dependencies
	Lifecycle LifecycleConfig

	// Attributes (may contain expressions)
	Attributes map[string]Expression

	// Dynamic blocks (must be expanded)
	DynamicBlocks []DynamicBlock

	// Provisioners (for cost implications like null_resource)
	Provisioners []Provisioner

	// Source tracking
	Location SourceLocation
}

// ResourceMode indicates managed resource vs data source
type ResourceMode int

const (
	ModeManaged ResourceMode = iota
	ModeData
)

// Provisioner represents a provisioner block
type Provisioner struct {
	Type       string // local-exec, remote-exec, file
	When       string // create, destroy
	OnFailure  string // continue, fail
	Attributes map[string]Expression
}

// ComputeID generates a stable ID for the definition
func (d *AssetDefinition) ComputeID() DefinitionID {
	h := sha256.New()
	h.Write([]byte(d.Address))
	h.Write([]byte(d.Provider))
	h.Write([]byte(fmt.Sprintf("%s:%d", d.Location.File, d.Location.StartLine)))
	return DefinitionID(hex.EncodeToString(h.Sum(nil))[:16])
}

// HasExpansion returns true if count or for_each is set
func (d *AssetDefinition) HasExpansion() bool {
	return d.Count != nil || d.ForEach != nil
}

// ResolvedAttribute is a fully evaluated attribute value
type ResolvedAttribute struct {
	Value     any           // Concrete value
	IsUnknown bool          // True if value couldn't be determined
	Reason    UnknownReason // Why it's unknown
	Sensitive bool          // Marked as sensitive
}

// UnknownReason explains why a value couldn't be determined
type UnknownReason int

const (
	ReasonKnown             UnknownReason = iota // Value is known
	ReasonComputedAtApply                        // Depends on infrastructure state
	ReasonDataSourcePending                      // Data source not yet evaluated
	ReasonCyclicReference                        // Circular dependency
	ReasonMissingVariable                        // Variable not provided
	ReasonExpressionError                        // Evaluation failed
)

// ResolvedProvider is a fully resolved provider configuration
type ResolvedProvider struct {
	Type       string            // aws, google, azurerm
	Alias      string            // Optional alias
	Region     string            // Resolved region
	Attributes map[string]any    // Other provider config
}

// AssetInstance is a CONCRETE, EXPANDED instance.
// This is what we actually cost - after count/for_each expansion.
type AssetInstance struct {
	// Identity
	ID           InstanceID        // Globally unique, hash-based
	DefinitionID DefinitionID      // Links back to definition
	Address      InstanceAddress   // aws_instance.web[0]

	// Instance-specific
	Key          InstanceKey       // The expansion key (0, "prod", etc.)

	// Fully resolved values (no expressions)
	Attributes   map[string]ResolvedAttribute

	// Provider after alias resolution
	Provider     ResolvedProvider

	// Dependencies after resolution (instance-level)
	Dependencies []InstanceID

	// Derived from dynamic blocks
	DynamicData  map[string][]map[string]ResolvedAttribute

	// Metadata
	Metadata     InstanceMetadata
}

// InstanceMetadata contains instance-level metadata
type InstanceMetadata struct {
	CreatedAt     time.Time
	Source        InstanceSource
	IsPlaceholder bool   // True if created for unknown expansion
	Warning       string // Any warning during expansion
}

// InstanceSource tracks how the instance was created
type InstanceSource int

const (
	SourceHCL         InstanceSource = iota // From .tf files
	SourcePlanJSON                          // From terraform plan JSON
	SourceState                             // From terraform state
	SourcePlaceholder                       // Synthetic for unknown count
)

// ComputeID generates a stable ID for the instance
func (i *AssetInstance) ComputeID() InstanceID {
	h := sha256.New()
	h.Write([]byte(i.DefinitionID))
	h.Write([]byte(i.Key.String()))
	return InstanceID(hex.EncodeToString(h.Sum(nil))[:16])
}

// GetAttribute returns an attribute value, handling unknowns
func (i *AssetInstance) GetAttribute(name string) (any, bool, UnknownReason) {
	attr, ok := i.Attributes[name]
	if !ok {
		return nil, false, ReasonKnown
	}
	return attr.Value, !attr.IsUnknown, attr.Reason
}

// InstanceEdge represents a dependency between instances
type InstanceEdge struct {
	From   InstanceID
	To     InstanceID
	Type   EdgeType
}

// EdgeType indicates the type of dependency
type EdgeType int

const (
	EdgeExplicit  EdgeType = iota // depends_on
	EdgeImplicit                  // Reference-based
	EdgeProvider                  // Provider dependency
)

// InstanceGraph is a DAG of AssetInstances.
// All operations happen on instances, NOT definitions.
type InstanceGraph struct {
	// Core data (use sorted access only)
	instances map[InstanceID]*AssetInstance
	edges     []InstanceEdge

	// Indexes (maintained automatically)
	byAddress    map[InstanceAddress]*AssetInstance
	byDefinition map[DefinitionID][]*AssetInstance

	// Computed on demand
	topologicalOrder []InstanceID
	orderValid       bool
}

// NewInstanceGraph creates an empty instance graph
func NewInstanceGraph() *InstanceGraph {
	return &InstanceGraph{
		instances:    make(map[InstanceID]*AssetInstance),
		byAddress:    make(map[InstanceAddress]*AssetInstance),
		byDefinition: make(map[DefinitionID][]*AssetInstance),
	}
}

// AddInstance adds an instance to the graph
func (g *InstanceGraph) AddInstance(inst *AssetInstance) {
	g.instances[inst.ID] = inst
	g.byAddress[inst.Address] = inst
	g.byDefinition[inst.DefinitionID] = append(g.byDefinition[inst.DefinitionID], inst)
	g.orderValid = false
}

// AddEdge adds a dependency edge
func (g *InstanceGraph) AddEdge(from, to InstanceID, edgeType EdgeType) {
	g.edges = append(g.edges, InstanceEdge{From: from, To: to, Type: edgeType})
	g.orderValid = false
}

// Instances returns all instances in stable, sorted order
func (g *InstanceGraph) Instances() []*AssetInstance {
	ids := make([]InstanceID, 0, len(g.instances))
	for id := range g.instances {
		ids = append(ids, id)
	}
	sort.Slice(ids, func(i, j int) bool {
		return ids[i] < ids[j]
	})

	result := make([]*AssetInstance, len(ids))
	for i, id := range ids {
		result[i] = g.instances[id]
	}
	return result
}

// ByAddress looks up an instance by its full address
func (g *InstanceGraph) ByAddress(addr InstanceAddress) (*AssetInstance, bool) {
	inst, ok := g.byAddress[addr]
	return inst, ok
}

// ByDefinition returns all instances expanded from a definition
func (g *InstanceGraph) ByDefinition(defID DefinitionID) []*AssetInstance {
	instances := g.byDefinition[defID]
	// Return sorted copy
	sorted := make([]*AssetInstance, len(instances))
	copy(sorted, instances)
	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i].Address < sorted[j].Address
	})
	return sorted
}

// TopologicalOrder returns instances in dependency order
func (g *InstanceGraph) TopologicalOrder() []InstanceID {
	if g.orderValid {
		return g.topologicalOrder
	}

	// Kahn's algorithm for topological sort
	inDegree := make(map[InstanceID]int)
	for id := range g.instances {
		inDegree[id] = 0
	}
	for _, edge := range g.edges {
		inDegree[edge.To]++
	}

	// Find all nodes with no incoming edges
	queue := make([]InstanceID, 0)
	for id, degree := range inDegree {
		if degree == 0 {
			queue = append(queue, id)
		}
	}
	sort.Slice(queue, func(i, j int) bool { return queue[i] < queue[j] })

	result := make([]InstanceID, 0, len(g.instances))
	for len(queue) > 0 {
		// Pop (stable: always take first)
		node := queue[0]
		queue = queue[1:]
		result = append(result, node)

		// Reduce in-degree for neighbors
		for _, edge := range g.edges {
			if edge.From == node {
				inDegree[edge.To]--
				if inDegree[edge.To] == 0 {
					queue = append(queue, edge.To)
					sort.Slice(queue, func(i, j int) bool { return queue[i] < queue[j] })
				}
			}
		}
	}

	g.topologicalOrder = result
	g.orderValid = true
	return result
}

// Size returns the number of instances
func (g *InstanceGraph) Size() int {
	return len(g.instances)
}

################################################################################
# FILE: :\good projects\cost estimation\core\model\enforced_identity.go
# TYPE: go
# SIZE: 8026 bytes
################################################################################
// Package model - Enforced canonical identity
// A single canonical format used EVERYWHERE.
package model

import (
	"errors"
	"fmt"
	"regexp"
	"strconv"
	"strings"
)

// ErrInvalidAddress is returned when an address cannot be parsed
var ErrInvalidAddress = errors.New("invalid resource address")

// CanonicalFormat is the ONLY accepted identity format.
// Pattern: [module.name:]...<type>.<name>[<key_type>=<key>]
//
// Examples:
//   aws_instance.web                           - single resource
//   aws_instance.web[count=0]                  - count expansion
//   aws_instance.web[for_each=prod]            - for_each expansion
//   module.vpc:aws_subnet.main[count=0]        - in module
//   module.vpc:module.db:aws_rds.main          - nested modules
const canonicalPattern = `^((?:module\.[a-zA-Z_][a-zA-Z0-9_]*:)*)?([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_\-]*)(\[(count|for_each)=([^\]]+)\])?$`

var canonicalRegex = regexp.MustCompile(canonicalPattern)

// EnforcedCanonicalAddress is a validated canonical address.
// Once created, it is guaranteed to be in the correct format.
type EnforcedCanonicalAddress struct {
	raw          string
	modulePath   []string
	resourceType string
	resourceName string
	keyType      KeyType
	keyValue     string
	intKey       int
}

// NewEnforcedAddress creates and validates a canonical address
func NewEnforcedAddress(addr string) (*EnforcedCanonicalAddress, error) {
	// First try to parse as canonical
	if match := canonicalRegex.FindStringSubmatch(addr); match != nil {
		return parseCanonicalMatch(addr, match)
	}

	// Try to normalize from Terraform format
	return normalizeFromTerraform(addr)
}

// MustNewEnforcedAddress creates an address or panics
func MustNewEnforcedAddress(addr string) *EnforcedCanonicalAddress {
	a, err := NewEnforcedAddress(addr)
	if err != nil {
		panic(fmt.Sprintf("invalid address %q: %v", addr, err))
	}
	return a
}

func parseCanonicalMatch(addr string, match []string) (*EnforcedCanonicalAddress, error) {
	a := &EnforcedCanonicalAddress{raw: addr}

	// Parse module path
	if match[1] != "" {
		modulePart := strings.TrimSuffix(match[1], ":")
		for _, part := range strings.Split(modulePart, ":") {
			if strings.HasPrefix(part, "module.") {
				a.modulePath = append(a.modulePath, strings.TrimPrefix(part, "module."))
			}
		}
	}

	a.resourceType = match[2]
	a.resourceName = match[3]

	// Parse key
	if match[4] != "" {
		keyTypeStr := match[5]
		keyVal := match[6]

		if keyTypeStr == "count" {
			a.keyType = KeyTypeInt
			n, err := strconv.Atoi(keyVal)
			if err != nil {
				return nil, fmt.Errorf("invalid count value: %s", keyVal)
			}
			a.intKey = n
			a.keyValue = keyVal
		} else if keyTypeStr == "for_each" {
			a.keyType = KeyTypeString
			a.keyValue = keyVal
		}
	} else {
		a.keyType = KeyTypeNone
	}

	return a, nil
}

func normalizeFromTerraform(addr string) (*EnforcedCanonicalAddress, error) {
	a := &EnforcedCanonicalAddress{}

	// Handle module path
	remaining := addr
	for strings.HasPrefix(remaining, "module.") {
		remaining = strings.TrimPrefix(remaining, "module.")
		dotIdx := strings.Index(remaining, ".")
		if dotIdx == -1 {
			return nil, ErrInvalidAddress
		}
		a.modulePath = append(a.modulePath, remaining[:dotIdx])
		remaining = remaining[dotIdx+1:]
	}

	// Parse resource type.name[key]
	bracketIdx := strings.Index(remaining, "[")
	resourcePart := remaining
	keyPart := ""
	if bracketIdx != -1 {
		resourcePart = remaining[:bracketIdx]
		keyPart = remaining[bracketIdx:]
	}

	// Split type.name
	dotIdx := strings.LastIndex(resourcePart, ".")
	if dotIdx == -1 {
		return nil, ErrInvalidAddress
	}
	a.resourceType = resourcePart[:dotIdx]
	a.resourceName = resourcePart[dotIdx+1:]

	// Parse key
	if keyPart != "" {
		// Remove brackets
		keyPart = strings.TrimPrefix(keyPart, "[")
		keyPart = strings.TrimSuffix(keyPart, "]")

		// Check if it's a number (count) or string (for_each)
		if n, err := strconv.Atoi(keyPart); err == nil {
			a.keyType = KeyTypeInt
			a.intKey = n
			a.keyValue = keyPart
		} else {
			a.keyType = KeyTypeString
			// Remove quotes if present
			a.keyValue = strings.Trim(keyPart, "\"'")
		}
	}

	// Build canonical form
	a.raw = a.String()
	return a, nil
}

// String returns the canonical string representation
func (a *EnforcedCanonicalAddress) String() string {
	if a.raw != "" {
		return a.raw
	}

	var sb strings.Builder

	// Module path
	for _, mod := range a.modulePath {
		sb.WriteString("module.")
		sb.WriteString(mod)
		sb.WriteString(":")
	}

	// Resource
	sb.WriteString(a.resourceType)
	sb.WriteString(".")
	sb.WriteString(a.resourceName)

	// Key
	switch a.keyType {
	case KeyTypeInt:
		sb.WriteString("[count=")
		sb.WriteString(strconv.Itoa(a.intKey))
		sb.WriteString("]")
	case KeyTypeString:
		sb.WriteString("[for_each=")
		sb.WriteString(a.keyValue)
		sb.WriteString("]")
	}

	return sb.String()
}

// ModulePath returns the module path components
func (a *EnforcedCanonicalAddress) ModulePath() []string {
	return a.modulePath
}

// ResourceType returns the resource type
func (a *EnforcedCanonicalAddress) ResourceType() string {
	return a.resourceType
}

// ResourceName returns the resource name
func (a *EnforcedCanonicalAddress) ResourceName() string {
	return a.resourceName
}

// Key returns the expansion key
func (a *EnforcedCanonicalAddress) Key() InstanceKey {
	return InstanceKey{
		Type:     a.keyType,
		IntValue: a.intKey,
		StrValue: a.keyValue,
	}
}

// IsInModule returns true if the resource is inside a module
func (a *EnforcedCanonicalAddress) IsInModule() bool {
	return len(a.modulePath) > 0
}

// BaseAddress returns the address without the expansion key
func (a *EnforcedCanonicalAddress) BaseAddress() string {
	var sb strings.Builder
	for _, mod := range a.modulePath {
		sb.WriteString("module.")
		sb.WriteString(mod)
		sb.WriteString(":")
	}
	sb.WriteString(a.resourceType)
	sb.WriteString(".")
	sb.WriteString(a.resourceName)
	return sb.String()
}

// WithKey returns a new address with a different key
func (a *EnforcedCanonicalAddress) WithKey(keyType KeyType, value interface{}) *EnforcedCanonicalAddress {
	newAddr := &EnforcedCanonicalAddress{
		modulePath:   a.modulePath,
		resourceType: a.resourceType,
		resourceName: a.resourceName,
		keyType:      keyType,
	}

	switch keyType {
	case KeyTypeInt:
		newAddr.intKey = value.(int)
		newAddr.keyValue = strconv.Itoa(value.(int))
	case KeyTypeString:
		newAddr.keyValue = value.(string)
	}

	newAddr.raw = newAddr.String()
	return newAddr
}

// Equals compares two addresses
func (a *EnforcedCanonicalAddress) Equals(other *EnforcedCanonicalAddress) bool {
	return a.String() == other.String()
}

// CanonicalAddressRegistry ensures unique addresses
type CanonicalAddressRegistry struct {
	addresses map[string]*EnforcedCanonicalAddress
}

// NewCanonicalAddressRegistry creates a new registry
func NewCanonicalAddressRegistry() *CanonicalAddressRegistry {
	return &CanonicalAddressRegistry{
		addresses: make(map[string]*EnforcedCanonicalAddress),
	}
}

// Register adds an address, returning error if duplicate
func (r *CanonicalAddressRegistry) Register(addr *EnforcedCanonicalAddress) error {
	key := addr.String()
	if _, exists := r.addresses[key]; exists {
		return fmt.Errorf("duplicate address: %s", key)
	}
	r.addresses[key] = addr
	return nil
}

// Get retrieves an address by string
func (r *CanonicalAddressRegistry) Get(addr string) *EnforcedCanonicalAddress {
	return r.addresses[addr]
}

// All returns all registered addresses
func (r *CanonicalAddressRegistry) All() []*EnforcedCanonicalAddress {
	result := make([]*EnforcedCanonicalAddress, 0, len(r.addresses))
	for _, a := range r.addresses {
		result = append(result, a)
	}
	return result
}

################################################################################
# FILE: :\good projects\cost estimation\core\model\identity.go
# TYPE: go
# SIZE: 9029 bytes
################################################################################
// Package model - Canonical instance identity
// Instance identity is NORMALIZED everywhere: cost lineage, policy, diffing, output.
package model

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"regexp"
	"sort"
	"strings"
)

// CanonicalAddress is a normalized, stable instance identity.
// Format: module.path:resource_type.name[key_type=key_value]
// Examples:
//   aws_instance.web                           (single instance)
//   aws_instance.web[count=0]                  (count expansion)
//   aws_instance.web[for_each=prod]            (for_each expansion)
//   module.app:aws_instance.web[count=0]      (in module)
//   module.app:module.db:aws_rds_instance.main (nested modules)
type CanonicalAddress string

// AddressBuilder constructs canonical addresses
type AddressBuilder struct {
	modulePath   []string
	resourceType string
	resourceName string
	keyType      string
	keyValue     string
}

// NewAddressBuilder creates a new builder
func NewAddressBuilder() *AddressBuilder {
	return &AddressBuilder{}
}

// InModule adds a module to the path
func (b *AddressBuilder) InModule(name string) *AddressBuilder {
	b.modulePath = append(b.modulePath, name)
	return b
}

// Resource sets the resource type and name
func (b *AddressBuilder) Resource(resourceType, name string) *AddressBuilder {
	b.resourceType = resourceType
	b.resourceName = name
	return b
}

// WithCount sets a count key
func (b *AddressBuilder) WithCount(index int) *AddressBuilder {
	b.keyType = "count"
	b.keyValue = fmt.Sprintf("%d", index)
	return b
}

// WithForEach sets a for_each key
func (b *AddressBuilder) WithForEach(key string) *AddressBuilder {
	b.keyType = "for_each"
	b.keyValue = key
	return b
}

// Build creates the canonical address
func (b *AddressBuilder) Build() CanonicalAddress {
	var sb strings.Builder

	// Module path
	for i, mod := range b.modulePath {
		if i > 0 {
			sb.WriteString(":")
		}
		sb.WriteString("module.")
		sb.WriteString(mod)
	}

	// Separator if we have modules
	if len(b.modulePath) > 0 {
		sb.WriteString(":")
	}

	// Resource
	sb.WriteString(b.resourceType)
	sb.WriteString(".")
	sb.WriteString(b.resourceName)

	// Key
	if b.keyType != "" {
		sb.WriteString("[")
		sb.WriteString(b.keyType)
		sb.WriteString("=")
		sb.WriteString(b.keyValue)
		sb.WriteString("]")
	}

	return CanonicalAddress(sb.String())
}

// ParseAddress parses any address format into canonical form
func ParseAddress(addr string) (CanonicalAddress, error) {
	// Already canonical?
	if isCanonical(addr) {
		return CanonicalAddress(addr), nil
	}

	// Parse Terraform-style address
	builder := NewAddressBuilder()

	// Split into parts
	parts := strings.Split(addr, ".")

	i := 0
	// Collect module path
	for i < len(parts)-2 {
		if parts[i] == "module" {
			builder.InModule(parts[i+1])
			i += 2
		} else {
			break
		}
	}

	// Resource type and name
	if i+1 >= len(parts) {
		return "", fmt.Errorf("invalid address: %s", addr)
	}

	resourceType := parts[i]
	resourceName := parts[i+1]

	// Check for index in resource name
	if idx := strings.Index(resourceName, "["); idx != -1 {
		keyPart := resourceName[idx+1 : len(resourceName)-1]
		resourceName = resourceName[:idx]

		// Parse key
		if num, err := fmt.Sscanf(keyPart, "%d", new(int)); err == nil && num == 1 {
			var index int
			fmt.Sscanf(keyPart, "%d", &index)
			builder.WithCount(index)
		} else {
			// Remove quotes if present
			keyPart = strings.Trim(keyPart, "\"")
			builder.WithForEach(keyPart)
		}
	}

	builder.Resource(resourceType, resourceName)
	return builder.Build(), nil
}

// isCanonical checks if address is already in canonical form
func isCanonical(addr string) bool {
	// Canonical format uses [key_type=value] not [index] or ["key"]
	return strings.Contains(addr, "[count=") || strings.Contains(addr, "[for_each=")
}

// StableID generates a hash-based ID from a canonical address
func (a CanonicalAddress) StableID() InstanceID {
	h := sha256.New()
	h.Write([]byte(a))
	return InstanceID(hex.EncodeToString(h.Sum(nil))[:16])
}

// ModulePath returns the module path component
func (a CanonicalAddress) ModulePath() string {
	s := string(a)
	idx := strings.LastIndex(s, ":")
	if idx == -1 {
		return ""
	}
	return s[:idx]
}

// ResourceAddress returns just the resource part
func (a CanonicalAddress) ResourceAddress() string {
	s := string(a)
	idx := strings.LastIndex(s, ":")
	if idx == -1 {
		return s
	}
	return s[idx+1:]
}

// BaseAddress returns the address without the key
func (a CanonicalAddress) BaseAddress() string {
	s := string(a)
	idx := strings.Index(s, "[")
	if idx == -1 {
		return s
	}
	return s[:idx]
}

// Key returns the key part, if any
func (a CanonicalAddress) Key() (keyType, keyValue string) {
	s := string(a)
	re := regexp.MustCompile(`\[(count|for_each)=([^\]]+)\]`)
	matches := re.FindStringSubmatch(s)
	if len(matches) == 3 {
		return matches[1], matches[2]
	}
	return "", ""
}

// String implements Stringer
func (a CanonicalAddress) String() string {
	return string(a)
}

// InstanceIdentity provides complete identity information
type InstanceIdentity struct {
	// Canonical address (normalized)
	Canonical CanonicalAddress

	// Stable ID (hash-based)
	ID InstanceID

	// Components
	ModulePath   string
	ResourceType string
	ResourceName string
	KeyType      string // "count" or "for_each" or ""
	KeyValue     string

	// Parent definition
	DefinitionID DefinitionID

	// For nested expansion tracking
	ParentKey    *InstanceIdentity
}

// NewInstanceIdentity creates identity from an instance
func NewInstanceIdentity(inst *AssetInstance) *InstanceIdentity {
	canonical, _ := ParseAddress(string(inst.Address))

	keyType, keyValue := "", ""
	switch inst.Key.Type {
	case KeyTypeInt:
		keyType = "count"
		keyValue = fmt.Sprintf("%d", inst.Key.IntValue)
	case KeyTypeString:
		keyType = "for_each"
		keyValue = inst.Key.StrValue
	}

	parts := strings.Split(canonical.BaseAddress(), ".")
	resourceType, resourceName := "", ""
	if len(parts) >= 2 {
		// Find last two parts that aren't module names
		for i := len(parts) - 2; i >= 0; i-- {
			if parts[i] != "module" {
				resourceType = parts[i]
				resourceName = parts[i+1]
				break
			}
		}
	}

	return &InstanceIdentity{
		Canonical:    canonical,
		ID:           canonical.StableID(),
		ModulePath:   canonical.ModulePath(),
		ResourceType: resourceType,
		ResourceName: resourceName,
		KeyType:      keyType,
		KeyValue:     keyValue,
		DefinitionID: inst.DefinitionID,
	}
}

// IdentityIndex indexes instances by various identity components
type IdentityIndex struct {
	byCanonical    map[CanonicalAddress]*InstanceIdentity
	byID           map[InstanceID]*InstanceIdentity
	byModule       map[string][]*InstanceIdentity
	byResourceType map[string][]*InstanceIdentity
	byDefinition   map[DefinitionID][]*InstanceIdentity
}

// NewIdentityIndex creates an empty index
func NewIdentityIndex() *IdentityIndex {
	return &IdentityIndex{
		byCanonical:    make(map[CanonicalAddress]*InstanceIdentity),
		byID:           make(map[InstanceID]*InstanceIdentity),
		byModule:       make(map[string][]*InstanceIdentity),
		byResourceType: make(map[string][]*InstanceIdentity),
		byDefinition:   make(map[DefinitionID][]*InstanceIdentity),
	}
}

// Add adds an identity to the index
func (idx *IdentityIndex) Add(id *InstanceIdentity) {
	idx.byCanonical[id.Canonical] = id
	idx.byID[id.ID] = id
	idx.byModule[id.ModulePath] = append(idx.byModule[id.ModulePath], id)
	idx.byResourceType[id.ResourceType] = append(idx.byResourceType[id.ResourceType], id)
	idx.byDefinition[id.DefinitionID] = append(idx.byDefinition[id.DefinitionID], id)
}

// ByCanonical looks up by canonical address
func (idx *IdentityIndex) ByCanonical(addr CanonicalAddress) *InstanceIdentity {
	return idx.byCanonical[addr]
}

// ByID looks up by ID
func (idx *IdentityIndex) ByID(id InstanceID) *InstanceIdentity {
	return idx.byID[id]
}

// ByModule returns all instances in a module
func (idx *IdentityIndex) ByModule(path string) []*InstanceIdentity {
	result := idx.byModule[path]
	sort.Slice(result, func(i, j int) bool {
		return result[i].Canonical < result[j].Canonical
	})
	return result
}

// ByResourceType returns all instances of a type
func (idx *IdentityIndex) ByResourceType(t string) []*InstanceIdentity {
	result := idx.byResourceType[t]
	sort.Slice(result, func(i, j int) bool {
		return result[i].Canonical < result[j].Canonical
	})
	return result
}

// ByDefinition returns all instances from a definition
func (idx *IdentityIndex) ByDefinition(id DefinitionID) []*InstanceIdentity {
	result := idx.byDefinition[id]
	sort.Slice(result, func(i, j int) bool {
		return result[i].Canonical < result[j].Canonical
	})
	return result
}

################################################################################
# FILE: :\good projects\cost estimation\core\output\formatter.go
# TYPE: go
# SIZE: 4597 bytes
################################################################################
// Package output provides output formatting interfaces.
// This package produces human and machine-readable outputs.
package output

import (
	"io"

	"terraform-cost/core/policy"
	"terraform-cost/core/types"
)

// Format represents output format type
type Format string

const (
	// FormatCLI is a human-readable CLI table
	FormatCLI Format = "cli"

	// FormatJSON is machine-readable JSON
	FormatJSON Format = "json"

	// FormatHTML is an HTML report
	FormatHTML Format = "html"

	// FormatMarkdown is a markdown report
	FormatMarkdown Format = "markdown"

	// FormatPR is a PR comment format
	FormatPR Format = "pr"
)

// Formatter produces output in a specific format
type Formatter interface {
	// Format returns the format type
	Format() Format

	// Render produces output for the given result
	Render(w io.Writer, result *EstimationResult) error
}

// EstimationResult contains the complete estimation output
type EstimationResult struct {
	// CostGraph is the calculated cost graph
	CostGraph *types.CostGraph `json:"cost_graph"`

	// AssetGraph is the source asset graph
	AssetGraph *types.AssetGraph `json:"asset_graph,omitempty"`

	// PolicyResult contains policy evaluation results
	PolicyResult *policy.EvaluationResult `json:"policy_result,omitempty"`

	// PricingSnapshot identifies the pricing data used
	PricingSnapshot *types.PricingSnapshot `json:"pricing_snapshot"`

	// UsageProfile is the usage profile that was applied
	UsageProfile *types.UsageProfile `json:"usage_profile,omitempty"`

	// Assumptions documents estimation assumptions
	Assumptions []Assumption `json:"assumptions,omitempty"`

	// Confidence is the overall confidence level (0.0 to 1.0)
	Confidence float64 `json:"confidence"`

	// Metadata contains execution context
	Metadata EstimationMetadata `json:"metadata"`

	// Diff contains comparison with previous estimate
	Diff *EstimationDiff `json:"diff,omitempty"`
}

// Assumption documents an estimation assumption
type Assumption struct {
	// Resource is the resource this assumption applies to
	Resource types.ResourceAddress `json:"resource,omitempty"`

	// Category is the assumption category
	Category string `json:"category"`

	// Description explains the assumption
	Description string `json:"description"`

	// Impact describes the potential impact
	Impact string `json:"impact,omitempty"`

	// Confidence is the confidence in this assumption
	Confidence float64 `json:"confidence,omitempty"`
}

// EstimationMetadata contains execution context
type EstimationMetadata struct {
	// Timestamp is when the estimation was performed
	Timestamp string `json:"timestamp"`

	// Duration is how long the estimation took
	Duration string `json:"duration"`

	// InputHash is a hash of the input for caching
	InputHash string `json:"input_hash"`

	// SnapshotID is the pricing snapshot ID
	SnapshotID string `json:"snapshot_id"`

	// Version is the tool version
	Version string `json:"version"`

	// Source is the input source
	Source types.InputSource `json:"source"`

	// Environment is the target environment
	Environment string `json:"environment,omitempty"`
}

// EstimationDiff contains comparison with a previous estimate
type EstimationDiff struct {
	// Previous is the previous cost
	Previous types.CostGraph `json:"previous"`

	// Added are new resources
	Added []DiffItem `json:"added,omitempty"`

	// Removed are removed resources
	Removed []DiffItem `json:"removed,omitempty"`

	// Changed are resources with cost changes
	Changed []DiffItem `json:"changed,omitempty"`

	// TotalChange is the difference in total cost
	TotalChange string `json:"total_change"`

	// PercentChange is the percentage change
	PercentChange float64 `json:"percent_change"`
}

// DiffItem represents a single diff entry
type DiffItem struct {
	// Resource is the resource address
	Resource string `json:"resource"`

	// PreviousCost is the old cost
	PreviousCost string `json:"previous_cost,omitempty"`

	// CurrentCost is the new cost
	CurrentCost string `json:"current_cost,omitempty"`

	// Change is the cost difference
	Change string `json:"change,omitempty"`
}

// FormatterRegistry manages formatter registration
type FormatterRegistry interface {
	// Register adds a formatter to the registry
	Register(formatter Formatter) error

	// GetFormatter returns a formatter for a format type
	GetFormatter(format Format) (Formatter, bool)

	// GetAll returns all registered formatters
	GetAll() []Formatter
}

################################################################################
# FILE: :\good projects\cost estimation\core\policy\deep_policy.go
# TYPE: go
# SIZE: 12552 bytes
################################################################################
// Package policy provides the policy evaluation engine with deep context access.
// Policies can access cost lineage, usage confidence, and instance identity.
package policy

import (
	"context"
	"fmt"
	"sort"

	"terraform-cost/core/determinism"
	"terraform-cost/core/model"
	"terraform-cost/core/pricing"
)

// DeepEvaluator evaluates cost policies with full context access
type DeepEvaluator struct {
	policies []DeepPolicy
}

// NewDeepEvaluator creates a new policy evaluator
func NewDeepEvaluator() *DeepEvaluator {
	return &DeepEvaluator{
		policies: []DeepPolicy{},
	}
}

// Register adds a policy
func (e *DeepEvaluator) Register(p DeepPolicy) {
	e.policies = append(e.policies, p)
}

// DeepPolicy is an interface for cost policies with deep context
type DeepPolicy interface {
	Name() string
	Evaluate(ctx context.Context, input *PolicyInput) (*PolicyOutput, error)
}

// PolicyInput provides DEEP context for policy evaluation
type PolicyInput struct {
	// Instance costs (per-instance, not aggregated)
	InstanceCosts map[model.InstanceID]*InstanceCostDetail

	// Total costs
	TotalMonthlyCost determinism.Money
	TotalHourlyCost  determinism.Money

	// Confidence information
	OverallConfidence float64
	LowConfidenceItems []LowConfidenceItem

	// Unknowns
	UnknownValues []UnknownValueInfo

	// Definitions (for grouping)
	Definitions map[model.DefinitionID]*model.AssetDefinition

	// Full lineage for tracing
	AllLineage []*pricing.CostLineage

	// Pricing snapshot used
	Snapshot *pricing.PricingSnapshot
}

// InstanceCostDetail provides deep detail for a single instance
type InstanceCostDetail struct {
	// Instance identity
	InstanceID   model.InstanceID
	Address      model.InstanceAddress
	DefinitionID model.DefinitionID
	InstanceKey  model.InstanceKey

	// Provider and region
	Provider string
	Region   string

	// Costs
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money
	Components  []ComponentDetail

	// Confidence
	Confidence float64
	Factors    []ConfidenceFactor

	// Full lineage
	Lineage []*pricing.CostLineage

	// Usage information
	Usage UsageInfo

	// Tags/labels for targeting
	Tags map[string]string
}

// ComponentDetail provides detail for a cost component
type ComponentDetail struct {
	Name        string
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money

	// Rate used
	Rate RateInfo

	// Usage
	UsageValue float64
	UsageUnit  string

	// Formula applied
	Formula pricing.FormulaApplication

	// Confidence
	Confidence float64
}

// RateInfo describes the pricing rate used
type RateInfo struct {
	ID       pricing.RateID
	Key      pricing.RateKey
	Price    string
	Unit     string
	Currency string
}

// UsageInfo provides usage details
type UsageInfo struct {
	Source      pricing.UsageSource
	Confidence  float64
	Assumptions []string
	Overridden  bool
}

// ConfidenceFactor explains why confidence is reduced
type ConfidenceFactor struct {
	Reason    string
	Impact    float64
	Component string
	IsUnknown bool
}

// LowConfidenceItem identifies items with low confidence
type LowConfidenceItem struct {
	InstanceID model.InstanceID
	Address    model.InstanceAddress
	Component  string
	Confidence float64
	Reason     string
}

// UnknownValueInfo describes an unknown value
type UnknownValueInfo struct {
	Address string
	Reason  string
	Impact  string
}

// PolicyOutput is the result of a single policy
type PolicyOutput struct {
	Passed  bool
	Message string

	// Affected instances (for targeting)
	AffectedInstances []model.InstanceID

	// Cost impact
	AffectedCost determinism.Money

	// Lineage references (for explainability)
	LineageRefs []*pricing.CostLineage

	// Suggested actions
	Suggestions []string
}

// DeepResult is the complete result of all policies
type DeepResult struct {
	Passed   bool
	Policies []DeepPolicyResult
}

// DeepPolicyResult is the result of a single policy
type DeepPolicyResult struct {
	Name    string
	Passed  bool
	Message string

	AffectedInstances []model.InstanceID
	AffectedCost      determinism.Money
	LineageRefs       []*pricing.CostLineage
	Suggestions       []string
}

// Evaluate runs all policies
func (e *DeepEvaluator) Evaluate(ctx context.Context, input *PolicyInput) (*DeepResult, error) {
	result := &DeepResult{
		Passed:   true,
		Policies: make([]DeepPolicyResult, 0, len(e.policies)),
	}

	for _, p := range e.policies {
		output, err := p.Evaluate(ctx, input)
		if err != nil {
			return nil, fmt.Errorf("policy %s failed: %w", p.Name(), err)
		}

		pr := DeepPolicyResult{
			Name:              p.Name(),
			Passed:            output.Passed,
			Message:           output.Message,
			AffectedInstances: output.AffectedInstances,
			AffectedCost:      output.AffectedCost,
			LineageRefs:       output.LineageRefs,
			Suggestions:       output.Suggestions,
		}
		result.Policies = append(result.Policies, pr)

		if !output.Passed {
			result.Passed = false
		}
	}

	return result, nil
}

// BudgetPolicy checks if total cost exceeds a budget
type BudgetPolicy struct {
	name          string
	monthlyBudget determinism.Money
	threshold     float64 // 0.0-1.0, warn when at this percentage
}

// NewBudgetPolicy creates a budget policy
func NewBudgetPolicy(name string, monthlyBudget determinism.Money, threshold float64) *BudgetPolicy {
	return &BudgetPolicy{
		name:          name,
		monthlyBudget: monthlyBudget,
		threshold:     threshold,
	}
}

func (p *BudgetPolicy) Name() string { return p.name }

func (p *BudgetPolicy) Evaluate(ctx context.Context, input *PolicyInput) (*PolicyOutput, error) {
	output := &PolicyOutput{
		Passed: true,
	}

	// Check if over budget
	if input.TotalMonthlyCost.Cmp(p.monthlyBudget) > 0 {
		output.Passed = false
		output.Message = fmt.Sprintf("Monthly cost $%s exceeds budget $%s",
			input.TotalMonthlyCost.String(), p.monthlyBudget.String())

		// Find top cost contributors
		output.AffectedInstances = p.findTopContributors(input, 5)
		output.AffectedCost = input.TotalMonthlyCost.Sub(p.monthlyBudget)
		output.Suggestions = []string{
			"Consider using smaller instance types",
			"Review usage assumptions for accuracy",
			"Check for unused resources",
		}
	} else {
		// Check threshold warning
		thresholdAmount := p.monthlyBudget.MulFloat(p.threshold)
		if input.TotalMonthlyCost.Cmp(thresholdAmount) > 0 {
			output.Message = fmt.Sprintf("Monthly cost $%s is at %.0f%% of budget $%s",
				input.TotalMonthlyCost.String(),
				(input.TotalMonthlyCost.Float64()/p.monthlyBudget.Float64())*100,
				p.monthlyBudget.String())
		} else {
			output.Message = fmt.Sprintf("Monthly cost $%s is within budget $%s",
				input.TotalMonthlyCost.String(), p.monthlyBudget.String())
		}
	}

	return output, nil
}

func (p *BudgetPolicy) findTopContributors(input *PolicyInput, n int) []model.InstanceID {
	// Sort instances by cost
	type costItem struct {
		id   model.InstanceID
		cost determinism.Money
	}

	items := make([]costItem, 0, len(input.InstanceCosts))
	for id, detail := range input.InstanceCosts {
		items = append(items, costItem{id: id, cost: detail.MonthlyCost})
	}

	sort.Slice(items, func(i, j int) bool {
		return items[i].cost.Cmp(items[j].cost) > 0
	})

	result := make([]model.InstanceID, 0, n)
	for i := 0; i < n && i < len(items); i++ {
		result = append(result, items[i].id)
	}
	return result
}

// ConfidencePolicy checks if estimation confidence is acceptable
type ConfidencePolicy struct {
	name          string
	minConfidence float64
}

// NewConfidencePolicy creates a confidence policy
func NewConfidencePolicy(name string, minConfidence float64) *ConfidencePolicy {
	return &ConfidencePolicy{
		name:          name,
		minConfidence: minConfidence,
	}
}

func (p *ConfidencePolicy) Name() string { return p.name }

func (p *ConfidencePolicy) Evaluate(ctx context.Context, input *PolicyInput) (*PolicyOutput, error) {
	output := &PolicyOutput{
		Passed: true,
	}

	if input.OverallConfidence < p.minConfidence {
		output.Passed = false
		output.Message = fmt.Sprintf("Estimation confidence %.2f%% is below minimum %.2f%%",
			input.OverallConfidence*100, p.minConfidence*100)

		// Find low confidence items
		for _, item := range input.LowConfidenceItems {
			output.AffectedInstances = append(output.AffectedInstances, item.InstanceID)
		}

		// Collect lineage for affected items
		for _, lineage := range input.AllLineage {
			if lineage.Confidence < p.minConfidence {
				output.LineageRefs = append(output.LineageRefs, lineage)
			}
		}

		output.Suggestions = []string{
			"Provide usage overrides for low-confidence components",
			"Check that all required variables are provided",
			"Review unknown values in the configuration",
		}
	} else {
		output.Message = fmt.Sprintf("Estimation confidence %.2f%% meets minimum %.2f%%",
			input.OverallConfidence*100, p.minConfidence*100)
	}

	return output, nil
}

// ResourceTypePolicy checks limits on specific resource types
type ResourceTypePolicy struct {
	name         string
	resourceType string
	maxInstances int
	maxCost      *determinism.Money
}

// NewResourceTypePolicy creates a resource type policy
func NewResourceTypePolicy(name, resourceType string, maxInstances int, maxCost *determinism.Money) *ResourceTypePolicy {
	return &ResourceTypePolicy{
		name:         name,
		resourceType: resourceType,
		maxInstances: maxInstances,
		maxCost:      maxCost,
	}
}

func (p *ResourceTypePolicy) Name() string { return p.name }

func (p *ResourceTypePolicy) Evaluate(ctx context.Context, input *PolicyInput) (*PolicyOutput, error) {
	output := &PolicyOutput{
		Passed: true,
	}

	// Count instances and sum cost for this resource type
	var count int
	totalCost := determinism.Zero("USD")
	affected := []model.InstanceID{}

	for id, detail := range input.InstanceCosts {
		// Check if this instance matches the resource type
		addr := string(detail.Address)
		if len(addr) >= len(p.resourceType) && addr[:len(p.resourceType)] == p.resourceType {
			count++
			totalCost = totalCost.Add(detail.MonthlyCost)
			affected = append(affected, id)
		}
	}

	// Check instance count
	if p.maxInstances > 0 && count > p.maxInstances {
		output.Passed = false
		output.Message = fmt.Sprintf("%s: %d instances exceeds limit of %d",
			p.resourceType, count, p.maxInstances)
		output.AffectedInstances = affected
	}

	// Check cost
	if p.maxCost != nil && totalCost.Cmp(*p.maxCost) > 0 {
		output.Passed = false
		if output.Message != "" {
			output.Message += "; "
		}
		output.Message += fmt.Sprintf("%s cost $%s exceeds limit $%s",
			p.resourceType, totalCost.String(), p.maxCost.String())
		output.AffectedInstances = affected
		output.AffectedCost = totalCost.Sub(*p.maxCost)
	}

	if output.Passed {
		output.Message = fmt.Sprintf("%s: %d instances, $%s/month - within limits",
			p.resourceType, count, totalCost.String())
	}

	return output, nil
}

// TagRequirementPolicy checks that instances have required tags
type TagRequirementPolicy struct {
	name         string
	requiredTags []string
}

// NewTagRequirementPolicy creates a tag requirement policy
func NewTagRequirementPolicy(name string, requiredTags []string) *TagRequirementPolicy {
	return &TagRequirementPolicy{
		name:         name,
		requiredTags: requiredTags,
	}
}

func (p *TagRequirementPolicy) Name() string { return p.name }

func (p *TagRequirementPolicy) Evaluate(ctx context.Context, input *PolicyInput) (*PolicyOutput, error) {
	output := &PolicyOutput{
		Passed: true,
	}

	missingTags := make(map[model.InstanceID][]string)

	for id, detail := range input.InstanceCosts {
		for _, req := range p.requiredTags {
			if _, ok := detail.Tags[req]; !ok {
				missingTags[id] = append(missingTags[id], req)
			}
		}
	}

	if len(missingTags) > 0 {
		output.Passed = false
		output.Message = fmt.Sprintf("%d instances missing required tags", len(missingTags))

		for id := range missingTags {
			output.AffectedInstances = append(output.AffectedInstances, id)
		}

		output.Suggestions = []string{
			"Add required tags: " + fmt.Sprintf("%v", p.requiredTags),
		}
	} else {
		output.Message = "All instances have required tags"
	}

	return output, nil
}

################################################################################
# FILE: :\good projects\cost estimation\core\policy\diff_policy.go
# TYPE: go
# SIZE: 10216 bytes
################################################################################
// Package policy - Diff-aware policy engine
// Policies can reason over change sets, not just aggregates.
// Can block "new unknown costs" and evaluate "new resources only".
package policy

import (
	"terraform-cost/core/graph"
	"terraform-cost/core/model"
)

// DiffAwarePolicy evaluates changes, not just totals
type DiffAwarePolicy interface {
	// Name returns the policy name
	Name() string

	// EvaluateDiff evaluates a diff
	EvaluateDiff(ctx *DiffPolicyContext) *DiffPolicyResult
}

// DiffPolicyContext provides diff context to policies
type DiffPolicyContext struct {
	// Before state (nil for new infrastructure)
	Before *CostSnapshot

	// After state
	After *CostSnapshot

	// Change analysis
	Changes *graph.ChangeCostAnalysis

	// Scope filter
	Scope DiffScope

	// Confidence context
	ConfidenceInfo *DiffConfidenceInfo
}

// CostSnapshot is a point-in-time cost state
type CostSnapshot struct {
	TotalMonthly  float64
	Resources     map[model.InstanceID]float64
	ByService     map[string]float64
	Confidence    float64
	Timestamp     string
}

// DiffScope defines what to evaluate
type DiffScope struct {
	// Only evaluate new resources
	NewResourcesOnly bool

	// Only evaluate production changes
	ProductionOnly bool

	// Only evaluate specific services
	Services []string

	// Only evaluate specific resource types
	ResourceTypes []string
}

// DiffConfidenceInfo tracks confidence changes
type DiffConfidenceInfo struct {
	// Before confidence
	BeforeConfidence float64

	// After confidence
	AfterConfidence float64

	// New unknowns introduced
	NewUnknowns []NewUnknownItem

	// Low confidence items
	LowConfidenceItems []LowConfItem
}

// NewUnknownItem is a new unknown cost
type NewUnknownItem struct {
	Address    string
	Reason     string
	CostImpact float64
}

// LowConfItem is a low confidence item
type LowConfItem struct {
	Address    string
	Confidence float64
	Reason     string
	Cost       float64
}

// DiffPolicyResult is the result of diff policy evaluation
type DiffPolicyResult struct {
	PolicyName    string
	Passed        bool
	Violations    []DiffViolation
	Warnings      []DiffWarning
	CostImpact    float64
	Recommendation string
}

// DiffViolation is a policy violation in a diff
type DiffViolation struct {
	Type        ViolationType
	Address     string
	Reason      string
	CostImpact  float64
	Blocking    bool
}

// ViolationType classifies violations
type ViolationType int

const (
	ViolationBudgetExceeded    ViolationType = iota
	ViolationNewUnknown
	ViolationConfidenceDropped
	ViolationNewHighCost
	ViolationUnauthorizedService
)

// String returns the violation type name
func (v ViolationType) String() string {
	switch v {
	case ViolationBudgetExceeded:
		return "budget_exceeded"
	case ViolationNewUnknown:
		return "new_unknown"
	case ViolationConfidenceDropped:
		return "confidence_dropped"
	case ViolationNewHighCost:
		return "new_high_cost"
	case ViolationUnauthorizedService:
		return "unauthorized_service"
	default:
		return "unknown"
	}
}

// DiffWarning is a warning in a diff
type DiffWarning struct {
	Type    string
	Message string
	Address string
}

// NewUnknownsPolicy blocks new unknown costs
type NewUnknownsPolicy struct {
	// Block on any new unknowns
	BlockOnNew bool

	// Minimum confidence for new resources
	MinConfidence float64
}

// NewNewUnknownsPolicy creates a policy
func NewNewUnknownsPolicy(block bool, minConfidence float64) *NewUnknownsPolicy {
	return &NewUnknownsPolicy{
		BlockOnNew:    block,
		MinConfidence: minConfidence,
	}
}

// Name returns the policy name
func (p *NewUnknownsPolicy) Name() string {
	return "new-unknowns"
}

// EvaluateDiff evaluates for new unknowns
func (p *NewUnknownsPolicy) EvaluateDiff(ctx *DiffPolicyContext) *DiffPolicyResult {
	result := &DiffPolicyResult{
		PolicyName: p.Name(),
		Passed:     true,
		Violations: []DiffViolation{},
		Warnings:   []DiffWarning{},
	}

	if ctx.ConfidenceInfo == nil {
		return result
	}

	// Check for new unknowns
	for _, unknown := range ctx.ConfidenceInfo.NewUnknowns {
		if p.BlockOnNew {
			result.Passed = false
			result.Violations = append(result.Violations, DiffViolation{
				Type:       ViolationNewUnknown,
				Address:    unknown.Address,
				Reason:     unknown.Reason,
				CostImpact: unknown.CostImpact,
				Blocking:   true,
			})
		} else {
			result.Warnings = append(result.Warnings, DiffWarning{
				Type:    "new_unknown",
				Message: unknown.Reason,
				Address: unknown.Address,
			})
		}
	}

	// Check confidence threshold
	for _, item := range ctx.ConfidenceInfo.LowConfidenceItems {
		if item.Confidence < p.MinConfidence {
			result.Violations = append(result.Violations, DiffViolation{
				Type:       ViolationConfidenceDropped,
				Address:    item.Address,
				Reason:     item.Reason,
				CostImpact: item.Cost,
				Blocking:   false,
			})
		}
	}

	return result
}

// DeltaBudgetPolicy checks change amounts against budgets
type DeltaBudgetPolicy struct {
	// Maximum monthly increase
	MaxMonthlyIncrease float64

	// Maximum percentage increase
	MaxPercentIncrease float64

	// Per-service limits
	ServiceLimits map[string]float64
}

// NewDeltaBudgetPolicy creates a policy
func NewDeltaBudgetPolicy(maxIncrease, maxPercent float64) *DeltaBudgetPolicy {
	return &DeltaBudgetPolicy{
		MaxMonthlyIncrease: maxIncrease,
		MaxPercentIncrease: maxPercent,
		ServiceLimits:      make(map[string]float64),
	}
}

// Name returns the policy name
func (p *DeltaBudgetPolicy) Name() string {
	return "delta-budget"
}

// EvaluateDiff evaluates budget against changes
func (p *DeltaBudgetPolicy) EvaluateDiff(ctx *DiffPolicyContext) *DiffPolicyResult {
	result := &DiffPolicyResult{
		PolicyName: p.Name(),
		Passed:     true,
		Violations: []DiffViolation{},
	}

	if ctx.Before == nil || ctx.After == nil {
		return result
	}

	// Calculate delta
	delta := ctx.After.TotalMonthly - ctx.Before.TotalMonthly
	result.CostImpact = delta

	// Check absolute increase
	if p.MaxMonthlyIncrease > 0 && delta > p.MaxMonthlyIncrease {
		result.Passed = false
		result.Violations = append(result.Violations, DiffViolation{
			Type:       ViolationBudgetExceeded,
			Reason:     "monthly increase exceeds limit",
			CostImpact: delta,
			Blocking:   true,
		})
	}

	// Check percentage increase
	if ctx.Before.TotalMonthly > 0 && p.MaxPercentIncrease > 0 {
		percentIncrease := (delta / ctx.Before.TotalMonthly) * 100
		if percentIncrease > p.MaxPercentIncrease {
			result.Passed = false
			result.Violations = append(result.Violations, DiffViolation{
				Type:       ViolationBudgetExceeded,
				Reason:     "percentage increase exceeds limit",
				CostImpact: delta,
				Blocking:   true,
			})
		}
	}

	// Check per-service limits
	for service, limit := range p.ServiceLimits {
		beforeCost := ctx.Before.ByService[service]
		afterCost := ctx.After.ByService[service]
		serviceDelta := afterCost - beforeCost

		if serviceDelta > limit {
			result.Passed = false
			result.Violations = append(result.Violations, DiffViolation{
				Type:       ViolationBudgetExceeded,
				Reason:     service + " service increase exceeds limit",
				CostImpact: serviceDelta,
				Blocking:   true,
			})
		}
	}

	return result
}

// NewResourcesOnlyPolicy evaluates only new resources
type NewResourcesOnlyPolicy struct {
	// Inner policy to apply
	inner DiffAwarePolicy
}

// NewNewResourcesOnlyPolicy creates a wrapper
func NewNewResourcesOnlyPolicy(inner DiffAwarePolicy) *NewResourcesOnlyPolicy {
	return &NewResourcesOnlyPolicy{inner: inner}
}

// Name returns the policy name
func (p *NewResourcesOnlyPolicy) Name() string {
	return "new-resources-only:" + p.inner.Name()
}

// EvaluateDiff evaluates only new resources
func (p *NewResourcesOnlyPolicy) EvaluateDiff(ctx *DiffPolicyContext) *DiffPolicyResult {
	// Create filtered context with only new resources
	filteredCtx := &DiffPolicyContext{
		Before: &CostSnapshot{
			TotalMonthly: 0,
			Resources:    make(map[model.InstanceID]float64),
			ByService:    make(map[string]float64),
			Confidence:   1.0,
		},
		After:          ctx.After,
		ConfidenceInfo: ctx.ConfidenceInfo,
		Scope:          ctx.Scope,
	}

	// Remove resources that existed before
	if ctx.Before != nil {
		for id := range ctx.Before.Resources {
			delete(filteredCtx.After.Resources, id)
		}
	}

	// Recalculate total
	filteredCtx.After.TotalMonthly = 0
	for _, cost := range filteredCtx.After.Resources {
		filteredCtx.After.TotalMonthly += cost
	}

	return p.inner.EvaluateDiff(filteredCtx)
}

// DiffPolicyEngine evaluates multiple diff-aware policies
type DiffPolicyEngine struct {
	policies []DiffAwarePolicy
}

// NewDiffPolicyEngine creates an engine
func NewDiffPolicyEngine() *DiffPolicyEngine {
	return &DiffPolicyEngine{
		policies: []DiffAwarePolicy{},
	}
}

// AddPolicy adds a policy
func (e *DiffPolicyEngine) AddPolicy(policy DiffAwarePolicy) {
	e.policies = append(e.policies, policy)
}

// Evaluate evaluates all policies
func (e *DiffPolicyEngine) Evaluate(ctx *DiffPolicyContext) *DiffPolicyEngineResult {
	result := &DiffPolicyEngineResult{
		Passed:  true,
		Results: []*DiffPolicyResult{},
	}

	for _, policy := range e.policies {
		policyResult := policy.EvaluateDiff(ctx)
		result.Results = append(result.Results, policyResult)

		if !policyResult.Passed {
			result.Passed = false
		}
	}

	return result
}

// DiffPolicyEngineResult is the result of evaluating all policies
type DiffPolicyEngineResult struct {
	Passed  bool
	Results []*DiffPolicyResult
}

// BlockingViolations returns all blocking violations
func (r *DiffPolicyEngineResult) BlockingViolations() []DiffViolation {
	var violations []DiffViolation
	for _, result := range r.Results {
		for _, v := range result.Violations {
			if v.Blocking {
				violations = append(violations, v)
			}
		}
	}
	return violations
}

################################################################################
# FILE: :\good projects\cost estimation\core\policy\evaluator.go
# TYPE: go
# SIZE: 4143 bytes
################################################################################
// Package policy provides the policy evaluation interface.
// This package enforces cost guardrails before deployment.
package policy

import (
	"context"

	"terraform-cost/core/types"
)

// Rule defines a single policy rule
type Rule interface {
	// Name returns the rule identifier
	Name() string

	// Description returns a human-readable description
	Description() string

	// Evaluate checks the rule against the cost graph
	// prev is the previous cost graph for diff-based policies (can be nil)
	Evaluate(ctx context.Context, current *types.CostGraph, prev *types.CostGraph) (*RuleResult, error)
}

// RuleResult contains the evaluation output for a single rule
type RuleResult struct {
	// RuleName is the rule that was evaluated
	RuleName string `json:"rule_name"`

	// Passed indicates if the rule passed
	Passed bool `json:"passed"`

	// Severity is the rule severity
	Severity Severity `json:"severity"`

	// Message is a human-readable result message
	Message string `json:"message"`

	// Details contains additional context
	Details map[string]interface{} `json:"details,omitempty"`

	// Violations lists specific violations
	Violations []Violation `json:"violations,omitempty"`
}

// Violation represents a specific policy violation
type Violation struct {
	// Resource is the violating resource
	Resource string `json:"resource"`

	// Message describes the violation
	Message string `json:"message"`

	// Details contains additional context
	Details map[string]interface{} `json:"details,omitempty"`
}

// Severity levels for policy violations
type Severity string

const (
	// SeverityInfo is informational only
	SeverityInfo Severity = "info"

	// SeverityWarning is a warning that doesn't block
	SeverityWarning Severity = "warning"

	// SeverityError is an error but doesn't block
	SeverityError Severity = "error"

	// SeverityBlock blocks deployment
	SeverityBlock Severity = "block"
)

// Evaluator runs all policy rules
type Evaluator interface {
	// RegisterRule adds a rule to the evaluator
	RegisterRule(rule Rule) error

	// Evaluate runs all rules and returns results
	Evaluate(ctx context.Context, current *types.CostGraph, prev *types.CostGraph) (*EvaluationResult, error)

	// EvaluateRules runs specific rules
	EvaluateRules(ctx context.Context, ruleNames []string, current *types.CostGraph, prev *types.CostGraph) (*EvaluationResult, error)
}

// EvaluationResult contains all rule results
type EvaluationResult struct {
	// Results contains individual rule results
	Results []*RuleResult `json:"results"`

	// PassedCount is the number of passed rules
	PassedCount int `json:"passed_count"`

	// FailedCount is the number of failed rules
	FailedCount int `json:"failed_count"`

	// Blocked indicates if any rule blocks deployment
	Blocked bool `json:"blocked"`

	// BlockReason explains why deployment is blocked
	BlockReason string `json:"block_reason,omitempty"`
}

// HasFailures returns true if any rules failed
func (r *EvaluationResult) HasFailures() bool {
	return r.FailedCount > 0
}

// GetBlockingRules returns rules that block deployment
func (r *EvaluationResult) GetBlockingRules() []*RuleResult {
	var blocking []*RuleResult
	for _, result := range r.Results {
		if !result.Passed && result.Severity == SeverityBlock {
			blocking = append(blocking, result)
		}
	}
	return blocking
}

// PolicyConfig contains policy configuration
type PolicyConfig struct {
	// Rules are the rules to evaluate
	Rules []RuleConfig `json:"rules"`

	// StopOnBlock stops evaluation on first blocking rule
	StopOnBlock bool `json:"stop_on_block"`
}

// RuleConfig contains configuration for a specific rule
type RuleConfig struct {
	// Name is the rule name
	Name string `json:"name"`

	// Enabled indicates if the rule is enabled
	Enabled bool `json:"enabled"`

	// Severity overrides the default severity
	Severity *Severity `json:"severity,omitempty"`

	// Parameters contains rule-specific parameters
	Parameters map[string]interface{} `json:"parameters,omitempty"`
}

################################################################################
# FILE: :\good projects\cost estimation\core\policy\explanation.go
# TYPE: go
# SIZE: 11794 bytes
################################################################################
// Package policy - Explainable policy results
// Policies explain WHY they failed, not just THAT they failed.
package policy

import (
	"fmt"
	"sort"
	"strings"

	"terraform-cost/core/determinism"
	"terraform-cost/core/model"
)

// ExplainedResult is a policy result with full explanation
type ExplainedResult struct {
	PolicyName string
	Passed     bool

	// Short summary
	Summary string

	// Detailed explanation
	Explanation *PolicyExplanation

	// Recommendations
	Recommendations []Recommendation
}

// PolicyExplanation provides deep explanation of policy outcome
type PolicyExplanation struct {
	// What the policy checks
	PolicyDescription string

	// What threshold/limit was applied
	Threshold *ThresholdInfo

	// What was analyzed
	AnalyzedScope AnalysisScope

	// What caused the violation (if failed)
	Violations []ViolationDetail

	// What contributed most to the outcome
	TopContributors []Contributor

	// Confidence considerations
	ConfidenceImpact *ConfidenceImpactInfo
}

// ThresholdInfo describes policy thresholds
type ThresholdInfo struct {
	Name      string // e.g., "monthly_budget"
	Value     string // e.g., "$1000.00"
	Actual    string // e.g., "$1234.56"
	Exceeded  bool
	ExcessBy  string // e.g., "$234.56 (23.5%)"
}

// AnalysisScope describes what was analyzed
type AnalysisScope struct {
	TotalInstances   int
	TotalComponents  int
	AnalyzedTypes    []string
	ExcludedTypes    []string
	TimeRange        string // if applicable
}

// ViolationDetail explains a specific violation
type ViolationDetail struct {
	// What violated
	InstanceAddress model.CanonicalAddress
	Component       string

	// Why it violated
	Reason string

	// How much impact
	CostImpact determinism.Money

	// What would fix it
	SuggestedFix string

	// Related lineage
	FormulaUsed   string
	RateUsed      string
	UsageAssumed  string
}

// Contributor identifies what contributed to outcome
type Contributor struct {
	Category string // "instance", "component", "rate", "usage"
	Name     string
	Impact   determinism.Money
	Percent  float64
	Reason   string
}

// ConfidenceImpactInfo describes how confidence affected the policy
type ConfidenceImpactInfo struct {
	OverallConfidence float64
	LowConfidenceItems int
	AffectedByUnknowns bool
	UnknownCount       int
	Caveat             string // e.g., "Result may change when unknowns resolve"
}

// Recommendation is a suggested action
type Recommendation struct {
	Priority    int    // 1=critical, 2=high, 3=medium
	Action      string
	Rationale   string
	EstimatedSavings *determinism.Money
}

// ExplainablePolicy is a policy that provides explanations
type ExplainablePolicy interface {
	Name() string
	Description() string
	EvaluateWithExplanation(ctx *FullLineageContext) (*ExplainedResult, error)
}

// ExplainedBudgetPolicy is a budget policy with explanations
type ExplainedBudgetPolicy struct {
	name          string
	description   string
	monthlyBudget determinism.Money
	warnThreshold float64
}

// NewExplainedBudgetPolicy creates an explainable budget policy
func NewExplainedBudgetPolicy(name string, budget determinism.Money, warnAt float64) *ExplainedBudgetPolicy {
	return &ExplainedBudgetPolicy{
		name:          name,
		description:   fmt.Sprintf("Ensures monthly costs stay within $%s budget", budget.String()),
		monthlyBudget: budget,
		warnThreshold: warnAt,
	}
}

func (p *ExplainedBudgetPolicy) Name() string        { return p.name }
func (p *ExplainedBudgetPolicy) Description() string { return p.description }

func (p *ExplainedBudgetPolicy) EvaluateWithExplanation(ctx *FullLineageContext) (*ExplainedResult, error) {
	result := &ExplainedResult{
		PolicyName: p.name,
		Passed:     true,
		Explanation: &PolicyExplanation{
			PolicyDescription: p.description,
			AnalyzedScope: AnalysisScope{
				TotalInstances: len(ctx.Instances),
			},
		},
	}

	// Count components
	for _, inst := range ctx.Instances {
		result.Explanation.AnalyzedScope.TotalComponents += len(inst.Components)
	}

	// Set threshold info
	result.Explanation.Threshold = &ThresholdInfo{
		Name:   "monthly_budget",
		Value:  "$" + p.monthlyBudget.String(),
		Actual: "$" + ctx.TotalMonthlyCost.String(),
	}

	// Check budget
	if ctx.TotalMonthlyCost.Cmp(p.monthlyBudget) > 0 {
		result.Passed = false
		excess := ctx.TotalMonthlyCost.Sub(p.monthlyBudget)
		percent := (ctx.TotalMonthlyCost.Float64() / p.monthlyBudget.Float64() - 1) * 100

		result.Summary = fmt.Sprintf("Monthly cost $%s exceeds budget $%s by $%s (%.1f%%)",
			ctx.TotalMonthlyCost.String(), p.monthlyBudget.String(), excess.String(), percent)

		result.Explanation.Threshold.Exceeded = true
		result.Explanation.Threshold.ExcessBy = fmt.Sprintf("$%s (%.1f%%)", excess.String(), percent)

		// Find top contributors
		result.Explanation.TopContributors = p.findTopContributors(ctx, 5)
		result.Explanation.Violations = p.buildViolations(ctx, excess)

		// Add recommendations
		result.Recommendations = p.generateRecommendations(ctx, excess)
	} else {
		percent := ctx.TotalMonthlyCost.Float64() / p.monthlyBudget.Float64() * 100
		result.Summary = fmt.Sprintf("Monthly cost $%s is within budget $%s (%.1f%% utilized)",
			ctx.TotalMonthlyCost.String(), p.monthlyBudget.String(), percent)

		// Warn if close to threshold
		if percent >= p.warnThreshold*100 {
			result.Recommendations = append(result.Recommendations, Recommendation{
				Priority:  3,
				Action:    "Monitor cost growth",
				Rationale: fmt.Sprintf("Currently at %.1f%% of budget", percent),
			})
		}
	}

	// Add confidence impact
	result.Explanation.ConfidenceImpact = &ConfidenceImpactInfo{
		OverallConfidence: ctx.OverallConfidence,
		LowConfidenceItems: len(ctx.LowConfidenceItems),
		UnknownCount:       len(ctx.Unknowns),
	}

	if ctx.OverallConfidence < 0.9 {
		result.Explanation.ConfidenceImpact.Caveat = 
			"Cost estimate has reduced confidence; actual costs may vary"
	}
	if len(ctx.Unknowns) > 0 {
		result.Explanation.ConfidenceImpact.AffectedByUnknowns = true
	}

	return result, nil
}

func (p *ExplainedBudgetPolicy) findTopContributors(ctx *FullLineageContext, n int) []Contributor {
	type item struct {
		addr model.CanonicalAddress
		cost determinism.Money
	}

	var items []item
	for _, inst := range ctx.Instances {
		items = append(items, item{
			addr: model.CanonicalAddress(inst.Address),
			cost: inst.MonthlyCost,
		})
	}

	sort.Slice(items, func(i, j int) bool {
		return items[i].cost.Cmp(items[j].cost) > 0
	})

	if n > len(items) {
		n = len(items)
	}

	contributors := make([]Contributor, n)
	for i := 0; i < n; i++ {
		percent := items[i].cost.Float64() / ctx.TotalMonthlyCost.Float64() * 100
		contributors[i] = Contributor{
			Category: "instance",
			Name:     string(items[i].addr),
			Impact:   items[i].cost,
			Percent:  percent,
			Reason:   fmt.Sprintf("%.1f%% of total cost", percent),
		}
	}

	return contributors
}

func (p *ExplainedBudgetPolicy) buildViolations(ctx *FullLineageContext, excess determinism.Money) []ViolationDetail {
	var violations []ViolationDetail

	// Find top 3 cost drivers as "violations"
	type item struct {
		inst *InstanceLineage
		cost determinism.Money
	}

	var items []item
	for _, inst := range ctx.Instances {
		items = append(items, item{inst: inst, cost: inst.MonthlyCost})
	}

	sort.Slice(items, func(i, j int) bool {
		return items[i].cost.Cmp(items[j].cost) > 0
	})

	n := 3
	if n > len(items) {
		n = len(items)
	}

	for i := 0; i < n; i++ {
		inst := items[i].inst
		violations = append(violations, ViolationDetail{
			InstanceAddress: model.CanonicalAddress(inst.Address),
			Reason:          fmt.Sprintf("High cost: $%s/month", inst.MonthlyCost.String()),
			CostImpact:      inst.MonthlyCost,
			SuggestedFix:    p.suggestFix(inst),
		})
	}

	return violations
}

func (p *ExplainedBudgetPolicy) suggestFix(inst *InstanceLineage) string {
	// Generate context-aware suggestions
	resourceType := strings.Split(string(inst.Address), ".")[0]

	switch {
	case strings.Contains(resourceType, "instance"):
		return "Consider using a smaller instance type or Spot instances"
	case strings.Contains(resourceType, "db") || strings.Contains(resourceType, "rds"):
		return "Consider Reserved Instances or Aurora Serverless"
	case strings.Contains(resourceType, "nat"):
		return "Consider VPC endpoints to reduce NAT traffic"
	case strings.Contains(resourceType, "lb"):
		return "Review target groups and consider consolidation"
	default:
		return "Review configuration for cost optimization"
	}
}

func (p *ExplainedBudgetPolicy) generateRecommendations(ctx *FullLineageContext, excess determinism.Money) []Recommendation {
	var recs []Recommendation

	recs = append(recs, Recommendation{
		Priority:  1,
		Action:    "Review top cost contributors",
		Rationale: "Focus on highest-cost instances for maximum impact",
	})

	// If many low confidence items
	if len(ctx.LowConfidenceItems) > len(ctx.Instances)/4 {
		recs = append(recs, Recommendation{
			Priority:  2,
			Action:    "Provide usage overrides for low-confidence components",
			Rationale: fmt.Sprintf("%d components have uncertain cost estimates", len(ctx.LowConfidenceItems)),
		})
	}

	// If unknowns present
	if len(ctx.Unknowns) > 0 {
		recs = append(recs, Recommendation{
			Priority:  2,
			Action:    "Resolve unknown Terraform values",
			Rationale: fmt.Sprintf("%d unknown values may affect final cost", len(ctx.Unknowns)),
		})
	}

	return recs
}

// FormatExplanation returns a human-readable explanation
func FormatExplanation(result *ExplainedResult) string {
	var sb strings.Builder

	// Header
	status := "âœ“ PASS"
	if !result.Passed {
		status = "âœ— FAIL"
	}
	sb.WriteString(fmt.Sprintf("Policy: %s [%s]\n", result.PolicyName, status))
	sb.WriteString(fmt.Sprintf("Summary: %s\n\n", result.Summary))

	if result.Explanation == nil {
		return sb.String()
	}

	// Threshold
	if t := result.Explanation.Threshold; t != nil {
		sb.WriteString("Threshold:\n")
		sb.WriteString(fmt.Sprintf("  %s: %s (actual: %s)\n", t.Name, t.Value, t.Actual))
		if t.Exceeded {
			sb.WriteString(fmt.Sprintf("  EXCEEDED by: %s\n", t.ExcessBy))
		}
		sb.WriteString("\n")
	}

	// Top contributors
	if len(result.Explanation.TopContributors) > 0 {
		sb.WriteString("Top Cost Contributors:\n")
		for i, c := range result.Explanation.TopContributors {
			sb.WriteString(fmt.Sprintf("  %d. %s: $%s (%.1f%%)\n", i+1, c.Name, c.Impact.String(), c.Percent))
		}
		sb.WriteString("\n")
	}

	// Violations
	if len(result.Explanation.Violations) > 0 {
		sb.WriteString("Violations:\n")
		for _, v := range result.Explanation.Violations {
			sb.WriteString(fmt.Sprintf("  â€¢ %s\n", v.InstanceAddress))
			sb.WriteString(fmt.Sprintf("    Reason: %s\n", v.Reason))
			sb.WriteString(fmt.Sprintf("    Suggestion: %s\n", v.SuggestedFix))
		}
		sb.WriteString("\n")
	}

	// Recommendations
	if len(result.Recommendations) > 0 {
		sb.WriteString("Recommendations:\n")
		for _, r := range result.Recommendations {
			priority := "!"
			if r.Priority == 1 {
				priority = "!!!"
			} else if r.Priority == 2 {
				priority = "!!"
			}
			sb.WriteString(fmt.Sprintf("  [%s] %s\n", priority, r.Action))
			sb.WriteString(fmt.Sprintf("       %s\n", r.Rationale))
		}
		sb.WriteString("\n")
	}

	// Confidence caveat
	if c := result.Explanation.ConfidenceImpact; c != nil && c.Caveat != "" {
		sb.WriteString(fmt.Sprintf("Note: %s\n", c.Caveat))
	}

	return sb.String()
}

################################################################################
# FILE: :\good projects\cost estimation\core\policy\full_lineage.go
# TYPE: go
# SIZE: 10052 bytes
################################################################################
// Package policy - Full lineage access for policies
// Policies can see the COMPLETE derivation chain.
package policy

import (
	"fmt"

	"terraform-cost/core/determinism"
	"terraform-cost/core/model"
	"terraform-cost/core/pricing"
)

// FullLineageContext provides COMPLETE cost derivation information to policies
type FullLineageContext struct {
	// Per-instance costs with full derivation
	Instances map[model.InstanceID]*InstanceLineage

	// Rollups
	TotalMonthlyCost determinism.Money
	TotalHourlyCost  determinism.Money

	// Confidence breakdown
	OverallConfidence    float64
	ConfidenceByInstance map[model.InstanceID]float64
	ConfidenceByComponent map[string]float64

	// Low confidence items
	LowConfidenceItems []LowConfidenceItem

	// Unknown tracking
	Unknowns []UnknownInfo
	UnknownsByInstance map[model.InstanceID][]UnknownInfo

	// Snapshot reference
	Snapshot SnapshotInfo
}

// InstanceLineage is the FULL derivation for a single instance
type InstanceLineage struct {
	// Instance identity
	InstanceID   model.InstanceID
	Address      model.InstanceAddress
	DefinitionID model.DefinitionID
	InstanceKey  model.InstanceKey

	// Provider context
	Provider string
	Region   string

	// Cost summary
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money
	Confidence  float64

	// FULL component breakdown
	Components []ComponentLineage

	// Resource tags
	Tags map[string]string

	// Unknowns affecting this instance
	Unknowns []UnknownInfo

	// Degradation reasons
	DegradedParts []DegradationInfo
}

// ComponentLineage is the FULL derivation for a cost component
type ComponentLineage struct {
	// Component identity
	Name        string
	ResourceType string

	// Cost
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money
	Confidence  float64

	// RATE: Which pricing rate was used
	Rate RateLineage

	// USAGE: Where usage data came from
	Usage UsageLineage

	// FORMULA: How cost was calculated
	Formula FormulaLineage

	// Is this component degraded?
	IsDegraded       bool
	DegradationReason string
}

// RateLineage tracks the pricing rate used
type RateLineage struct {
	// Rate identity
	RateID      pricing.RateID
	RateKey     pricing.RateKey

	// Rate details
	Price       string
	Unit        string
	Currency    string
	Description string

	// Tier info (for tiered pricing)
	Tier        *TierInfo

	// Was this rate found?
	Found       bool
	MissingReason string
}

// TierInfo describes pricing tier
type TierInfo struct {
	TierIndex   int
	StartUsage  string
	EndUsage    string
	TierPrice   string
}

// UsageLineage tracks where usage data came from
type UsageLineage struct {
	// Source of usage data
	Source UsageSourceType

	// The value used
	Value       float64
	Unit        string

	// Confidence in this value
	Confidence  float64

	// Was this overridden by user?
	IsOverridden bool

	// Profile used (if any)
	Profile     string

	// Assumptions made
	Assumptions []string

	// Was this unknown?
	IsUnknown   bool
	UnknownReason string
}

// UsageSourceType indicates where usage came from
type UsageSourceType int

const (
	UsageFromDefault UsageSourceType = iota
	UsageFromProfile
	UsageFromOverride
	UsageFromHistorical
	UsageFromEstimate
	UsageUnknown
)

// String returns the source name
func (s UsageSourceType) String() string {
	switch s {
	case UsageFromDefault:
		return "default"
	case UsageFromProfile:
		return "profile"
	case UsageFromOverride:
		return "override"
	case UsageFromHistorical:
		return "historical"
	case UsageFromEstimate:
		return "estimate"
	case UsageUnknown:
		return "unknown"
	default:
		return "unknown"
	}
}

// FormulaLineage tracks how cost was calculated
type FormulaLineage struct {
	// Formula name
	Name       string

	// Readable expression
	Expression string

	// All inputs used
	Inputs     map[string]FormulaInput

	// The output
	Output     string
}

// FormulaInput is a single input to a formula
type FormulaInput struct {
	Name       string
	Value      string
	Source     string // "rate", "usage", "constant"
	Confidence float64
}

// UnknownInfo describes an unknown value
type UnknownInfo struct {
	// What is unknown
	Address   string
	Component string
	Attribute string

	// Why it's unknown
	Reason    string

	// Impact on cost
	Impact    UnknownImpact
}

// UnknownImpact describes how an unknown affects cost
type UnknownImpact int

const (
	ImpactHigh   UnknownImpact = iota // Cost is unreliable
	ImpactMedium                       // Cost is approximate
	ImpactLow                          // Cost is slightly affected
)

// String returns the impact level
func (i UnknownImpact) String() string {
	switch i {
	case ImpactHigh:
		return "high"
	case ImpactMedium:
		return "medium"
	case ImpactLow:
		return "low"
	default:
		return "unknown"
	}
}

// DegradationInfo describes why a cost is degraded
type DegradationInfo struct {
	Component string
	Reason    string
	Impact    float64
}

// SnapshotInfo is the pricing snapshot reference
type SnapshotInfo struct {
	ID          pricing.SnapshotID
	ContentHash string
	Provider    string
	Region      string
	CreatedAt   string
	EffectiveAt string
	IsStale     bool
}

// LineageAwarePolicy is a policy that uses full lineage
type LineageAwarePolicy interface {
	Name() string
	EvaluateWithLineage(ctx *FullLineageContext) (*LineageAwarePolicyResult, error)
}

// LineageAwarePolicyResult is the result of a lineage-aware policy
type LineageAwarePolicyResult struct {
	Passed  bool
	Message string

	// What was analyzed
	AnalyzedInstances int
	AnalyzedComponents int

	// What failed
	FailedInstances   []model.InstanceID
	FailedComponents  []string

	// Cost impact
	AffectedCost determinism.Money

	// Full lineage for failures (for explainability)
	FailureLineage []*InstanceLineage

	// Recommendations
	Recommendations []string
}

// UsageConfidencePolicy fails if usage confidence is too low
type UsageConfidencePolicy struct {
	name          string
	minConfidence float64
}

// NewUsageConfidencePolicy creates a usage confidence policy
func NewUsageConfidencePolicy(name string, minConfidence float64) *UsageConfidencePolicy {
	return &UsageConfidencePolicy{name: name, minConfidence: minConfidence}
}

// Name returns the policy name
func (p *UsageConfidencePolicy) Name() string { return p.name }

// EvaluateWithLineage evaluates with full lineage access
func (p *UsageConfidencePolicy) EvaluateWithLineage(ctx *FullLineageContext) (*LineageAwarePolicyResult, error) {
	result := &LineageAwarePolicyResult{
		Passed: true,
	}

	var lowConfidenceInstances []*InstanceLineage
	var lowConfidenceComponents []string

	for _, inst := range ctx.Instances {
		result.AnalyzedInstances++

		for _, comp := range inst.Components {
			result.AnalyzedComponents++

			// Check USAGE confidence specifically
			if comp.Usage.Confidence < p.minConfidence {
				result.Passed = false

				if !containsID(result.FailedInstances, inst.InstanceID) {
					result.FailedInstances = append(result.FailedInstances, inst.InstanceID)
					lowConfidenceInstances = append(lowConfidenceInstances, inst)
				}

				lowConfidenceComponents = append(lowConfidenceComponents,
					string(inst.Address)+"/"+comp.Name)

				result.AffectedCost = result.AffectedCost.Add(comp.MonthlyCost)
			}
		}
	}

	if !result.Passed {
		result.Message = fmt.Sprintf(
			"%d components have usage confidence below %.0f%%",
			len(lowConfidenceComponents), p.minConfidence*100)

		result.FailedComponents = lowConfidenceComponents
		result.FailureLineage = lowConfidenceInstances

		result.Recommendations = []string{
			"Provide usage overrides for low-confidence components",
			"Use a usage profile to set expected values",
			"Review assumptions in the usage estimation",
		}
	} else {
		result.Message = fmt.Sprintf(
			"All %d components meet %.0f%% usage confidence",
			result.AnalyzedComponents, p.minConfidence*100)
	}

	return result, nil
}

// FormulaAuditPolicy checks that all formulas are documented
type FormulaAuditPolicy struct {
	name string
}

// NewFormulaAuditPolicy creates a formula audit policy
func NewFormulaAuditPolicy(name string) *FormulaAuditPolicy {
	return &FormulaAuditPolicy{name: name}
}

// Name returns the policy name
func (p *FormulaAuditPolicy) Name() string { return p.name }

// EvaluateWithLineage evaluates with full lineage access
func (p *FormulaAuditPolicy) EvaluateWithLineage(ctx *FullLineageContext) (*LineageAwarePolicyResult, error) {
	result := &LineageAwarePolicyResult{
		Passed: true,
	}

	var undocumentedFormulas []string

	for _, inst := range ctx.Instances {
		result.AnalyzedInstances++

		for _, comp := range inst.Components {
			result.AnalyzedComponents++

			// Check formula documentation
			if comp.Formula.Name == "" || comp.Formula.Expression == "" {
				result.Passed = false

				if !containsID(result.FailedInstances, inst.InstanceID) {
					result.FailedInstances = append(result.FailedInstances, inst.InstanceID)
				}

				undocumentedFormulas = append(undocumentedFormulas,
					string(inst.Address)+"/"+comp.Name)
			}
		}
	}

	if !result.Passed {
		result.Message = fmt.Sprintf(
			"%d formulas are undocumented",
			len(undocumentedFormulas))

		result.FailedComponents = undocumentedFormulas

		result.Recommendations = []string{
			"Ensure all pricing formulas are documented",
			"Review cost calculation logic",
		}
	} else {
		result.Message = fmt.Sprintf(
			"All %d formulas are documented",
			result.AnalyzedComponents)
	}

	return result, nil
}

func containsID(slice []model.InstanceID, id model.InstanceID) bool {
	for _, item := range slice {
		if item == id {
			return true
		}
	}
	return false
}

################################################################################
# FILE: :\good projects\cost estimation\core\pricing\alias_rate_key.go
# TYPE: go
# SIZE: 6070 bytes
################################################################################
// Package pricing - Alias-aware rate key
// Alias MUST be part of rate key - no exceptions
package pricing

import (
	"fmt"
)

// AliasAwareRateKey is a rate key that ALWAYS includes provider alias
type AliasAwareRateKey struct {
	Provider     string
	Alias        string  // REQUIRED - empty means default
	Region       string
	AccountID    string  // Optional but recommended
	ResourceType string
	Component    string
	SKU          string

	// Computed key
	key string
}

// NewAliasAwareRateKey creates a rate key with required alias
func NewAliasAwareRateKey(provider, alias, region, resourceType, component string) *AliasAwareRateKey {
	k := &AliasAwareRateKey{
		Provider:     provider,
		Alias:        alias,
		Region:       region,
		ResourceType: resourceType,
		Component:    component,
	}
	k.computeKey()
	return k
}

// WithAccountID adds account ID to the key
func (k *AliasAwareRateKey) WithAccountID(accountID string) *AliasAwareRateKey {
	k.AccountID = accountID
	k.computeKey()
	return k
}

// WithSKU adds SKU to the key
func (k *AliasAwareRateKey) WithSKU(sku string) *AliasAwareRateKey {
	k.SKU = sku
	k.computeKey()
	return k
}

func (k *AliasAwareRateKey) computeKey() {
	// Format: provider:alias:region:account:type:component:sku
	// Alias is ALWAYS included (empty = default)
	aliasStr := k.Alias
	if aliasStr == "" {
		aliasStr = "_default_"
	}
	
	accountStr := k.AccountID
	if accountStr == "" {
		accountStr = "_"
	}

	skuStr := k.SKU
	if skuStr == "" {
		skuStr = "_"
	}

	k.key = fmt.Sprintf("%s:%s:%s:%s:%s:%s:%s",
		k.Provider, aliasStr, k.Region, accountStr,
		k.ResourceType, k.Component, skuStr,
	)
}

// Key returns the computed key string
func (k *AliasAwareRateKey) Key() string {
	return k.key
}

// String returns the key
func (k *AliasAwareRateKey) String() string {
	return k.key
}

// Matches checks if this key matches another
func (k *AliasAwareRateKey) Matches(other *AliasAwareRateKey) bool {
	return k.key == other.key
}

// MatchesProvider checks if provider/alias/region match
func (k *AliasAwareRateKey) MatchesProvider(provider, alias, region string) bool {
	return k.Provider == provider && k.Alias == alias && k.Region == region
}

// RateKeyBuilder builds alias-aware rate keys
type RateKeyBuilder struct {
	provider  string
	alias     string
	region    string
	accountID string
}

// NewRateKeyBuilder creates a builder
func NewRateKeyBuilder(provider, alias, region string) *RateKeyBuilder {
	return &RateKeyBuilder{
		provider: provider,
		alias:    alias,
		region:   region,
	}
}

// WithAccount sets account ID
func (b *RateKeyBuilder) WithAccount(accountID string) *RateKeyBuilder {
	b.accountID = accountID
	return b
}

// Build creates a rate key for a resource
func (b *RateKeyBuilder) Build(resourceType, component string) *AliasAwareRateKey {
	k := NewAliasAwareRateKey(b.provider, b.alias, b.region, resourceType, component)
	if b.accountID != "" {
		k.WithAccountID(b.accountID)
	}
	return k
}

// BuildWithSKU creates a rate key with SKU
func (b *RateKeyBuilder) BuildWithSKU(resourceType, component, sku string) *AliasAwareRateKey {
	k := NewAliasAwareRateKey(b.provider, b.alias, b.region, resourceType, component)
	if b.accountID != "" {
		k.WithAccountID(b.accountID)
	}
	k.WithSKU(sku)
	return k
}

// RateKeyValidator ensures rate keys include alias
type RateKeyValidator struct {
	errors []RateKeyError
}

// RateKeyError is an error in rate key construction
type RateKeyError struct {
	Context string
	Message string
}

// NewRateKeyValidator creates a validator
func NewRateKeyValidator() *RateKeyValidator {
	return &RateKeyValidator{
		errors: []RateKeyError{},
	}
}

// ValidateKey ensures a key is properly formed
func (v *RateKeyValidator) ValidateKey(key *AliasAwareRateKey, context string) bool {
	if key.Provider == "" {
		v.errors = append(v.errors, RateKeyError{
			Context: context,
			Message: "provider is required",
		})
		return false
	}
	if key.Region == "" {
		v.errors = append(v.errors, RateKeyError{
			Context: context,
			Message: "region is required",
		})
		return false
	}
	if key.ResourceType == "" {
		v.errors = append(v.errors, RateKeyError{
			Context: context,
			Message: "resource type is required",
		})
		return false
	}
	return true
}

// GetErrors returns all errors
func (v *RateKeyValidator) GetErrors() []RateKeyError {
	return v.errors
}

// AliasAwareRateResolver resolves rates with alias awareness
type AliasAwareRateResolver struct {
	validator *RateKeyValidator
}

// NewAliasAwareRateResolver creates a resolver
func NewAliasAwareRateResolver() *AliasAwareRateResolver {
	return &AliasAwareRateResolver{
		validator: NewRateKeyValidator(),
	}
}

// ResolveRate resolves a rate, ensuring alias is included
func (r *AliasAwareRateResolver) ResolveRate(snapshot *PricingSnapshot, key *AliasAwareRateKey) (*RateEntry, error) {
	if !r.validator.ValidateKey(key, key.ResourceType) {
		return nil, fmt.Errorf("invalid rate key for %s", key.ResourceType)
	}

	// Lookup with full alias-aware key
	rate, ok := snapshot.LookupRateByKey(key.Key())
	if !ok {
		// Try fallback to default alias
		if key.Alias != "" {
			fallbackKey := NewAliasAwareRateKey(key.Provider, "", key.Region, key.ResourceType, key.Component)
			rate, ok = snapshot.LookupRateByKey(fallbackKey.Key())
			if ok {
				return rate, nil
			}
		}
		return nil, &RateNotFoundError{Key: key.Key()}
	}

	return rate, nil
}

// RateNotFoundError indicates a rate was not found
type RateNotFoundError struct {
	Key string
}

func (e *RateNotFoundError) Error() string {
	return "rate not found: " + e.Key
}

// LookupRateByKey looks up a rate by key string
func (s *PricingSnapshot) LookupRateByKey(key string) (*RateEntry, bool) {
	for i := range s.rates {
		if s.rates[i].Key.String() == key {
			return &s.rates[i], true
		}
	}
	return nil, false
}

################################################################################
# FILE: :\good projects\cost estimation\core\pricing\cache_governance.go
# TYPE: go
# SIZE: 7679 bytes
################################################################################
// Package pricing - Cache governance with TTL and schema versioning
// Stale pricing is silent failure. Governance is mandatory.
package pricing

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"sync"
	"time"
)

// CacheGovernance manages pricing cache lifecycle
type CacheGovernance struct {
	// TTL policy
	defaultTTL time.Duration
	perSourceTTL map[string]time.Duration

	// Schema versioning
	schemaVersions map[string]string

	// Provider metadata hashes
	providerHashes map[string]string

	// Cache entries with metadata
	entries map[string]*CacheEntry

	// Lock
	mu sync.RWMutex
}

// CacheEntry is a cached pricing entry with governance metadata
type CacheEntry struct {
	Key           string
	Value         interface{}
	SnapshotID    string
	SchemaVersion string
	ProviderHash  string
	CreatedAt     time.Time
	ExpiresAt     time.Time
	AccessCount   int
	LastAccessed  time.Time
}

// IsExpired checks if the entry has expired
func (e *CacheEntry) IsExpired() bool {
	return time.Now().After(e.ExpiresAt)
}

// IsStale checks if the entry is stale (schema/provider changed)
func (e *CacheEntry) IsStale(currentSchema, currentProviderHash string) bool {
	if e.SchemaVersion != currentSchema {
		return true
	}
	if e.ProviderHash != currentProviderHash {
		return true
	}
	return false
}

// CachePolicy defines cache behavior
type CachePolicy struct {
	// TTL for entries
	TTL time.Duration

	// Max entries
	MaxEntries int

	// Schema version
	SchemaVersion string

	// Force refresh on schema change
	RefreshOnSchemaChange bool

	// Force refresh on provider update
	RefreshOnProviderUpdate bool
}

// DefaultCachePolicy returns the default policy
func DefaultCachePolicy() *CachePolicy {
	return &CachePolicy{
		TTL:                     24 * time.Hour,
		MaxEntries:              10000,
		SchemaVersion:           "1.0",
		RefreshOnSchemaChange:   true,
		RefreshOnProviderUpdate: true,
	}
}

// NewCacheGovernance creates a new governance instance
func NewCacheGovernance(policy *CachePolicy) *CacheGovernance {
	if policy == nil {
		policy = DefaultCachePolicy()
	}
	return &CacheGovernance{
		defaultTTL:     policy.TTL,
		perSourceTTL:   make(map[string]time.Duration),
		schemaVersions: make(map[string]string),
		providerHashes: make(map[string]string),
		entries:        make(map[string]*CacheEntry),
	}
}

// SetSourceTTL sets TTL for a specific source
func (g *CacheGovernance) SetSourceTTL(source string, ttl time.Duration) {
	g.mu.Lock()
	defer g.mu.Unlock()
	g.perSourceTTL[source] = ttl
}

// SetSchemaVersion sets the schema version for a provider
func (g *CacheGovernance) SetSchemaVersion(provider, version string) {
	g.mu.Lock()
	defer g.mu.Unlock()
	g.schemaVersions[provider] = version
}

// SetProviderHash sets the metadata hash for a provider
func (g *CacheGovernance) SetProviderHash(provider, hash string) {
	g.mu.Lock()
	defer g.mu.Unlock()
	g.providerHashes[provider] = hash
}

// Get retrieves an entry if valid
func (g *CacheGovernance) Get(key, provider string) (interface{}, bool) {
	g.mu.RLock()
	entry, exists := g.entries[key]
	g.mu.RUnlock()

	if !exists {
		return nil, false
	}

	// Check expiration
	if entry.IsExpired() {
		g.Invalidate(key)
		return nil, false
	}

	// Check staleness
	currentSchema := g.schemaVersions[provider]
	currentHash := g.providerHashes[provider]
	if entry.IsStale(currentSchema, currentHash) {
		g.Invalidate(key)
		return nil, false
	}

	// Update access stats
	g.mu.Lock()
	entry.AccessCount++
	entry.LastAccessed = time.Now()
	g.mu.Unlock()

	return entry.Value, true
}

// Put stores an entry with metadata
func (g *CacheGovernance) Put(key string, value interface{}, provider, snapshotID string) {
	g.mu.Lock()
	defer g.mu.Unlock()

	ttl := g.defaultTTL
	if sourceTTL, ok := g.perSourceTTL[provider]; ok {
		ttl = sourceTTL
	}

	now := time.Now()
	g.entries[key] = &CacheEntry{
		Key:           key,
		Value:         value,
		SnapshotID:    snapshotID,
		SchemaVersion: g.schemaVersions[provider],
		ProviderHash:  g.providerHashes[provider],
		CreatedAt:     now,
		ExpiresAt:     now.Add(ttl),
		AccessCount:   0,
		LastAccessed:  now,
	}
}

// Invalidate removes an entry
func (g *CacheGovernance) Invalidate(key string) {
	g.mu.Lock()
	defer g.mu.Unlock()
	delete(g.entries, key)
}

// InvalidateProvider invalidates all entries for a provider
func (g *CacheGovernance) InvalidateProvider(provider string) {
	g.mu.Lock()
	defer g.mu.Unlock()

	// Build list of keys to remove
	toRemove := []string{}
	currentSchema := g.schemaVersions[provider]
	currentHash := g.providerHashes[provider]

	for key, entry := range g.entries {
		if entry.IsStale(currentSchema, currentHash) {
			toRemove = append(toRemove, key)
		}
	}

	for _, key := range toRemove {
		delete(g.entries, key)
	}
}

// InvalidateExpired removes all expired entries
func (g *CacheGovernance) InvalidateExpired() int {
	g.mu.Lock()
	defer g.mu.Unlock()

	count := 0
	for key, entry := range g.entries {
		if entry.IsExpired() {
			delete(g.entries, key)
			count++
		}
	}
	return count
}

// Stats returns cache statistics
func (g *CacheGovernance) Stats() *CacheStats {
	g.mu.RLock()
	defer g.mu.RUnlock()

	stats := &CacheStats{
		TotalEntries:   len(g.entries),
		ExpiredEntries: 0,
		StaleEntries:   0,
	}

	for _, entry := range g.entries {
		if entry.IsExpired() {
			stats.ExpiredEntries++
		}
	}

	return stats
}

// CacheStats contains cache statistics
type CacheStats struct {
	TotalEntries   int
	ExpiredEntries int
	StaleEntries   int
}

// ComputeProviderHash computes a hash of provider metadata
func ComputeProviderHash(provider string, version string, lastUpdated time.Time) string {
	h := sha256.New()
	h.Write([]byte(provider))
	h.Write([]byte(version))
	h.Write([]byte(lastUpdated.Format(time.RFC3339)))
	return hex.EncodeToString(h.Sum(nil))[:16]
}

// SchemaRegistry tracks schema versions
type SchemaRegistry struct {
	versions map[string]SchemaVersion
	mu       sync.RWMutex
}

// SchemaVersion describes a schema version
type SchemaVersion struct {
	Provider    string
	Version     string
	Hash        string
	FieldCount  int
	LastUpdated time.Time
}

// NewSchemaRegistry creates a new registry
func NewSchemaRegistry() *SchemaRegistry {
	return &SchemaRegistry{
		versions: make(map[string]SchemaVersion),
	}
}

// Register registers a schema version
func (r *SchemaRegistry) Register(provider, version string, fieldCount int) {
	r.mu.Lock()
	defer r.mu.Unlock()

	hash := computeSchemaHash(provider, version, fieldCount)
	r.versions[provider] = SchemaVersion{
		Provider:    provider,
		Version:     version,
		Hash:        hash,
		FieldCount:  fieldCount,
		LastUpdated: time.Now(),
	}
}

// Get returns the schema version for a provider
func (r *SchemaRegistry) Get(provider string) (SchemaVersion, bool) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	v, ok := r.versions[provider]
	return v, ok
}

// HasChanged checks if schema has changed
func (r *SchemaRegistry) HasChanged(provider, previousHash string) bool {
	r.mu.RLock()
	defer r.mu.RUnlock()
	if v, ok := r.versions[provider]; ok {
		return v.Hash != previousHash
	}
	return true
}

func computeSchemaHash(provider, version string, fieldCount int) string {
	h := sha256.New()
	h.Write([]byte(provider))
	h.Write([]byte(version))
	h.Write([]byte(fmt.Sprintf("%d", fieldCount)))
	return hex.EncodeToString(h.Sum(nil))[:16]
}

################################################################################
# FILE: :\good projects\cost estimation\core\pricing\enforcer.go
# TYPE: go
# SIZE: 7864 bytes
################################################################################
// Package pricing - Mandatory snapshot enforcement
// No cost can be computed without a valid, verified snapshot.
package pricing

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"terraform-cost/core/determinism"
)

// ErrNoSnapshot is returned when no pricing snapshot is available
var ErrNoSnapshot = errors.New("pricing snapshot required but not provided")

// ErrSnapshotInvalid is returned when snapshot fails verification
var ErrSnapshotInvalid = errors.New("pricing snapshot failed integrity verification")

// ErrSnapshotExpired is returned when snapshot is too old
var ErrSnapshotExpired = errors.New("pricing snapshot has expired")

// ErrRateNotFound is returned when a rate is not in the snapshot
var ErrRateNotFound = errors.New("rate not found in pricing snapshot")

// EnforcedResolver wraps a pricing resolver with mandatory snapshot enforcement.
// It is IMPOSSIBLE to get pricing without a valid snapshot.
type EnforcedResolver struct {
	store         SnapshotStore
	maxAge        time.Duration
	strictMode    bool
	mu            sync.RWMutex
	activeSnapshot *PricingSnapshot
}

// SnapshotStore provides snapshot storage
type SnapshotStore interface {
	// Get retrieves a specific snapshot by ID
	Get(ctx context.Context, id SnapshotID) (*PricingSnapshot, error)

	// GetLatest retrieves the latest snapshot for a provider/region
	// Returns error if no snapshot exists
	GetLatest(ctx context.Context, provider, region string) (*PricingSnapshot, error)

	// Store saves a snapshot
	Store(ctx context.Context, snapshot *PricingSnapshot) error
}

// EnforcedResolverConfig configures the enforced resolver
type EnforcedResolverConfig struct {
	// MaxAge is the maximum age of a snapshot before it's considered expired
	MaxAge time.Duration

	// StrictMode fails on any missing rate (vs degraded estimation)
	StrictMode bool
}

// NewEnforcedResolver creates a resolver that REQUIRES snapshots
func NewEnforcedResolver(store SnapshotStore, config EnforcedResolverConfig) *EnforcedResolver {
	maxAge := config.MaxAge
	if maxAge == 0 {
		maxAge = 24 * time.Hour // Default: 24 hours
	}
	return &EnforcedResolver{
		store:      store,
		maxAge:     maxAge,
		strictMode: config.StrictMode,
	}
}

// SnapshotRequest specifies which snapshot to use
type SnapshotRequest struct {
	// SnapshotID - if provided, use this specific snapshot
	SnapshotID SnapshotID

	// Otherwise, find latest for provider/region
	Provider string
	Region   string

	// AllowExpired allows using expired snapshots (with warning)
	AllowExpired bool
}

// ResolveResult contains the resolution result
type ResolveResult struct {
	// Snapshot used (ALWAYS set on success)
	Snapshot *PricingSnapshot

	// Rate found (nil if not found)
	Rate *RateEntry

	// Status
	Found   bool
	Reason  string
	Warning string
}

// GetSnapshot retrieves a snapshot - NEVER returns nil snapshot on success
func (r *EnforcedResolver) GetSnapshot(ctx context.Context, req SnapshotRequest) (*PricingSnapshot, error) {
	var snapshot *PricingSnapshot
	var err error

	// Try specific ID first
	if req.SnapshotID != "" {
		snapshot, err = r.store.Get(ctx, req.SnapshotID)
		if err != nil {
			return nil, fmt.Errorf("failed to get snapshot %s: %w", req.SnapshotID, err)
		}
	} else if req.Provider != "" && req.Region != "" {
		snapshot, err = r.store.GetLatest(ctx, req.Provider, req.Region)
		if err != nil {
			return nil, fmt.Errorf("no snapshot for %s/%s: %w", req.Provider, req.Region, ErrNoSnapshot)
		}
	} else {
		return nil, ErrNoSnapshot
	}

	if snapshot == nil {
		return nil, ErrNoSnapshot
	}

	// Verify integrity
	if !snapshot.Verify() {
		return nil, ErrSnapshotInvalid
	}

	// Check expiry
	if time.Since(snapshot.CreatedAt) > r.maxAge {
		if !req.AllowExpired {
			return nil, fmt.Errorf("%w: snapshot is %v old (max: %v)",
				ErrSnapshotExpired, time.Since(snapshot.CreatedAt), r.maxAge)
		}
	}

	return snapshot, nil
}

// LookupRate finds a rate in a snapshot - snapshot is REQUIRED
func (r *EnforcedResolver) LookupRate(
	snapshot *PricingSnapshot,
	resourceType, component string,
	attrs map[string]string,
) (*ResolveResult, error) {
	if snapshot == nil {
		return nil, ErrNoSnapshot
	}

	result := &ResolveResult{
		Snapshot: snapshot,
	}

	rate, found := snapshot.LookupRate(resourceType, component, attrs)
	if !found {
		result.Found = false
		result.Reason = fmt.Sprintf("no rate for %s/%s in snapshot %s", resourceType, component, snapshot.ID)

		if r.strictMode {
			return result, ErrRateNotFound
		}
		return result, nil
	}

	result.Found = true
	result.Rate = rate
	return result, nil
}

// MustHaveSnapshot ensures a snapshot exists or panics - for critical paths
func MustHaveSnapshot(snapshot *PricingSnapshot) {
	if snapshot == nil {
		panic("BUG: pricing snapshot is nil - this should never happen")
	}
}

// CostCalculation tracks a cost calculation with mandatory snapshot reference
type CostCalculation struct {
	// MANDATORY: Snapshot reference
	SnapshotID   SnapshotID
	SnapshotHash determinism.ContentHash

	// The calculation
	InstanceID  string
	Component   string
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money

	// Rate used
	RateID  RateID
	RateKey RateKey

	// Formula applied
	Formula FormulaApplication

	// Confidence (reduced if rate was missing or usage unknown)
	Confidence float64

	// Degradation info
	IsDegraded    bool
	DegradedParts []DegradedPart
}

// DegradedPart describes why a calculation was degraded
type DegradedPart struct {
	Component string
	Reason    DegradationReason
	Message   string
}

// DegradationReason explains why estimation is degraded
type DegradationReason int

const (
	ReasonRateMissing DegradationReason = iota
	ReasonUsageUnknown
	ReasonResourceUnknown
	ReasonSnapshotStale
)

// String returns the reason name
func (r DegradationReason) String() string {
	switch r {
	case ReasonRateMissing:
		return "rate_missing"
	case ReasonUsageUnknown:
		return "usage_unknown"
	case ReasonResourceUnknown:
		return "resource_unknown"
	case ReasonSnapshotStale:
		return "snapshot_stale"
	default:
		return "unknown"
	}
}

// InMemorySnapshotStore is a simple in-memory store for testing
type InMemorySnapshotStore struct {
	mu        sync.RWMutex
	snapshots map[SnapshotID]*PricingSnapshot
	latest    map[string]*PricingSnapshot // key: provider:region
}

// NewInMemorySnapshotStore creates an in-memory store
func NewInMemorySnapshotStore() *InMemorySnapshotStore {
	return &InMemorySnapshotStore{
		snapshots: make(map[SnapshotID]*PricingSnapshot),
		latest:    make(map[string]*PricingSnapshot),
	}
}

// Get retrieves a snapshot by ID
func (s *InMemorySnapshotStore) Get(ctx context.Context, id SnapshotID) (*PricingSnapshot, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	snap, ok := s.snapshots[id]
	if !ok {
		return nil, ErrNoSnapshot
	}
	return snap, nil
}

// GetLatest retrieves the latest snapshot for provider/region
func (s *InMemorySnapshotStore) GetLatest(ctx context.Context, provider, region string) (*PricingSnapshot, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	key := provider + ":" + region
	snap, ok := s.latest[key]
	if !ok {
		return nil, ErrNoSnapshot
	}
	return snap, nil
}

// Store saves a snapshot
func (s *InMemorySnapshotStore) Store(ctx context.Context, snapshot *PricingSnapshot) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.snapshots[snapshot.ID] = snapshot
	key := snapshot.Provider + ":" + snapshot.Region
	// Update latest if this is newer
	if existing, ok := s.latest[key]; !ok || snapshot.CreatedAt.After(existing.CreatedAt) {
		s.latest[key] = snapshot
	}
	return nil
}

################################################################################
# FILE: :\good projects\cost estimation\core\pricing\immutable_store.go
# TYPE: go
# SIZE: 8980 bytes
################################################################################
// Package pricing - Immutable snapshot storage
// Snapshots are write-once, content-hashed, and versioned.
// No silent updates. Ever.
package pricing

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sync"
	"time"
)

// ImmutabilityError is returned when attempting to violate immutability
var ErrImmutabilityViolation = errors.New("immutability violation: snapshot cannot be modified")

// ErrHashMismatch is returned when stored hash doesn't match computed hash
var ErrHashMismatch = errors.New("snapshot hash mismatch: data may be corrupted")

// ImmutableSnapshotStore is a storage layer that ENFORCES immutability.
// Once a snapshot is written, it can NEVER be overwritten.
type ImmutableSnapshotStore struct {
	mu       sync.RWMutex
	basePath string

	// In-memory index
	index map[SnapshotID]*SnapshotMetadata

	// Latest per provider:region
	latest map[string]SnapshotID
}

// SnapshotMetadata is stored alongside each snapshot
type SnapshotMetadata struct {
	ID          SnapshotID `json:"id"`
	ContentHash string     `json:"content_hash"`
	CreatedAt   time.Time  `json:"created_at"`
	EffectiveAt time.Time  `json:"effective_at"`
	Provider    string     `json:"provider"`
	Region      string     `json:"region"`
	Version     int        `json:"version"`
	Size        int64      `json:"size"`
	FilePath    string     `json:"file_path"`
}

// NewImmutableSnapshotStore creates a new immutable store
func NewImmutableSnapshotStore(basePath string) (*ImmutableSnapshotStore, error) {
	if err := os.MkdirAll(basePath, 0755); err != nil {
		return nil, fmt.Errorf("failed to create snapshot directory: %w", err)
	}

	store := &ImmutableSnapshotStore{
		basePath: basePath,
		index:    make(map[SnapshotID]*SnapshotMetadata),
		latest:   make(map[string]SnapshotID),
	}

	// Load existing index
	if err := store.loadIndex(); err != nil {
		// Index doesn't exist yet - that's OK
	}

	return store, nil
}

// Store writes a snapshot - FAILS if already exists
func (s *ImmutableSnapshotStore) Store(ctx context.Context, snapshot *PricingSnapshot) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	// Check if already exists
	if _, exists := s.index[snapshot.ID]; exists {
		return ErrImmutabilityViolation
	}

	// Compute content hash
	data, err := s.serialize(snapshot)
	if err != nil {
		return fmt.Errorf("failed to serialize snapshot: %w", err)
	}

	computedHash := sha256.Sum256(data)
	hashStr := hex.EncodeToString(computedHash[:])

	// Verify against snapshot's hash
	if hashStr != snapshot.ContentHash.Hex() {
		return ErrHashMismatch
	}

	// Write to file
	filename := fmt.Sprintf("%s_%s.json", snapshot.ID, hashStr[:8])
	filePath := filepath.Join(s.basePath, filename)

	// Check file doesn't already exist (belt and suspenders)
	if _, err := os.Stat(filePath); err == nil {
		return ErrImmutabilityViolation
	}

	// Write file
	if err := os.WriteFile(filePath, data, 0444); err != nil { // Read-only!
		return fmt.Errorf("failed to write snapshot: %w", err)
	}

	// Update index
	meta := &SnapshotMetadata{
		ID:          snapshot.ID,
		ContentHash: hashStr,
		CreatedAt:   snapshot.CreatedAt,
		EffectiveAt: snapshot.EffectiveAt,
		Provider:    snapshot.Provider,
		Region:      snapshot.Region,
		Version:     1, // First version
		Size:        int64(len(data)),
		FilePath:    filePath,
	}

	s.index[snapshot.ID] = meta

	// Update latest
	key := snapshot.Provider + ":" + snapshot.Region
	if current, ok := s.latest[key]; !ok {
		s.latest[key] = snapshot.ID
	} else {
		// Only update if newer
		if currentMeta := s.index[current]; currentMeta.CreatedAt.Before(snapshot.CreatedAt) {
			s.latest[key] = snapshot.ID
		}
	}

	// Persist index
	return s.saveIndex()
}

// Get retrieves a snapshot by ID - verifies hash
func (s *ImmutableSnapshotStore) Get(ctx context.Context, id SnapshotID) (*PricingSnapshot, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	meta, ok := s.index[id]
	if !ok {
		return nil, ErrNoSnapshot
	}

	// Read file
	data, err := os.ReadFile(meta.FilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read snapshot: %w", err)
	}

	// Verify hash
	computedHash := sha256.Sum256(data)
	hashStr := hex.EncodeToString(computedHash[:])
	if hashStr != meta.ContentHash {
		return nil, ErrHashMismatch
	}

	// Deserialize
	return s.deserialize(data)
}

// GetLatest retrieves the latest snapshot for provider/region
func (s *ImmutableSnapshotStore) GetLatest(ctx context.Context, provider, region string) (*PricingSnapshot, error) {
	s.mu.RLock()
	key := provider + ":" + region
	id, ok := s.latest[key]
	s.mu.RUnlock()

	if !ok {
		return nil, ErrNoSnapshot
	}

	return s.Get(ctx, id)
}

// ListVersions returns all versions for a provider/region
func (s *ImmutableSnapshotStore) ListVersions(provider, region string) []*SnapshotMetadata {
	s.mu.RLock()
	defer s.mu.RUnlock()

	var result []*SnapshotMetadata
	for _, meta := range s.index {
		if meta.Provider == provider && meta.Region == region {
			result = append(result, meta)
		}
	}
	return result
}

// VerifyIntegrity checks all stored snapshots
func (s *ImmutableSnapshotStore) VerifyIntegrity() ([]string, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	var corrupted []string

	for id, meta := range s.index {
		data, err := os.ReadFile(meta.FilePath)
		if err != nil {
			corrupted = append(corrupted, fmt.Sprintf("%s: file missing", id))
			continue
		}

		computedHash := sha256.Sum256(data)
		hashStr := hex.EncodeToString(computedHash[:])
		if hashStr != meta.ContentHash {
			corrupted = append(corrupted, fmt.Sprintf("%s: hash mismatch", id))
		}
	}

	return corrupted, nil
}

func (s *ImmutableSnapshotStore) serialize(snapshot *PricingSnapshot) ([]byte, error) {
	// Create a serializable version
	type serializableSnapshot struct {
		ID          SnapshotID         `json:"id"`
		ContentHash string             `json:"content_hash"`
		CreatedAt   time.Time          `json:"created_at"`
		EffectiveAt time.Time          `json:"effective_at"`
		Provider    string             `json:"provider"`
		Region      string             `json:"region"`
		Rates       []RateEntry        `json:"rates"`
		Coverage    SnapshotCoverage   `json:"coverage"`
	}

	ss := serializableSnapshot{
		ID:          snapshot.ID,
		ContentHash: snapshot.ContentHash.Hex(),
		CreatedAt:   snapshot.CreatedAt,
		EffectiveAt: snapshot.EffectiveAt,
		Provider:    snapshot.Provider,
		Region:      snapshot.Region,
		Rates:       snapshot.Rates(),
		Coverage:    snapshot.Coverage,
	}

	return json.MarshalIndent(ss, "", "  ")
}

func (s *ImmutableSnapshotStore) deserialize(data []byte) (*PricingSnapshot, error) {
	type serializableSnapshot struct {
		ID          SnapshotID         `json:"id"`
		ContentHash string             `json:"content_hash"`
		CreatedAt   time.Time          `json:"created_at"`
		EffectiveAt time.Time          `json:"effective_at"`
		Provider    string             `json:"provider"`
		Region      string             `json:"region"`
		Rates       []RateEntry        `json:"rates"`
		Coverage    SnapshotCoverage   `json:"coverage"`
	}

	var ss serializableSnapshot
	if err := json.Unmarshal(data, &ss); err != nil {
		return nil, err
	}

	// Rebuild snapshot using builder
	builder := NewSnapshotBuilder(ss.Provider, ss.Region).
		WithEffectiveAt(ss.EffectiveAt)

	for _, rate := range ss.Rates {
		builder.AddRate(rate.Key, rate.Price, rate.Unit, rate.Currency)
	}

	snapshot := builder.Build()
	return snapshot, nil
}

func (s *ImmutableSnapshotStore) loadIndex() error {
	indexPath := filepath.Join(s.basePath, "index.json")
	data, err := os.ReadFile(indexPath)
	if err != nil {
		return err
	}

	type indexFile struct {
		Snapshots map[SnapshotID]*SnapshotMetadata `json:"snapshots"`
		Latest    map[string]SnapshotID            `json:"latest"`
	}

	var idx indexFile
	if err := json.Unmarshal(data, &idx); err != nil {
		return err
	}

	s.index = idx.Snapshots
	s.latest = idx.Latest
	return nil
}

func (s *ImmutableSnapshotStore) saveIndex() error {
	indexPath := filepath.Join(s.basePath, "index.json")

	type indexFile struct {
		Snapshots map[SnapshotID]*SnapshotMetadata `json:"snapshots"`
		Latest    map[string]SnapshotID            `json:"latest"`
		UpdatedAt time.Time                        `json:"updated_at"`
	}

	idx := indexFile{
		Snapshots: s.index,
		Latest:    s.latest,
		UpdatedAt: time.Now().UTC(),
	}

	data, err := json.MarshalIndent(idx, "", "  ")
	if err != nil {
		return err
	}

	// Write atomically using temp file
	tempPath := indexPath + ".tmp"
	if err := os.WriteFile(tempPath, data, 0644); err != nil {
		return err
	}

	return os.Rename(tempPath, indexPath)
}

################################################################################
# FILE: :\good projects\cost estimation\core\pricing\pricing_gate.go
# TYPE: go
# SIZE: 3094 bytes
################################################################################
// Package pricing - Pricing gate enforcement
// No pricing may occur before provider finalization.
// This is enforced with panic, not error return.
package pricing

import (
	"fmt"
	"sync"
)

// PricingGate enforces that pricing only occurs after provider finalization
type PricingGate struct {
	mu              sync.RWMutex
	frozen          bool
	frozenProviders map[string]*FrozenProvider
}

// FrozenProvider is an immutable provider configuration
type FrozenProvider struct {
	Provider  string
	Alias     string
	Region    string
	Account   string
	frozen    bool
}

// NewPricingGate creates a new gate
func NewPricingGate() *PricingGate {
	return &PricingGate{
		frozenProviders: make(map[string]*FrozenProvider),
	}
}

// FreezeProvider freezes a provider configuration
func (g *PricingGate) FreezeProvider(provider, alias, region, account string) *FrozenProvider {
	g.mu.Lock()
	defer g.mu.Unlock()

	if g.frozen {
		panic("INVARIANT VIOLATED: cannot add providers after gate is frozen")
	}

	key := provider + ":" + alias
	fp := &FrozenProvider{
		Provider: provider,
		Alias:    alias,
		Region:   region,
		Account:  account,
		frozen:   true,
	}
	g.frozenProviders[key] = fp
	return fp
}

// Freeze freezes the gate - no more providers can be added
func (g *PricingGate) Freeze() {
	g.mu.Lock()
	defer g.mu.Unlock()
	g.frozen = true
}

// IsFrozen returns whether the gate is frozen
func (g *PricingGate) IsFrozen() bool {
	g.mu.RLock()
	defer g.mu.RUnlock()
	return g.frozen
}

// MustGetProvider returns a provider or panics
func (g *PricingGate) MustGetProvider(provider, alias string) *FrozenProvider {
	g.mu.RLock()
	defer g.mu.RUnlock()

	if !g.frozen {
		panic("INVARIANT VIOLATED: pricing before provider finalization")
	}

	key := provider + ":" + alias
	fp, ok := g.frozenProviders[key]
	if !ok {
		panic(fmt.Sprintf("INVARIANT VIOLATED: provider %s not frozen", key))
	}
	return fp
}

// AssertCanPrice panics if pricing is not allowed
func (g *PricingGate) AssertCanPrice() {
	if !g.IsFrozen() {
		panic("INVARIANT VIOLATED: pricing before provider finalization")
	}
}

// BuildRateKey builds a rate key with mandatory alias
func (fp *FrozenProvider) BuildRateKey(resourceType, component string) *AliasAwareRateKey {
	if !fp.frozen {
		panic("INVARIANT VIOLATED: building rate key from unfrozen provider")
	}
	return NewAliasAwareRateKey(fp.Provider, fp.Alias, fp.Region, resourceType, component)
}

// BuildRateKeyWithAccount builds a rate key with account
func (fp *FrozenProvider) BuildRateKeyWithAccount(resourceType, component string) *AliasAwareRateKey {
	if !fp.frozen {
		panic("INVARIANT VIOLATED: building rate key from unfrozen provider")
	}
	key := NewAliasAwareRateKey(fp.Provider, fp.Alias, fp.Region, resourceType, component)
	key.WithAccountID(fp.Account)
	return key
}

// String returns provider identity
func (fp *FrozenProvider) String() string {
	if fp.Alias != "" {
		return fp.Provider + "." + fp.Alias
	}
	return fp.Provider
}

################################################################################
# FILE: :\good projects\cost estimation\core\pricing\resolver.go
# TYPE: go
# SIZE: 3323 bytes
################################################################################
// Package pricing provides the pricing resolution interface.
// This package resolves prices from cache, database, and cloud APIs.
package pricing

import (
	"context"

	"terraform-cost/core/types"
)

// Resolver resolves pricing for rate keys
type Resolver interface {
	// Resolve fetches rates for the given keys
	Resolve(ctx context.Context, keys []types.RateKey, snapshot *types.PricingSnapshot) (*types.PricingResult, error)

	// GetSnapshot returns the current pricing snapshot for a provider/region
	GetSnapshot(ctx context.Context, provider types.Provider, region string) (*types.PricingSnapshot, error)

	// RefreshSnapshot updates pricing data from cloud APIs
	RefreshSnapshot(ctx context.Context, provider types.Provider, region string) (*types.PricingSnapshot, error)
}

// Cache provides in-memory pricing caching
type Cache interface {
	// Get retrieves a rate from cache
	Get(key types.RateKey) (*types.Rate, bool)

	// Set stores a rate in cache
	Set(key types.RateKey, rate *types.Rate)

	// GetMulti retrieves multiple rates
	GetMulti(keys []types.RateKey) map[string]*types.Rate

	// SetMulti stores multiple rates
	SetMulti(rates map[string]*types.Rate)

	// Invalidate removes a rate from cache
	Invalidate(key types.RateKey)

	// Clear removes all cached rates
	Clear()

	// Size returns the number of cached entries
	Size() int
}

// Store provides persistent pricing storage
type Store interface {
	// GetRates retrieves rates from storage
	GetRates(ctx context.Context, keys []types.RateKey, snapshotID string) ([]types.Rate, error)

	// SaveRates stores rates in storage
	SaveRates(ctx context.Context, rates []types.Rate) error

	// GetSnapshot retrieves a pricing snapshot
	GetSnapshot(ctx context.Context, id string) (*types.PricingSnapshot, error)

	// SaveSnapshot stores a pricing snapshot
	SaveSnapshot(ctx context.Context, snapshot *types.PricingSnapshot) error

	// GetLatestSnapshot returns the most recent snapshot for a provider/region
	GetLatestSnapshot(ctx context.Context, provider types.Provider, region string) (*types.PricingSnapshot, error)

	// ListSnapshots returns all snapshots for a provider/region
	ListSnapshots(ctx context.Context, provider types.Provider, region string) ([]types.PricingSnapshot, error)
}

// Source fetches pricing from external cloud APIs
type Source interface {
	// Provider returns the cloud provider
	Provider() types.Provider

	// FetchRates retrieves rates for the given keys
	FetchRates(ctx context.Context, keys []types.RateKey) ([]types.Rate, error)

	// FetchAll retrieves all rates for a region
	FetchAll(ctx context.Context, region string) ([]types.Rate, error)

	// SupportedRegions returns the list of supported regions
	SupportedRegions() []string
}

// SourceRegistry manages pricing source registration
type SourceRegistry interface {
	// Register adds a source to the registry
	Register(source Source) error

	// GetSource returns a source for a provider
	GetSource(provider types.Provider) (Source, bool)

	// GetAll returns all registered sources
	GetAll() []Source
}

// CompositeResolver implements Resolver using cache, store, and sources
type CompositeResolver struct {
	Cache   Cache
	Store   Store
	Sources SourceRegistry
}

################################################################################
# FILE: :\good projects\cost estimation\core\pricing\snapshot.go
# TYPE: go
# SIZE: 11387 bytes
################################################################################
// Package pricing provides immutable pricing snapshots with content hashing.
package pricing

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"sort"
	"time"

	"github.com/shopspring/decimal"

	"terraform-cost/core/determinism"
)

// SnapshotID uniquely identifies a pricing snapshot
type SnapshotID string

// RateID uniquely identifies a rate within a snapshot
type RateID string

// PricingSnapshot is IMMUTABLE after creation.
// It represents a point-in-time capture of pricing data.
type PricingSnapshot struct {
	// Identity
	ID          SnapshotID              // UUID or hash-based
	ContentHash determinism.ContentHash // SHA-256 of all rates
	CreatedAt   time.Time               // When snapshot was created
	EffectiveAt time.Time               // When prices became effective
	ExpiresAt   *time.Time              // Optional expiry (for cached data)

	// Source information
	Source      PricingSource
	Region      string
	Provider    string // aws, azure, gcp

	// The actual rates (sorted for determinism)
	rates       []RateEntry
	rateIndex   map[RateKey]*RateEntry

	// Coverage information
	Coverage    SnapshotCoverage

	// Immutability flag
	sealed      bool
}

// PricingSource indicates where pricing data came from
type PricingSource int

const (
	SourceCloudAPI    PricingSource = iota // From cloud provider API
	SourceLocalCache                       // From local cache
	SourceDatabase                         // From pricing database
	SourceManual                           // Manually specified
	SourceDefault                          // Hardcoded defaults
)

// String returns the source name
func (s PricingSource) String() string {
	switch s {
	case SourceCloudAPI:
		return "cloud_api"
	case SourceLocalCache:
		return "local_cache"
	case SourceDatabase:
		return "database"
	case SourceManual:
		return "manual"
	case SourceDefault:
		return "default"
	default:
		return "unknown"
	}
}

// RateKey uniquely identifies a rate
type RateKey struct {
	ResourceType string // aws_instance
	Component    string // Compute, Storage
	UsageType    string // BoxUsage, DataTransfer
	Attributes   string // Serialized attributes (instance_type=t3.micro)
}

// String returns a deterministic string representation
func (k RateKey) String() string {
	return k.ResourceType + "/" + k.Component + "/" + k.UsageType + "/" + k.Attributes
}

// RateEntry is a single pricing rate
type RateEntry struct {
	ID          RateID
	Key         RateKey
	Price       decimal.Decimal // Price per unit
	Unit        string          // hour, GB, request
	Currency    string          // USD
	Description string
	Tiers       []RateTier // For tiered pricing
	Conditions  []RateCondition
}

// RateTier represents a tier in tiered pricing
type RateTier struct {
	StartUsage decimal.Decimal // Start of tier
	EndUsage   *decimal.Decimal // End of tier (nil = unlimited)
	Price      decimal.Decimal  // Price in this tier
}

// RateCondition is a condition that must match for the rate
type RateCondition struct {
	Attribute string
	Operator  string // eq, neq, contains, prefix
	Value     string
}

// Bytes returns deterministic bytes for hashing
func (r *RateEntry) Bytes() []byte {
	// Use JSON for deterministic serialization
	data, _ := json.Marshal(map[string]interface{}{
		"key":      r.Key.String(),
		"price":    r.Price.String(),
		"unit":     r.Unit,
		"currency": r.Currency,
	})
	return data
}

// SnapshotCoverage tracks what's included and what's missing
type SnapshotCoverage struct {
	IncludedServices []string
	ResourceTypes    int
	TotalRates       int
	MissingRates     []MissingRate
	CoveragePercent  float64 // Estimated coverage
}

// MissingRate documents an EXPLICIT missing rate
type MissingRate struct {
	ResourceType string
	Component    string
	Reason       MissingReason
	Message      string // Human-readable explanation
}

// MissingReason explains why a rate is missing
type MissingReason int

const (
	ReasonNotInAPI           MissingReason = iota // API doesn't provide this
	ReasonRegionNotSupported                       // Region not available
	ReasonServiceNotImpl                           // We haven't implemented this
	ReasonRateLimitHit                             // API rate limit
	ReasonParseError                               // Couldn't parse response
	ReasonNotApplicable                            // Resource is free
)

// String returns the reason name
func (r MissingReason) String() string {
	switch r {
	case ReasonNotInAPI:
		return "not_in_api"
	case ReasonRegionNotSupported:
		return "region_not_supported"
	case ReasonServiceNotImpl:
		return "not_implemented"
	case ReasonRateLimitHit:
		return "rate_limit"
	case ReasonParseError:
		return "parse_error"
	case ReasonNotApplicable:
		return "not_applicable"
	default:
		return "unknown"
	}
}

// SnapshotBuilder builds a pricing snapshot
type SnapshotBuilder struct {
	provider    string
	region      string
	source      PricingSource
	effectiveAt time.Time
	rates       []RateEntry
	missing     []MissingRate
	services    map[string]bool
}

// NewSnapshotBuilder creates a new builder
func NewSnapshotBuilder(provider, region string) *SnapshotBuilder {
	return &SnapshotBuilder{
		provider:    provider,
		region:      region,
		source:      SourceDefault,
		effectiveAt: time.Now().UTC(),
		services:    make(map[string]bool),
	}
}

// WithSource sets the pricing source
func (b *SnapshotBuilder) WithSource(source PricingSource) *SnapshotBuilder {
	b.source = source
	return b
}

// WithEffectiveAt sets the effective date
func (b *SnapshotBuilder) WithEffectiveAt(t time.Time) *SnapshotBuilder {
	b.effectiveAt = t
	return b
}

// AddRate adds a rate to the snapshot
func (b *SnapshotBuilder) AddRate(key RateKey, price decimal.Decimal, unit, currency string) *SnapshotBuilder {
	b.rates = append(b.rates, RateEntry{
		Key:      key,
		Price:    price,
		Unit:     unit,
		Currency: currency,
	})
	b.services[key.ResourceType] = true
	return b
}

// AddMissing documents a missing rate
func (b *SnapshotBuilder) AddMissing(resourceType, component string, reason MissingReason, message string) *SnapshotBuilder {
	b.missing = append(b.missing, MissingRate{
		ResourceType: resourceType,
		Component:    component,
		Reason:       reason,
		Message:      message,
	})
	return b
}

// Build creates an immutable snapshot
func (b *SnapshotBuilder) Build() *PricingSnapshot {
	// Sort rates for deterministic ordering
	sort.Slice(b.rates, func(i, j int) bool {
		return b.rates[i].Key.String() < b.rates[j].Key.String()
	})

	// Generate IDs for each rate
	idGen := determinism.NewIDGenerator("rate")
	for i := range b.rates {
		b.rates[i].ID = RateID(idGen.Generate(b.rates[i].Key.String()))
	}

	// Build index
	index := make(map[RateKey]*RateEntry)
	for i := range b.rates {
		index[b.rates[i].Key] = &b.rates[i]
	}

	// Collect services
	services := make([]string, 0, len(b.services))
	for svc := range b.services {
		services = append(services, svc)
	}
	sort.Strings(services)

	// Create snapshot
	snap := &PricingSnapshot{
		CreatedAt:   time.Now().UTC(),
		EffectiveAt: b.effectiveAt,
		Source:      b.source,
		Region:      b.region,
		Provider:    b.provider,
		rates:       b.rates,
		rateIndex:   index,
		Coverage: SnapshotCoverage{
			IncludedServices: services,
			ResourceTypes:    len(b.services),
			TotalRates:       len(b.rates),
			MissingRates:     b.missing,
		},
	}

	// Compute content hash
	snap.ContentHash = snap.computeHash()

	// Generate ID from hash
	snap.ID = SnapshotID(hex.EncodeToString(snap.ContentHash[:8]))

	// Seal the snapshot
	snap.sealed = true

	return snap
}

// computeHash creates a content hash of all rates
func (s *PricingSnapshot) computeHash() determinism.ContentHash {
	h := sha256.New()
	h.Write([]byte(s.Provider))
	h.Write([]byte(s.Region))
	h.Write([]byte(s.EffectiveAt.Format(time.RFC3339)))
	for _, rate := range s.rates {
		h.Write(rate.Bytes())
	}
	var hash determinism.ContentHash
	copy(hash[:], h.Sum(nil))
	return hash
}

// GetRate looks up a rate by key
func (s *PricingSnapshot) GetRate(key RateKey) (*RateEntry, bool) {
	rate, ok := s.rateIndex[key]
	return rate, ok
}

// LookupRate finds a rate by resource type and component
func (s *PricingSnapshot) LookupRate(resourceType, component string, attrs map[string]string) (*RateEntry, bool) {
	// Serialize attributes deterministically
	attrKeys := determinism.SortedKeys(attrs)
	var attrStr string
	for _, k := range attrKeys {
		if attrStr != "" {
			attrStr += ","
		}
		attrStr += k + "=" + attrs[k]
	}

	key := RateKey{
		ResourceType: resourceType,
		Component:    component,
		Attributes:   attrStr,
	}
	return s.GetRate(key)
}

// Rates returns all rates in sorted order
func (s *PricingSnapshot) Rates() []RateEntry {
	result := make([]RateEntry, len(s.rates))
	copy(result, s.rates)
	return result
}

// Verify checks content hash integrity
func (s *PricingSnapshot) Verify() bool {
	computed := s.computeHash()
	return computed == s.ContentHash
}

// CostEstimate MUST reference a snapshot
type CostEstimate struct {
	// Snapshot reference (mandatory)
	SnapshotID   SnapshotID
	SnapshotHash determinism.ContentHash // For verification

	// The estimate
	InstanceID   string
	Component    string
	MonthlyCost  determinism.Money
	HourlyCost   determinism.Money

	// Lineage (see Gap 5)
	Lineage      *CostLineage
}

// CostLineage tracks the full derivation chain (Gap 5)
type CostLineage struct {
	// What was priced
	InstanceID  string
	Component   string

	// Pricing source
	SnapshotID  SnapshotID
	RateID      RateID
	RateKey     RateKey

	// Formula applied
	Formula     FormulaApplication

	// Usage input
	Usage       UsageLineage

	// Derived costs (for aggregated)
	DerivedFrom []*CostLineage

	// Confidence
	Confidence  float64 // 0.0 - 1.0

	// Timestamp
	Timestamp   time.Time
}

// FormulaApplication tracks how cost was calculated
type FormulaApplication struct {
	Name       string            // "hourly_compute"
	Expression string            // "rate * hours * quantity"
	Inputs     map[string]string // rate=0.10, hours=730, quantity=3
	Output     string            // 219.00
}

// UsageLineage tracks usage source
type UsageLineage struct {
	Source      UsageSource
	Profile     string   // "production", "dev"
	Confidence  float64  // 0.0 - 1.0
	Assumptions []string // ["assumed 75% utilization"]
}

// UsageSource indicates where usage data came from
type UsageSource int

const (
	UsageDefault   UsageSource = iota // Hardcoded defaults
	UsageOverride                     // User provided
	UsageEstimated                    // ML/heuristic estimated
	UsageActual                       // Historical actual
)

// String returns the source name
func (s UsageSource) String() string {
	switch s {
	case UsageDefault:
		return "default"
	case UsageOverride:
		return "override"
	case UsageEstimated:
		return "estimated"
	case UsageActual:
		return "actual"
	default:
		return "unknown"
	}
}

################################################################################
# FILE: :\good projects\cost estimation\core\scanner\registry.go
# TYPE: go
# SIZE: 2844 bytes
################################################################################
// Package scanner - Registry for scanner implementations
package scanner

import (
	"context"
	"fmt"
	"sync"

	"terraform-cost/core/types"
)

// Registry manages scanner registration and lookup
type Registry interface {
	// Register adds a scanner to the registry
	Register(scanner Scanner) error

	// GetScanner returns a scanner by name
	GetScanner(name string) (Scanner, bool)

	// GetAll returns all registered scanners
	GetAll() []Scanner

	// DetectAndScan finds the appropriate scanner and scans the input
	DetectAndScan(ctx context.Context, input *types.ProjectInput) (*ScanResult, error)
}

// DefaultRegistry is the default scanner registry implementation
type DefaultRegistry struct {
	mu       sync.RWMutex
	scanners map[string]Scanner
	order    []string // maintains registration order for priority
}

// NewRegistry creates a new scanner registry
func NewRegistry() *DefaultRegistry {
	return &DefaultRegistry{
		scanners: make(map[string]Scanner),
		order:    make([]string, 0),
	}
}

// Register adds a scanner to the registry
func (r *DefaultRegistry) Register(scanner Scanner) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	name := scanner.Name()
	if _, exists := r.scanners[name]; exists {
		return fmt.Errorf("scanner already registered: %s", name)
	}

	r.scanners[name] = scanner
	r.order = append(r.order, name)
	return nil
}

// GetScanner returns a scanner by name
func (r *DefaultRegistry) GetScanner(name string) (Scanner, bool) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	scanner, ok := r.scanners[name]
	return scanner, ok
}

// GetAll returns all registered scanners in registration order
func (r *DefaultRegistry) GetAll() []Scanner {
	r.mu.RLock()
	defer r.mu.RUnlock()

	scanners := make([]Scanner, 0, len(r.order))
	for _, name := range r.order {
		if scanner, ok := r.scanners[name]; ok {
			scanners = append(scanners, scanner)
		}
	}
	return scanners
}

// DetectAndScan finds the first scanner that can handle the input and runs it
func (r *DefaultRegistry) DetectAndScan(ctx context.Context, input *types.ProjectInput) (*ScanResult, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	for _, name := range r.order {
		scanner := r.scanners[name]

		canScan, err := scanner.CanScan(ctx, input)
		if err != nil {
			continue // Skip scanners that error on detection
		}

		if canScan {
			return scanner.Scan(ctx, input)
		}
	}

	return nil, fmt.Errorf("no scanner found for input: %s", input.Path)
}

// Global default registry
var defaultRegistry = NewRegistry()

// Register adds a scanner to the default registry
func Register(scanner Scanner) error {
	return defaultRegistry.Register(scanner)
}

// GetDefault returns the default registry
func GetDefault() *DefaultRegistry {
	return defaultRegistry
}

################################################################################
# FILE: :\good projects\cost estimation\core\scanner\scanner.go
# TYPE: go
# SIZE: 2917 bytes
################################################################################
// Package scanner defines the interface for infrastructure scanners.
// Scanners parse IaC configurations into RawAsset descriptors.
// NO pricing or cost logic belongs here.
package scanner

import (
	"context"

	"terraform-cost/core/types"
)

// Scanner parses infrastructure code into raw assets
type Scanner interface {
	// Name returns the scanner identifier
	Name() string

	// CanScan determines if this scanner can handle the input
	CanScan(ctx context.Context, input *types.ProjectInput) (bool, error)

	// Scan parses the input and returns raw assets
	Scan(ctx context.Context, input *types.ProjectInput) (*ScanResult, error)
}

// ScanResult contains the output of a scan operation
type ScanResult struct {
	// Assets are the parsed infrastructure resources
	Assets []types.RawAsset `json:"assets"`

	// Modules are referenced modules
	Modules []ModuleReference `json:"modules,omitempty"`

	// Variables are the resolved variables
	Variables map[string]interface{} `json:"variables,omitempty"`

	// Warnings are non-fatal issues encountered
	Warnings []ScanWarning `json:"warnings,omitempty"`

	// Errors are parsing errors
	Errors []ScanError `json:"errors,omitempty"`
}

// ModuleReference tracks module dependencies
type ModuleReference struct {
	// Source is the module source (registry, git, local)
	Source string `json:"source"`

	// Version is the module version constraint
	Version string `json:"version,omitempty"`

	// Path is the local path to the module
	Path string `json:"path"`

	// Key is the module key in the configuration
	Key string `json:"key"`
}

// ScanWarning represents a non-fatal scanning issue
type ScanWarning struct {
	// File is the file where the warning occurred
	File string `json:"file"`

	// Line is the line number
	Line int `json:"line,omitempty"`

	// Message describes the warning
	Message string `json:"message"`

	// Code is a warning code for programmatic handling
	Code string `json:"code,omitempty"`
}

// ScanError represents a scanning error
type ScanError struct {
	// File is the file where the error occurred
	File string `json:"file"`

	// Line is the line number
	Line int `json:"line,omitempty"`

	// Message describes the error
	Message string `json:"message"`

	// Code is an error code for programmatic handling
	Code string `json:"code,omitempty"`

	// Err is the underlying error
	Err error `json:"-"`
}

// Error implements the error interface
func (e ScanError) Error() string {
	return e.Message
}

// Unwrap returns the underlying error
func (e ScanError) Unwrap() error {
	return e.Err
}

// HasErrors returns true if there are any errors
func (r *ScanResult) HasErrors() bool {
	return len(r.Errors) > 0
}

// HasWarnings returns true if there are any warnings
func (r *ScanResult) HasWarnings() bool {
	return len(r.Warnings) > 0
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\data_barrier.go
# TYPE: go
# SIZE: 8072 bytes
################################################################################
// Package terraform - Data source estimation barriers
// Data sources create HARD uncertainty. They cannot be estimated deterministically.
package terraform

import (
	"fmt"
	"strings"

	"terraform-cost/core/confidence"
)

// DataSourceBarrier enforces estimation rules for data sources
type DataSourceBarrier struct {
	// Data sources that are inherently unpriceable
	unpriceable map[string]bool

	// Attributes that when sourced from data, block pricing
	blockingAttributes map[string][]string

	// Confidence impacts per data source type
	confidenceImpacts map[string]float64
}

// NewDataSourceBarrier creates a new barrier
func NewDataSourceBarrier() *DataSourceBarrier {
	return &DataSourceBarrier{
		unpriceable: map[string]bool{
			"aws_ami":                true, // Runtime lookup
			"aws_availability_zones": true, // Runtime lookup
			"aws_caller_identity":    true, // Runtime lookup
			"aws_region":             true, // Runtime lookup
			"aws_vpc":                true, // External resource
			"aws_subnet":             true, // External resource
			"aws_security_group":     true, // External resource
			"aws_iam_role":           true, // External resource
		},
		blockingAttributes: map[string][]string{
			"aws_instance": {"ami", "subnet_id"},
			"aws_db_instance": {"db_subnet_group_name"},
			"aws_lambda_function": {"role"},
			"aws_ecs_service": {"cluster"},
		},
		confidenceImpacts: map[string]float64{
			"aws_ami":                0.25, // AMI affects pricing
			"aws_availability_zones": 0.10, // AZ is minor
			"aws_caller_identity":    0.05, // No pricing impact
			"aws_vpc":                0.15, // VPC affects networking
			"aws_subnet":             0.15,
			"aws_security_group":     0.05,
			"aws_iam_role":           0.05,
			"default":                0.20,
		},
	}
}

// DataSourceReference represents a reference to a data source
type DataSourceReference struct {
	DataType      string // e.g., "aws_ami"
	DataName      string // e.g., "latest"
	Attribute     string // e.g., "id"
	FullReference string // e.g., "data.aws_ami.latest.id"
}

// ParseDataSourceReference parses a data source reference
func ParseDataSourceReference(ref string) (*DataSourceReference, bool) {
	if !strings.HasPrefix(ref, "data.") {
		return nil, false
	}

	parts := strings.Split(ref, ".")
	if len(parts) < 3 {
		return nil, false
	}

	result := &DataSourceReference{
		DataType:      parts[1],
		DataName:      parts[2],
		FullReference: ref,
	}

	if len(parts) >= 4 {
		result.Attribute = strings.Join(parts[3:], ".")
	}

	return result, true
}

// CanEstimate checks if an attribute can be estimated when sourced from data
func (b *DataSourceBarrier) CanEstimate(resourceType, attribute string, dataRef *DataSourceReference) EstimationDecision {
	decision := EstimationDecision{
		CanEstimate:      true,
		ConfidenceImpact: 0,
		Reason:           "",
		Recommendations:  []string{},
	}

	// Check if data source is inherently unpriceable
	if b.unpriceable[dataRef.DataType] {
		decision.ConfidenceImpact = b.getConfidenceImpact(dataRef.DataType)
		decision.Reason = fmt.Sprintf("data source %s is resolved at runtime", dataRef.DataType)
		decision.Recommendations = append(decision.Recommendations,
			fmt.Sprintf("Consider providing explicit value for %s.%s", resourceType, attribute))
	}

	// Check if this attribute blocks pricing when from data
	blockingAttrs := b.blockingAttributes[resourceType]
	for _, blocked := range blockingAttrs {
		if blocked == attribute {
			decision.CanEstimate = false
			decision.ConfidenceImpact = 0.4 // Severe
			decision.Reason = fmt.Sprintf("attribute %s cannot be estimated from data source", attribute)
			decision.Recommendations = append(decision.Recommendations,
				fmt.Sprintf("Provide explicit %s value or use usage override", attribute))
			return decision
		}
	}

	return decision
}

// EstimationDecision is the result of checking if estimation is possible
type EstimationDecision struct {
	CanEstimate      bool
	ConfidenceImpact float64
	Reason           string
	Recommendations  []string
}

func (b *DataSourceBarrier) getConfidenceImpact(dataType string) float64 {
	if impact, ok := b.confidenceImpacts[dataType]; ok {
		return impact
	}
	return b.confidenceImpacts["default"]
}

// ApplyDataSourceImpacts applies confidence impacts for all data source references
func (b *DataSourceBarrier) ApplyDataSourceImpacts(
	tracker *confidence.ConfidenceTracker,
	resourceType string,
	attributes map[string]interface{},
	dataRefs map[string]*DataSourceReference,
) []EstimationDecision {
	var decisions []EstimationDecision

	for attrName, dataRef := range dataRefs {
		decision := b.CanEstimate(resourceType, attrName, dataRef)
		decisions = append(decisions, decision)

		if !decision.CanEstimate {
			tracker.Apply("data_source_barrier", decision.Reason)
		} else if decision.ConfidenceImpact > 0 {
			tracker.Apply("data_source_uncertainty", decision.Reason)
		}
	}

	return decisions
}

// AttributeSourceAnalyzer analyzes where attribute values come from
type AttributeSourceAnalyzer struct {
	barrier *DataSourceBarrier
}

// NewAttributeSourceAnalyzer creates an analyzer
func NewAttributeSourceAnalyzer() *AttributeSourceAnalyzer {
	return &AttributeSourceAnalyzer{
		barrier: NewDataSourceBarrier(),
	}
}

// AttributeSource describes where an attribute value comes from
type AttributeSource struct {
	// Source type
	Type AttributeSourceType

	// Reference (if from data or resource)
	Reference string

	// Is this estimable?
	IsEstimable bool

	// Confidence impact
	ConfidenceImpact float64

	// Reason if not estimable
	Reason string
}

// AttributeSourceType indicates the source of an attribute
type AttributeSourceType int

const (
	SourceLiteral     AttributeSourceType = iota // Hardcoded value
	SourceVariable                                // From variable
	SourceLocal                                   // From local
	SourceDataSource                              // From data source
	SourceResource                                // From another resource
	SourceUnknown                                 // Cannot determine
)

// String returns the source type name
func (t AttributeSourceType) String() string {
	switch t {
	case SourceLiteral:
		return "literal"
	case SourceVariable:
		return "variable"
	case SourceLocal:
		return "local"
	case SourceDataSource:
		return "data_source"
	case SourceResource:
		return "resource"
	default:
		return "unknown"
	}
}

// AnalyzeAttribute determines the source of an attribute value
func (a *AttributeSourceAnalyzer) AnalyzeAttribute(resourceType, attrName, expression string, references []string) AttributeSource {
	source := AttributeSource{
		Type:        SourceUnknown,
		IsEstimable: true,
	}

	// No references = literal
	if len(references) == 0 {
		source.Type = SourceLiteral
		return source
	}

	// Check first reference to determine type
	ref := references[0]

	if strings.HasPrefix(ref, "var.") {
		source.Type = SourceVariable
		source.Reference = ref
		source.ConfidenceImpact = 0.1 // Variables are usually known
		return source
	}

	if strings.HasPrefix(ref, "local.") {
		source.Type = SourceLocal
		source.Reference = ref
		source.ConfidenceImpact = 0.05 // Locals are resolvable
		return source
	}

	if strings.HasPrefix(ref, "data.") {
		source.Type = SourceDataSource
		source.Reference = ref

		dataRef, _ := ParseDataSourceReference(ref)
		if dataRef != nil {
			decision := a.barrier.CanEstimate(resourceType, attrName, dataRef)
			source.IsEstimable = decision.CanEstimate
			source.ConfidenceImpact = decision.ConfidenceImpact
			source.Reason = decision.Reason
		}
		return source
	}

	// Resource reference
	source.Type = SourceResource
	source.Reference = ref
	source.ConfidenceImpact = 0.15 // Resource refs are runtime
	return source
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\dependencies.go
# TYPE: go
# SIZE: 8737 bytes
################################################################################
// Package terraform - Dependency graph and depends_on handling
package terraform

import (
	"sort"
	"strings"

	"terraform-cost/core/determinism"
	"terraform-cost/core/model"
)

// DependencyResolver builds the dependency graph between instances
type DependencyResolver struct {
	// Instance index for lookups
	instanceByAddr  map[model.InstanceAddress]*model.AssetInstance
	instanceByDefn  map[model.DefinitionID][]*model.AssetInstance
}

// NewDependencyResolver creates a new resolver
func NewDependencyResolver() *DependencyResolver {
	return &DependencyResolver{
		instanceByAddr: make(map[model.InstanceAddress]*model.AssetInstance),
		instanceByDefn: make(map[model.DefinitionID][]*model.AssetInstance),
	}
}

// ResolveDependencies builds all dependency edges
func (r *DependencyResolver) ResolveDependencies(
	instances []*model.AssetInstance,
	definitions map[model.DefinitionID]*model.AssetDefinition,
) []model.InstanceEdge {
	// Build indexes
	r.buildIndexes(instances)

	var edges []model.InstanceEdge

	for _, inst := range instances {
		def := definitions[inst.DefinitionID]
		if def == nil {
			continue
		}

		// 1. Explicit depends_on
		explicitEdges := r.resolveExplicitDeps(inst, def.DependsOn)
		edges = append(edges, explicitEdges...)

		// 2. Implicit reference-based dependencies
		implicitEdges := r.resolveImplicitDeps(inst, def)
		edges = append(edges, implicitEdges...)

		// 3. Provider dependencies
		providerEdges := r.resolveProviderDeps(inst)
		edges = append(edges, providerEdges...)
	}

	// Sort edges for determinism
	sort.Slice(edges, func(i, j int) bool {
		if edges[i].From != edges[j].From {
			return edges[i].From < edges[j].From
		}
		return edges[i].To < edges[j].To
	})

	// Deduplicate
	return r.deduplicate(edges)
}

func (r *DependencyResolver) buildIndexes(instances []*model.AssetInstance) {
	for _, inst := range instances {
		r.instanceByAddr[inst.Address] = inst
		r.instanceByDefn[inst.DefinitionID] = append(r.instanceByDefn[inst.DefinitionID], inst)
	}
}

// resolveExplicitDeps handles depends_on meta-argument
func (r *DependencyResolver) resolveExplicitDeps(
	inst *model.AssetInstance,
	dependsOn []string,
) []model.InstanceEdge {
	var edges []model.InstanceEdge

	for _, dep := range dependsOn {
		// depends_on references definitions, not instances
		// We need to create edges to ALL instances of that definition
		targetInstances := r.findInstancesByAddress(dep)
		for _, target := range targetInstances {
			if target.ID != inst.ID { // No self-loops
				edges = append(edges, model.InstanceEdge{
					From: inst.ID,
					To:   target.ID,
					Type: model.EdgeExplicit,
				})
			}
		}
	}

	return edges
}

// resolveImplicitDeps finds dependencies from attribute references
func (r *DependencyResolver) resolveImplicitDeps(
	inst *model.AssetInstance,
	def *model.AssetDefinition,
) []model.InstanceEdge {
	var edges []model.InstanceEdge

	// Collect all references from attributes
	for _, expr := range def.Attributes {
		for _, ref := range expr.References {
			// Parse reference to find target
			targetAddr := r.parseRefToAddress(ref)
			if targetAddr == "" {
				continue
			}

			targetInstances := r.findInstancesByAddress(targetAddr)
			for _, target := range targetInstances {
				if target.ID != inst.ID {
					edges = append(edges, model.InstanceEdge{
						From: inst.ID,
						To:   target.ID,
						Type: model.EdgeImplicit,
					})
				}
			}
		}
	}

	return edges
}

// resolveProviderDeps creates edges for provider requirements
func (r *DependencyResolver) resolveProviderDeps(inst *model.AssetInstance) []model.InstanceEdge {
	// Provider dependencies are generally implicit in Terraform
	// but we track them for completeness
	return nil
}

// findInstancesByAddress finds instances matching an address pattern
func (r *DependencyResolver) findInstancesByAddress(addr string) []*model.AssetInstance {
	var result []*model.AssetInstance

	// First try exact match
	if inst, ok := r.instanceByAddr[model.InstanceAddress(addr)]; ok {
		return []*model.AssetInstance{inst}
	}

	// Try as definition address (returns all instances)
	for instAddr, inst := range r.instanceByAddr {
		// Check if instance address starts with the definition address
		if strings.HasPrefix(string(instAddr), addr+"[") || string(instAddr) == addr {
			result = append(result, inst)
		}
	}

	// Sort for determinism
	sort.Slice(result, func(i, j int) bool {
		return result[i].Address < result[j].Address
	})

	return result
}

// parseRefToAddress extracts the resource address from a reference
// e.g., "aws_instance.web.id" -> "aws_instance.web"
// e.g., "module.app.aws_s3_bucket.data" -> "module.app.aws_s3_bucket.data"
func (r *DependencyResolver) parseRefToAddress(ref string) string {
	parts := strings.Split(ref, ".")

	// Skip variable/local references
	if len(parts) < 2 {
		return ""
	}

	switch parts[0] {
	case "var", "local", "path", "terraform":
		return "" // Not a resource reference
	case "data":
		if len(parts) >= 3 {
			return strings.Join(parts[:3], ".")
		}
	case "module":
		// Find where the resource part starts
		for i := 0; i < len(parts)-1; i += 2 {
			if parts[i] != "module" {
				// parts[i] is the resource type
				return strings.Join(parts[:i+2], ".")
			}
		}
	default:
		// Regular resource reference
		if len(parts) >= 2 {
			return parts[0] + "." + parts[1]
		}
	}

	return ""
}

func (r *DependencyResolver) deduplicate(edges []model.InstanceEdge) []model.InstanceEdge {
	seen := make(map[string]bool)
	result := make([]model.InstanceEdge, 0, len(edges))

	for _, e := range edges {
		key := string(e.From) + "->" + string(e.To)
		if !seen[key] {
			seen[key] = true
			result = append(result, e)
		}
	}

	return result
}

// TopologicalSort sorts instances in dependency order
func TopologicalSort(instances []*model.AssetInstance, edges []model.InstanceEdge) []model.InstanceID {
	// Build adjacency list
	adj := make(map[model.InstanceID][]model.InstanceID)
	inDegree := make(map[model.InstanceID]int)

	for _, inst := range instances {
		adj[inst.ID] = []model.InstanceID{}
		inDegree[inst.ID] = 0
	}

	for _, edge := range edges {
		adj[edge.From] = append(adj[edge.From], edge.To)
		inDegree[edge.To]++
	}

	// Kahn's algorithm with stable ordering
	var queue []model.InstanceID
	for id, degree := range inDegree {
		if degree == 0 {
			queue = append(queue, id)
		}
	}
	determinism.SortSlice(queue, func(a, b model.InstanceID) bool {
		return a < b
	})

	var result []model.InstanceID
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		result = append(result, node)

		for _, neighbor := range adj[node] {
			inDegree[neighbor]--
			if inDegree[neighbor] == 0 {
				queue = append(queue, neighbor)
				determinism.SortSlice(queue, func(a, b model.InstanceID) bool {
					return a < b
				})
			}
		}
	}

	// Check for cycles
	if len(result) != len(instances) {
		// Cycle detected - return what we have
		// Caller should handle this error case
	}

	return result
}

// DetectCycles finds all cycles in the dependency graph
func DetectCycles(instances []*model.AssetInstance, edges []model.InstanceEdge) [][]model.InstanceID {
	// Build adjacency list
	adj := make(map[model.InstanceID][]model.InstanceID)
	for _, inst := range instances {
		adj[inst.ID] = []model.InstanceID{}
	}
	for _, edge := range edges {
		adj[edge.From] = append(adj[edge.From], edge.To)
	}

	// DFS-based cycle detection
	var cycles [][]model.InstanceID
	color := make(map[model.InstanceID]int) // 0=white, 1=gray, 2=black
	parent := make(map[model.InstanceID]model.InstanceID)

	var dfs func(node model.InstanceID)
	dfs = func(node model.InstanceID) {
		color[node] = 1 // Gray

		for _, neighbor := range adj[node] {
			if color[neighbor] == 1 {
				// Back edge found - cycle detected
				cycle := []model.InstanceID{neighbor}
				for n := node; n != neighbor; n = parent[n] {
					cycle = append([]model.InstanceID{n}, cycle...)
				}
				cycles = append(cycles, cycle)
			} else if color[neighbor] == 0 {
				parent[neighbor] = node
				dfs(neighbor)
			}
		}

		color[node] = 2 // Black
	}

	// Sort nodes for deterministic traversal
	nodes := make([]model.InstanceID, 0, len(adj))
	for id := range adj {
		nodes = append(nodes, id)
	}
	determinism.SortSlice(nodes, func(a, b model.InstanceID) bool {
		return a < b
	})

	for _, node := range nodes {
		if color[node] == 0 {
			dfs(node)
		}
	}

	return cycles
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\determinism_class.go
# TYPE: go
# SIZE: 6531 bytes
################################################################################
// Package terraform - Function classification by determinism
// Functions are classified as PureDeterministic, PureContextual, or Impure.
// Impure functions block estimation in strict mode.
package terraform

// DeterminismClass indicates function determinism
type DeterminismClass int

const (
	// PureDeterministic - same inputs always produce same outputs
	PureDeterministic DeterminismClass = iota

	// PureContextual - deterministic given context (e.g., provider region)
	PureContextual

	// Impure - not deterministic (timestamp, uuid, external calls)
	Impure
)

// String returns the class name
func (c DeterminismClass) String() string {
	names := []string{"pure_deterministic", "pure_contextual", "impure"}
	if int(c) < len(names) {
		return names[c]
	}
	return "unknown"
}

// FunctionDeterminism maps Terraform functions to their determinism class
var FunctionDeterminism = map[string]DeterminismClass{
	// Pure Deterministic - safe
	"abs":           PureDeterministic,
	"ceil":          PureDeterministic,
	"floor":         PureDeterministic,
	"max":           PureDeterministic,
	"min":           PureDeterministic,
	"pow":           PureDeterministic,
	"signum":        PureDeterministic,
	"length":        PureDeterministic,
	"concat":        PureDeterministic,
	"contains":      PureDeterministic,
	"distinct":      PureDeterministic,
	"flatten":       PureDeterministic,
	"keys":          PureDeterministic,
	"values":        PureDeterministic,
	"lookup":        PureDeterministic,
	"merge":         PureDeterministic,
	"reverse":       PureDeterministic,
	"sort":          PureDeterministic,
	"zipmap":        PureDeterministic,
	"coalesce":      PureDeterministic,
	"compact":       PureDeterministic,
	"element":       PureDeterministic,
	"index":         PureDeterministic,
	"list":          PureDeterministic,
	"map":           PureDeterministic,
	"range":         PureDeterministic,
	"setintersection": PureDeterministic,
	"setproduct":    PureDeterministic,
	"setunion":      PureDeterministic,
	"slice":         PureDeterministic,
	"chomp":         PureDeterministic,
	"format":        PureDeterministic,
	"formatlist":    PureDeterministic,
	"indent":        PureDeterministic,
	"join":          PureDeterministic,
	"lower":         PureDeterministic,
	"upper":         PureDeterministic,
	"regex":         PureDeterministic,
	"regexall":      PureDeterministic,
	"replace":       PureDeterministic,
	"split":         PureDeterministic,
	"strrev":        PureDeterministic,
	"substr":        PureDeterministic,
	"title":         PureDeterministic,
	"trim":          PureDeterministic,
	"trimprefix":    PureDeterministic,
	"trimsuffix":    PureDeterministic,
	"trimspace":     PureDeterministic,
	"base64decode":  PureDeterministic,
	"base64encode":  PureDeterministic,
	"jsonencode":    PureDeterministic,
	"jsondecode":    PureDeterministic,
	"yamlencode":    PureDeterministic,
	"yamldecode":    PureDeterministic,
	"csvdecode":     PureDeterministic,
	"urlencode":     PureDeterministic,
	"md5":           PureDeterministic,
	"sha1":          PureDeterministic,
	"sha256":        PureDeterministic,
	"sha512":        PureDeterministic,
	"tolist":        PureDeterministic,
	"toset":         PureDeterministic,
	"tomap":         PureDeterministic,
	"tonumber":      PureDeterministic,
	"tostring":      PureDeterministic,
	"try":           PureDeterministic,
	"can":           PureDeterministic,

	// Pure Contextual - depends on provider/environment context
	"cidrhost":      PureContextual,
	"cidrnetmask":   PureContextual,
	"cidrsubnet":    PureContextual,
	"cidrsubnets":   PureContextual,
	"pathexpand":    PureContextual, // Depends on home directory

	// Impure - not deterministic, blocks in strict mode
	"timestamp":     Impure,
	"uuid":          Impure,
	"file":          Impure, // Reads from filesystem
	"fileexists":    Impure,
	"fileset":       Impure, // Directory listing
	"filebase64":    Impure,
	"templatefile":  Impure,
	"filemd5":       Impure,
	"filesha1":      Impure,
	"filesha256":    Impure,
	"filesha512":    Impure,
	"filebase64sha256": Impure,
	"filebase64sha512": Impure,
	"bcrypt":        Impure, // Random salt
	"rsadecrypt":    Impure, // External key
	"textencodebase64": PureDeterministic,
	"textdecodebase64": PureDeterministic,
}

// GetDeterminismClass returns the determinism class for a function
func GetDeterminismClass(function string) DeterminismClass {
	if class, ok := FunctionDeterminism[function]; ok {
		return class
	}
	// Unknown functions are treated as impure for safety
	return Impure
}

// IsPure returns true if function is deterministic
func IsPure(function string) bool {
	class := GetDeterminismClass(function)
	return class == PureDeterministic || class == PureContextual
}

// BlocksStrictMode returns true if function blocks strict mode
func BlocksStrictMode(function string) bool {
	return GetDeterminismClass(function) == Impure
}

// GetConfidenceImpact returns confidence impact for a function
func GetConfidenceImpact(function string) float64 {
	switch GetDeterminismClass(function) {
	case PureDeterministic:
		return 0.0 // No impact
	case PureContextual:
		return 0.1 // Small impact
	case Impure:
		return 0.5 // Large impact
	default:
		return 0.3 // Unknown
	}
}

// DeterminismAnalysis analyzes an expression for determinism
type DeterminismAnalysis struct {
	IsDeterministic bool
	ImpureFunctions []string
	ContextualFunctions []string
	TotalImpact     float64
}

// AnalyzeFunctions analyzes a list of function calls
func AnalyzeFunctions(functions []string) *DeterminismAnalysis {
	analysis := &DeterminismAnalysis{
		IsDeterministic: true,
		ImpureFunctions: []string{},
		ContextualFunctions: []string{},
		TotalImpact: 0.0,
	}

	for _, fn := range functions {
		class := GetDeterminismClass(fn)
		impact := GetConfidenceImpact(fn)
		analysis.TotalImpact += impact

		switch class {
		case Impure:
			analysis.IsDeterministic = false
			analysis.ImpureFunctions = append(analysis.ImpureFunctions, fn)
		case PureContextual:
			analysis.ContextualFunctions = append(analysis.ContextualFunctions, fn)
		}
	}

	return analysis
}

// ShouldBlock returns true if analysis should block estimation in strict mode
func (a *DeterminismAnalysis) ShouldBlock(strictMode bool) bool {
	return strictMode && len(a.ImpureFunctions) > 0
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\dynamic.go
# TYPE: go
# SIZE: 6073 bytes
################################################################################
// Package terraform - Dynamic block expansion
package terraform

import (
	"fmt"
	"sort"

	"terraform-cost/core/model"
)

// DynamicBlockExpander handles Terraform dynamic blocks
type DynamicBlockExpander struct{}

// NewDynamicBlockExpander creates a new expander
func NewDynamicBlockExpander() *DynamicBlockExpander {
	return &DynamicBlockExpander{}
}

// ExpandDynamicBlocks expands all dynamic blocks in a definition
func (e *DynamicBlockExpander) ExpandDynamicBlocks(
	def *model.AssetDefinition,
	evalCtx *EvalContext,
) (map[string][]map[string]model.ResolvedAttribute, []string) {
	result := make(map[string][]map[string]model.ResolvedAttribute)
	var warnings []string

	for _, dyn := range def.DynamicBlocks {
		blocks, warn := e.expandSingle(dyn, evalCtx)
		if warn != "" {
			warnings = append(warnings, warn)
		}
		result[dyn.Name] = blocks
	}

	return result, warnings
}

func (e *DynamicBlockExpander) expandSingle(
	dyn model.DynamicBlock,
	evalCtx *EvalContext,
) ([]map[string]model.ResolvedAttribute, string) {
	// Resolve the for_each expression
	forEachValue, ok := e.resolveForEach(dyn.ForEach, evalCtx)
	if !ok {
		return nil, fmt.Sprintf("dynamic %q: for_each could not be resolved", dyn.Name)
	}

	// Determine iterator name (default to block name)
	iterator := dyn.Iterator
	if iterator == "" {
		iterator = dyn.Name
	}

	var blocks []map[string]model.ResolvedAttribute

	// Iterate based on type
	switch v := forEachValue.(type) {
	case []any:
		for i, item := range v {
			block := e.expandContent(dyn.Content, iterator, i, item, evalCtx)
			blocks = append(blocks, block)
		}
	case map[string]any:
		// Sort keys for determinism
		keys := make([]string, 0, len(v))
		for k := range v {
			keys = append(keys, k)
		}
		sort.Strings(keys)

		for _, key := range keys {
			block := e.expandContent(dyn.Content, iterator, key, v[key], evalCtx)
			blocks = append(blocks, block)
		}
	default:
		return nil, fmt.Sprintf("dynamic %q: for_each must be list or map", dyn.Name)
	}

	return blocks, ""
}

func (e *DynamicBlockExpander) resolveForEach(expr model.Expression, ctx *EvalContext) (any, bool) {
	if expr.IsLiteral {
		return expr.LiteralVal, true
	}

	// Evaluate expression
	if ctx != nil {
		val, err := ctx.Evaluate(expr)
		if err != nil {
			return nil, false
		}
		return val, true
	}

	return nil, false
}

func (e *DynamicBlockExpander) expandContent(
	content map[string]model.Expression,
	iterator string,
	key any,
	value any,
	parentCtx *EvalContext,
) map[string]model.ResolvedAttribute {
	// Create child context with iterator variables
	ctx := parentCtx.Clone()
	ctx.SetLocal(iterator+".key", key)
	ctx.SetLocal(iterator+".value", value)

	result := make(map[string]model.ResolvedAttribute)

	for name, expr := range content {
		if expr.IsLiteral {
			result[name] = model.ResolvedAttribute{
				Value:     expr.LiteralVal,
				IsUnknown: false,
			}
		} else {
			// Try to evaluate with iterator context
			val, err := ctx.Evaluate(expr)
			if err != nil {
				result[name] = model.ResolvedAttribute{
					IsUnknown: true,
					Reason:    model.ReasonExpressionError,
				}
			} else {
				result[name] = model.ResolvedAttribute{
					Value:     val,
					IsUnknown: false,
				}
			}
		}
	}

	return result
}

// EvalContext provides evaluation context for expressions
type EvalContext struct {
	variables map[string]any
	locals    map[string]any
	resources map[string]any
	data      map[string]any
	parent    *EvalContext
}

// NewEvalContext creates a new evaluation context
func NewEvalContext() *EvalContext {
	return &EvalContext{
		variables: make(map[string]any),
		locals:    make(map[string]any),
		resources: make(map[string]any),
		data:      make(map[string]any),
	}
}

// Clone creates a child context
func (c *EvalContext) Clone() *EvalContext {
	return &EvalContext{
		variables: make(map[string]any),
		locals:    make(map[string]any),
		resources: make(map[string]any),
		data:      make(map[string]any),
		parent:    c,
	}
}

// SetLocal sets a local value
func (c *EvalContext) SetLocal(name string, value any) {
	c.locals[name] = value
}

// GetLocal gets a local value (searching parent chain)
func (c *EvalContext) GetLocal(name string) (any, bool) {
	if val, ok := c.locals[name]; ok {
		return val, true
	}
	if c.parent != nil {
		return c.parent.GetLocal(name)
	}
	return nil, false
}

// Evaluate evaluates an expression in this context
func (c *EvalContext) Evaluate(expr model.Expression) (any, error) {
	if expr.IsLiteral {
		return expr.LiteralVal, nil
	}

	// Parse references and resolve
	for _, ref := range expr.References {
		// Try to resolve reference
		// This is simplified - real implementation would parse the reference
		if val, ok := c.GetLocal(ref); ok {
			return val, nil
		}
	}

	return nil, fmt.Errorf("cannot evaluate expression: %s", expr.Raw)
}

// NestedDynamicBlock handles nested dynamic blocks (dynamic within dynamic)
type NestedDynamicBlock struct {
	Parent  string
	Block   model.DynamicBlock
}

// ExpandNested expands nested dynamic blocks
func (e *DynamicBlockExpander) ExpandNested(
	nested []NestedDynamicBlock,
	parentBlocks map[string][]map[string]model.ResolvedAttribute,
	evalCtx *EvalContext,
) map[string][]map[string]model.ResolvedAttribute {
	// For each parent block instance, expand child dynamics
	result := make(map[string][]map[string]model.ResolvedAttribute)

	for _, n := range nested {
		parentInstances := parentBlocks[n.Parent]
		for _, parentAttrs := range parentInstances {
			// Create context with parent block values
			childCtx := evalCtx.Clone()
			for k, v := range parentAttrs {
				childCtx.SetLocal(n.Parent+"."+k, v.Value)
			}

			// Expand the nested block
			blocks, _ := e.expandSingle(n.Block, childCtx)
			result[n.Block.Name] = append(result[n.Block.Name], blocks...)
		}
	}

	return result
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\function_class.go
# TYPE: go
# SIZE: 7306 bytes
################################################################################
// Package terraform - Function classification
// Pure vs impure, deterministic vs environment-dependent
package terraform

// FunctionClass classifies Terraform functions
type FunctionClass int

const (
	FunctionPure          FunctionClass = iota // Pure, deterministic (length, concat)
	FunctionImpure                              // Side effects (file, timestamp)
	FunctionEnvironment                         // Depends on environment (pathexpand)
	FunctionRandom                              // Non-deterministic (uuid)
	FunctionExternal                            // External data (data sources)
)

// String returns the class name
func (c FunctionClass) String() string {
	switch c {
	case FunctionPure:
		return "pure"
	case FunctionImpure:
		return "impure"
	case FunctionEnvironment:
		return "environment"
	case FunctionRandom:
		return "random"
	case FunctionExternal:
		return "external"
	default:
		return "unknown"
	}
}

// IsDeterministic returns true if the function is deterministic
func (c FunctionClass) IsDeterministic() bool {
	return c == FunctionPure
}

// FunctionInfo contains metadata about a function
type FunctionInfo struct {
	Name             string
	Class            FunctionClass
	AffectsCardinality bool
	ConfidenceImpact float64
	Description      string
}

// FunctionClassifier classifies Terraform functions
type FunctionClassifier struct {
	functions map[string]*FunctionInfo
}

// NewFunctionClassifier creates a classifier with known functions
func NewFunctionClassifier() *FunctionClassifier {
	fc := &FunctionClassifier{
		functions: make(map[string]*FunctionInfo),
	}
	fc.registerBuiltins()
	return fc
}

func (fc *FunctionClassifier) registerBuiltins() {
	// Pure functions - deterministic, no side effects
	pureFunctions := []string{
		"abs", "ceil", "floor", "log", "max", "min", "pow", "signum",
		"chomp", "format", "formatlist", "indent", "join", "lower", "upper",
		"regex", "regexall", "replace", "split", "strrev", "substr", "title", "trim",
		"trimprefix", "trimsuffix", "trimspace",
		"chunklist", "coalesce", "coalescelist", "compact", "concat", "contains",
		"distinct", "element", "flatten", "index", "keys", "length", "list",
		"lookup", "map", "matchkeys", "merge", "range", "reverse", "setintersection",
		"setproduct", "setsubtract", "setunion", "slice", "sort", "sum", "transpose",
		"values", "zipmap",
		"alltrue", "anytrue", "can", "try",
		"tobool", "tolist", "tomap", "tonumber", "toset", "tostring",
		"base64decode", "base64encode", "base64gzip", "csvdecode", "jsondecode",
		"jsonencode", "textdecodebase64", "textencodebase64", "urlencode", "yamldecode",
		"yamlencode",
		"cidrhost", "cidrnetmask", "cidrsubnet", "cidrsubnets",
		"md5", "sha1", "sha256", "sha512", "bcrypt",
	}

	for _, name := range pureFunctions {
		fc.functions[name] = &FunctionInfo{
			Name:             name,
			Class:            FunctionPure,
			AffectsCardinality: false,
			ConfidenceImpact: 0,
			Description:      "Pure function",
		}
	}

	// Cardinality-affecting pure functions
	cardinalityFunctions := []string{"range", "setproduct", "flatten", "concat"}
	for _, name := range cardinalityFunctions {
		if f, ok := fc.functions[name]; ok {
			f.AffectsCardinality = true
		}
	}

	// Impure functions - file system access
	impureFunctions := map[string]string{
		"file":          "reads file from disk",
		"fileexists":    "checks file existence",
		"fileset":       "globs files on disk",
		"filebase64":    "reads file as base64",
		"templatefile":  "reads and renders template",
		"abspath":       "resolves absolute path",
	}

	for name, desc := range impureFunctions {
		fc.functions[name] = &FunctionInfo{
			Name:             name,
			Class:            FunctionImpure,
			AffectsCardinality: name == "fileset",
			ConfidenceImpact: 0.2,
			Description:      desc,
		}
	}

	// Environment-dependent functions
	envFunctions := map[string]string{
		"pathexpand": "expands ~ to home dir",
		"dirname":    "depends on path separator",
		"basename":   "depends on path separator",
	}

	for name, desc := range envFunctions {
		fc.functions[name] = &FunctionInfo{
			Name:             name,
			Class:            FunctionEnvironment,
			AffectsCardinality: false,
			ConfidenceImpact: 0.1,
			Description:      desc,
		}
	}

	// Random/non-deterministic functions
	randomFunctions := map[string]string{
		"uuid":     "generates random UUID",
		"bcrypt":   "generates random salt",
		"timestamp":"returns current time",
	}

	for name, desc := range randomFunctions {
		fc.functions[name] = &FunctionInfo{
			Name:             name,
			Class:            FunctionRandom,
			AffectsCardinality: false,
			ConfidenceImpact: 0.3,
			Description:      desc,
		}
	}
}

// Classify returns the classification for a function
func (fc *FunctionClassifier) Classify(name string) *FunctionInfo {
	if info, ok := fc.functions[name]; ok {
		return info
	}
	// Unknown function - assume impure
	return &FunctionInfo{
		Name:             name,
		Class:            FunctionImpure,
		AffectsCardinality: false,
		ConfidenceImpact: 0.15,
		Description:      "Unknown function",
	}
}

// IsDeterministic checks if a function is deterministic
func (fc *FunctionClassifier) IsDeterministic(name string) bool {
	info := fc.Classify(name)
	return info.Class.IsDeterministic()
}

// GetConfidenceImpact returns the confidence impact of using a function
func (fc *FunctionClassifier) GetConfidenceImpact(name string) float64 {
	info := fc.Classify(name)
	return info.ConfidenceImpact
}

// ClassifyExpression classifies an expression based on functions used
func (fc *FunctionClassifier) ClassifyExpression(expr string, functions []string) *ExpressionClassification {
	result := &ExpressionClassification{
		Expression:         expr,
		IsDeterministic:    true,
		Functions:          []string{},
		NonDeterministic:   []string{},
		ConfidenceImpact:   0,
		AffectsCardinality: false,
	}

	for _, fn := range functions {
		info := fc.Classify(fn)
		result.Functions = append(result.Functions, fn)

		if !info.Class.IsDeterministic() {
			result.IsDeterministic = false
			result.NonDeterministic = append(result.NonDeterministic, fn)
		}

		if info.ConfidenceImpact > result.ConfidenceImpact {
			result.ConfidenceImpact = info.ConfidenceImpact
		}

		if info.AffectsCardinality {
			result.AffectsCardinality = true
		}
	}

	return result
}

// ExpressionClassification is the result of classifying an expression
type ExpressionClassification struct {
	Expression         string
	IsDeterministic    bool
	Functions          []string
	NonDeterministic   []string
	ConfidenceImpact   float64
	AffectsCardinality bool
}

// Warning returns a warning message if non-deterministic
func (ec *ExpressionClassification) Warning() string {
	if ec.IsDeterministic {
		return ""
	}
	return "expression uses non-deterministic functions: " + joinStrings(ec.NonDeterministic)
}

func joinStrings(strs []string) string {
	if len(strs) == 0 {
		return ""
	}
	result := strs[0]
	for i := 1; i < len(strs); i++ {
		result += ", " + strs[i]
	}
	return result
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\module_outputs.go
# TYPE: go
# SIZE: 7246 bytes
################################################################################
// Package terraform - Module output semantics
// Module outputs are NOT locals. They are:
// - Dependency edges
// - Potentially unknown
// - Cardinality-affecting
package terraform

import (
	"fmt"
	"strings"
)

// ModuleOutput represents a module output value
type ModuleOutput struct {
	// Path to the module
	ModulePath string

	// Output name
	Name string

	// Full address (module.name.output_name)
	Address string

	// Is this output known?
	IsKnown bool

	// Value if known
	Value interface{}

	// Expression if unknown
	Expression string

	// References in the expression
	References []string

	// Is this a dependency edge?
	IsDependencyEdge bool

	// Can this affect cardinality?
	AffectsCardinality bool

	// Confidence impact
	ConfidenceImpact float64
}

// ModuleOutputAnalyzer analyzes module outputs
type ModuleOutputAnalyzer struct {
	outputs map[string]*ModuleOutput
}

// NewModuleOutputAnalyzer creates an analyzer
func NewModuleOutputAnalyzer() *ModuleOutputAnalyzer {
	return &ModuleOutputAnalyzer{
		outputs: make(map[string]*ModuleOutput),
	}
}

// RegisterOutput registers a module output
func (a *ModuleOutputAnalyzer) RegisterOutput(modulePath, name string, expr *ExpressionValue) *ModuleOutput {
	address := modulePath + "." + name

	output := &ModuleOutput{
		ModulePath:         modulePath,
		Name:               name,
		Address:            address,
		IsKnown:            expr != nil && expr.IsKnown,
		References:         []string{},
		IsDependencyEdge:   true, // Module outputs are ALWAYS dependency edges
		AffectsCardinality: false,
		ConfidenceImpact:   0,
	}

	if expr != nil {
		output.Value = expr.Value
		output.Expression = expr.Expression
		output.References = expr.References

		// Check if this could affect cardinality
		output.AffectsCardinality = a.couldAffectCardinality(expr)

		// Calculate confidence impact
		output.ConfidenceImpact = a.calculateConfidenceImpact(output)
	}

	a.outputs[address] = output
	return output
}

// GetOutput returns an output by address
func (a *ModuleOutputAnalyzer) GetOutput(address string) (*ModuleOutput, bool) {
	output, ok := a.outputs[address]
	return output, ok
}

// IsModuleOutputRef checks if a reference is to a module output
func (a *ModuleOutputAnalyzer) IsModuleOutputRef(ref string) bool {
	// module.name.output_name
	return strings.HasPrefix(ref, "module.") && strings.Count(ref, ".") >= 2
}

// GetReferencedOutput gets the output for a reference
func (a *ModuleOutputAnalyzer) GetReferencedOutput(ref string) (*ModuleOutput, bool) {
	if !a.IsModuleOutputRef(ref) {
		return nil, false
	}
	return a.GetOutput(ref)
}

func (a *ModuleOutputAnalyzer) couldAffectCardinality(expr *ExpressionValue) bool {
	if expr == nil {
		return false
	}

	// Check if expression returns a collection
	if expr.Expression != "" {
		collectors := []string{"list", "map", "set", "tolist", "toset", "tomap"}
		for _, c := range collectors {
			if strings.Contains(expr.Expression, c) {
				return true
			}
		}
	}

	// Check if value is a collection
	switch expr.Value.(type) {
	case []interface{}, map[string]interface{}:
		return true
	}

	return false
}

func (a *ModuleOutputAnalyzer) calculateConfidenceImpact(output *ModuleOutput) float64 {
	if output.IsKnown {
		return 0.0
	}

	impact := 0.2 // Base impact for unknown output

	// Higher impact if it affects cardinality
	if output.AffectsCardinality {
		impact += 0.15
	}

	// Higher impact if references data sources
	for _, ref := range output.References {
		if strings.HasPrefix(ref, "data.") {
			impact += 0.1
			break
		}
	}

	return impact
}

// OutputDependencyEdge represents a dependency through module output
type OutputDependencyEdge struct {
	// Source: the module producing the output
	SourceModule string
	OutputName   string

	// Target: the consumer of the output
	TargetAddress string
	TargetAttr    string

	// Semantics
	IsKnown            bool
	AffectsCardinality bool
}

// ExtractOutputDependencies extracts dependency edges from references
func (a *ModuleOutputAnalyzer) ExtractOutputDependencies(address, attribute string, references []string) []*OutputDependencyEdge {
	var edges []*OutputDependencyEdge

	for _, ref := range references {
		if a.IsModuleOutputRef(ref) {
			output, _ := a.GetReferencedOutput(ref)

			edge := &OutputDependencyEdge{
				TargetAddress: address,
				TargetAttr:    attribute,
				IsKnown:       false,
			}

			// Parse module.name.output
			parts := strings.Split(ref, ".")
			if len(parts) >= 3 {
				edge.SourceModule = parts[0] + "." + parts[1]
				edge.OutputName = parts[2]
			}

			if output != nil {
				edge.IsKnown = output.IsKnown
				edge.AffectsCardinality = output.AffectsCardinality
			}

			edges = append(edges, edge)
		}
	}

	return edges
}

// ModuleOutputValidator validates module output usage
type ModuleOutputValidator struct {
	analyzer *ModuleOutputAnalyzer
	warnings []ModuleOutputWarning
}

// ModuleOutputWarning is a warning about module output usage
type ModuleOutputWarning struct {
	TargetAddress string
	OutputRef     string
	Type          OutputWarningType
	Message       string
}

// OutputWarningType classifies warnings
type OutputWarningType int

const (
	WarnUnknownOutput          OutputWarningType = iota // Output value unknown
	WarnCardinalityFromOutput                            // Using output for cardinality
	WarnDataSourceInOutput                               // Output depends on data source
)

// NewModuleOutputValidator creates a validator
func NewModuleOutputValidator(analyzer *ModuleOutputAnalyzer) *ModuleOutputValidator {
	return &ModuleOutputValidator{
		analyzer: analyzer,
		warnings: []ModuleOutputWarning{},
	}
}

// ValidateUsage validates usage of module outputs
func (v *ModuleOutputValidator) ValidateUsage(address, attribute string, references []string, isCardinalityContext bool) {
	for _, ref := range references {
		if v.analyzer.IsModuleOutputRef(ref) {
			output, ok := v.analyzer.GetReferencedOutput(ref)

			if !ok {
				// Unknown output
				v.warnings = append(v.warnings, ModuleOutputWarning{
					TargetAddress: address,
					OutputRef:     ref,
					Type:          WarnUnknownOutput,
					Message:       fmt.Sprintf("module output %s is not registered", ref),
				})
				continue
			}

			if !output.IsKnown {
				v.warnings = append(v.warnings, ModuleOutputWarning{
					TargetAddress: address,
					OutputRef:     ref,
					Type:          WarnUnknownOutput,
					Message:       fmt.Sprintf("module output %s has unknown value", ref),
				})
			}

			if isCardinalityContext && output.AffectsCardinality {
				v.warnings = append(v.warnings, ModuleOutputWarning{
					TargetAddress: address,
					OutputRef:     ref,
					Type:          WarnCardinalityFromOutput,
					Message:       fmt.Sprintf("cardinality depends on module output %s", ref),
				})
			}
		}
	}
}

// GetWarnings returns all warnings
func (v *ModuleOutputValidator) GetWarnings() []ModuleOutputWarning {
	return v.warnings
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\phased_expansion.go
# TYPE: go
# SIZE: 13766 bytes
################################################################################
// Package terraform - Phased module expansion
// Expansion happens in strict order to avoid phantom resources:
// 1. Parse â†’ 2. Bind Providers â†’ 3. Resolve Variables â†’ 4. Expand Modules â†’ 5. Expand Resources
package terraform

import (
	"context"
	"fmt"
	"sort"
)

// ExpansionPhase represents a distinct expansion stage
type ExpansionPhase int

const (
	ExpansionPhaseParse           ExpansionPhase = iota // Parse HCL
	ExpansionPhaseBindProviders                          // Bind provider configurations
	ExpansionPhaseResolveVars                            // Resolve variables and locals
	ExpansionPhaseExpandModules                          // Expand module calls
	ExpansionPhaseExpandResources                        // Expand count/for_each
	ExpansionPhaseBuildGraph                             // Build final graph
)

// String returns the phase name
func (p ExpansionPhase) String() string {
	switch p {
	case ExpansionPhaseParse:
		return "parse"
	case ExpansionPhaseBindProviders:
		return "bind_providers"
	case ExpansionPhaseResolveVars:
		return "resolve_vars"
	case ExpansionPhaseExpandModules:
		return "expand_modules"
	case ExpansionPhaseExpandResources:
		return "expand_resources"
	case ExpansionPhaseBuildGraph:
		return "build_graph"
	default:
		return "unknown"
	}
}

// PhasedExpander expands infrastructure in strict phases
type PhasedExpander struct {
	// Current phase
	currentPhase ExpansionPhase

	// Mode for handling unknowns
	mode EvaluationMode

	// Enforcer for strict mode
	enforcer *StrictModeEnforcer

	// Phase results
	phaseResults map[ExpansionPhase]*PhaseResult

	// Provider resolver
	providerResolver *ModuleProviderResolver

	// Expansion stats
	stats ExpansionStats
}

// PhaseResult is the result of a single phase
type PhaseResult struct {
	Phase       ExpansionPhase
	Success     bool
	Errors      []PhaseError
	Warnings    []PhaseWarning
	ItemCount   int
	DurationMs  int64
}

// PhaseError is an error from a phase
type PhaseError struct {
	Phase   ExpansionPhase
	Address string
	Message string
	Cause   error
}

// PhaseWarning is a warning from a phase
type PhaseWarning struct {
	Phase   ExpansionPhase
	Address string
	Message string
}

// ExpansionStats tracks expansion statistics
type ExpansionStats struct {
	ModulesFound      int
	ModulesExpanded   int
	ResourcesFound    int
	ResourcesExpanded int
	InstancesCreated  int
	UnknownsDeferred  int
	ProvidersResolved int
	VariablesResolved int
}

// NewPhasedExpander creates a new phased expander
func NewPhasedExpander(mode EvaluationMode) *PhasedExpander {
	return &PhasedExpander{
		currentPhase:     ExpansionPhaseParse,
		mode:             mode,
		enforcer:         NewStrictModeEnforcer(mode),
		phaseResults:     make(map[ExpansionPhase]*PhaseResult),
		providerResolver: NewModuleProviderResolver(),
	}
}

// ExpansionInput is the input to phased expansion
type ExpansionInput struct {
	// Parsed modules
	Modules []*ModuleDefinition

	// Root variables
	Variables map[string]interface{}

	// Provider configurations
	Providers []*ProviderConfig

	// Workspace
	Workspace string
}

// ModuleDefinition is a parsed module
type ModuleDefinition struct {
	Path      string
	Source    string
	Parent    string
	Count     *ExpressionValue
	ForEach   *ExpressionValue
	Providers map[string]string
	Inputs    map[string]*ExpressionValue
	Resources []*ResourceDefinition
	Children  []string
}

// ResourceDefinition is a parsed resource
type ResourceDefinition struct {
	Address      string
	ModulePath   string
	Type         string
	Name         string
	Provider     string
	Count        *ExpressionValue
	ForEach      *ExpressionValue
	Attributes   map[string]*ExpressionValue
	DependsOn    []string
}

// ExpressionValue is an expression that may or may not be evaluated
type ExpressionValue struct {
	IsKnown    bool
	Value      interface{}
	Expression string
	References []string
}

// ExpansionOutput is the output of phased expansion
type ExpansionOutput struct {
	// Final instances
	Instances []*ExpandedInstance

	// Phase results
	Phases []*PhaseResult

	// Stats
	Stats ExpansionStats

	// Is expansion complete?
	Complete bool

	// Blocked on unknowns?
	Blocked bool
	BlockedReasons []string
}

// ExpandedInstance is an expanded resource instance
type ExpandedInstance struct {
	Address       string
	ModulePath    string
	DefinitionID  string
	ResourceType  string
	InstanceKey   interface{}
	Provider      *ProviderContext
	Attributes    map[string]interface{}
	DependsOn     []string
	References    []string
}

// Expand runs all phases in order
func (e *PhasedExpander) Expand(ctx context.Context, input *ExpansionInput) (*ExpansionOutput, error) {
	output := &ExpansionOutput{
		Instances: []*ExpandedInstance{},
		Phases:    []*PhaseResult{},
		Complete:  false,
	}

	// Phase 1: Parse (already done - input is parsed)
	e.recordPhase(ExpansionPhaseParse, true, 0, nil)

	// Phase 2: Bind Providers
	if err := e.executeBindProviders(ctx, input); err != nil {
		output.Phases = e.getPhaseResults()
		return output, err
	}

	// Phase 3: Resolve Variables
	resolvedVars, err := e.executeResolveVars(ctx, input)
	if err != nil && e.mode == ModeStrict {
		output.Phases = e.getPhaseResults()
		return output, err
	}

	// Phase 4: Expand Modules
	expandedModules, err := e.executeExpandModules(ctx, input, resolvedVars)
	if err != nil && e.mode == ModeStrict {
		output.Phases = e.getPhaseResults()
		return output, err
	}

	// Phase 5: Expand Resources
	instances, err := e.executeExpandResources(ctx, expandedModules, resolvedVars)
	if err != nil && e.mode == ModeStrict {
		output.Phases = e.getPhaseResults()
		return output, err
	}

	output.Instances = instances
	output.Phases = e.getPhaseResults()
	output.Stats = e.stats
	output.Complete = !e.enforcer.IsBlocked()
	output.Blocked = e.enforcer.IsBlocked()

	if output.Blocked {
		for _, err := range e.enforcer.GetBlockingErrors() {
			output.BlockedReasons = append(output.BlockedReasons, err.Reason)
		}
	}

	return output, nil
}

func (e *PhasedExpander) executeBindProviders(ctx context.Context, input *ExpansionInput) error {
	e.currentPhase = ExpansionPhaseBindProviders

	// Register root providers
	for _, p := range input.Providers {
		e.providerResolver.RegisterRootProvider(p)
		e.stats.ProvidersResolved++
	}

	// Register module provider mappings
	for _, mod := range input.Modules {
		if len(mod.Providers) > 0 {
			e.providerResolver.RegisterModuleCall(mod.Parent, mod.Path, mod.Providers)
		}
	}

	e.recordPhase(ExpansionPhaseBindProviders, true, len(input.Providers), nil)
	return nil
}

func (e *PhasedExpander) executeResolveVars(ctx context.Context, input *ExpansionInput) (map[string]interface{}, error) {
	e.currentPhase = ExpansionPhaseResolveVars

	resolved := make(map[string]interface{})
	var errors []PhaseError

	// Copy input variables
	for k, v := range input.Variables {
		resolved[k] = v
		e.stats.VariablesResolved++
	}

	// NOTE: In full implementation, this would:
	// - Resolve locals in dependency order
	// - Evaluate variable defaults
	// - Handle workspace-specific values

	hasErrors := len(errors) > 0
	e.recordPhase(ExpansionPhaseResolveVars, !hasErrors, e.stats.VariablesResolved, errors)

	if hasErrors && e.mode == ModeStrict {
		return resolved, fmt.Errorf("variable resolution failed in strict mode")
	}

	return resolved, nil
}

func (e *PhasedExpander) executeExpandModules(ctx context.Context, input *ExpansionInput, vars map[string]interface{}) ([]*ModuleDefinition, error) {
	e.currentPhase = ExpansionPhaseExpandModules

	var expanded []*ModuleDefinition
	var errors []PhaseError

	for _, mod := range input.Modules {
		e.stats.ModulesFound++

		// Check count/for_each
		if mod.Count != nil {
			if !mod.Count.IsKnown {
				if err := e.enforcer.CheckUnknownCount(mod.Path, "module count is unknown"); err != nil {
					errors = append(errors, PhaseError{
						Phase:   ExpansionPhaseExpandModules,
						Address: mod.Path,
						Message: "unknown module count",
						Cause:   err,
					})
					e.stats.UnknownsDeferred++
					continue
				}
			}
		}

		if mod.ForEach != nil {
			if !mod.ForEach.IsKnown {
				if err := e.enforcer.CheckUnknownForEach(mod.Path, "module for_each is unknown"); err != nil {
					errors = append(errors, PhaseError{
						Phase:   ExpansionPhaseExpandModules,
						Address: mod.Path,
						Message: "unknown module for_each",
						Cause:   err,
					})
					e.stats.UnknownsDeferred++
					continue
				}
			}
		}

		expanded = append(expanded, mod)
		e.stats.ModulesExpanded++
	}

	hasErrors := len(errors) > 0
	e.recordPhase(ExpansionPhaseExpandModules, !hasErrors, e.stats.ModulesExpanded, errors)

	return expanded, nil
}

func (e *PhasedExpander) executeExpandResources(ctx context.Context, modules []*ModuleDefinition, vars map[string]interface{}) ([]*ExpandedInstance, error) {
	e.currentPhase = ExpansionPhaseExpandResources

	var instances []*ExpandedInstance
	var errors []PhaseError

	for _, mod := range modules {
		for _, res := range mod.Resources {
			e.stats.ResourcesFound++

			// Resolve provider for this resource
			providerCtx, err := e.providerResolver.ResolveProvider(res.ModulePath, res.Type, res.Provider)
			if err != nil {
				if strictErr := e.enforcer.CheckUnknownProvider(res.Address, res.Provider); strictErr != nil {
					errors = append(errors, PhaseError{
						Phase:   ExpansionPhaseExpandResources,
						Address: res.Address,
						Message: err.Error(),
						Cause:   strictErr,
					})
					continue
				}
			}

			// Expand count
			if res.Count != nil {
				if !res.Count.IsKnown {
					if err := e.enforcer.CheckUnknownCount(res.Address, "resource count is unknown"); err != nil {
						errors = append(errors, PhaseError{
							Phase:   ExpansionPhaseExpandResources,
							Address: res.Address,
							Message: "unknown count",
							Cause:   err,
						})
						e.stats.UnknownsDeferred++
						continue
					}
					// In permissive/estimate mode, expand with default
					res.Count.Value = GetModeConfig(e.mode).DefaultUnknownCount
				}

				count := e.toInt(res.Count.Value)
				for i := 0; i < count; i++ {
					inst := e.createInstance(res, i, nil, providerCtx)
					instances = append(instances, inst)
					e.stats.InstancesCreated++
				}
				e.stats.ResourcesExpanded++
				continue
			}

			// Expand for_each
			if res.ForEach != nil {
				if !res.ForEach.IsKnown {
					if err := e.enforcer.CheckUnknownForEach(res.Address, "resource for_each is unknown"); err != nil {
						errors = append(errors, PhaseError{
							Phase:   ExpansionPhaseExpandResources,
							Address: res.Address,
							Message: "unknown for_each",
							Cause:   err,
						})
						e.stats.UnknownsDeferred++
						continue
					}
				}

				keys := e.extractKeys(res.ForEach.Value)
				for _, key := range keys {
					inst := e.createInstance(res, 0, key, providerCtx)
					instances = append(instances, inst)
					e.stats.InstancesCreated++
				}
				e.stats.ResourcesExpanded++
				continue
			}

			// Single instance
			inst := e.createInstance(res, 0, nil, providerCtx)
			instances = append(instances, inst)
			e.stats.InstancesCreated++
			e.stats.ResourcesExpanded++
		}
	}

	// Sort for determinism
	sort.Slice(instances, func(i, j int) bool {
		return instances[i].Address < instances[j].Address
	})

	hasErrors := len(errors) > 0
	e.recordPhase(ExpansionPhaseExpandResources, !hasErrors, e.stats.InstancesCreated, errors)

	return instances, nil
}

func (e *PhasedExpander) createInstance(res *ResourceDefinition, countIdx int, forEachKey interface{}, provider *ProviderContext) *ExpandedInstance {
	address := res.Address
	if countIdx > 0 || res.Count != nil {
		address = fmt.Sprintf("%s[%d]", res.Address, countIdx)
	}
	if forEachKey != nil {
		address = fmt.Sprintf("%s[%q]", res.Address, forEachKey)
	}

	return &ExpandedInstance{
		Address:      address,
		ModulePath:   res.ModulePath,
		DefinitionID: res.Address,
		ResourceType: res.Type,
		InstanceKey:  forEachKey,
		Provider:     provider,
		DependsOn:    res.DependsOn,
	}
}

func (e *PhasedExpander) recordPhase(phase ExpansionPhase, success bool, count int, errors []PhaseError) {
	result := &PhaseResult{
		Phase:     phase,
		Success:   success,
		ItemCount: count,
		Errors:    errors,
	}
	e.phaseResults[phase] = result
}

func (e *PhasedExpander) getPhaseResults() []*PhaseResult {
	results := make([]*PhaseResult, 0, len(e.phaseResults))
	for phase := ExpansionPhaseParse; phase <= ExpansionPhaseBuildGraph; phase++ {
		if r, ok := e.phaseResults[phase]; ok {
			results = append(results, r)
		}
	}
	return results
}

func (e *PhasedExpander) toInt(v interface{}) int {
	switch n := v.(type) {
	case int:
		return n
	case int64:
		return int(n)
	case float64:
		return int(n)
	default:
		return 1
	}
}

func (e *PhasedExpander) extractKeys(v interface{}) []string {
	switch val := v.(type) {
	case map[string]interface{}:
		keys := make([]string, 0, len(val))
		for k := range val {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		return keys
	case []interface{}:
		keys := make([]string, 0, len(val))
		for _, item := range val {
			if s, ok := item.(string); ok {
				keys = append(keys, s)
			}
		}
		return keys
	default:
		return []string{}
	}
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\pipeline.go
# TYPE: go
# SIZE: 14785 bytes
################################################################################
// Package terraform provides a formal evaluation pipeline with strict phase separation.
// Phases: PARSE â†’ EVALUATE â†’ RESOLVE â†’ EXPAND â†’ BUILD
package terraform

import (
	"context"
	"fmt"
	"sort"

	"terraform-cost/core/determinism"
	"terraform-cost/core/model"
)

// Phase represents a distinct stage in evaluation
type Phase int

const (
	PhaseParse    Phase = iota // Parse HCL into raw blocks
	PhaseEvaluate              // Evaluate expressions
	PhaseResolve               // Resolve variables, locals, data sources
	PhaseExpand                // Expand count/for_each
	PhaseBuild                 // Build instance graph
)

// String returns the phase name
func (p Phase) String() string {
	switch p {
	case PhaseParse:
		return "parse"
	case PhaseEvaluate:
		return "evaluate"
	case PhaseResolve:
		return "resolve"
	case PhaseExpand:
		return "expand"
	case PhaseBuild:
		return "build"
	default:
		return "unknown"
	}
}

// Pipeline orchestrates all evaluation phases in strict order
type Pipeline struct {
	parser    *Parser
	evaluator *Evaluator
	resolver  *Resolver
	expander  *Expander
	builder   *GraphBuilder

	// Options
	opts PipelineOptions
}

// PipelineOptions configures pipeline behavior
type PipelineOptions struct {
	// Workspace name (default: "default")
	Workspace string

	// Variables from CLI/environment
	Variables map[string]any

	// Target resources (partial apply)
	Targets []string

	// Continue on errors
	ContinueOnError bool

	// Provider defaults
	DefaultProviders map[string]ProviderConfig

	// Unknown handling
	UnknownCountDefault int
}

// NewPipeline creates a new evaluation pipeline
func NewPipeline(opts PipelineOptions) *Pipeline {
	if opts.Workspace == "" {
		opts.Workspace = "default"
	}
	if opts.UnknownCountDefault == 0 {
		opts.UnknownCountDefault = 1
	}

	return &Pipeline{
		parser:    NewParser(),
		evaluator: NewEvaluator(),
		resolver:  NewResolver(opts.Variables),
		expander:  NewExpander(opts.UnknownCountDefault),
		builder:   NewGraphBuilder(),
		opts:      opts,
	}
}

// PipelineResult is the output of the pipeline
type PipelineResult struct {
	Graph    *model.InstanceGraph
	Warnings []Warning
	Errors   []Error
	Stats    PipelineStats
}

// PipelineStats tracks statistics from the pipeline run
type PipelineStats struct {
	DefinitionsFound int
	InstancesCreated int
	EdgesCreated     int
	UnknownValues    int
	ParseDuration    int64 // milliseconds
	TotalDuration    int64
}

// Warning is a non-fatal issue
type Warning struct {
	Phase   Phase
	Address string
	Message string
}

// Error is a fatal issue (may be recoverable if ContinueOnError)
type Error struct {
	Phase   Phase
	Address string
	Message string
	Cause   error
}

// Execute runs all phases in strict order
func (p *Pipeline) Execute(ctx context.Context, input *ScanInput) (*PipelineResult, error) {
	result := &PipelineResult{
		Warnings: []Warning{},
		Errors:   []Error{},
	}

	// Phase 1: Parse
	parsed, err := p.runParse(ctx, input, result)
	if err != nil && !p.opts.ContinueOnError {
		return result, fmt.Errorf("parse phase failed: %w", err)
	}

	// Phase 2: Evaluate expressions
	evaluated, err := p.runEvaluate(ctx, parsed, result)
	if err != nil && !p.opts.ContinueOnError {
		return result, fmt.Errorf("evaluate phase failed: %w", err)
	}

	// Phase 3: Resolve variables, locals, data sources
	resolved, err := p.runResolve(ctx, evaluated, result)
	if err != nil && !p.opts.ContinueOnError {
		return result, fmt.Errorf("resolve phase failed: %w", err)
	}

	// Phase 4: Expand instances
	expanded, err := p.runExpand(ctx, resolved, result)
	if err != nil && !p.opts.ContinueOnError {
		return result, fmt.Errorf("expand phase failed: %w", err)
	}

	// Phase 5: Build instance graph
	graph, err := p.runBuild(ctx, expanded, result)
	if err != nil {
		return result, fmt.Errorf("build phase failed: %w", err)
	}

	result.Graph = graph
	result.Stats.DefinitionsFound = len(parsed.Definitions)
	result.Stats.InstancesCreated = graph.Size()
	return result, nil
}

// ScanInput is the input to the pipeline
type ScanInput struct {
	RootPath    string
	Files       []string
	ModulePaths []string
	Workspace   string
}

// ParsedModule represents parsed HCL content
type ParsedModule struct {
	Path        string
	Definitions []*model.AssetDefinition
	Variables   []*VariableBlock
	Locals      []*LocalBlock
	Outputs     []*OutputBlock
	Providers   []*ProviderBlock
	Modules     []*ModuleCall
	DataSources []*model.AssetDefinition
}

// VariableBlock is a Terraform variable
type VariableBlock struct {
	Name        string
	Type        string
	Default     any
	Description string
	Sensitive   bool
	Validation  []ValidationRule
}

// LocalBlock is a Terraform local
type LocalBlock struct {
	Name       string
	Expression model.Expression
}

// OutputBlock is a Terraform output
type OutputBlock struct {
	Name        string
	Expression  model.Expression
	Description string
	Sensitive   bool
	DependsOn   []string
}

// ProviderBlock is a Terraform provider configuration
type ProviderBlock struct {
	Type       string
	Alias      string
	Attributes map[string]model.Expression
}

// ProviderConfig is a resolved provider
type ProviderConfig struct {
	Type   string
	Alias  string
	Region string
	Module string              // Module where defined
	Config map[string]any
}

// ModuleCall is a Terraform module block
type ModuleCall struct {
	Name       string
	Source     string
	Version    string
	Count      *model.Expression
	ForEach    *model.Expression
	Providers  map[string]string // Provider aliases
	Inputs     map[string]model.Expression
	DependsOn  []string
}

// ValidationRule is a variable validation
type ValidationRule struct {
	Condition    model.Expression
	ErrorMessage string
}

// runParse executes the parse phase
func (p *Pipeline) runParse(ctx context.Context, input *ScanInput, result *PipelineResult) (*ParsedModule, error) {
	return p.parser.Parse(ctx, input)
}

// EvaluatedModule has expressions partially evaluated
type EvaluatedModule struct {
	*ParsedModule
	// Local values computed
	ComputedLocals map[string]any
	// Provider configs resolved
	ResolvedProviders map[string]ProviderConfig
}

func (p *Pipeline) runEvaluate(ctx context.Context, parsed *ParsedModule, result *PipelineResult) (*EvaluatedModule, error) {
	return p.evaluator.Evaluate(ctx, parsed)
}

// ResolvedModule has all references resolved
type ResolvedModule struct {
	*EvaluatedModule
	// Variable values after resolution
	ResolvedVariables map[string]any
	// Data sources evaluated (some may be unknown)
	ResolvedData map[string]ResolvedData
}

// ResolvedData is a resolved data source
type ResolvedData struct {
	Address    string
	Attributes map[string]model.ResolvedAttribute
	IsKnown    bool
}

func (p *Pipeline) runResolve(ctx context.Context, evaluated *EvaluatedModule, result *PipelineResult) (*ResolvedModule, error) {
	return p.resolver.Resolve(ctx, evaluated)
}

// ExpandedModule has all count/for_each expanded
type ExpandedModule struct {
	*ResolvedModule
	// Instances after expansion
	Instances []*model.AssetInstance
}

func (p *Pipeline) runExpand(ctx context.Context, resolved *ResolvedModule, result *PipelineResult) (*ExpandedModule, error) {
	return p.expander.Expand(ctx, resolved, result)
}

func (p *Pipeline) runBuild(ctx context.Context, expanded *ExpandedModule, result *PipelineResult) (*model.InstanceGraph, error) {
	return p.builder.Build(ctx, expanded)
}

// Parser handles Phase 1: Parse
type Parser struct{}

func NewParser() *Parser { return &Parser{} }

func (p *Parser) Parse(ctx context.Context, input *ScanInput) (*ParsedModule, error) {
	// Implementation would use HCL parser
	// For now, return skeleton
	return &ParsedModule{
		Path:        input.RootPath,
		Definitions: []*model.AssetDefinition{},
		Variables:   []*VariableBlock{},
		Locals:      []*LocalBlock{},
	}, nil
}

// Evaluator handles Phase 2: Evaluate
type Evaluator struct{}

func NewEvaluator() *Evaluator { return &Evaluator{} }

func (e *Evaluator) Evaluate(ctx context.Context, parsed *ParsedModule) (*EvaluatedModule, error) {
	result := &EvaluatedModule{
		ParsedModule:      parsed,
		ComputedLocals:    make(map[string]any),
		ResolvedProviders: make(map[string]ProviderConfig),
	}

	// Evaluate locals in dependency order
	// Resolve provider configurations

	return result, nil
}

// Resolver handles Phase 3: Resolve
type Resolver struct {
	inputVars map[string]any
}

func NewResolver(vars map[string]any) *Resolver {
	if vars == nil {
		vars = make(map[string]any)
	}
	return &Resolver{inputVars: vars}
}

func (r *Resolver) Resolve(ctx context.Context, evaluated *EvaluatedModule) (*ResolvedModule, error) {
	result := &ResolvedModule{
		EvaluatedModule:   evaluated,
		ResolvedVariables: make(map[string]any),
		ResolvedData:      make(map[string]ResolvedData),
	}

	// Resolve variables from inputs, defaults, environment
	for _, v := range evaluated.Variables {
		if val, ok := r.inputVars[v.Name]; ok {
			result.ResolvedVariables[v.Name] = val
		} else if v.Default != nil {
			result.ResolvedVariables[v.Name] = v.Default
		}
	}

	return result, nil
}

// Expander handles Phase 4: Expand
type Expander struct {
	defaultCount int
}

func NewExpander(defaultCount int) *Expander {
	return &Expander{defaultCount: defaultCount}
}

func (e *Expander) Expand(ctx context.Context, resolved *ResolvedModule, result *PipelineResult) (*ExpandedModule, error) {
	expanded := &ExpandedModule{
		ResolvedModule: resolved,
		Instances:      []*model.AssetInstance{},
	}

	idGen := determinism.NewIDGenerator("inst")

	for _, def := range resolved.Definitions {
		instances, warnings := e.expandDefinition(def, resolved, idGen)
		expanded.Instances = append(expanded.Instances, instances...)

		for _, w := range warnings {
			result.Warnings = append(result.Warnings, Warning{
				Phase:   PhaseExpand,
				Address: string(def.Address),
				Message: w,
			})
		}
	}

	// Sort instances for determinism
	sort.Slice(expanded.Instances, func(i, j int) bool {
		return expanded.Instances[i].Address < expanded.Instances[j].Address
	})

	return expanded, nil
}

func (e *Expander) expandDefinition(def *model.AssetDefinition, resolved *ResolvedModule, idGen *determinism.IDGenerator) ([]*model.AssetInstance, []string) {
	var warnings []string

	// Handle count
	if def.Count != nil {
		count, known := e.resolveCount(def.Count, resolved)
		if !known {
			warnings = append(warnings, fmt.Sprintf("count could not be determined, assuming %d", e.defaultCount))
			count = e.defaultCount
		}

		instances := make([]*model.AssetInstance, count)
		for i := 0; i < count; i++ {
			addr := model.InstanceAddress(fmt.Sprintf("%s[%d]", def.Address, i))
			instances[i] = &model.AssetInstance{
				ID:           model.InstanceID(idGen.Generate(string(def.ID), fmt.Sprintf("%d", i))),
				DefinitionID: def.ID,
				Address:      addr,
				Key:          model.InstanceKey{Type: model.KeyTypeInt, IntValue: i},
				Attributes:   e.resolveAttributes(def, i, "", resolved),
			}
		}
		return instances, warnings
	}

	// Handle for_each
	if def.ForEach != nil {
		keys, known := e.resolveForEach(def.ForEach, resolved)
		if !known {
			warnings = append(warnings, "for_each could not be determined")
			return []*model.AssetInstance{}, warnings
		}

		// Sort keys for determinism
		sort.Strings(keys)

		instances := make([]*model.AssetInstance, len(keys))
		for i, key := range keys {
			addr := model.InstanceAddress(fmt.Sprintf("%s[%q]", def.Address, key))
			instances[i] = &model.AssetInstance{
				ID:           model.InstanceID(idGen.Generate(string(def.ID), key)),
				DefinitionID: def.ID,
				Address:      addr,
				Key:          model.InstanceKey{Type: model.KeyTypeString, StrValue: key},
				Attributes:   e.resolveAttributes(def, 0, key, resolved),
			}
		}
		return instances, warnings
	}

	// No expansion - single instance
	return []*model.AssetInstance{
		{
			ID:           model.InstanceID(idGen.Generate(string(def.ID))),
			DefinitionID: def.ID,
			Address:      model.InstanceAddress(def.Address),
			Key:          model.InstanceKey{Type: model.KeyTypeNone},
			Attributes:   e.resolveAttributes(def, 0, "", resolved),
		},
	}, warnings
}

func (e *Expander) resolveCount(expr *model.Expression, resolved *ResolvedModule) (int, bool) {
	if expr.IsLiteral {
		if n, ok := expr.LiteralVal.(int); ok {
			return n, true
		}
		if f, ok := expr.LiteralVal.(float64); ok {
			return int(f), true
		}
	}
	// Would need full expression evaluation
	return 0, false
}

func (e *Expander) resolveForEach(expr *model.Expression, resolved *ResolvedModule) ([]string, bool) {
	if expr.IsLiteral {
		switch v := expr.LiteralVal.(type) {
		case map[string]any:
			keys := make([]string, 0, len(v))
			for k := range v {
				keys = append(keys, k)
			}
			return keys, true
		case []any:
			keys := make([]string, len(v))
			for i, item := range v {
				if s, ok := item.(string); ok {
					keys[i] = s
				}
			}
			return keys, true
		}
	}
	return nil, false
}

func (e *Expander) resolveAttributes(def *model.AssetDefinition, countIdx int, eachKey string, resolved *ResolvedModule) map[string]model.ResolvedAttribute {
	result := make(map[string]model.ResolvedAttribute)

	for name, expr := range def.Attributes {
		// Skip meta-arguments
		if name == "count" || name == "for_each" || name == "depends_on" || name == "lifecycle" || name == "provider" {
			continue
		}

		if expr.IsLiteral {
			result[name] = model.ResolvedAttribute{
				Value:     expr.LiteralVal,
				IsUnknown: false,
			}
		} else {
			// Mark as unknown for now
			result[name] = model.ResolvedAttribute{
				IsUnknown: true,
				Reason:    model.ReasonComputedAtApply,
			}
		}
	}

	return result
}

// GraphBuilder handles Phase 5: Build
type GraphBuilder struct{}

func NewGraphBuilder() *GraphBuilder { return &GraphBuilder{} }

func (b *GraphBuilder) Build(ctx context.Context, expanded *ExpandedModule) (*model.InstanceGraph, error) {
	graph := model.NewInstanceGraph()

	// Add all instances
	for _, inst := range expanded.Instances {
		graph.AddInstance(inst)
	}

	// Build dependency edges from depends_on and references
	// This requires analyzing instance dependencies

	return graph, nil
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\provider.go
# TYPE: go
# SIZE: 6912 bytes
################################################################################
// Package terraform - Provider configuration and alias resolution
package terraform

import (
	"fmt"
	"sort"
	"strings"

	"terraform-cost/core/model"
)

// ProviderResolver handles provider configuration and alias inheritance
type ProviderResolver struct {
	// Resolved providers by key (type.alias)
	providers map[string]ProviderConfig

	// Provider inheritance chain
	inheritance map[string]string // child -> parent

	// Default regions per provider type
	defaultRegions map[string]string
}

// NewProviderResolver creates a new resolver
func NewProviderResolver() *ProviderResolver {
	return &ProviderResolver{
		providers:   make(map[string]ProviderConfig),
		inheritance: make(map[string]string),
		defaultRegions: map[string]string{
			"aws":     "us-east-1",
			"azurerm": "eastus",
			"google":  "us-central1",
		},
	}
}

// AddProvider registers a provider configuration
func (r *ProviderResolver) AddProvider(cfg ProviderConfig) {
	key := r.providerKey(cfg.Type, cfg.Alias)
	r.providers[key] = cfg
}

// SetInheritance sets up module provider inheritance
// modulePath is the child module, providerMap maps child aliases to parent aliases
func (r *ProviderResolver) SetInheritance(modulePath string, providerMap map[string]string) {
	for childAlias, parentAlias := range providerMap {
		childKey := modulePath + ":" + childAlias
		r.inheritance[childKey] = parentAlias
	}
}

// Resolve determines the provider configuration for a resource
func (r *ProviderResolver) Resolve(
	resourceType string,
	explicitProvider string,
	modulePath string,
) (model.ResolvedProvider, error) {
	// Determine provider type from resource type
	providerType := r.providerTypeFromResource(resourceType)

	// Determine provider key
	providerKey := r.determineProviderKey(providerType, explicitProvider, modulePath)

	// Look up provider
	cfg, ok := r.providers[providerKey]
	if !ok {
		// Fall back to default provider
		cfg = r.defaultProvider(providerType)
	}

	return model.ResolvedProvider{
		Type:       cfg.Type,
		Alias:      cfg.Alias,
		Region:     cfg.Region,
		Attributes: cfg.Config,
	}, nil
}

// providerTypeFromResource extracts provider type from resource type
// e.g., "aws_instance" -> "aws", "google_compute_instance" -> "google"
func (r *ProviderResolver) providerTypeFromResource(resourceType string) string {
	parts := strings.SplitN(resourceType, "_", 2)
	if len(parts) < 1 {
		return ""
	}
	return parts[0]
}

// providerKey creates a unique key for a provider
func (r *ProviderResolver) providerKey(providerType, alias string) string {
	if alias == "" {
		return providerType
	}
	return providerType + "." + alias
}

// determineProviderKey determines which provider to use
func (r *ProviderResolver) determineProviderKey(
	providerType string,
	explicitProvider string,
	modulePath string,
) string {
	// If explicit provider specified, use it
	if explicitProvider != "" {
		// Check if it needs inheritance lookup
		if modulePath != "" {
			inheritKey := modulePath + ":" + explicitProvider
			if inherited, ok := r.inheritance[inheritKey]; ok {
				return inherited
			}
		}
		return explicitProvider
	}

	// Check module-level provider inheritance
	if modulePath != "" {
		// Walk up the module tree looking for provider
		for path := modulePath; path != ""; path = r.parentModule(path) {
			inheritKey := path + ":" + providerType
			if inherited, ok := r.inheritance[inheritKey]; ok {
				return inherited
			}
		}
	}

	// Default to un-aliased provider
	return providerType
}

// parentModule returns the parent module path
func (r *ProviderResolver) parentModule(path string) string {
	parts := strings.Split(path, ".")
	if len(parts) <= 1 {
		return ""
	}
	return strings.Join(parts[:len(parts)-1], ".")
}

// defaultProvider returns a default provider config
func (r *ProviderResolver) defaultProvider(providerType string) ProviderConfig {
	region := r.defaultRegions[providerType]
	if region == "" {
		region = "us-east-1" // Fallback
	}
	return ProviderConfig{
		Type:   providerType,
		Alias:  "",
		Region: region,
		Config: map[string]any{},
	}
}

// ResolveAllProviders resolves providers for all instances
func (r *ProviderResolver) ResolveAllProviders(
	instances []*model.AssetInstance,
	definitions map[model.DefinitionID]*model.AssetDefinition,
) error {
	for _, inst := range instances {
		def := definitions[inst.DefinitionID]
		if def == nil {
			continue
		}

		// Get explicit provider from definition
		explicitProvider := ""
		if provAttr, ok := def.Attributes["provider"]; ok && provAttr.IsLiteral {
			if s, ok := provAttr.LiteralVal.(string); ok {
				explicitProvider = s
			}
		}

		// Extract module path from address
		modulePath := r.modulePathFromAddress(string(def.Address))

		// Resolve provider
		resolved, err := r.Resolve(string(def.Type), explicitProvider, modulePath)
		if err != nil {
			return fmt.Errorf("failed to resolve provider for %s: %w", inst.Address, err)
		}

		inst.Provider = resolved
	}

	return nil
}

// modulePathFromAddress extracts module path from resource address
// e.g., "module.foo.module.bar.aws_instance.web" -> "module.foo.module.bar"
func (r *ProviderResolver) modulePathFromAddress(addr string) string {
	parts := strings.Split(addr, ".")
	var moduleParts []string

	for i := 0; i < len(parts)-2; i += 2 {
		if parts[i] == "module" {
			moduleParts = append(moduleParts, "module."+parts[i+1])
		} else {
			break
		}
	}

	return strings.Join(moduleParts, ".")
}

// Providers returns all registered providers in sorted order
func (r *ProviderResolver) Providers() []ProviderConfig {
	keys := make([]string, 0, len(r.providers))
	for k := range r.providers {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	result := make([]ProviderConfig, len(keys))
	for i, k := range keys {
		result[i] = r.providers[k]
	}
	return result
}

// ExtractRegion extracts region from provider config or resource attributes
func (r *ProviderResolver) ExtractRegion(
	inst *model.AssetInstance,
	def *model.AssetDefinition,
) string {
	// First check instance provider
	if inst.Provider.Region != "" {
		return inst.Provider.Region
	}

	// Check resource attributes for region
	if regionAttr, ok := inst.Attributes["region"]; ok && !regionAttr.IsUnknown {
		if s, ok := regionAttr.Value.(string); ok {
			return s
		}
	}

	// Check availability_zone and derive region
	if azAttr, ok := inst.Attributes["availability_zone"]; ok && !azAttr.IsUnknown {
		if s, ok := azAttr.Value.(string); ok {
			// Remove the AZ suffix (e.g., "us-east-1a" -> "us-east-1")
			if len(s) > 1 {
				return s[:len(s)-1]
			}
		}
	}

	// Fall back to provider default
	return r.defaultRegions[inst.Provider.Type]
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\provider_binding.go
# TYPE: go
# SIZE: 8428 bytes
################################################################################
// Package terraform - Module provider binding resolution
// Provider aliases MUST propagate correctly through module boundaries.
package terraform

import (
	"fmt"
	"strings"
)

// ModuleProviderBinding represents how providers are passed to modules
type ModuleProviderBinding struct {
	// Module path (e.g., "module.vpc.module.subnet")
	ModulePath string

	// Provider mappings from parent to child
	// Key: local provider name in module (e.g., "aws")
	// Value: parent provider reference (e.g., "aws.us_east")
	Bindings map[string]string

	// Explicit providers block in module call
	ExplicitProviders map[string]string

	// Inherited from parent (not explicitly set)
	InheritedProviders map[string]string
}

// ModuleProviderResolver resolves provider bindings through module chains
type ModuleProviderResolver struct {
	// Root provider configs
	rootProviders map[string]*ProviderConfig

	// Per-module bindings
	moduleBindings map[string]*ModuleProviderBinding

	// Resolved cache
	resolvedCache map[string]*ProviderContext
}

// NewModuleProviderResolver creates a resolver
func NewModuleProviderResolver() *ModuleProviderResolver {
	return &ModuleProviderResolver{
		rootProviders:  make(map[string]*ProviderConfig),
		moduleBindings: make(map[string]*ModuleProviderBinding),
		resolvedCache:  make(map[string]*ProviderContext),
	}
}

// RegisterRootProvider registers a provider at root level
func (r *ModuleProviderResolver) RegisterRootProvider(config *ProviderConfig) {
	key := config.Type
	if config.Alias != "" {
		key = config.Type + "." + config.Alias
	}
	r.rootProviders[key] = config
}

// RegisterModuleCall registers a module call with its provider mappings
func (r *ModuleProviderResolver) RegisterModuleCall(parentPath, moduleName string, providers map[string]string) {
	childPath := moduleName
	if parentPath != "" {
		childPath = parentPath + "." + moduleName
	}

	binding := &ModuleProviderBinding{
		ModulePath:         childPath,
		Bindings:           make(map[string]string),
		ExplicitProviders:  providers,
		InheritedProviders: make(map[string]string),
	}

	// Process explicit providers
	for localName, parentRef := range providers {
		binding.Bindings[localName] = parentRef
	}

	r.moduleBindings[childPath] = binding
}

// ResolveProvider resolves the exact provider config for a resource
// Following Terraform's provider inheritance rules exactly
func (r *ModuleProviderResolver) ResolveProvider(modulePath, resourceType, explicitProvider string) (*ProviderContext, error) {
	// Cache key
	cacheKey := fmt.Sprintf("%s::%s::%s", modulePath, resourceType, explicitProvider)
	if cached, ok := r.resolvedCache[cacheKey]; ok {
		return cached, nil
	}

	// Extract provider type from resource
	providerType := extractProviderTypeFromResource(resourceType)

	// Determine which provider reference to resolve
	providerRef := providerType // default
	if explicitProvider != "" {
		providerRef = explicitProvider
	}

	// Resolve through module chain
	ctx, err := r.resolveProviderThroughChain(modulePath, providerRef, providerType)
	if err != nil {
		return nil, err
	}

	r.resolvedCache[cacheKey] = ctx
	return ctx, nil
}

// resolveProviderThroughChain walks the module chain to find the actual provider
func (r *ModuleProviderResolver) resolveProviderThroughChain(modulePath, providerRef, providerType string) (*ProviderContext, error) {
	// If at root, resolve directly
	if modulePath == "" {
		return r.resolveAtRoot(providerRef)
	}

	// Check if this module has explicit binding for this provider
	binding := r.moduleBindings[modulePath]

	// Extract just the provider name without alias for matching
	baseProviderName := providerType
	if idx := strings.Index(providerRef, "."); idx != -1 {
		baseProviderName = providerRef[:idx]
	}

	if binding != nil {
		// Check explicit providers first
		if parentRef, ok := binding.ExplicitProviders[baseProviderName]; ok {
			// This module maps this provider to a parent provider
			// Recurse to parent to resolve the actual config
			parentPath := getParentPath(modulePath)
			resolved, err := r.resolveProviderThroughChain(parentPath, parentRef, providerType)
			if err != nil {
				return nil, err
			}
			// Mark as inherited
			resolved.IsInherited = true
			resolved.DefinedInModule = parentPath
			return resolved, nil
		}

		// Check all bindings
		if parentRef, ok := binding.Bindings[providerRef]; ok {
			parentPath := getParentPath(modulePath)
			resolved, err := r.resolveProviderThroughChain(parentPath, parentRef, providerType)
			if err != nil {
				return nil, err
			}
			resolved.IsInherited = true
			return resolved, nil
		}
	}

	// No explicit binding - inherit from parent
	parentPath := getParentPath(modulePath)
	resolved, err := r.resolveProviderThroughChain(parentPath, providerRef, providerType)
	if err != nil {
		return nil, err
	}
	resolved.IsInherited = true
	return resolved, nil
}

// resolveAtRoot resolves a provider at the root module
func (r *ModuleProviderResolver) resolveAtRoot(providerRef string) (*ProviderContext, error) {
	// Look for exact match
	if config, ok := r.rootProviders[providerRef]; ok {
		return &ProviderContext{
			ProviderType:    config.Type,
			Alias:           config.Alias,
			Region:          config.Region,
			IsInherited:     false,
			DefinedInModule: "",
			FullAddress:     providerRef,
			Config:          config.Config,
		}, nil
	}

	// Try without alias (default provider)
	providerType := providerRef
	if idx := strings.Index(providerRef, "."); idx != -1 {
		providerType = providerRef[:idx]
	}

	if config, ok := r.rootProviders[providerType]; ok {
		return &ProviderContext{
			ProviderType:    config.Type,
			Alias:           config.Alias,
			Region:          config.Region,
			IsInherited:     false,
			DefinedInModule: "",
			FullAddress:     providerRef,
			Config:          config.Config,
		}, nil
	}

	// No provider found - return error, not a guess
	return nil, &ProviderNotFoundError{
		ProviderRef: providerRef,
		ModulePath:  "",
	}
}

// ProviderNotFoundError indicates a provider could not be resolved
type ProviderNotFoundError struct {
	ProviderRef string
	ModulePath  string
}

func (e *ProviderNotFoundError) Error() string {
	if e.ModulePath == "" {
		return fmt.Sprintf("provider %q not found in root module", e.ProviderRef)
	}
	return fmt.Sprintf("provider %q not found for module %q", e.ProviderRef, e.ModulePath)
}

func extractProviderTypeFromResource(resourceType string) string {
	if idx := strings.Index(resourceType, "_"); idx != -1 {
		return resourceType[:idx]
	}
	return resourceType
}

func getParentPath(modulePath string) string {
	if idx := strings.LastIndex(modulePath, "."); idx != -1 {
		return modulePath[:idx]
	}
	return ""
}

// ProviderBindingValidator validates that all resources have valid provider bindings
type ProviderBindingValidator struct {
	resolver *ModuleProviderResolver
	errors   []ProviderBindingError
}

// ProviderBindingError is a provider resolution error
type ProviderBindingError struct {
	ResourceAddress string
	ModulePath      string
	ProviderRef     string
	Reason          string
}

// NewProviderBindingValidator creates a validator
func NewProviderBindingValidator(resolver *ModuleProviderResolver) *ProviderBindingValidator {
	return &ProviderBindingValidator{
		resolver: resolver,
		errors:   []ProviderBindingError{},
	}
}

// Validate ensures all resources in a module have valid provider bindings
func (v *ProviderBindingValidator) Validate(resources []ResourceWithProvider) []ProviderBindingError {
	v.errors = []ProviderBindingError{}

	for _, res := range resources {
		_, err := v.resolver.ResolveProvider(res.ModulePath, res.ResourceType, res.ExplicitProvider)
		if err != nil {
			v.errors = append(v.errors, ProviderBindingError{
				ResourceAddress: res.Address,
				ModulePath:      res.ModulePath,
				ProviderRef:     res.ExplicitProvider,
				Reason:          err.Error(),
			})
		}
	}

	return v.errors
}

// ResourceWithProvider is a resource that needs provider resolution
type ResourceWithProvider struct {
	Address          string
	ModulePath       string
	ResourceType     string
	ExplicitProvider string
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\provider_context.go
# TYPE: go
# SIZE: 7293 bytes
################################################################################
// Package terraform - Provider context propagation
// Each instance MUST know exactly which provider config applies.
package terraform

import (
	"fmt"
	"strings"

	"terraform-cost/core/types"
)

// ProviderContext represents the resolved provider configuration for a resource
type ProviderContext struct {
	// Provider type (aws, google, azurerm)
	ProviderType string

	// Alias (empty for default)
	Alias string

	// Resolved region
	Region string

	// Is this inherited from module?
	IsInherited bool

	// Module path where this was defined
	DefinedInModule string

	// Full provider address
	FullAddress string

	// Additional configuration
	Config map[string]interface{}
}

// ProviderKey returns a unique key for this provider
func (p *ProviderContext) ProviderKey() string {
	if p.Alias == "" {
		return p.ProviderType
	}
	return p.ProviderType + "." + p.Alias
}

// ProviderRegistry tracks all provider configurations
type ProviderRegistry struct {
	// Provider configs by module path + alias
	configs map[string]*ProviderConfig

	// Default providers per type
	defaults map[string]*ProviderConfig

	// Module provider mappings (providers = { aws = aws.west })
	moduleMappings map[string]map[string]string
}

// ProviderConfig is defined in pipeline.go - using that definition

// NewProviderRegistry creates a new registry
func NewProviderRegistry() *ProviderRegistry {
	return &ProviderRegistry{
		configs:        make(map[string]*ProviderConfig),
		defaults:       make(map[string]*ProviderConfig),
		moduleMappings: make(map[string]map[string]string),
	}
}

// RegisterProvider registers a provider configuration
func (r *ProviderRegistry) RegisterProvider(modulePath string, config *ProviderConfig) {
	key := r.makeKey(modulePath, config.Type, config.Alias)
	r.configs[key] = config

	// Track default if no alias
	if config.Alias == "" {
		defaultKey := r.makeKey(modulePath, config.Type, "")
		r.defaults[defaultKey] = config
	}
}

// RegisterModuleMapping registers a module's provider mapping
func (r *ProviderRegistry) RegisterModuleMapping(modulePath string, mappings map[string]string) {
	r.moduleMappings[modulePath] = mappings
}

// ResolveForResource resolves the provider context for a resource
func (r *ProviderRegistry) ResolveForResource(modulePath, resourceType, providerAttr string) *ProviderContext {
	// Determine provider type from resource type
	providerType := r.extractProviderType(resourceType)

	// Check if resource has explicit provider attribute
	if providerAttr != "" {
		return r.resolveExplicitProvider(modulePath, providerAttr)
	}

	// Check module mappings
	if mapping, ok := r.moduleMappings[modulePath]; ok {
		if mapped, exists := mapping[providerType]; exists {
			return r.resolveExplicitProvider(modulePath, mapped)
		}
	}

	// Look for default provider in current module chain
	return r.resolveDefaultProvider(modulePath, providerType)
}

func (r *ProviderRegistry) resolveExplicitProvider(modulePath, providerRef string) *ProviderContext {
	// Parse provider reference (e.g., "aws.west")
	parts := strings.SplitN(providerRef, ".", 2)
	providerType := parts[0]
	alias := ""
	if len(parts) > 1 {
		alias = parts[1]
	}

	// Search from current module up to root
	currentPath := modulePath
	for {
		key := r.makeKey(currentPath, providerType, alias)
		if config, ok := r.configs[key]; ok {
			return &ProviderContext{
				ProviderType:    providerType,
				Alias:           alias,
				Region:          config.Region,
				IsInherited:     currentPath != modulePath,
				DefinedInModule: currentPath,
				FullAddress:     providerRef,
				Config:          config.Config,
			}
		}

		// Move up one module level
		if currentPath == "" {
			break
		}
		lastDot := strings.LastIndex(currentPath, ".")
		if lastDot == -1 {
			currentPath = ""
		} else {
			currentPath = currentPath[:lastDot]
		}
	}

	// Provider not found - return unknown context
	return &ProviderContext{
		ProviderType: providerType,
		Alias:        alias,
		Region:       "", // UNKNOWN - will need to be resolved or flagged
		FullAddress:  providerRef,
	}
}

func (r *ProviderRegistry) resolveDefaultProvider(modulePath, providerType string) *ProviderContext {
	// Search from current module up to root for default provider
	currentPath := modulePath
	for {
		key := r.makeKey(currentPath, providerType, "")
		if config, ok := r.defaults[key]; ok {
			return &ProviderContext{
				ProviderType:    providerType,
				Alias:           "",
				Region:          config.Region,
				IsInherited:     currentPath != modulePath,
				DefinedInModule: currentPath,
				FullAddress:     providerType,
				Config:          config.Config,
			}
		}

		// Move up one module level
		if currentPath == "" {
			break
		}
		lastDot := strings.LastIndex(currentPath, ".")
		if lastDot == -1 {
			currentPath = ""
		} else {
			currentPath = currentPath[:lastDot]
		}
	}

	// No provider found - use defaults
	return r.createDefaultContext(providerType)
}

func (r *ProviderRegistry) createDefaultContext(providerType string) *ProviderContext {
	// Default regions per provider
	defaultRegions := map[string]string{
		"aws":      "us-east-1",
		"google":   "us-central1",
		"azurerm":  "eastus",
	}

	region := defaultRegions[providerType]
	if region == "" {
		region = "unknown"
	}

	return &ProviderContext{
		ProviderType: providerType,
		Alias:        "",
		Region:       region,
		IsInherited:  false,
		FullAddress:  providerType,
	}
}

func (r *ProviderRegistry) extractProviderType(resourceType string) string {
	// aws_instance -> aws
	// google_compute_instance -> google
	// azurerm_virtual_machine -> azurerm
	idx := strings.Index(resourceType, "_")
	if idx == -1 {
		return resourceType
	}
	return resourceType[:idx]
}

func (r *ProviderRegistry) makeKey(modulePath, providerType, alias string) string {
	if alias != "" {
		return fmt.Sprintf("%s::%s.%s", modulePath, providerType, alias)
	}
	return fmt.Sprintf("%s::%s", modulePath, providerType)
}

// InstanceWithProvider binds an instance to its provider context
type InstanceWithProvider struct {
	InstanceAddress string
	InstanceKey     interface{}
	ProviderCtx     *ProviderContext // Resolved provider context

	// For cost estimation
	PricingRegion   types.Region   // Region for pricing lookups
	PricingProvider types.Provider // Provider for pricing lookups
}

// ResolveRegionForPricing returns the region to use for pricing lookups
func (i *InstanceWithProvider) ResolveRegionForPricing() types.Region {
	if i.ProviderCtx == nil || i.ProviderCtx.Region == "" {
		return types.Region("us-east-1") // Fallback
	}
	return types.Region(i.ProviderCtx.Region)
}

// GetPricingProvider returns the provider for pricing lookups
func (i *InstanceWithProvider) GetPricingProvider() types.Provider {
	if i.ProviderCtx == nil {
		return types.ProviderUnknown
	}
	switch i.ProviderCtx.ProviderType {
	case "aws":
		return types.ProviderAWS
	case "google":
		return types.ProviderGCP
	case "azurerm":
		return types.ProviderAzure
	default:
		return types.ProviderUnknown
	}
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\provider_finalization.go
# TYPE: go
# SIZE: 7253 bytes
################################################################################
// Package terraform - Provider alias finalization
// Provider context MUST be frozen before pricing resolution.
// Alias + region + account is a first-class dimension.
package terraform

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
)

// FrozenProviderContext is an immutable provider binding
type FrozenProviderContext struct {
	// Canonical identity
	ProviderKey string // e.g., "aws.us_east"

	// Provider details
	Type   string
	Alias  string
	Region string

	// Account context
	AccountID string
	AssumeRole string

	// Content hash (immutable)
	ContentHash string

	// Is this frozen?
	frozen bool
}

// Freeze creates an immutable copy
func (p *ProviderContext) Freeze() *FrozenProviderContext {
	frozen := &FrozenProviderContext{
		ProviderKey: p.ProviderKey(),
		Type:        p.ProviderType,
		Alias:       p.Alias,
		Region:      p.Region,
		frozen:      true,
	}

	// Extract account from config if present
	if p.Config != nil {
		if accountID, ok := p.Config["account_id"].(string); ok {
			frozen.AccountID = accountID
		}
		if roleArn, ok := p.Config["assume_role"].(string); ok {
			frozen.AssumeRole = roleArn
		}
	}

	// Compute content hash
	frozen.ContentHash = frozen.computeHash()

	return frozen
}

func (f *FrozenProviderContext) computeHash() string {
	h := sha256.New()
	h.Write([]byte(f.Type))
	h.Write([]byte(f.Alias))
	h.Write([]byte(f.Region))
	h.Write([]byte(f.AccountID))
	h.Write([]byte(f.AssumeRole))
	return hex.EncodeToString(h.Sum(nil))[:12]
}

// RateKey returns the key for pricing lookup
func (f *FrozenProviderContext) RateKey(resourceType, sku string) string {
	// Format: provider:region:type:sku
	return fmt.Sprintf("%s:%s:%s:%s", f.Type, f.Region, resourceType, sku)
}

// PricingDimension returns all dimensions for pricing
func (f *FrozenProviderContext) PricingDimension() PricingDimension {
	return PricingDimension{
		Provider:  f.Type,
		Region:    f.Region,
		AccountID: f.AccountID,
		Alias:     f.Alias,
	}
}

// PricingDimension contains all provider dimensions for pricing
type PricingDimension struct {
	Provider  string
	Region    string
	AccountID string
	Alias     string
}

// Key returns a unique key for this dimension
func (d PricingDimension) Key() string {
	if d.AccountID != "" {
		return fmt.Sprintf("%s:%s:%s", d.Provider, d.Region, d.AccountID)
	}
	return fmt.Sprintf("%s:%s", d.Provider, d.Region)
}

// ProviderFinalizer ensures providers are frozen before use
type ProviderFinalizer struct {
	// All frozen providers
	frozen map[string]*FrozenProviderContext

	// Finalization order
	order []string

	// Is finalization complete?
	finalized bool
}

// NewProviderFinalizer creates a finalizer
func NewProviderFinalizer() *ProviderFinalizer {
	return &ProviderFinalizer{
		frozen:    make(map[string]*FrozenProviderContext),
		order:     []string{},
		finalized: false,
	}
}

// Freeze freezes a provider context
func (pf *ProviderFinalizer) Freeze(ctx *ProviderContext) (*FrozenProviderContext, error) {
	if pf.finalized {
		return nil, fmt.Errorf("provider finalization already complete")
	}

	frozen := ctx.Freeze()
	pf.frozen[frozen.ProviderKey] = frozen
	pf.order = append(pf.order, frozen.ProviderKey)

	return frozen, nil
}

// Finalize marks finalization complete - no more providers can be added
func (pf *ProviderFinalizer) Finalize() {
	pf.finalized = true
}

// Get returns a frozen provider
func (pf *ProviderFinalizer) Get(key string) (*FrozenProviderContext, bool) {
	frozen, ok := pf.frozen[key]
	return frozen, ok
}

// MustGet returns a frozen provider or panics
func (pf *ProviderFinalizer) MustGet(key string) *FrozenProviderContext {
	frozen, ok := pf.frozen[key]
	if !ok {
		panic(fmt.Sprintf("provider %s not frozen", key))
	}
	return frozen
}

// All returns all frozen providers
func (pf *ProviderFinalizer) All() []*FrozenProviderContext {
	result := make([]*FrozenProviderContext, 0, len(pf.frozen))
	for _, key := range pf.order {
		result = append(result, pf.frozen[key])
	}
	return result
}

// IsFinalized returns true if finalization is complete
func (pf *ProviderFinalizer) IsFinalized() bool {
	return pf.finalized
}

// InstanceProviderBinding binds an instance to its frozen provider
type InstanceProviderBinding struct {
	InstanceAddress string
	InstanceKey     interface{}
	Provider        *FrozenProviderContext
	BoundAt         string // When binding was established
}

// BindingRegistry tracks all instance-provider bindings
type BindingRegistry struct {
	bindings map[string]*InstanceProviderBinding
}

// NewBindingRegistry creates a registry
func NewBindingRegistry() *BindingRegistry {
	return &BindingRegistry{
		bindings: make(map[string]*InstanceProviderBinding),
	}
}

// Bind binds an instance to a provider
func (r *BindingRegistry) Bind(address string, key interface{}, provider *FrozenProviderContext) {
	r.bindings[address] = &InstanceProviderBinding{
		InstanceAddress: address,
		InstanceKey:     key,
		Provider:        provider,
		BoundAt:         "expansion",
	}
}

// Get returns the binding for an instance
func (r *BindingRegistry) Get(address string) (*InstanceProviderBinding, bool) {
	binding, ok := r.bindings[address]
	return binding, ok
}

// MustGet returns the binding or panics
func (r *BindingRegistry) MustGet(address string) *InstanceProviderBinding {
	binding, ok := r.bindings[address]
	if !ok {
		panic(fmt.Sprintf("no provider binding for %s", address))
	}
	return binding
}

// EnsureBound verifies an instance is bound before pricing
func (r *BindingRegistry) EnsureBound(address string) error {
	if _, ok := r.bindings[address]; !ok {
		return &UnboundInstanceError{Address: address}
	}
	return nil
}

// UnboundInstanceError indicates an instance has no provider binding
type UnboundInstanceError struct {
	Address string
}

func (e *UnboundInstanceError) Error() string {
	return fmt.Sprintf("instance %s has no provider binding - cannot price", e.Address)
}

// ProviderPricingGate ensures pricing only happens after provider finalization
type ProviderPricingGate struct {
	finalizer *ProviderFinalizer
	registry  *BindingRegistry
}

// NewProviderPricingGate creates a gate
func NewProviderPricingGate(finalizer *ProviderFinalizer, registry *BindingRegistry) *ProviderPricingGate {
	return &ProviderPricingGate{
		finalizer: finalizer,
		registry:  registry,
	}
}

// CanPrice checks if pricing is allowed for an instance
func (g *ProviderPricingGate) CanPrice(address string) error {
	// Check finalization
	if !g.finalizer.IsFinalized() {
		return fmt.Errorf("provider finalization not complete - cannot price %s", address)
	}

	// Check binding
	return g.registry.EnsureBound(address)
}

// GetPricingDimension returns the pricing dimension for an instance
func (g *ProviderPricingGate) GetPricingDimension(address string) (*PricingDimension, error) {
	if err := g.CanPrice(address); err != nil {
		return nil, err
	}

	binding := g.registry.MustGet(address)
	dim := binding.Provider.PricingDimension()
	return &dim, nil
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\safe_expansion.go
# TYPE: go
# SIZE: 8907 bytes
################################################################################
// Package terraform - Safe for_each handling
// When for_each keys are unknown: DO NOT EXPAND.
// Replace with symbolic range, surface warning, block in strict mode.
package terraform

import (
	"fmt"
)

// ForEachResult represents the result of for_each evaluation
type ForEachResult struct {
	// Is the for_each value known?
	IsKnown bool

	// Keys if known
	Keys []string

	// If unknown, symbolic range
	SymbolicRange *SymbolicRange

	// Warning to surface
	Warning string

	// Block estimation in strict mode?
	BlocksEstimation bool
}

// SymbolicRange represents an unknown cardinality
type SymbolicRange struct {
	// Minimum instances (conservative)
	Min int

	// Maximum instances (if bounded, -1 for unbounded)
	Max int

	// Expression that could not be evaluated
	Expression string

	// References that caused unknown
	UnknownReferences []string

	// Confidence impact
	ConfidenceImpact float64
}

// SafeForEachEvaluator evaluates for_each safely
type SafeForEachEvaluator struct {
	mode           EvaluationMode
	enforcer       *StrictModeEnforcer
	unknownHandler UnknownForEachHandler
}

// UnknownForEachHandler defines how to handle unknown for_each
type UnknownForEachHandler int

const (
	// HandlerBlock blocks estimation
	HandlerBlock UnknownForEachHandler = iota

	// HandlerSymbolic uses symbolic range
	HandlerSymbolic

	// HandlerMinimum uses minimum assumption (0 or 1)
	HandlerMinimum
)

// NewSafeForEachEvaluator creates an evaluator
func NewSafeForEachEvaluator(mode EvaluationMode) *SafeForEachEvaluator {
	handler := HandlerSymbolic
	if mode == ModeStrict {
		handler = HandlerBlock
	}

	return &SafeForEachEvaluator{
		mode:           mode,
		enforcer:       NewStrictModeEnforcer(mode),
		unknownHandler: handler,
	}
}

// Evaluate evaluates a for_each expression
func (e *SafeForEachEvaluator) Evaluate(address string, expr *ExpressionValue) *ForEachResult {
	result := &ForEachResult{
		IsKnown:          false,
		Keys:             []string{},
		BlocksEstimation: false,
	}

	// If expression is known, extract keys
	if expr != nil && expr.IsKnown {
		result.IsKnown = true
		result.Keys = extractForEachKeys(expr.Value)
		return result
	}

	// Unknown for_each - handle according to mode
	result.IsKnown = false

	// Check for blocking conditions
	if e.mode == ModeStrict {
		result.BlocksEstimation = true
		result.Warning = fmt.Sprintf("for_each at %s is unknown - blocking estimation in strict mode", address)
		return result
	}

	// Create symbolic range
	result.SymbolicRange = e.createSymbolicRange(address, expr)
	result.Warning = fmt.Sprintf(
		"for_each at %s has unknown cardinality (estimated %d-%d instances)",
		address, result.SymbolicRange.Min, result.SymbolicRange.Max,
	)

	return result
}

func (e *SafeForEachEvaluator) createSymbolicRange(address string, expr *ExpressionValue) *SymbolicRange {
	sr := &SymbolicRange{
		Min:              0,
		Max:              -1, // Unbounded
		ConfidenceImpact: 0.5,
	}

	if expr != nil {
		sr.Expression = expr.Expression
		sr.UnknownReferences = expr.References
	}

	// Infer bounds from expression type if possible
	if expr != nil && len(expr.References) > 0 {
		for _, ref := range expr.References {
			sr.UnknownReferences = append(sr.UnknownReferences, ref)

			// Data source references are fully unknown
			if isDataSourceRef(ref) {
				sr.Min = 0
				sr.Max = -1
				sr.ConfidenceImpact = 0.6
				continue
			}

			// Variable references might have bounds
			if isVariableRef(ref) {
				sr.Min = 1
				sr.Max = 10 // Conservative assumption
				sr.ConfidenceImpact = 0.4
			}
		}
	}

	return sr
}

func extractForEachKeys(value interface{}) []string {
	switch v := value.(type) {
	case map[string]interface{}:
		keys := make([]string, 0, len(v))
		for k := range v {
			keys = append(keys, k)
		}
		return keys
	case []interface{}:
		keys := make([]string, 0, len(v))
		for _, item := range v {
			if s, ok := item.(string); ok {
				keys = append(keys, s)
			}
		}
		return keys
	case []string:
		return v
	default:
		return []string{}
	}
}

func isDataSourceRef(ref string) bool {
	return len(ref) >= 5 && ref[:5] == "data."
}

func isVariableRef(ref string) bool {
	return len(ref) >= 4 && ref[:4] == "var."
}

// SafeCountEvaluator evaluates count safely
type SafeCountEvaluator struct {
	mode     EvaluationMode
	enforcer *StrictModeEnforcer
}

// CountResult represents the result of count evaluation
type CountResult struct {
	IsKnown          bool
	Value            int
	SymbolicRange    *SymbolicRange
	Warning          string
	BlocksEstimation bool
}

// NewSafeCountEvaluator creates an evaluator
func NewSafeCountEvaluator(mode EvaluationMode) *SafeCountEvaluator {
	return &SafeCountEvaluator{
		mode:     mode,
		enforcer: NewStrictModeEnforcer(mode),
	}
}

// Evaluate evaluates a count expression
func (e *SafeCountEvaluator) Evaluate(address string, expr *ExpressionValue) *CountResult {
	result := &CountResult{
		IsKnown:          false,
		Value:            0,
		BlocksEstimation: false,
	}

	// If expression is known, extract value
	if expr != nil && expr.IsKnown {
		result.IsKnown = true
		result.Value = extractCountValue(expr.Value)
		return result
	}

	// Unknown count
	if e.mode == ModeStrict {
		result.BlocksEstimation = true
		result.Warning = fmt.Sprintf("count at %s is unknown - blocking estimation in strict mode", address)
		return result
	}

	// Create symbolic range
	result.SymbolicRange = e.inferCountRange(address, expr)
	result.Warning = fmt.Sprintf(
		"count at %s has unknown value (estimated %d-%d instances)",
		address, result.SymbolicRange.Min, result.SymbolicRange.Max,
	)

	// Use minimum for estimation
	result.Value = result.SymbolicRange.Min

	return result
}

func (e *SafeCountEvaluator) inferCountRange(address string, expr *ExpressionValue) *SymbolicRange {
	sr := &SymbolicRange{
		Min:              0,
		Max:              10, // Conservative upper bound
		ConfidenceImpact: 0.4,
	}

	if expr != nil {
		sr.Expression = expr.Expression
		sr.UnknownReferences = expr.References

		// Check for common patterns
		if containsLengthCall(expr.Expression) {
			sr.Min = 0
			sr.Max = 20
			sr.ConfidenceImpact = 0.45
		}

		if containsConditional(expr.Expression) {
			sr.Min = 0
			sr.Max = 1
			sr.ConfidenceImpact = 0.3
		}
	}

	return sr
}

func extractCountValue(value interface{}) int {
	switch v := value.(type) {
	case int:
		return v
	case int64:
		return int(v)
	case float64:
		return int(v)
	default:
		return 1
	}
}

func containsLengthCall(expr string) bool {
	return len(expr) >= 6 && (contains(expr, "length(") || contains(expr, "len("))
}

func containsConditional(expr string) bool {
	return contains(expr, "?") || contains(expr, "if ")
}

func contains(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}

// CardinalityWarning is a warning about unknown cardinality
type CardinalityWarning struct {
	Address          string
	Type             string // "count" or "for_each"
	Expression       string
	SymbolicRange    *SymbolicRange
	Message          string
	BlocksEstimation bool
}

// CardinalityWarnings collects cardinality warnings
type CardinalityWarnings struct {
	warnings []CardinalityWarning
}

// NewCardinalityWarnings creates a collector
func NewCardinalityWarnings() *CardinalityWarnings {
	return &CardinalityWarnings{
		warnings: []CardinalityWarning{},
	}
}

// AddForEach adds a for_each warning
func (w *CardinalityWarnings) AddForEach(address string, result *ForEachResult) {
	if result.IsKnown {
		return
	}
	w.warnings = append(w.warnings, CardinalityWarning{
		Address:          address,
		Type:             "for_each",
		SymbolicRange:    result.SymbolicRange,
		Message:          result.Warning,
		BlocksEstimation: result.BlocksEstimation,
	})
}

// AddCount adds a count warning
func (w *CardinalityWarnings) AddCount(address string, result *CountResult) {
	if result.IsKnown {
		return
	}
	w.warnings = append(w.warnings, CardinalityWarning{
		Address:          address,
		Type:             "count",
		SymbolicRange:    result.SymbolicRange,
		Message:          result.Warning,
		BlocksEstimation: result.BlocksEstimation,
	})
}

// All returns all warnings
func (w *CardinalityWarnings) All() []CardinalityWarning {
	return w.warnings
}

// HasBlocking returns true if any warning blocks estimation
func (w *CardinalityWarnings) HasBlocking() bool {
	for _, warn := range w.warnings {
		if warn.BlocksEstimation {
			return true
		}
	}
	return false
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\strict_mode.go
# TYPE: go
# SIZE: 8967 bytes
################################################################################
// Package terraform - Strict evaluation modes
// STRICT: block on unsafe unknowns
// PERMISSIVE: allow but degrade confidence
// ESTIMATE: best-effort (current behavior)
package terraform

import (
	"errors"
	"fmt"
)

// EvaluationMode controls how strictly unknowns are handled
type EvaluationMode int

const (
	// ModeEstimate - best effort, may guess (current default)
	ModeEstimate EvaluationMode = iota

	// ModePermissive - allows unknowns but degrades confidence
	ModePermissive

	// ModeStrict - blocks estimation on unsafe unknowns
	ModeStrict
)

// String returns the mode name
func (m EvaluationMode) String() string {
	switch m {
	case ModeEstimate:
		return "estimate"
	case ModePermissive:
		return "permissive"
	case ModeStrict:
		return "strict"
	default:
		return "unknown"
	}
}

// EvaluationModeFromString parses a mode string
func EvaluationModeFromString(s string) (EvaluationMode, error) {
	switch s {
	case "estimate", "":
		return ModeEstimate, nil
	case "permissive":
		return ModePermissive, nil
	case "strict":
		return ModeStrict, nil
	default:
		return ModeEstimate, fmt.Errorf("unknown evaluation mode: %s", s)
	}
}

// StrictModeEnforcer enforces strict mode rules
type StrictModeEnforcer struct {
	mode    EvaluationMode
	errors  []StrictModeError
	blocked bool
}

// StrictModeError is an error from strict mode enforcement
type StrictModeError struct {
	Address   string
	Attribute string
	Reason    string
	Category  ErrorCategory
	Blocking  bool // Does this error block estimation?
}

// ErrorCategory classifies the type of error
type ErrorCategory int

const (
	ErrorUnknownCount              ErrorCategory = iota // count is unknown
	ErrorUnknownForEach                                  // for_each is unknown
	ErrorUnknownProvider                                 // provider config unknown
	ErrorUnknownUsage                                    // usage value unknown
	ErrorDataSourceReference                             // data source in blocking position
	ErrorCircularDependency                              // cycle detected
	ErrorMissingRate                                     // no pricing rate found
	ErrorInvalidType                                     // type mismatch
)

// String returns the category name
func (c ErrorCategory) String() string {
	switch c {
	case ErrorUnknownCount:
		return "unknown_count"
	case ErrorUnknownForEach:
		return "unknown_for_each"
	case ErrorUnknownProvider:
		return "unknown_provider"
	case ErrorUnknownUsage:
		return "unknown_usage"
	case ErrorDataSourceReference:
		return "data_source_reference"
	case ErrorCircularDependency:
		return "circular_dependency"
	case ErrorMissingRate:
		return "missing_rate"
	case ErrorInvalidType:
		return "invalid_type"
	default:
		return "unknown"
	}
}

// NewStrictModeEnforcer creates an enforcer for the given mode
func NewStrictModeEnforcer(mode EvaluationMode) *StrictModeEnforcer {
	return &StrictModeEnforcer{
		mode:    mode,
		errors:  []StrictModeError{},
		blocked: false,
	}
}

// CheckUnknownCount checks if unknown count should block
func (e *StrictModeEnforcer) CheckUnknownCount(address string, reason string) error {
	err := StrictModeError{
		Address:  address,
		Reason:   reason,
		Category: ErrorUnknownCount,
		Blocking: e.mode == ModeStrict,
	}
	e.errors = append(e.errors, err)

	if e.mode == ModeStrict {
		e.blocked = true
		return &BlockedEstimationError{
			Address: address,
			Reason:  "unknown count blocks estimation in strict mode",
		}
	}
	return nil
}

// CheckUnknownForEach checks if unknown for_each should block
func (e *StrictModeEnforcer) CheckUnknownForEach(address string, reason string) error {
	err := StrictModeError{
		Address:  address,
		Reason:   reason,
		Category: ErrorUnknownForEach,
		Blocking: e.mode == ModeStrict,
	}
	e.errors = append(e.errors, err)

	if e.mode == ModeStrict {
		e.blocked = true
		return &BlockedEstimationError{
			Address: address,
			Reason:  "unknown for_each blocks estimation in strict mode",
		}
	}
	return nil
}

// CheckUnknownProvider checks if unknown provider should block
func (e *StrictModeEnforcer) CheckUnknownProvider(address, providerRef string) error {
	err := StrictModeError{
		Address:  address,
		Reason:   fmt.Sprintf("provider %s could not be resolved", providerRef),
		Category: ErrorUnknownProvider,
		Blocking: e.mode == ModeStrict,
	}
	e.errors = append(e.errors, err)

	if e.mode == ModeStrict {
		e.blocked = true
		return &BlockedEstimationError{
			Address: address,
			Reason:  "unknown provider blocks estimation in strict mode",
		}
	}
	return nil
}

// CheckDataSourceInBlockingPosition checks if data source ref is blocking
func (e *StrictModeEnforcer) CheckDataSourceInBlockingPosition(address, attribute, dataRef string) error {
	blocking := e.mode == ModeStrict

	err := StrictModeError{
		Address:   address,
		Attribute: attribute,
		Reason:    fmt.Sprintf("data source reference %s cannot be estimated", dataRef),
		Category:  ErrorDataSourceReference,
		Blocking:  blocking,
	}
	e.errors = append(e.errors, err)

	if blocking {
		e.blocked = true
		return &BlockedEstimationError{
			Address: address,
			Reason:  fmt.Sprintf("data source %s in blocking position", dataRef),
		}
	}
	return nil
}

// CheckMissingRate checks if missing rate should block
func (e *StrictModeEnforcer) CheckMissingRate(address, rateKey string) error {
	// Missing rates always block in strict mode
	blocking := e.mode == ModeStrict

	err := StrictModeError{
		Address:  address,
		Reason:   fmt.Sprintf("no pricing rate found for %s", rateKey),
		Category: ErrorMissingRate,
		Blocking: blocking,
	}
	e.errors = append(e.errors, err)

	if blocking {
		e.blocked = true
		return &BlockedEstimationError{
			Address: address,
			Reason:  fmt.Sprintf("missing rate %s blocks estimation", rateKey),
		}
	}
	return nil
}

// IsBlocked returns true if estimation is blocked
func (e *StrictModeEnforcer) IsBlocked() bool {
	return e.blocked
}

// GetErrors returns all errors
func (e *StrictModeEnforcer) GetErrors() []StrictModeError {
	return e.errors
}

// GetBlockingErrors returns only blocking errors
func (e *StrictModeEnforcer) GetBlockingErrors() []StrictModeError {
	var result []StrictModeError
	for _, err := range e.errors {
		if err.Blocking {
			result = append(result, err)
		}
	}
	return result
}

// BlockedEstimationError indicates estimation was blocked
type BlockedEstimationError struct {
	Address string
	Reason  string
}

func (e *BlockedEstimationError) Error() string {
	return fmt.Sprintf("estimation blocked for %s: %s", e.Address, e.Reason)
}

// IsBlockedEstimationError checks if an error is a blocked estimation error
func IsBlockedEstimationError(err error) bool {
	var blocked *BlockedEstimationError
	return errors.As(err, &blocked)
}

// ModeConfig configures behavior per mode
type ModeConfig struct {
	Mode EvaluationMode

	// What to do with unknown counts
	UnknownCountBehavior UnknownBehavior

	// What to do with unknown for_each
	UnknownForEachBehavior UnknownBehavior

	// What to do with data source references
	DataSourceBehavior DataSourceBehavior

	// Default count when unknown
	DefaultUnknownCount int
}

// UnknownBehavior defines how to handle unknowns
type UnknownBehavior int

const (
	UnknownBlock    UnknownBehavior = iota // Block estimation
	UnknownDegrade                          // Continue but degrade confidence
	UnknownDefault                          // Use default value
)

// DataSourceBehavior defines how to handle data sources
type DataSourceBehavior int

const (
	DataSourceBlock   DataSourceBehavior = iota // Block on data source refs
	DataSourceDegrade                            // Degrade confidence
	DataSourceIgnore                             // Treat as unknown value
)

// GetModeConfig returns the configuration for a mode
func GetModeConfig(mode EvaluationMode) ModeConfig {
	switch mode {
	case ModeStrict:
		return ModeConfig{
			Mode:                   ModeStrict,
			UnknownCountBehavior:   UnknownBlock,
			UnknownForEachBehavior: UnknownBlock,
			DataSourceBehavior:     DataSourceBlock,
			DefaultUnknownCount:    0,
		}
	case ModePermissive:
		return ModeConfig{
			Mode:                   ModePermissive,
			UnknownCountBehavior:   UnknownDegrade,
			UnknownForEachBehavior: UnknownDegrade,
			DataSourceBehavior:     DataSourceDegrade,
			DefaultUnknownCount:    1,
		}
	default: // ModeEstimate
		return ModeConfig{
			Mode:                   ModeEstimate,
			UnknownCountBehavior:   UnknownDefault,
			UnknownForEachBehavior: UnknownDefault,
			DataSourceBehavior:     DataSourceIgnore,
			DefaultUnknownCount:    1,
		}
	}
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\strict_module_output.go
# TYPE: go
# SIZE: 6157 bytes
################################################################################
// Package terraform - Module output strict handling
// Module outputs are NEVER like locals.
// They are: dependency edges, potentially unknown, cardinality-affecting.
package terraform

import (
	"fmt"
	"strings"
)

// StrictModuleOutput enforces correct module output handling
type StrictModuleOutput struct {
	// Always a dependency edge
	IsDependencyEdge bool // ALWAYS true

	// Output identity
	ModulePath string
	OutputName string
	Address    string

	// State
	IsKnown     bool
	IsComputed  bool // Runtime value
	IsSensitive bool

	// Value (only if known and not sensitive)
	Value interface{}

	// Expression (always captured)
	Expression string
	References []string

	// Cardinality impact
	AffectsCardinality    bool
	CardinalityExpression string

	// Confidence
	ConfidenceImpact float64
}

// NewStrictModuleOutput creates a strict module output
func NewStrictModuleOutput(modulePath, outputName string) *StrictModuleOutput {
	return &StrictModuleOutput{
		IsDependencyEdge: true, // ALWAYS
		ModulePath:       modulePath,
		OutputName:       outputName,
		Address:          modulePath + "." + outputName,
		IsKnown:          false, // Default to unknown
		ConfidenceImpact: 0.2,  // Default impact for module outputs
	}
}

// MarkKnown marks the output as known with a value
func (o *StrictModuleOutput) MarkKnown(value interface{}) {
	o.IsKnown = true
	o.Value = value

	// Check if value affects cardinality
	switch v := value.(type) {
	case []interface{}:
		o.AffectsCardinality = true
		o.CardinalityExpression = fmt.Sprintf("list with %d elements", len(v))
	case map[string]interface{}:
		o.AffectsCardinality = true
		o.CardinalityExpression = fmt.Sprintf("map with %d keys", len(v))
	}
}

// MarkUnknown marks the output as unknown
func (o *StrictModuleOutput) MarkUnknown(expression string, references []string) {
	o.IsKnown = false
	o.Expression = expression
	o.References = references
	o.ConfidenceImpact = 0.3 // Higher impact for unknown

	// Check if expression affects cardinality
	if o.expressionAffectsCardinality(expression) {
		o.AffectsCardinality = true
		o.ConfidenceImpact = 0.4
	}
}

func (o *StrictModuleOutput) expressionAffectsCardinality(expr string) bool {
	if expr == "" {
		return false
	}
	cardinalityFns := []string{"tolist", "toset", "tomap", "list", "set", "map", "keys", "values"}
	for _, fn := range cardinalityFns {
		if strings.Contains(expr, fn+"(") {
			return true
		}
	}
	return false
}

// StrictModuleOutputRegistry tracks all module outputs
type StrictModuleOutputRegistry struct {
	outputs map[string]*StrictModuleOutput
}

// NewStrictModuleOutputRegistry creates a registry
func NewStrictModuleOutputRegistry() *StrictModuleOutputRegistry {
	return &StrictModuleOutputRegistry{
		outputs: make(map[string]*StrictModuleOutput),
	}
}

// Register registers a module output
func (r *StrictModuleOutputRegistry) Register(output *StrictModuleOutput) {
	r.outputs[output.Address] = output
}

// Get gets an output by address
func (r *StrictModuleOutputRegistry) Get(address string) (*StrictModuleOutput, bool) {
	output, ok := r.outputs[address]
	return output, ok
}

// IsModuleOutputReference checks if a reference is to a module output
func (r *StrictModuleOutputRegistry) IsModuleOutputReference(ref string) bool {
	// module.name.output_name pattern
	if !strings.HasPrefix(ref, "module.") {
		return false
	}
	parts := strings.Split(ref, ".")
	return len(parts) >= 3
}

// ResolveReference resolves a module output reference
func (r *StrictModuleOutputRegistry) ResolveReference(ref string) (*StrictModuleOutput, error) {
	if !r.IsModuleOutputReference(ref) {
		return nil, fmt.Errorf("not a module output reference: %s", ref)
	}

	output, ok := r.Get(ref)
	if !ok {
		// Unknown module output - create a strict unknown entry
		parts := strings.Split(ref, ".")
		if len(parts) >= 3 {
			modulePath := strings.Join(parts[:2], ".")
			outputName := strings.Join(parts[2:], ".")
			output = NewStrictModuleOutput(modulePath, outputName)
			output.MarkUnknown("unknown_reference", []string{ref})
			r.Register(output)
		}
		return output, nil
	}

	return output, nil
}

// ValidateUsageInCardinality validates using module output for cardinality
func (r *StrictModuleOutputRegistry) ValidateUsageInCardinality(ref string, context string) *StrictModuleOutputWarning {
	output, _ := r.ResolveReference(ref)
	if output == nil {
		return nil
	}

	// If output is unknown or affects cardinality, this is dangerous
	if !output.IsKnown || output.AffectsCardinality {
		return &StrictModuleOutputWarning{
			Address:  ref,
			Context:  context,
			Warning:  fmt.Sprintf("module output %s used in cardinality context but is %s", ref, output.state()),
			Severity: WarningSevere,
			BlocksEstimation: !output.IsKnown,
		}
	}

	return nil
}

func (o *StrictModuleOutput) state() string {
	if !o.IsKnown {
		return "unknown"
	}
	if o.AffectsCardinality {
		return "cardinality-affecting"
	}
	return "known"
}

// StrictModuleOutputWarning is a warning about module output usage
type StrictModuleOutputWarning struct {
	Address          string
	Context          string
	Warning          string
	Severity         WarningSeverity
	BlocksEstimation bool
}

// WarningSeverity indicates warning severity
type WarningSeverity int

const (
	WarningInfo WarningSeverity = iota
	WarningModerate
	WarningSevere
)

// AllUnknown returns all unknown outputs
func (r *StrictModuleOutputRegistry) AllUnknown() []*StrictModuleOutput {
	var result []*StrictModuleOutput
	for _, output := range r.outputs {
		if !output.IsKnown {
			result = append(result, output)
		}
	}
	return result
}

// AllCardinalityAffecting returns outputs that affect cardinality
func (r *StrictModuleOutputRegistry) AllCardinalityAffecting() []*StrictModuleOutput {
	var result []*StrictModuleOutput
	for _, output := range r.outputs {
		if output.AffectsCardinality {
			result = append(result, output)
		}
	}
	return result
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\strict_unknown.go
# TYPE: go
# SIZE: 10833 bytes
################################################################################
// Package terraform - Strict unknown value semantics
// Unknowns NEVER collapse. They ALWAYS propagate. Cost ALWAYS degrades.
package terraform

import (
	"fmt"
)

// StrictUnknown represents an unknown value that CANNOT be collapsed.
// This is not a nil, not a zero, not an empty string - it is EXPLICITLY unknown.
type StrictUnknown struct {
	// Why this is unknown
	Reason UnknownReason

	// What type we expected
	ExpectedType ValueType

	// Where it came from
	Source string

	// What depends on this
	DependentCount int

	// How many levels deep (for debugging)
	PropagationDepth int
}

// IsUnknown always returns true for StrictUnknown
func (u *StrictUnknown) IsUnknown() bool { return true }

// String returns a debug representation
func (u *StrictUnknown) String() string {
	return fmt.Sprintf("(unknown: %s from %s)", u.Reason, u.Source)
}

// StrictValue is a value that is EITHER known OR unknown, never both, never nil.
type StrictValue struct {
	known   interface{}
	unknown *StrictUnknown
}

// MustBeKnown panics if the value is unknown - use for programming errors only
func (v StrictValue) MustBeKnown(context string) interface{} {
	if v.IsUnknown() {
		panic(fmt.Sprintf("BUG: expected known value but got unknown in %s: %s", context, v.unknown.String()))
	}
	return v.known
}

// StrictKnown creates a known value
func StrictKnown(val interface{}) StrictValue {
	if val == nil {
		// nil is a VALID known value (null)
		return StrictValue{known: nil, unknown: nil}
	}
	return StrictValue{known: val, unknown: nil}
}

// StrictUnknownValue creates an unknown value
func StrictUnknownValue(reason UnknownReason, expectedType ValueType, source string) StrictValue {
	return StrictValue{
		unknown: &StrictUnknown{
			Reason:       reason,
			ExpectedType: expectedType,
			Source:       source,
		},
	}
}

// IsKnown returns true ONLY if value is known
func (v StrictValue) IsKnown() bool {
	return v.unknown == nil
}

// IsUnknown returns true ONLY if value is unknown
func (v StrictValue) IsUnknown() bool {
	return v.unknown != nil
}

// Get returns the value if known, nil if unknown
// IMPORTANT: Check IsKnown() first!
func (v StrictValue) Get() interface{} {
	if v.IsUnknown() {
		return nil
	}
	return v.known
}

// GetUnknown returns the unknown info
func (v StrictValue) GetUnknown() *StrictUnknown {
	return v.unknown
}

// Propagate creates a NEW unknown that depends on this one
// The original unknown is preserved, depth is increased
func (v StrictValue) Propagate(newSource string) StrictValue {
	if v.IsKnown() {
		return v // Known values don't propagate
	}
	return StrictValue{
		unknown: &StrictUnknown{
			Reason:           ReasonDependsOnUnknown,
			ExpectedType:     v.unknown.ExpectedType,
			Source:           fmt.Sprintf("%s (via %s)", newSource, v.unknown.Source),
			PropagationDepth: v.unknown.PropagationDepth + 1,
		},
	}
}

// UnknownSet tracks all unresolved unknowns in a context
type UnknownSet struct {
	unknowns map[string]*StrictUnknown
}

// NewUnknownSet creates an empty unknown set
func NewUnknownSet() *UnknownSet {
	return &UnknownSet{
		unknowns: make(map[string]*StrictUnknown),
	}
}

// Add records an unknown
func (s *UnknownSet) Add(address string, u *StrictUnknown) {
	s.unknowns[address] = u
}

// Has checks if an address is unknown
func (s *UnknownSet) Has(address string) bool {
	_, ok := s.unknowns[address]
	return ok
}

// Get returns the unknown for an address
func (s *UnknownSet) Get(address string) *StrictUnknown {
	return s.unknowns[address]
}

// Merge combines two unknown sets
func (s *UnknownSet) Merge(other *UnknownSet) {
	if other == nil {
		return
	}
	for k, v := range other.unknowns {
		s.unknowns[k] = v
	}
}

// Count returns the number of unknowns
func (s *UnknownSet) Count() int {
	return len(s.unknowns)
}

// All returns all unknowns
func (s *UnknownSet) All() map[string]*StrictUnknown {
	result := make(map[string]*StrictUnknown)
	for k, v := range s.unknowns {
		result[k] = v
	}
	return result
}

// UnknownPropagator ensures unknowns propagate through operations
type UnknownPropagator struct {
	set *UnknownSet
}

// NewUnknownPropagator creates a propagator
func NewUnknownPropagator() *UnknownPropagator {
	return &UnknownPropagator{
		set: NewUnknownSet(),
	}
}

// CheckAndPropagate checks if any input is unknown, and if so returns propagated unknown
func (p *UnknownPropagator) CheckAndPropagate(inputs []StrictValue, operation string) (StrictValue, bool) {
	for _, input := range inputs {
		if input.IsUnknown() {
			// Any unknown input â†’ entire result is unknown
			propagated := input.Propagate(operation)
			return propagated, true
		}
	}
	return StrictValue{}, false
}

// Set returns the underlying unknown set
func (p *UnknownPropagator) Set() *UnknownSet {
	return p.set
}

// StrictArithmetic performs arithmetic that respects unknowns
type StrictArithmetic struct{}

// Add adds two values - if either is unknown, result is unknown
func (StrictArithmetic) Add(a, b StrictValue) StrictValue {
	if a.IsUnknown() {
		return a.Propagate("add.left")
	}
	if b.IsUnknown() {
		return b.Propagate("add.right")
	}

	// Both known - do arithmetic
	aNum, aOk := toFloat(a.Get())
	bNum, bOk := toFloat(b.Get())
	if !aOk || !bOk {
		return StrictUnknownValue(ReasonExpressionError, TypeNumber, "add: non-numeric operand")
	}
	return StrictKnown(aNum + bNum)
}

// Mul multiplies two values - if either is unknown, result is unknown
func (StrictArithmetic) Mul(a, b StrictValue) StrictValue {
	if a.IsUnknown() {
		return a.Propagate("mul.left")
	}
	if b.IsUnknown() {
		return b.Propagate("mul.right")
	}

	aNum, aOk := toFloat(a.Get())
	bNum, bOk := toFloat(b.Get())
	if !aOk || !bOk {
		return StrictUnknownValue(ReasonExpressionError, TypeNumber, "mul: non-numeric operand")
	}
	return StrictKnown(aNum * bNum)
}

// Div divides two values - if either is unknown, result is unknown
func (StrictArithmetic) Div(a, b StrictValue) StrictValue {
	if a.IsUnknown() {
		return a.Propagate("div.left")
	}
	if b.IsUnknown() {
		return b.Propagate("div.right")
	}

	aNum, aOk := toFloat(a.Get())
	bNum, bOk := toFloat(b.Get())
	if !aOk || !bOk {
		return StrictUnknownValue(ReasonExpressionError, TypeNumber, "div: non-numeric operand")
	}
	if bNum == 0 {
		return StrictUnknownValue(ReasonExpressionError, TypeNumber, "div: division by zero")
	}
	return StrictKnown(aNum / bNum)
}

func toFloat(v interface{}) (float64, bool) {
	switch n := v.(type) {
	case float64:
		return n, true
	case float32:
		return float64(n), true
	case int:
		return float64(n), true
	case int64:
		return float64(n), true
	case int32:
		return float64(n), true
	default:
		return 0, false
	}
}

// StrictCondition evaluates conditions respecting unknowns
type StrictCondition struct{}

// IfThenElse evaluates a conditional - if condition is unknown, result is unknown
func (StrictCondition) IfThenElse(condition, thenVal, elseVal StrictValue) StrictValue {
	if condition.IsUnknown() {
		// Unknown condition â†’ result is unknown
		return condition.Propagate("condition")
	}

	// Condition is known - evaluate
	cond, ok := condition.Get().(bool)
	if !ok {
		return StrictUnknownValue(ReasonExpressionError, TypeUnknown, "if: non-boolean condition")
	}

	if cond {
		return thenVal
	}
	return elseVal
}

// Equals compares two values - if either is unknown, result is unknown
func (StrictCondition) Equals(a, b StrictValue) StrictValue {
	if a.IsUnknown() {
		return a.Propagate("equals.left")
	}
	if b.IsUnknown() {
		return b.Propagate("equals.right")
	}
	return StrictKnown(a.Get() == b.Get())
}

// StrictList handles list operations with unknown propagation
type StrictList struct{}

// Index gets an element - if list or index is unknown, result is unknown
func (StrictList) Index(list StrictValue, index StrictValue) StrictValue {
	if list.IsUnknown() {
		return list.Propagate("list.index")
	}
	if index.IsUnknown() {
		return index.Propagate("list.index")
	}

	l, ok := list.Get().([]interface{})
	if !ok {
		return StrictUnknownValue(ReasonExpressionError, TypeUnknown, "index: not a list")
	}

	idx, ok := toInt(index.Get())
	if !ok {
		return StrictUnknownValue(ReasonExpressionError, TypeUnknown, "index: non-integer index")
	}

	if idx < 0 || idx >= len(l) {
		return StrictUnknownValue(ReasonExpressionError, TypeUnknown, "index: out of bounds")
	}

	return StrictKnown(l[idx])
}

// Length gets list length - if list is unknown, result is unknown
func (StrictList) Length(list StrictValue) StrictValue {
	if list.IsUnknown() {
		return list.Propagate("list.length")
	}

	switch v := list.Get().(type) {
	case []interface{}:
		return StrictKnown(len(v))
	case string:
		return StrictKnown(len(v))
	case map[string]interface{}:
		return StrictKnown(len(v))
	default:
		return StrictUnknownValue(ReasonExpressionError, TypeNumber, "length: unsupported type")
	}
}

func toInt(v interface{}) (int, bool) {
	switch n := v.(type) {
	case int:
		return n, true
	case int64:
		return int(n), true
	case float64:
		return int(n), true
	default:
		return 0, false
	}
}

// CostDegradation tracks how costs are degraded due to unknowns
type CostDegradation struct {
	IsDegraded bool
	Confidence float64 // 0.0 - 1.0

	Reasons []DegradationReason
}

// DegradationReason explains why cost is degraded
type DegradationReason struct {
	Component string
	Reason    string
	Impact    float64 // How much this reduces confidence
	IsUnknown bool    // Is this due to an unknown value?
}

// NewCostDegradation creates a fresh (non-degraded) state
func NewCostDegradation() *CostDegradation {
	return &CostDegradation{
		IsDegraded: false,
		Confidence: 1.0,
		Reasons:    []DegradationReason{},
	}
}

// RecordUnknown records that an unknown caused degradation
func (d *CostDegradation) RecordUnknown(component, source string, impact float64) {
	d.IsDegraded = true
	d.Confidence *= (1.0 - impact)
	d.Reasons = append(d.Reasons, DegradationReason{
		Component: component,
		Reason:    fmt.Sprintf("unknown value: %s", source),
		Impact:    impact,
		IsUnknown: true,
	})
}

// RecordMissing records that a missing value caused degradation
func (d *CostDegradation) RecordMissing(component, what string, impact float64) {
	d.IsDegraded = true
	d.Confidence *= (1.0 - impact)
	d.Reasons = append(d.Reasons, DegradationReason{
		Component: component,
		Reason:    fmt.Sprintf("missing: %s", what),
		Impact:    impact,
		IsUnknown: false,
	})
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\unknown.go
# TYPE: go
# SIZE: 13736 bytes
################################################################################
// Package terraform - Unknown value propagation
// Implements correct Terraform unknown semantics: unknowns MUST propagate, never collapse.
package terraform

import (
	"fmt"

	"terraform-cost/core/model"
)

// UnknownValue represents a value that cannot be determined at plan time.
// This is a FIRST-CLASS type, not a nil or empty value.
type UnknownValue struct {
	// Type hint for the expected type
	ExpectedType ValueType

	// Why this value is unknown
	Reason UnknownReason

	// Source of the unknown (for debugging)
	Source string

	// Depth tracks how many levels of unknowns we've propagated through
	Depth int
}

// ValueType indicates the expected type of an unknown value
type ValueType int

const (
	TypeUnknown ValueType = iota
	TypeString
	TypeNumber
	TypeBool
	TypeList
	TypeMap
	TypeObject
)

// UnknownReason explains WHY a value is unknown
type UnknownReason int

const (
	// ReasonComputedAtApply - value computed during terraform apply
	ReasonComputedAtApply UnknownReason = iota

	// ReasonDataSourcePending - data source not yet evaluated
	ReasonDataSourcePending

	// ReasonVariableNotProvided - required variable with no default
	ReasonVariableNotProvided

	// ReasonDependsOnUnknown - depends on another unknown value
	ReasonDependsOnUnknown

	// ReasonExpressionError - expression couldn't be evaluated
	ReasonExpressionError

	// ReasonResourceNotCreated - resource doesn't exist yet
	ReasonResourceNotCreated
)

// String returns human-readable reason
func (r UnknownReason) String() string {
	switch r {
	case ReasonComputedAtApply:
		return "computed at apply time"
	case ReasonDataSourcePending:
		return "data source not yet evaluated"
	case ReasonVariableNotProvided:
		return "required variable not provided"
	case ReasonDependsOnUnknown:
		return "depends on unknown value"
	case ReasonExpressionError:
		return "expression evaluation failed"
	case ReasonResourceNotCreated:
		return "resource not yet created"
	default:
		return "unknown reason"
	}
}

// Value is a wrapper that can hold either a known value or an unknown
type Value struct {
	known   interface{}
	unknown *UnknownValue
}

// Known creates a known value
func Known(v interface{}) Value {
	return Value{known: v}
}

// Unknown creates an unknown value
func Unknown(reason UnknownReason, source string) Value {
	return Value{
		unknown: &UnknownValue{
			Reason: reason,
			Source: source,
			Depth:  0,
		},
	}
}

// UnknownWithType creates a typed unknown
func UnknownWithType(t ValueType, reason UnknownReason, source string) Value {
	return Value{
		unknown: &UnknownValue{
			ExpectedType: t,
			Reason:       reason,
			Source:       source,
			Depth:        0,
		},
	}
}

// IsKnown returns true if value is known
func (v Value) IsKnown() bool {
	return v.unknown == nil
}

// IsUnknown returns true if value is unknown
func (v Value) IsUnknown() bool {
	return v.unknown != nil
}

// Get returns the known value or nil
func (v Value) Get() interface{} {
	if v.IsUnknown() {
		return nil
	}
	return v.known
}

// GetUnknown returns the unknown info
func (v Value) GetUnknown() *UnknownValue {
	return v.unknown
}

// PropagateUnknown creates a new unknown that depends on this one
func (v Value) PropagateUnknown(newSource string) Value {
	if v.IsKnown() {
		return v // Nothing to propagate
	}

	return Value{
		unknown: &UnknownValue{
			ExpectedType: v.unknown.ExpectedType,
			Reason:       ReasonDependsOnUnknown,
			Source:       fmt.Sprintf("%s (from %s)", newSource, v.unknown.Source),
			Depth:        v.unknown.Depth + 1,
		},
	}
}

// UnknownAwareAttribute wraps an attribute that may be unknown
type UnknownAwareAttribute struct {
	Value     Value
	Sensitive bool
	Source    model.SourceLocation
}

// UnknownTracker tracks unknowns throughout the evaluation pipeline
type UnknownTracker struct {
	unknowns map[string]*UnknownValue
}

// NewUnknownTracker creates a new tracker
func NewUnknownTracker() *UnknownTracker {
	return &UnknownTracker{
		unknowns: make(map[string]*UnknownValue),
	}
}

// Track records an unknown value
func (t *UnknownTracker) Track(address string, u *UnknownValue) {
	t.unknowns[address] = u
}

// IsUnknown checks if an address is unknown
func (t *UnknownTracker) IsUnknown(address string) bool {
	_, ok := t.unknowns[address]
	return ok
}

// Get returns unknown info for an address
func (t *UnknownTracker) Get(address string) *UnknownValue {
	return t.unknowns[address]
}

// All returns all tracked unknowns
func (t *UnknownTracker) All() map[string]*UnknownValue {
	// Return copy
	result := make(map[string]*UnknownValue)
	for k, v := range t.unknowns {
		result[k] = v
	}
	return result
}

// Count returns the number of unknowns
func (t *UnknownTracker) Count() int {
	return len(t.unknowns)
}

// UnknownAwareExpander expands resources with proper unknown handling
type UnknownAwareExpander struct {
	tracker *UnknownTracker

	// What to do when count/for_each is unknown
	behavior UnknownExpansionBehavior
}

// UnknownExpansionBehavior defines how to handle unknown count/for_each
type UnknownExpansionBehavior int

const (
	// BehaviorPlaceholder creates a single placeholder instance
	BehaviorPlaceholder UnknownExpansionBehavior = iota

	// BehaviorSkip skips the resource entirely
	BehaviorSkip

	// BehaviorError returns an error
	BehaviorError
)

// NewUnknownAwareExpander creates a new expander
func NewUnknownAwareExpander(behavior UnknownExpansionBehavior) *UnknownAwareExpander {
	return &UnknownAwareExpander{
		tracker:  NewUnknownTracker(),
		behavior: behavior,
	}
}

// ExpandWithUnknowns expands a definition, properly handling unknowns
func (e *UnknownAwareExpander) ExpandWithUnknowns(
	def *model.AssetDefinition,
	ctx *EvalContext,
) ([]*model.AssetInstance, *ExpansionResult) {
	result := &ExpansionResult{
		Warnings: []string{},
		Unknowns: []*UnknownValue{},
	}

	// Check for count
	if def.Count != nil {
		countVal := e.evaluateExpression(*def.Count, ctx)

		if countVal.IsUnknown() {
			// UNKNOWN COUNT: do not guess!
			e.tracker.Track(string(def.Address)+".count", countVal.GetUnknown())
			result.Unknowns = append(result.Unknowns, countVal.GetUnknown())
			result.Warnings = append(result.Warnings,
				fmt.Sprintf("count is unknown: %s", countVal.GetUnknown().Reason))

			switch e.behavior {
			case BehaviorPlaceholder:
				return e.createPlaceholderInstance(def, countVal.GetUnknown()), result
			case BehaviorSkip:
				return []*model.AssetInstance{}, result
			case BehaviorError:
				result.Error = fmt.Errorf("unknown count not allowed")
				return nil, result
			}
		}

		// Known count
		count, ok := countVal.Get().(int)
		if !ok {
			if f, ok := countVal.Get().(float64); ok {
				count = int(f)
			}
		}
		return e.expandCount(def, count, ctx), result
	}

	// Check for for_each
	if def.ForEach != nil {
		forEachVal := e.evaluateExpression(*def.ForEach, ctx)

		if forEachVal.IsUnknown() {
			// UNKNOWN FOR_EACH: do not guess!
			e.tracker.Track(string(def.Address)+".for_each", forEachVal.GetUnknown())
			result.Unknowns = append(result.Unknowns, forEachVal.GetUnknown())
			result.Warnings = append(result.Warnings,
				fmt.Sprintf("for_each is unknown: %s", forEachVal.GetUnknown().Reason))

			switch e.behavior {
			case BehaviorPlaceholder:
				return e.createPlaceholderInstance(def, forEachVal.GetUnknown()), result
			case BehaviorSkip:
				return []*model.AssetInstance{}, result
			case BehaviorError:
				result.Error = fmt.Errorf("unknown for_each not allowed")
				return nil, result
			}
		}

		return e.expandForEach(def, forEachVal.Get(), ctx), result
	}

	// No expansion
	return []*model.AssetInstance{e.createSingleInstance(def, ctx)}, result
}

// ExpansionResult contains the result of expansion
type ExpansionResult struct {
	Warnings []string
	Unknowns []*UnknownValue
	Error    error
}

func (e *UnknownAwareExpander) evaluateExpression(expr model.Expression, ctx *EvalContext) Value {
	if expr.IsLiteral {
		return Known(expr.LiteralVal)
	}

	// Check if any references are unknown
	for _, ref := range expr.References {
		if u := e.tracker.Get(ref); u != nil {
			return Unknown(ReasonDependsOnUnknown, ref)
		}
	}

	// Try to evaluate
	if ctx != nil {
		val, err := ctx.Evaluate(expr)
		if err != nil {
			return Unknown(ReasonExpressionError, expr.Raw)
		}
		return Known(val)
	}

	return Unknown(ReasonExpressionError, expr.Raw)
}

func (e *UnknownAwareExpander) createPlaceholderInstance(
	def *model.AssetDefinition,
	u *UnknownValue,
) []*model.AssetInstance {
	inst := &model.AssetInstance{
		ID:           model.InstanceID(fmt.Sprintf("%s:placeholder", def.ID)),
		DefinitionID: def.ID,
		Address:      model.InstanceAddress(fmt.Sprintf("%s[?]", def.Address)),
		Key:          model.InstanceKey{Type: model.KeyTypeNone},
		Attributes:   make(map[string]model.ResolvedAttribute),
		Metadata: model.InstanceMetadata{
			IsPlaceholder: true,
			Warning:       fmt.Sprintf("placeholder for unknown expansion: %s", u.Reason),
		},
	}

	// Mark all attributes as unknown
	for name := range def.Attributes {
		inst.Attributes[name] = model.ResolvedAttribute{
			IsUnknown: true,
			Reason:    model.ReasonComputedAtApply,
		}
	}

	return []*model.AssetInstance{inst}
}

func (e *UnknownAwareExpander) createSingleInstance(
	def *model.AssetDefinition,
	ctx *EvalContext,
) *model.AssetInstance {
	inst := &model.AssetInstance{
		ID:           model.InstanceID(def.ID),
		DefinitionID: def.ID,
		Address:      model.InstanceAddress(def.Address),
		Key:          model.InstanceKey{Type: model.KeyTypeNone},
		Attributes:   e.resolveAttributes(def, ctx),
	}
	return inst
}

func (e *UnknownAwareExpander) expandCount(
	def *model.AssetDefinition,
	count int,
	ctx *EvalContext,
) []*model.AssetInstance {
	instances := make([]*model.AssetInstance, count)
	for i := 0; i < count; i++ {
		instances[i] = &model.AssetInstance{
			ID:           model.InstanceID(fmt.Sprintf("%s:%d", def.ID, i)),
			DefinitionID: def.ID,
			Address:      model.InstanceAddress(fmt.Sprintf("%s[%d]", def.Address, i)),
			Key:          model.InstanceKey{Type: model.KeyTypeInt, IntValue: i},
			Attributes:   e.resolveAttributesWithCount(def, i, ctx),
		}
	}
	return instances
}

func (e *UnknownAwareExpander) expandForEach(
	def *model.AssetDefinition,
	forEach interface{},
	ctx *EvalContext,
) []*model.AssetInstance {
	var instances []*model.AssetInstance

	switch v := forEach.(type) {
	case map[string]interface{}:
		for key, value := range v {
			instances = append(instances, &model.AssetInstance{
				ID:           model.InstanceID(fmt.Sprintf("%s:%s", def.ID, key)),
				DefinitionID: def.ID,
				Address:      model.InstanceAddress(fmt.Sprintf("%s[%q]", def.Address, key)),
				Key:          model.InstanceKey{Type: model.KeyTypeString, StrValue: key},
				Attributes:   e.resolveAttributesWithEach(def, key, value, ctx),
			})
		}
	case []interface{}:
		for i, item := range v {
			if key, ok := item.(string); ok {
				instances = append(instances, &model.AssetInstance{
					ID:           model.InstanceID(fmt.Sprintf("%s:%s", def.ID, key)),
					DefinitionID: def.ID,
					Address:      model.InstanceAddress(fmt.Sprintf("%s[%q]", def.Address, key)),
					Key:          model.InstanceKey{Type: model.KeyTypeString, StrValue: key},
					Attributes:   e.resolveAttributesWithEach(def, key, item, ctx),
				})
			} else {
				// Use index as fallback
				instances = append(instances, &model.AssetInstance{
					ID:           model.InstanceID(fmt.Sprintf("%s:%d", def.ID, i)),
					DefinitionID: def.ID,
					Address:      model.InstanceAddress(fmt.Sprintf("%s[%d]", def.Address, i)),
					Key:          model.InstanceKey{Type: model.KeyTypeInt, IntValue: i},
					Attributes:   e.resolveAttributesWithEach(def, i, item, ctx),
				})
			}
		}
	}

	return instances
}

func (e *UnknownAwareExpander) resolveAttributes(
	def *model.AssetDefinition,
	ctx *EvalContext,
) map[string]model.ResolvedAttribute {
	result := make(map[string]model.ResolvedAttribute)

	for name, expr := range def.Attributes {
		if name == "count" || name == "for_each" || name == "depends_on" || name == "lifecycle" || name == "provider" {
			continue
		}

		val := e.evaluateExpression(expr, ctx)
		if val.IsUnknown() {
			result[name] = model.ResolvedAttribute{
				IsUnknown: true,
				Reason:    model.UnknownReason(val.GetUnknown().Reason),
			}
		} else {
			result[name] = model.ResolvedAttribute{
				Value:     val.Get(),
				IsUnknown: false,
			}
		}
	}

	return result
}

func (e *UnknownAwareExpander) resolveAttributesWithCount(
	def *model.AssetDefinition,
	index int,
	ctx *EvalContext,
) map[string]model.ResolvedAttribute {
	// Clone context and add count.index
	childCtx := ctx.Clone()
	childCtx.SetLocal("count.index", index)
	return e.resolveAttributes(def, childCtx)
}

func (e *UnknownAwareExpander) resolveAttributesWithEach(
	def *model.AssetDefinition,
	key interface{},
	value interface{},
	ctx *EvalContext,
) map[string]model.ResolvedAttribute {
	childCtx := ctx.Clone()
	childCtx.SetLocal("each.key", key)
	childCtx.SetLocal("each.value", value)
	return e.resolveAttributes(def, childCtx)
}

// Tracker returns the unknown tracker
func (e *UnknownAwareExpander) Tracker() *UnknownTracker {
	return e.tracker
}

################################################################################
# FILE: :\good projects\cost estimation\core\types\asset.go
# TYPE: go
# SIZE: 6162 bytes
################################################################################
// Package types - Asset domain types
package types

// RawAsset represents a parsed infrastructure resource before graph construction.
// This is the output of scanners - no pricing or cost information here.
type RawAsset struct {
	// Address is the Terraform resource address
	Address ResourceAddress `json:"address"`

	// Provider is the cloud provider (aws, azure, gcp)
	Provider Provider `json:"provider"`

	// Type is the resource type (e.g., "aws_instance", "aws_s3_bucket")
	Type string `json:"type"`

	// Name is the resource name from the Terraform configuration
	Name string `json:"name"`

	// Attributes contains all resource attributes
	Attributes Attributes `json:"attributes"`

	// Module is the module path (empty for root module)
	Module string `json:"module,omitempty"`

	// Count is the count value if using count meta-argument
	Count int `json:"count,omitempty"`

	// ForEach contains the for_each keys if using for_each meta-argument
	ForEach []string `json:"for_each,omitempty"`

	// IsDataSource indicates if this is a data source, not a resource
	IsDataSource bool `json:"is_data_source"`

	// SourceFile is the file where this resource is defined
	SourceFile string `json:"source_file,omitempty"`

	// SourceLine is the line number in the source file
	SourceLine int `json:"source_line,omitempty"`
}

// Asset represents a node in the Asset Graph.
// This is the normalized, provider-agnostic representation of infrastructure.
type Asset struct {
	// ID is a unique identifier for this asset
	ID string `json:"id"`

	// Address is the original Terraform resource address
	Address ResourceAddress `json:"address"`

	// Provider is the cloud provider
	Provider Provider `json:"provider"`

	// Category groups assets by function (compute, storage, network, etc.)
	Category AssetCategory `json:"category"`

	// Type is the resource type
	Type string `json:"type"`

	// Name is the resource name
	Name string `json:"name"`

	// Attributes contains normalized resource attributes
	Attributes Attributes `json:"attributes"`

	// Children contains child assets (e.g., EBS volumes attached to an EC2 instance)
	Children []*Asset `json:"children,omitempty"`

	// Parent is the parent asset (nil for root-level assets)
	Parent *Asset `json:"-"`

	// Dependencies lists assets this asset depends on
	Dependencies []*Asset `json:"-"`

	// Metadata contains additional information about the asset
	Metadata AssetMetadata `json:"metadata"`

	// Region is the deployment region
	Region Region `json:"region,omitempty"`

	// Tags are resource tags
	Tags map[string]string `json:"tags,omitempty"`
}

// AssetCategory groups assets by their primary function
type AssetCategory string

const (
	CategoryCompute    AssetCategory = "compute"
	CategoryStorage    AssetCategory = "storage"
	CategoryNetwork    AssetCategory = "network"
	CategoryDatabase   AssetCategory = "database"
	CategoryContainer  AssetCategory = "container"
	CategoryServerless AssetCategory = "serverless"
	CategorySecurity   AssetCategory = "security"
	CategoryMonitoring AssetCategory = "monitoring"
	CategoryAI         AssetCategory = "ai_ml"
	CategoryOther      AssetCategory = "other"
)

// String returns the string representation
func (c AssetCategory) String() string {
	return string(c)
}

// AssetMetadata contains asset-specific metadata
type AssetMetadata struct {
	// Source is the file path where the asset is defined
	Source string `json:"source,omitempty"`

	// Line is the line number in the source file
	Line int `json:"line,omitempty"`

	// IsDataSource indicates if this originated from a data source
	IsDataSource bool `json:"is_data_source"`

	// ModulePath is the module path
	ModulePath string `json:"module_path,omitempty"`

	// Index is the count or for_each index
	Index string `json:"index,omitempty"`
}

// AssetGraph represents the complete infrastructure as a directed acyclic graph
type AssetGraph struct {
	// Roots contains top-level assets (no parent)
	Roots []*Asset `json:"roots"`

	// ByID provides O(1) lookup by asset ID
	ByID map[string]*Asset `json:"-"`

	// ByAddress provides lookup by Terraform address
	ByAddress map[ResourceAddress]*Asset `json:"-"`

	// ByProvider groups assets by cloud provider
	ByProvider map[Provider][]*Asset `json:"-"`

	// ByCategory groups assets by category
	ByCategory map[AssetCategory][]*Asset `json:"-"`

	// Metadata contains graph-level metadata
	Metadata GraphMetadata `json:"metadata"`
}

// GraphMetadata contains metadata about the asset graph
type GraphMetadata struct {
	// TotalAssets is the total count of assets
	TotalAssets int `json:"total_assets"`

	// Providers lists all providers in the graph
	Providers []Provider `json:"providers"`

	// Modules lists all module paths
	Modules []string `json:"modules,omitempty"`
}

// NewAssetGraph creates a new empty asset graph
func NewAssetGraph() *AssetGraph {
	return &AssetGraph{
		Roots:      make([]*Asset, 0),
		ByID:       make(map[string]*Asset),
		ByAddress:  make(map[ResourceAddress]*Asset),
		ByProvider: make(map[Provider][]*Asset),
		ByCategory: make(map[AssetCategory][]*Asset),
	}
}

// Add adds an asset to the graph
func (g *AssetGraph) Add(asset *Asset) {
	g.ByID[asset.ID] = asset
	g.ByAddress[asset.Address] = asset
	g.ByProvider[asset.Provider] = append(g.ByProvider[asset.Provider], asset)
	g.ByCategory[asset.Category] = append(g.ByCategory[asset.Category], asset)

	if asset.Parent == nil {
		g.Roots = append(g.Roots, asset)
	}

	g.Metadata.TotalAssets++
}

// Walk traverses all assets in the graph, calling fn for each
func (g *AssetGraph) Walk(fn func(*Asset) error) error {
	for _, root := range g.Roots {
		if err := walkAsset(root, fn); err != nil {
			return err
		}
	}
	return nil
}

func walkAsset(asset *Asset, fn func(*Asset) error) error {
	if err := fn(asset); err != nil {
		return err
	}
	for _, child := range asset.Children {
		if err := walkAsset(child, fn); err != nil {
			return err
		}
	}
	return nil
}

################################################################################
# FILE: :\good projects\cost estimation\core\types\cost.go
# TYPE: go
# SIZE: 7583 bytes
################################################################################
// Package types - Cost graph types
package types

import "github.com/shopspring/decimal"

// Currency represents a currency code
type Currency string

const (
	CurrencyUSD Currency = "USD"
	CurrencyEUR Currency = "EUR"
	CurrencyGBP Currency = "GBP"
)

// String returns the string representation
func (c Currency) String() string {
	return string(c)
}

// RateKey uniquely identifies a pricing rate
type RateKey struct {
	// Provider is the cloud provider
	Provider Provider `json:"provider"`

	// Service is the cloud service (e.g., "EC2", "S3")
	Service string `json:"service"`

	// ProductFamily is the product family (e.g., "Compute Instance", "Storage")
	ProductFamily string `json:"product_family"`

	// Region is the cloud region
	Region string `json:"region"`

	// Attributes contains SKU-specific attributes
	Attributes map[string]string `json:"attributes,omitempty"`
}

// String returns a string representation for caching/lookup
func (k RateKey) String() string {
	return string(k.Provider) + "/" + k.Service + "/" + k.ProductFamily + "/" + k.Region
}

// CostUnit represents a single billable line item
type CostUnit struct {
	// ID uniquely identifies this cost unit
	ID string `json:"id"`

	// Label is a human-readable label
	Label string `json:"label"`

	// Description provides additional context
	Description string `json:"description,omitempty"`

	// Measure is the billing unit (e.g., "GB-month", "hours", "requests")
	Measure string `json:"measure"`

	// Quantity is the usage quantity
	Quantity decimal.Decimal `json:"quantity"`

	// RateKey identifies the pricing rate
	RateKey RateKey `json:"rate_key"`

	// Rate is the unit price
	Rate decimal.Decimal `json:"rate"`

	// Amount is the calculated cost (Quantity * Rate)
	Amount decimal.Decimal `json:"amount"`

	// Currency is the cost currency
	Currency Currency `json:"currency"`

	// Lineage tracks why this cost exists
	Lineage CostLineage `json:"lineage"`

	// IsSubcost indicates if this is a sub-component of a larger cost
	IsSubcost bool `json:"is_subcost,omitempty"`
}

// CostLineage tracks the origin and calculation of a cost
type CostLineage struct {
	// AssetID links to the source asset
	AssetID string `json:"asset_id"`

	// AssetAddress is the Terraform resource address
	AssetAddress ResourceAddress `json:"asset_address"`

	// Formula describes how the cost was calculated
	Formula string `json:"formula"`

	// UsageVector is the usage data used in calculation
	UsageVector *UsageVector `json:"usage_vector,omitempty"`

	// Assumptions lists assumptions made during calculation
	Assumptions []string `json:"assumptions,omitempty"`
}

// CostAggregate groups cost units by a dimension
type CostAggregate struct {
	// ID uniquely identifies this aggregate
	ID string `json:"id"`

	// Label is a human-readable label
	Label string `json:"label"`

	// Description provides additional context
	Description string `json:"description,omitempty"`

	// Units contains the cost units in this aggregate
	Units []*CostUnit `json:"units,omitempty"`

	// Children contains child aggregates
	Children []*CostAggregate `json:"children,omitempty"`

	// MonthlyCost is the calculated monthly total
	MonthlyCost decimal.Decimal `json:"monthly_cost"`

	// HourlyCost is the calculated hourly cost
	HourlyCost decimal.Decimal `json:"hourly_cost"`

	// Currency is the cost currency
	Currency Currency `json:"currency"`
}

// Add adds a cost unit to the aggregate
func (a *CostAggregate) Add(unit *CostUnit) {
	a.Units = append(a.Units, unit)
	a.MonthlyCost = a.MonthlyCost.Add(unit.Amount)
}

// Total returns the total monthly cost
func (a *CostAggregate) Total() decimal.Decimal {
	total := a.MonthlyCost
	for _, child := range a.Children {
		total = total.Add(child.Total())
	}
	return total
}

// CostGraph represents the complete cost model as a graph
type CostGraph struct {
	// Root is the top-level aggregate
	Root *CostAggregate `json:"root"`

	// ByAsset groups costs by asset ID
	ByAsset map[string]*CostAggregate `json:"by_asset,omitempty"`

	// ByProvider groups costs by cloud provider
	ByProvider map[Provider]*CostAggregate `json:"by_provider,omitempty"`

	// ByService groups costs by service
	ByService map[string]*CostAggregate `json:"by_service,omitempty"`

	// ByCategory groups costs by asset category
	ByCategory map[AssetCategory]*CostAggregate `json:"by_category,omitempty"`

	// TotalMonthlyCost is the overall monthly total
	TotalMonthlyCost decimal.Decimal `json:"total_monthly_cost"`

	// TotalHourlyCost is the overall hourly total
	TotalHourlyCost decimal.Decimal `json:"total_hourly_cost"`

	// Currency is the primary currency
	Currency Currency `json:"currency"`

	// Metadata contains graph-level information
	Metadata CostGraphMetadata `json:"metadata"`
}

// CostGraphMetadata contains metadata about the cost graph
type CostGraphMetadata struct {
	// PricingSnapshotID is the pricing snapshot used
	PricingSnapshotID string `json:"pricing_snapshot_id"`

	// CreatedAt is when the graph was created
	CreatedAt string `json:"created_at"`

	// AssetCount is the number of priced assets
	AssetCount int `json:"asset_count"`

	// CostUnitCount is the total number of cost units
	CostUnitCount int `json:"cost_unit_count"`

	// MissingPrices lists rate keys that couldn't be resolved
	MissingPrices []RateKey `json:"missing_prices,omitempty"`
}

// NewCostGraph creates a new empty cost graph
func NewCostGraph(currency Currency) *CostGraph {
	return &CostGraph{
		Root: &CostAggregate{
			ID:       "root",
			Label:    "Total",
			Currency: currency,
		},
		ByAsset:    make(map[string]*CostAggregate),
		ByProvider: make(map[Provider]*CostAggregate),
		ByService:  make(map[string]*CostAggregate),
		ByCategory: make(map[AssetCategory]*CostAggregate),
		Currency:   currency,
	}
}

// AddCostUnit adds a cost unit to the graph with proper indexing
func (g *CostGraph) AddCostUnit(unit *CostUnit, asset *Asset) {
	// Add to root
	g.Root.Add(unit)

	// Add to by-asset index
	if _, ok := g.ByAsset[asset.ID]; !ok {
		g.ByAsset[asset.ID] = &CostAggregate{
			ID:       asset.ID,
			Label:    string(asset.Address),
			Currency: g.Currency,
		}
	}
	g.ByAsset[asset.ID].Add(unit)

	// Add to by-provider index
	if _, ok := g.ByProvider[asset.Provider]; !ok {
		g.ByProvider[asset.Provider] = &CostAggregate{
			ID:       string(asset.Provider),
			Label:    string(asset.Provider),
			Currency: g.Currency,
		}
	}
	g.ByProvider[asset.Provider].Add(unit)

	// Add to by-service index
	service := unit.RateKey.Service
	if _, ok := g.ByService[service]; !ok {
		g.ByService[service] = &CostAggregate{
			ID:       service,
			Label:    service,
			Currency: g.Currency,
		}
	}
	g.ByService[service].Add(unit)

	// Add to by-category index
	if _, ok := g.ByCategory[asset.Category]; !ok {
		g.ByCategory[asset.Category] = &CostAggregate{
			ID:       string(asset.Category),
			Label:    string(asset.Category),
			Currency: g.Currency,
		}
	}
	g.ByCategory[asset.Category].Add(unit)

	// Update totals
	g.TotalMonthlyCost = g.TotalMonthlyCost.Add(unit.Amount)
	g.Metadata.CostUnitCount++
}

// Summarize recalculates all totals in the graph
func (g *CostGraph) Summarize() {
	g.TotalMonthlyCost = g.Root.Total()
	// Convert to hourly (730 hours/month)
	g.TotalHourlyCost = g.TotalMonthlyCost.Div(decimal.NewFromInt(730))
}

################################################################################
# FILE: :\good projects\cost estimation\core\types\pricing.go
# TYPE: go
# SIZE: 4299 bytes
################################################################################
// Package types - Pricing types
package types

import (
	"time"

	"github.com/shopspring/decimal"
)

// PricingSnapshot represents a point-in-time pricing dataset
type PricingSnapshot struct {
	// ID uniquely identifies this snapshot
	ID string `json:"id"`

	// Provider is the cloud provider
	Provider Provider `json:"provider"`

	// Region is the pricing region
	Region string `json:"region"`

	// Timestamp is when the snapshot was taken
	Timestamp time.Time `json:"timestamp"`

	// Hash is a content hash for validation
	Hash string `json:"hash"`

	// Source indicates where the pricing came from
	Source string `json:"source"`

	// Version is the pricing data version
	Version string `json:"version,omitempty"`
}

// Rate represents a pricing rate for a specific SKU
type Rate struct {
	// Key uniquely identifies what this rate applies to
	Key RateKey `json:"key"`

	// Price is the unit price
	Price decimal.Decimal `json:"price"`

	// Unit is the billing unit (e.g., "hour", "GB-month")
	Unit string `json:"unit"`

	// Currency is the price currency
	Currency Currency `json:"currency"`

	// EffectiveFrom is when this rate became effective
	EffectiveFrom time.Time `json:"effective_from"`

	// EffectiveTo is when this rate expires (nil = current)
	EffectiveTo *time.Time `json:"effective_to,omitempty"`

	// SnapshotID links to the pricing snapshot
	SnapshotID string `json:"snapshot_id"`

	// Description provides additional context
	Description string `json:"description,omitempty"`

	// Tiers contains tiered pricing information
	Tiers []PricingTier `json:"tiers,omitempty"`
}

// PricingTier represents a tier in tiered pricing
type PricingTier struct {
	// StartQuantity is the tier start (inclusive)
	StartQuantity decimal.Decimal `json:"start_quantity"`

	// EndQuantity is the tier end (exclusive, nil = unlimited)
	EndQuantity *decimal.Decimal `json:"end_quantity,omitempty"`

	// Price is the unit price for this tier
	Price decimal.Decimal `json:"price"`

	// Unit is the billing unit
	Unit string `json:"unit"`
}

// CalculateTieredCost calculates cost for tiered pricing
func (r *Rate) CalculateTieredCost(quantity decimal.Decimal) decimal.Decimal {
	if len(r.Tiers) == 0 {
		return quantity.Mul(r.Price)
	}

	total := decimal.Zero
	remaining := quantity

	for _, tier := range r.Tiers {
		if remaining.LessThanOrEqual(decimal.Zero) {
			break
		}

		var tierQuantity decimal.Decimal
		if tier.EndQuantity == nil {
			tierQuantity = remaining
		} else {
			tierRange := tier.EndQuantity.Sub(tier.StartQuantity)
			if remaining.LessThan(tierRange) {
				tierQuantity = remaining
			} else {
				tierQuantity = tierRange
			}
		}

		total = total.Add(tierQuantity.Mul(tier.Price))
		remaining = remaining.Sub(tierQuantity)
	}

	return total
}

// PricingResult contains resolved pricing for a set of rate keys
type PricingResult struct {
	// Rates maps rate keys to their resolved rates
	Rates map[string]Rate `json:"rates"`

	// Snapshot is the pricing snapshot used
	Snapshot PricingSnapshot `json:"snapshot"`

	// Missing lists rate keys that couldn't be resolved
	Missing []RateKey `json:"missing,omitempty"`

	// FromCache indicates how many rates were from cache
	FromCache int `json:"from_cache"`

	// FromDB indicates how many rates were from database
	FromDB int `json:"from_db"`

	// FromAPI indicates how many rates were from API
	FromAPI int `json:"from_api"`
}

// GetRate retrieves a rate by its key
func (r *PricingResult) GetRate(key RateKey) (Rate, bool) {
	if r == nil || r.Rates == nil {
		return Rate{}, false
	}
	rate, ok := r.Rates[key.String()]
	return rate, ok
}

// PricingFilter specifies criteria for pricing lookups
type PricingFilter struct {
	// Provider filters by cloud provider
	Provider Provider `json:"provider,omitempty"`

	// Service filters by service name
	Service string `json:"service,omitempty"`

	// Region filters by region
	Region string `json:"region,omitempty"`

	// ProductFamily filters by product family
	ProductFamily string `json:"product_family,omitempty"`

	// Attributes filters by specific attributes
	Attributes map[string]string `json:"attributes,omitempty"`
}

################################################################################
# FILE: :\good projects\cost estimation\core\types\project.go
# TYPE: go
# SIZE: 3240 bytes
################################################################################
// Package types - Project input types
package types

import "time"

// ProjectInput represents a normalized input for estimation
type ProjectInput struct {
	// ID uniquely identifies this input
	ID string `json:"id"`

	// Path is the filesystem path to the project
	Path string `json:"path"`

	// Type is the detected project type
	Type ProjectType `json:"type"`

	// Source indicates where the input came from
	Source InputSource `json:"source"`

	// Metadata contains additional context
	Metadata InputMetadata `json:"metadata"`
}

// ProjectType identifies the type of infrastructure project
type ProjectType string

const (
	ProjectTypeTerraformHCL    ProjectType = "terraform-hcl"
	ProjectTypeTerraformPlan   ProjectType = "terraform-plan"
	ProjectTypeTerragrunt      ProjectType = "terragrunt"
	ProjectTypeCloudFormation  ProjectType = "cloudformation"
	ProjectTypeUnknown         ProjectType = "unknown"
)

// String returns the string representation
func (t ProjectType) String() string {
	return string(t)
}

// InputSource indicates the origin of the input
type InputSource string

const (
	SourceCLI      InputSource = "cli"
	SourceWeb      InputSource = "web"
	SourceGit      InputSource = "git"
	SourceCICD     InputSource = "cicd"
	SourceAPI      InputSource = "api"
)

// String returns the string representation
func (s InputSource) String() string {
	return string(s)
}

// InputMetadata contains metadata about the input
type InputMetadata struct {
	// Repository is the Git repository URL
	Repository string `json:"repository,omitempty"`

	// Branch is the Git branch
	Branch string `json:"branch,omitempty"`

	// Commit is the Git commit SHA
	Commit string `json:"commit,omitempty"`

	// User is the authenticated user
	User string `json:"user,omitempty"`

	// Timestamp is when the input was received
	Timestamp time.Time `json:"timestamp"`

	// Files lists the input files
	Files []string `json:"files,omitempty"`

	// Hash is a content hash for caching
	Hash string `json:"hash,omitempty"`

	// Environment is the target environment
	Environment string `json:"environment,omitempty"`

	// Tags are user-provided tags
	Tags map[string]string `json:"tags,omitempty"`
}

// DetectedProject contains detection results
type DetectedProject struct {
	// Type is the project type
	Type ProjectType `json:"type"`

	// Roots are the Terraform root modules
	Roots []string `json:"roots"`

	// Confidence is the detection confidence (0.0 to 1.0)
	Confidence float64 `json:"confidence"`

	// Files are the detected IaC files
	Files []DetectedFile `json:"files"`
}

// DetectedFile represents a detected infrastructure file
type DetectedFile struct {
	// Path is the file path relative to project root
	Path string `json:"path"`

	// Type is the file type
	Type FileType `json:"type"`
}

// FileType identifies the type of infrastructure file
type FileType string

const (
	FileTypeTerraform      FileType = "terraform"
	FileTypeTerraformVars  FileType = "tfvars"
	FileTypeTerraformPlan  FileType = "tfplan"
	FileTypeTerragrunt     FileType = "terragrunt"
	FileTypeCloudFormation FileType = "cloudformation"
)

################################################################################
# FILE: :\good projects\cost estimation\core\types\types.go
# TYPE: go
# SIZE: 3456 bytes
################################################################################
// Package types defines core domain types shared across all layers.
// This package contains NO business logic - only type definitions.
package types

import "time"

// Provider represents a cloud provider
type Provider string

const (
	ProviderAWS     Provider = "aws"
	ProviderAzure   Provider = "azure"
	ProviderGCP     Provider = "gcp"
	ProviderUnknown Provider = "unknown"
)

// String returns the string representation of the provider
func (p Provider) String() string {
	return string(p)
}

// IsValid checks if the provider is a known provider
func (p Provider) IsValid() bool {
	switch p {
	case ProviderAWS, ProviderAzure, ProviderGCP:
		return true
	default:
		return false
	}
}

// ResourceAddress uniquely identifies a resource in Terraform
// Format: module.name.resource_type.resource_name or resource_type.resource_name
type ResourceAddress string

// String returns the string representation
func (r ResourceAddress) String() string {
	return string(r)
}

// Attribute represents a resource attribute value
// CRITICAL: Attribute may be UNEVALUATED if it depends on context
type Attribute struct {
	Value       interface{} `json:"value"`
	IsComputed  bool        `json:"is_computed"`
	IsSensitive bool        `json:"is_sensitive"`
	IsUnknown   bool        `json:"is_unknown"` // True if value cannot be determined

	// Expression tracking for deferred evaluation
	Expression       string   `json:"expression,omitempty"`        // Source expression
	ExpressionType   string   `json:"expression_type,omitempty"`   // "literal", "variable", "local", etc
	References       []string `json:"references,omitempty"`        // Referenced addresses
	ConfidenceImpact float64  `json:"confidence_impact,omitempty"` // 0.0-1.0 impact on confidence

	Type string `json:"type,omitempty"`
}

// Attributes is a map of attribute names to values
type Attributes map[string]Attribute

// Get retrieves an attribute value, returning nil if not found
func (a Attributes) Get(key string) interface{} {
	if attr, ok := a[key]; ok {
		return attr.Value
	}
	return nil
}

// GetString retrieves a string attribute value
func (a Attributes) GetString(key string) string {
	if v := a.Get(key); v != nil {
		if s, ok := v.(string); ok {
			return s
		}
	}
	return ""
}

// GetInt retrieves an integer attribute value
func (a Attributes) GetInt(key string) int {
	if v := a.Get(key); v != nil {
		switch n := v.(type) {
		case int:
			return n
		case int64:
			return int(n)
		case float64:
			return int(n)
		}
	}
	return 0
}

// GetBool retrieves a boolean attribute value
func (a Attributes) GetBool(key string) bool {
	if v := a.Get(key); v != nil {
		if b, ok := v.(bool); ok {
			return b
		}
	}
	return false
}

// GetFloat retrieves a float64 attribute value
func (a Attributes) GetFloat(key string) float64 {
	if v := a.Get(key); v != nil {
		switch n := v.(type) {
		case float64:
			return n
		case int:
			return float64(n)
		case int64:
			return float64(n)
		}
	}
	return 0
}

// Metadata contains common metadata fields
type Metadata struct {
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	Version   string    `json:"version"`
}

// Region represents a cloud region
type Region string

// String returns the string representation
func (r Region) String() string {
	return string(r)
}

################################################################################
# FILE: :\good projects\cost estimation\core\types\usage.go
# TYPE: go
# SIZE: 6309 bytes
################################################################################
// Package types - Usage estimation types
package types

// UsageMetric identifies a measurable usage dimension
type UsageMetric string

// Common usage metrics across all providers
const (
	// Time-based metrics
	MetricMonthlyHours UsageMetric = "monthly_hours"
	MetricDailyHours   UsageMetric = "daily_hours"

	// Storage metrics
	MetricMonthlyGB        UsageMetric = "monthly_gb"
	MetricMonthlyGBStorage UsageMetric = "monthly_gb_storage"
	MetricMonthlySnapshots UsageMetric = "monthly_snapshots"

	// Transfer metrics
	MetricMonthlyGBTransferOut   UsageMetric = "monthly_gb_transfer_out"
	MetricMonthlyGBTransferIn    UsageMetric = "monthly_gb_transfer_in"
	MetricMonthlyGBInterRegion   UsageMetric = "monthly_gb_inter_region"
	MetricMonthlyGBInterAZ       UsageMetric = "monthly_gb_inter_az"

	// Request metrics
	MetricMonthlyRequests       UsageMetric = "monthly_requests"
	MetricMonthlyReadRequests   UsageMetric = "monthly_read_requests"
	MetricMonthlyWriteRequests  UsageMetric = "monthly_write_requests"
	MetricMonthlyAPIRequests    UsageMetric = "monthly_api_requests"

	// Operation metrics
	MetricMonthlyOperations     UsageMetric = "monthly_operations"
	MetricMonthlyGetOperations  UsageMetric = "monthly_get_operations"
	MetricMonthlyPutOperations  UsageMetric = "monthly_put_operations"
	MetricMonthlyListOperations UsageMetric = "monthly_list_operations"

	// Compute metrics
	MetricMonthlyCPUCredits UsageMetric = "monthly_cpu_credits"
	MetricMonthlyVCPUHours  UsageMetric = "monthly_vcpu_hours"
	MetricMonthlyGBHours    UsageMetric = "monthly_gb_hours"

	// Database metrics
	MetricMonthlyIORequests       UsageMetric = "monthly_io_requests"
	MetricMonthlyBackupStorageGB  UsageMetric = "monthly_backup_storage_gb"

	// Serverless metrics
	MetricMonthlyInvocations   UsageMetric = "monthly_invocations"
	MetricMonthlyGBSeconds     UsageMetric = "monthly_gb_seconds"
	MetricMonthlyDurationMs    UsageMetric = "monthly_duration_ms"
)

// String returns the string representation
func (m UsageMetric) String() string {
	return string(m)
}

// UsageVector represents estimated usage for a specific metric
type UsageVector struct {
	// Metric is the usage dimension being measured
	Metric UsageMetric `json:"metric"`

	// Value is the estimated usage amount
	Value float64 `json:"value"`

	// Confidence is the confidence level (0.0 to 1.0)
	Confidence float64 `json:"confidence"`

	// Source indicates where this estimate came from
	Source UsageSource `json:"source"`

	// Min is the minimum expected value (for range estimates)
	Min *float64 `json:"min,omitempty"`

	// Max is the maximum expected value (for range estimates)
	Max *float64 `json:"max,omitempty"`

	// Description explains the usage estimate
	Description string `json:"description,omitempty"`
}

// UsageSource indicates the origin of usage data
type UsageSource string

const (
	// SourceDefault uses built-in default values
	SourceDefault UsageSource = "default"

	// SourceOverride uses user-provided values
	SourceOverride UsageSource = "override"

	// SourceProfile uses a pre-defined usage profile
	SourceProfile UsageSource = "profile"

	// SourceHistorical uses historical data analysis
	SourceHistorical UsageSource = "historical"

	// SourceML uses machine learning predictions
	SourceML UsageSource = "ml"

	// SourceTerraform uses values from Terraform configuration
	SourceTerraform UsageSource = "terraform"
)

// String returns the string representation
func (s UsageSource) String() string {
	return string(s)
}

// UsageProfile represents a complete usage configuration for an estimation
type UsageProfile struct {
	// Name is the profile identifier
	Name string `json:"name"`

	// Description explains the profile
	Description string `json:"description,omitempty"`

	// Environment is the target environment (dev, staging, prod)
	Environment string `json:"environment,omitempty"`

	// Defaults are default usage values by resource type
	Defaults map[string][]UsageVector `json:"defaults,omitempty"`

	// Overrides are resource-specific usage overrides
	Overrides map[ResourceAddress][]UsageVector `json:"overrides,omitempty"`

	// Multipliers scale usage values for scenario analysis
	Multipliers map[UsageMetric]float64 `json:"multipliers,omitempty"`
}

// NewUsageProfile creates a new usage profile with the given name
func NewUsageProfile(name string) *UsageProfile {
	return &UsageProfile{
		Name:        name,
		Defaults:    make(map[string][]UsageVector),
		Overrides:   make(map[ResourceAddress][]UsageVector),
		Multipliers: make(map[UsageMetric]float64),
	}
}

// GetOverrides returns usage overrides for a specific resource
func (p *UsageProfile) GetOverrides(addr ResourceAddress) []UsageVector {
	if p == nil {
		return nil
	}
	return p.Overrides[addr]
}

// GetDefaults returns default usage for a resource type
func (p *UsageProfile) GetDefaults(resourceType string) []UsageVector {
	if p == nil {
		return nil
	}
	return p.Defaults[resourceType]
}

// ApplyMultiplier applies a multiplier to usage vectors
func (p *UsageProfile) ApplyMultiplier(vectors []UsageVector) []UsageVector {
	if p == nil || len(p.Multipliers) == 0 {
		return vectors
	}

	result := make([]UsageVector, len(vectors))
	for i, v := range vectors {
		result[i] = v
		if multiplier, ok := p.Multipliers[v.Metric]; ok {
			result[i].Value = v.Value * multiplier
			if v.Min != nil {
				min := *v.Min * multiplier
				result[i].Min = &min
			}
			if v.Max != nil {
				max := *v.Max * multiplier
				result[i].Max = &max
			}
		}
	}
	return result
}

// UsageContext provides context for usage estimation
type UsageContext struct {
	// Profile is the active usage profile
	Profile *UsageProfile

	// Environment is the target environment
	Environment string

	// Region is the deployment region
	Region Region

	// Scenario is the estimation scenario (min, typical, max)
	Scenario UsageScenario
}

// UsageScenario represents different usage estimation scenarios
type UsageScenario string

const (
	ScenarioMin     UsageScenario = "min"
	ScenarioTypical UsageScenario = "typical"
	ScenarioMax     UsageScenario = "max"
)

################################################################################
# FILE: :\good projects\cost estimation\core\ui\runner.go
# TYPE: go
# SIZE: 5520 bytes
################################################################################
// Package ui - Interactive estimation runner with live progress
package ui

import (
	"context"
	"fmt"
	"time"

	"terraform-cost/core/graph"
)

// EstimationRunner runs estimation with live UI feedback
type EstimationRunner struct {
	w           *Writer
	executor    *graph.ConcurrentExecutor
	showSpinner bool
	showTable   bool
}

// NewEstimationRunner creates a runner
func NewEstimationRunner(w *Writer, workers int) *EstimationRunner {
	return &EstimationRunner{
		w:           w,
		executor:    graph.NewConcurrentExecutor(workers),
		showSpinner: true,
		showTable:   true,
	}
}

// EstimationResult is the result of an estimation run
type EstimationResult struct {
	TotalMonthly    string
	TotalHourly     string
	Resources       int
	Instances       int
	Confidence      float64
	Duration        time.Duration
	Warnings        []string
	LowConfidence   []LowConfidenceItem
	TopCosts        []TopCostItem
	ByService       map[string]string
}

// LowConfidenceItem is a resource with low confidence
type LowConfidenceItem struct {
	Address    string
	Confidence float64
	Reason     string
}

// TopCostItem is a high-cost resource
type TopCostItem struct {
	Address string
	Monthly string
	Percent float64
}

// Run executes estimation and displays results
func (r *EstimationRunner) Run(ctx context.Context, infraGraph *graph.InfrastructureGraph, estimator graph.NodeExecutor) (*EstimationResult, error) {
	result := &EstimationResult{
		Warnings:    []string{},
		LowConfidence: []LowConfidenceItem{},
		TopCosts:    []TopCostItem{},
		ByService:   make(map[string]string),
	}

	start := time.Now()

	// Show header
	r.w.Header("Terraform Cost Estimation")
	r.w.Info("Analyzing infrastructure...")
	r.w.Println("")

	// Phase 1: Scanning
	spinner := r.w.NewSpinner("Scanning resources...")
	spinner.Start()
	time.Sleep(500 * time.Millisecond) // Simulate work
	spinner.Stop(true)

	// Phase 2: Resolving
	spinner = r.w.NewSpinner("Resolving dependencies...")
	spinner.Start()
	time.Sleep(300 * time.Millisecond)
	spinner.Stop(true)

	// Phase 3: Estimation with progress
	r.w.Println("")
	r.w.SubHeader("Estimating costs...")
	
	bar := r.w.NewProgressBar(infraGraph.Size(), "Progress")
	
	err := r.executor.ExecuteWithProgress(ctx, infraGraph, estimator, func(p graph.ExecutionProgress) {
		bar.Update(int(p.Completed + p.Failed))
	}, 100*time.Millisecond)

	bar.Done()

	if err != nil {
		r.w.Error("Estimation failed: %v", err)
		return nil, err
	}

	// Get stats
	stats := r.executor.GetStats()
	result.Duration = time.Since(start)
	result.Instances = int(stats.CompletedNodes)

	// Show errors if any
	errors := r.executor.GetErrors()
	if len(errors) > 0 {
		r.w.Println("")
		r.w.Warning("%d resources failed to estimate", len(errors))
		for _, e := range errors {
			r.w.Debug("  %s: %s", e.NodeID, e.Message)
		}
	}

	return result, nil
}

// DisplayResult shows the estimation result
func (r *EstimationRunner) DisplayResult(result *EstimationResult) {
	// Cost summary
	summary := r.w.NewCostSummary()
	summary.TotalMonthly = result.TotalMonthly
	summary.TotalHourly = result.TotalHourly
	summary.Confidence = result.Confidence
	summary.Resources = result.Instances
	summary.Warnings = len(result.Warnings)
	summary.Render()

	// Top costs table
	if len(result.TopCosts) > 0 {
		r.w.Println("")
		r.w.SubHeader("Top Costs")
		table := r.w.NewTable("Resource", "Monthly Cost", "% of Total")
		for _, item := range result.TopCosts {
			table.AddRow(item.Address, item.Monthly, fmt.Sprintf("%.1f%%", item.Percent))
		}
		table.Render()
	}

	// By service breakdown
	if len(result.ByService) > 0 {
		r.w.Println("")
		r.w.SubHeader("By Service")
		table := r.w.NewTable("Service", "Monthly Cost")
		for service, cost := range result.ByService {
			table.AddRow(service, cost)
		}
		table.Render()
	}

	// Low confidence warnings
	if len(result.LowConfidence) > 0 {
		r.w.Println("")
		r.w.Warning("Low Confidence Resources")
		for _, item := range result.LowConfidence {
			r.w.Println("  %s: %.0f%% - %s", 
				r.w.color(Yellow, item.Address), 
				item.Confidence*100, 
				item.Reason)
		}
	}

	// Duration
	r.w.Println("")
	r.w.Println(r.w.color(Dim, fmt.Sprintf("Completed in %s", result.Duration.Round(time.Millisecond))))
}

// DisplayDiff shows cost comparison
func (r *EstimationRunner) DisplayDiff(before, after *EstimationResult) {
	diff := r.w.NewResourceDiff()
	
	// Calculate total change
	// This would parse the actual values in real implementation
	diff.TotalChange = "$50.00/month"
	diff.IsIncrease = true

	// Add sample items (real implementation would compare)
	diff.Added = []DiffItem{
		{Address: "aws_instance.new", NewCost: "$100.00/month"},
	}
	diff.Changed = []DiffItem{
		{Address: "aws_rds_instance.main", OldCost: "$200.00", NewCost: "$250.00", Change: "$50.00", IsIncrease: true},
	}

	diff.Render()
}

// JSONOutput outputs results as JSON
func (r *EstimationRunner) JSONOutput(result *EstimationResult) {
	// In real implementation, use encoding/json
	r.w.Println(`{`)
	r.w.Println(`  "totalMonthly": "%s",`, result.TotalMonthly)
	r.w.Println(`  "totalHourly": "%s",`, result.TotalHourly)
	r.w.Println(`  "confidence": %.2f,`, result.Confidence)
	r.w.Println(`  "resources": %d,`, result.Instances)
	r.w.Println(`  "duration": "%s"`, result.Duration)
	r.w.Println(`}`)
}

################################################################################
# FILE: :\good projects\cost estimation\core\ui\terminal.go
# TYPE: go
# SIZE: 10160 bytes
################################################################################
// Package ui - Terminal user interface
// Rich CLI output with progress bars, tables, and colors.
package ui

import (
	"fmt"
	"io"
	"os"
	"strings"
	"time"
)

// Colors for terminal output
const (
	Reset   = "\033[0m"
	Bold    = "\033[1m"
	Dim     = "\033[2m"
	Red     = "\033[31m"
	Green   = "\033[32m"
	Yellow  = "\033[33m"
	Blue    = "\033[34m"
	Magenta = "\033[35m"
	Cyan    = "\033[36m"
	White   = "\033[37m"
)

// Writer is the UI output destination
type Writer struct {
	out       io.Writer
	noColor   bool
	verbosity int
}

// NewWriter creates a UI writer
func NewWriter(out io.Writer, noColor bool) *Writer {
	if out == nil {
		out = os.Stdout
	}
	return &Writer{
		out:       out,
		noColor:   noColor,
		verbosity: 1,
	}
}

// SetVerbosity sets output verbosity (0=quiet, 1=normal, 2=verbose)
func (w *Writer) SetVerbosity(level int) {
	w.verbosity = level
}

// color applies color if enabled
func (w *Writer) color(c, text string) string {
	if w.noColor {
		return text
	}
	return c + text + Reset
}

// Print writes a line
func (w *Writer) Print(format string, args ...interface{}) {
	fmt.Fprintf(w.out, format, args...)
}

// Println writes a line with newline
func (w *Writer) Println(format string, args ...interface{}) {
	fmt.Fprintf(w.out, format+"\n", args...)
}

// Header prints a section header
func (w *Writer) Header(title string) {
	w.Println("")
	w.Println(w.color(Bold+Cyan, "â”â”â” "+title+" â”â”â”"))
	w.Println("")
}

// SubHeader prints a subsection header
func (w *Writer) SubHeader(title string) {
	w.Println(w.color(Bold, "â–¸ "+title))
}

// Success prints a success message
func (w *Writer) Success(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	w.Println(w.color(Green, "âœ“ ")+msg)
}

// Warning prints a warning
func (w *Writer) Warning(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	w.Println(w.color(Yellow, "âš  ")+msg)
}

// Error prints an error
func (w *Writer) Error(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	w.Println(w.color(Red, "âœ— ")+msg)
}

// Info prints an info message
func (w *Writer) Info(format string, args ...interface{}) {
	if w.verbosity < 1 {
		return
	}
	msg := fmt.Sprintf(format, args...)
	w.Println(w.color(Blue, "â„¹ ")+msg)
}

// Debug prints a debug message
func (w *Writer) Debug(format string, args ...interface{}) {
	if w.verbosity < 2 {
		return
	}
	msg := fmt.Sprintf(format, args...)
	w.Println(w.color(Dim, "  "+msg))
}

// ProgressBar renders a progress bar
type ProgressBar struct {
	w         *Writer
	total     int
	current   int
	width     int
	label     string
	startTime time.Time
}

// NewProgressBar creates a progress bar
func (w *Writer) NewProgressBar(total int, label string) *ProgressBar {
	return &ProgressBar{
		w:         w,
		total:     total,
		width:     40,
		label:     label,
		startTime: time.Now(),
	}
}

// Update updates the progress bar
func (p *ProgressBar) Update(current int) {
	p.current = current
	p.render()
}

// Increment increments the progress bar
func (p *ProgressBar) Increment() {
	p.current++
	p.render()
}

func (p *ProgressBar) render() {
	if p.total == 0 {
		return
	}

	percent := float64(p.current) / float64(p.total)
	filled := int(percent * float64(p.width))
	
	bar := strings.Repeat("â–ˆ", filled) + strings.Repeat("â–‘", p.width-filled)
	
	// Calculate ETA
	elapsed := time.Since(p.startTime)
	eta := ""
	if p.current > 0 {
		remaining := time.Duration(float64(elapsed) / float64(p.current) * float64(p.total-p.current))
		eta = fmt.Sprintf(" ETA: %s", formatDuration(remaining))
	}

	fmt.Fprintf(p.w.out, "\r%s [%s] %3.0f%% (%d/%d)%s", 
		p.label, bar, percent*100, p.current, p.total, eta)
}

// Done completes the progress bar
func (p *ProgressBar) Done() {
	fmt.Fprintln(p.w.out)
}

// Table renders a table
type Table struct {
	w       *Writer
	headers []string
	rows    [][]string
	widths  []int
}

// NewTable creates a table
func (w *Writer) NewTable(headers ...string) *Table {
	widths := make([]int, len(headers))
	for i, h := range headers {
		widths[i] = len(h)
	}
	return &Table{
		w:       w,
		headers: headers,
		rows:    [][]string{},
		widths:  widths,
	}
}

// AddRow adds a row to the table
func (t *Table) AddRow(cells ...string) {
	// Pad or truncate cells to match header count
	row := make([]string, len(t.headers))
	for i := range row {
		if i < len(cells) {
			row[i] = cells[i]
		}
		if len(row[i]) > t.widths[i] {
			t.widths[i] = len(row[i])
		}
	}
	t.rows = append(t.rows, row)
}

// Render prints the table
func (t *Table) Render() {
	// Build format string
	format := ""
	for i, w := range t.widths {
		if i > 0 {
			format += " â”‚ "
		}
		format += fmt.Sprintf("%%-%ds", w)
	}
	format += "\n"

	// Header
	headerArgs := make([]interface{}, len(t.headers))
	for i, h := range t.headers {
		headerArgs[i] = h
	}
	t.w.Print(t.w.color(Bold, fmt.Sprintf(format, headerArgs...)))

	// Separator
	sep := ""
	for i, w := range t.widths {
		if i > 0 {
			sep += "â”€â”¼â”€"
		}
		sep += strings.Repeat("â”€", w)
	}
	t.w.Println(sep)

	// Rows
	for _, row := range t.rows {
		args := make([]interface{}, len(row))
		for i, cell := range row {
			args[i] = cell
		}
		t.w.Print(format, args...)
	}
}

// CostSummary renders a cost summary
type CostSummary struct {
	w           *Writer
	TotalMonthly string
	TotalHourly  string
	Confidence   float64
	Resources    int
	Warnings     int
}

// NewCostSummary creates a cost summary
func (w *Writer) NewCostSummary() *CostSummary {
	return &CostSummary{w: w}
}

// Render prints the cost summary
func (s *CostSummary) Render() {
	s.w.Header("Cost Estimation Summary")

	// Main cost box
	s.w.Println(s.w.color(Bold, "â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®"))
	s.w.Println(s.w.color(Bold, "â”‚")+s.w.color(Green, fmt.Sprintf("  Monthly Cost: %-20s", s.TotalMonthly))+s.w.color(Bold, "â”‚"))
	s.w.Println(s.w.color(Bold, "â”‚")+s.w.color(Dim, fmt.Sprintf("  Hourly Cost:  %-20s", s.TotalHourly))+s.w.color(Bold, "â”‚"))
	s.w.Println(s.w.color(Bold, "â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯"))

	s.w.Println("")

	// Confidence indicator
	confColor := Green
	confIcon := "â—"
	if s.Confidence < 0.8 {
		confColor = Yellow
		confIcon = "â—"
	}
	if s.Confidence < 0.5 {
		confColor = Red
		confIcon = "â—‹"
	}
	s.w.Println(s.w.color(confColor, fmt.Sprintf("%s Confidence: %.0f%%", confIcon, s.Confidence*100)))

	// Stats
	s.w.Println(s.w.color(Dim, fmt.Sprintf("  Resources: %d", s.Resources)))
	if s.Warnings > 0 {
		s.w.Warning("%d warnings", s.Warnings)
	}
}

// Spinner shows a loading spinner
type Spinner struct {
	w       *Writer
	label   string
	frames  []string
	current int
	stop    chan struct{}
	done    chan struct{}
}

// NewSpinner creates a spinner
func (w *Writer) NewSpinner(label string) *Spinner {
	return &Spinner{
		w:      w,
		label:  label,
		frames: []string{"â ‹", "â ™", "â ¹", "â ¸", "â ¼", "â ´", "â ¦", "â §", "â ‡", "â "},
		stop:   make(chan struct{}),
		done:   make(chan struct{}),
	}
}

// Start starts the spinner
func (s *Spinner) Start() {
	go func() {
		ticker := time.NewTicker(80 * time.Millisecond)
		defer ticker.Stop()
		for {
			select {
			case <-s.stop:
				close(s.done)
				return
			case <-ticker.C:
				s.current = (s.current + 1) % len(s.frames)
				fmt.Fprintf(s.w.out, "\r%s %s", s.w.color(Cyan, s.frames[s.current]), s.label)
			}
		}
	}()
}

// Stop stops the spinner
func (s *Spinner) Stop(success bool) {
	close(s.stop)
	<-s.done
	
	icon := s.w.color(Green, "âœ“")
	if !success {
		icon = s.w.color(Red, "âœ—")
	}
	fmt.Fprintf(s.w.out, "\r%s %s\n", icon, s.label)
}

// ResourceDiff shows resource cost diff
type ResourceDiff struct {
	w           *Writer
	Added       []DiffItem
	Removed     []DiffItem
	Changed     []DiffItem
	TotalChange string
	IsIncrease  bool
}

// DiffItem is a single diff item
type DiffItem struct {
	Address    string
	OldCost    string
	NewCost    string
	Change     string
	IsIncrease bool
}

// NewResourceDiff creates a diff view
func (w *Writer) NewResourceDiff() *ResourceDiff {
	return &ResourceDiff{w: w}
}

// Render prints the diff
func (d *ResourceDiff) Render() {
	d.w.Header("Cost Changes")

	// Added
	if len(d.Added) > 0 {
		d.w.SubHeader(fmt.Sprintf("Added (%d)", len(d.Added)))
		for _, item := range d.Added {
			d.w.Println(d.w.color(Green, "+ ")+"%s: %s", item.Address, item.NewCost)
		}
		d.w.Println("")
	}

	// Removed
	if len(d.Removed) > 0 {
		d.w.SubHeader(fmt.Sprintf("Removed (%d)", len(d.Removed)))
		for _, item := range d.Removed {
			d.w.Println(d.w.color(Red, "- ")+"%s: %s", item.Address, item.OldCost)
		}
		d.w.Println("")
	}

	// Changed
	if len(d.Changed) > 0 {
		d.w.SubHeader(fmt.Sprintf("Changed (%d)", len(d.Changed)))
		for _, item := range d.Changed {
			arrow := d.w.color(Yellow, "â†’")
			change := item.Change
			if item.IsIncrease {
				change = d.w.color(Red, "+"+change)
			} else {
				change = d.w.color(Green, change)
			}
			d.w.Println("  %s: %s %s %s (%s)", item.Address, item.OldCost, arrow, item.NewCost, change)
		}
		d.w.Println("")
	}

	// Total
	d.w.Println(strings.Repeat("â”€", 40))
	changeColor := Green
	changePrefix := ""
	if d.IsIncrease {
		changeColor = Red
		changePrefix = "+"
	}
	d.w.Println(d.w.color(Bold, "Total Change: ")+d.w.color(changeColor, changePrefix+d.TotalChange))
}

func formatDuration(d time.Duration) string {
	if d < time.Second {
		return "< 1s"
	}
	if d < time.Minute {
		return fmt.Sprintf("%ds", int(d.Seconds()))
	}
	return fmt.Sprintf("%dm %ds", int(d.Minutes()), int(d.Seconds())%60)
}

################################################################################
# FILE: :\good projects\cost estimation\core\usage\assumptions.go
# TYPE: go
# SIZE: 6400 bytes
################################################################################
// Package usage - Tracked assumptions
// Every default MUST be recorded as an assumption and reduce confidence.
package usage

import (
	"fmt"
	"terraform-cost/core/confidence"
)

// Assumption represents a usage assumption made during estimation
type Assumption struct {
	// What was assumed
	Component string
	Attribute string

	// What value was used
	Value     interface{}
	Unit      string

	// Why this was assumed
	Source    AssumptionSource
	Reason    string

	// Confidence impact
	ConfidenceImpact float64

	// Is this overrideable?
	Overrideable     bool
	OverrideKey      string // Key to use in usage file
}

// AssumptionSource indicates where the assumption came from
type AssumptionSource int

const (
	AssumptionFromDefault    AssumptionSource = iota // Hardcoded default
	AssumptionFromHeuristic                           // Calculated from other attributes
	AssumptionFromProfile                             // Usage profile
	AssumptionFromHistorical                          // Historical data
)

// String returns the source name
func (s AssumptionSource) String() string {
	switch s {
	case AssumptionFromDefault:
		return "default"
	case AssumptionFromHeuristic:
		return "heuristic"
	case AssumptionFromProfile:
		return "profile"
	case AssumptionFromHistorical:
		return "historical"
	default:
		return "unknown"
	}
}

// AssumptionTracker tracks all assumptions made during estimation
type AssumptionTracker struct {
	assumptions []*Assumption
	byComponent map[string][]*Assumption
}

// NewAssumptionTracker creates a new tracker
func NewAssumptionTracker() *AssumptionTracker {
	return &AssumptionTracker{
		assumptions: []*Assumption{},
		byComponent: make(map[string][]*Assumption),
	}
}

// RecordDefault records a default value assumption
// This ALWAYS reduces confidence
func (t *AssumptionTracker) RecordDefault(component, attribute string, value interface{}, unit string, impact float64) *Assumption {
	a := &Assumption{
		Component:        component,
		Attribute:        attribute,
		Value:            value,
		Unit:             unit,
		Source:           AssumptionFromDefault,
		Reason:           "using default value",
		ConfidenceImpact: impact,
		Overrideable:     true,
		OverrideKey:      fmt.Sprintf("%s.%s", component, attribute),
	}

	t.assumptions = append(t.assumptions, a)
	t.byComponent[component] = append(t.byComponent[component], a)
	return a
}

// RecordHeuristic records a heuristic-based assumption
func (t *AssumptionTracker) RecordHeuristic(component, attribute string, value interface{}, unit, reason string, impact float64) *Assumption {
	a := &Assumption{
		Component:        component,
		Attribute:        attribute,
		Value:            value,
		Unit:             unit,
		Source:           AssumptionFromHeuristic,
		Reason:           reason,
		ConfidenceImpact: impact,
		Overrideable:     true,
		OverrideKey:      fmt.Sprintf("%s.%s", component, attribute),
	}

	t.assumptions = append(t.assumptions, a)
	t.byComponent[component] = append(t.byComponent[component], a)
	return a
}

// All returns all assumptions
func (t *AssumptionTracker) All() []*Assumption {
	return t.assumptions
}

// ForComponent returns assumptions for a component
func (t *AssumptionTracker) ForComponent(component string) []*Assumption {
	return t.byComponent[component]
}

// TotalConfidenceImpact returns the total confidence impact
func (t *AssumptionTracker) TotalConfidenceImpact() float64 {
	total := 0.0
	for _, a := range t.assumptions {
		total += a.ConfidenceImpact
	}
	return total
}

// ApplyToTracker applies all assumptions to a confidence tracker
func (t *AssumptionTracker) ApplyToTracker(ct *confidence.ConfidenceTracker) {
	for _, a := range t.assumptions {
		ct.Apply("default_usage", fmt.Sprintf("%s: %v %s", a.OverrideKey, a.Value, a.Unit))
	}
}

// Count returns the number of assumptions
func (t *AssumptionTracker) Count() int {
	return len(t.assumptions)
}

// DefaultAssumptionImpacts defines standard confidence impacts
var DefaultAssumptionImpacts = map[string]float64{
	// Compute
	"lambda.memory_size":         0.05,
	"lambda.invocations":         0.20, // High impact - very variable
	"lambda.duration":            0.15,
	"ec2.cpu_utilization":        0.10,
	"ec2.data_transfer_gb":       0.20,
	"ecs.desired_count":          0.10,
	
	// Storage
	"s3.storage_gb":              0.25, // High impact - very variable
	"s3.requests":                0.20,
	"ebs.iops":                   0.10,
	"rds.storage_gb":             0.15,
	
	// Network
	"nat.data_processed_gb":      0.25, // High impact
	"lb.processed_bytes":         0.20,
	"data_transfer.egress_gb":    0.25,
	
	// Cache
	"elasticache.data_tiering":   0.05,
	
	// Default for unknown
	"default":                    0.15,
}

// GetDefaultImpact returns the standard impact for an assumption
func GetDefaultImpact(key string) float64 {
	if impact, ok := DefaultAssumptionImpacts[key]; ok {
		return impact
	}
	return DefaultAssumptionImpacts["default"]
}

// CommonDefaults defines common default values
var CommonDefaults = map[string]interface{}{
	// Lambda
	"aws_lambda_function.memory_size":  128,
	"aws_lambda_function.timeout":      3,
	"aws_lambda_function.invocations":  1000000, // 1M/month
	"aws_lambda_function.duration_ms":  100,

	// EC2
	"aws_instance.cpu_utilization":     50.0,  // %
	"aws_instance.data_transfer_gb":    100.0, // GB/month

	// ECS
	"aws_ecs_service.desired_count":    1,
	"aws_ecs_task.cpu_utilization":     50.0,

	// S3
	"aws_s3_bucket.storage_gb":         100.0, // GB
	"aws_s3_bucket.put_requests":       10000,
	"aws_s3_bucket.get_requests":       100000,

	// RDS
	"aws_db_instance.storage_gb":       20.0,
	"aws_db_instance.iops":             1000,

	// NAT
	"aws_nat_gateway.data_processed_gb": 100.0,

	// ALB
	"aws_lb.processed_bytes":           1000000000, // 1 GB
	"aws_lb.new_connections":           1000,
	"aws_lb.active_connections":        100,
}

// GetDefault returns a default value for a resource attribute
func GetDefault(resourceType, attribute string) (interface{}, bool) {
	key := resourceType + "." + attribute
	if val, ok := CommonDefaults[key]; ok {
		return val, true
	}
	return nil, false
}

################################################################################
# FILE: :\good projects\cost estimation\core\usage\estimator.go
# TYPE: go
# SIZE: 2653 bytes
################################################################################
// Package usage provides usage estimation interfaces.
// This package estimates how infrastructure will be used.
// Usage is decoupled from resource definitions to enable scenario modeling.
package usage

import (
	"context"

	"terraform-cost/core/types"
)

// Estimator estimates usage for a specific resource type
type Estimator interface {
	// Provider returns the cloud provider
	Provider() types.Provider

	// ResourceType returns the resource type this estimator handles
	ResourceType() string

	// Estimate produces usage vectors for an asset
	Estimate(ctx context.Context, asset *types.Asset, uctx *Context) ([]types.UsageVector, error)
}

// Context provides context for usage estimation
type Context struct {
	// Profile is the active usage profile
	Profile *types.UsageProfile

	// Environment is the target environment (dev, staging, prod)
	Environment string

	// Region is the deployment region
	Region types.Region

	// Scenario is the estimation scenario
	Scenario types.UsageScenario

	// Now is the current time (for time-based calculations)
	Now string

	// CustomDefaults are additional default values
	CustomDefaults map[types.UsageMetric]float64
}

// DefaultContext creates a new usage context with defaults
func DefaultContext() *Context {
	return &Context{
		Environment: "production",
		Scenario:    types.ScenarioTypical,
	}
}

// EstimatorRegistry manages usage estimator registration
type EstimatorRegistry interface {
	// Register adds an estimator to the registry
	Register(estimator Estimator) error

	// GetEstimator returns an estimator for a provider and resource type
	GetEstimator(provider types.Provider, resourceType string) (Estimator, bool)

	// GetProviderEstimators returns all estimators for a provider
	GetProviderEstimators(provider types.Provider) []Estimator
}

// EstimationResult contains usage estimation output
type EstimationResult struct {
	// AssetID is the asset this estimation is for
	AssetID string

	// Vectors are the usage estimates
	Vectors []types.UsageVector

	// Confidence is the overall confidence level
	Confidence float64

	// Assumptions lists assumptions made
	Assumptions []string
}

// Manager orchestrates usage estimation across all assets
type Manager interface {
	// EstimateAll estimates usage for all assets in a graph
	EstimateAll(ctx context.Context, graph *types.AssetGraph, uctx *Context) (map[string]*EstimationResult, error)

	// EstimateAsset estimates usage for a single asset
	EstimateAsset(ctx context.Context, asset *types.Asset, uctx *Context) (*EstimationResult, error)
}

################################################################################
# FILE: :\good projects\cost estimation\core\usage\registry.go
# TYPE: go
# SIZE: 2268 bytes
################################################################################
// Package usage - Usage estimator registry
package usage

import (
	"fmt"
	"sync"

	"terraform-cost/core/types"
)

// DefaultEstimatorRegistry is the default implementation
type DefaultEstimatorRegistry struct {
	mu         sync.RWMutex
	estimators map[string]Estimator // key: provider/resource_type
}

// NewEstimatorRegistry creates a new estimator registry
func NewEstimatorRegistry() *DefaultEstimatorRegistry {
	return &DefaultEstimatorRegistry{
		estimators: make(map[string]Estimator),
	}
}

// Register adds an estimator to the registry
func (r *DefaultEstimatorRegistry) Register(estimator Estimator) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := makeEstimatorKey(estimator.Provider(), estimator.ResourceType())
	if _, exists := r.estimators[key]; exists {
		return fmt.Errorf("estimator already registered: %s", key)
	}

	r.estimators[key] = estimator
	return nil
}

// GetEstimator returns an estimator for a provider and resource type
func (r *DefaultEstimatorRegistry) GetEstimator(provider types.Provider, resourceType string) (Estimator, bool) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	key := makeEstimatorKey(provider, resourceType)
	estimator, ok := r.estimators[key]
	return estimator, ok
}

// GetProviderEstimators returns all estimators for a provider
func (r *DefaultEstimatorRegistry) GetProviderEstimators(provider types.Provider) []Estimator {
	r.mu.RLock()
	defer r.mu.RUnlock()

	var estimators []Estimator
	prefix := string(provider) + "/"
	for key, estimator := range r.estimators {
		if len(key) > len(prefix) && key[:len(prefix)] == prefix {
			estimators = append(estimators, estimator)
		}
	}
	return estimators
}

func makeEstimatorKey(provider types.Provider, resourceType string) string {
	return string(provider) + "/" + resourceType
}

// Global default registry
var defaultEstimatorRegistry = NewEstimatorRegistry()

// RegisterEstimator adds an estimator to the default registry
func RegisterEstimator(estimator Estimator) error {
	return defaultEstimatorRegistry.Register(estimator)
}

// GetDefaultEstimatorRegistry returns the default registry
func GetDefaultEstimatorRegistry() *DefaultEstimatorRegistry {
	return defaultEstimatorRegistry
}

################################################################################
# FILE: :\good projects\cost estimation\core\usage\strict_defaults.go
# TYPE: go
# SIZE: 11167 bytes
################################################################################
// Package usage - Strict default enforcement
// Defaults MUST bias toward over-estimation, not under-estimation.
// Every default MUST make users uncomfortable if they don't override.
package usage

import (
	"fmt"
	"terraform-cost/core/confidence"
	"terraform-cost/core/determinism"
)

// StrictDefaultPolicy enforces that all defaults are visible and conservative
type StrictDefaultPolicy struct {
	// Defaults that are known to bias low
	lowBiasDefaults map[string]DefaultRisk

	// Minimum confidence impacts per category
	minImpacts map[string]float64
}

// DefaultRisk describes the risk of a default value
type DefaultRisk struct {
	DefaultValue     interface{}
	RiskLevel        RiskLevel
	ProductionTypical interface{} // What production usually sees
	ConfidenceImpact float64
	Warning          string
}

// RiskLevel indicates how risky a default is
type RiskLevel int

const (
	RiskLow    RiskLevel = iota // Default is conservative
	RiskMedium                   // Default may underestimate
	RiskHigh                     // Default likely underestimates
	RiskCritical                 // Default almost certainly underestimates
)

// String returns the risk level name
func (r RiskLevel) String() string {
	switch r {
	case RiskLow:
		return "low"
	case RiskMedium:
		return "medium"
	case RiskHigh:
		return "high"
	case RiskCritical:
		return "critical"
	default:
		return "unknown"
	}
}

// NewStrictDefaultPolicy creates a strict policy
func NewStrictDefaultPolicy() *StrictDefaultPolicy {
	return &StrictDefaultPolicy{
		lowBiasDefaults: map[string]DefaultRisk{
			// Lambda - invocations are typically MUCH higher
			"aws_lambda_function.invocations": {
				DefaultValue:     1000000,            // 1M
				RiskLevel:        RiskCritical,
				ProductionTypical: 100000000,          // 100M
				ConfidenceImpact: 0.35,
				Warning:          "Lambda invocations default (1M) is typically 100x lower than production",
			},
			"aws_lambda_function.duration_ms": {
				DefaultValue:     100,
				RiskLevel:        RiskHigh,
				ProductionTypical: 500,
				ConfidenceImpact: 0.25,
				Warning:          "Lambda duration default (100ms) may underestimate cold starts",
			},

			// S3 - storage grows rapidly
			"aws_s3_bucket.storage_gb": {
				DefaultValue:     100,
				RiskLevel:        RiskCritical,
				ProductionTypical: 10000,             // 10TB
				ConfidenceImpact: 0.40,
				Warning:          "S3 storage default (100GB) is typically 100x lower than production",
			},
			"aws_s3_bucket.put_requests": {
				DefaultValue:     10000,
				RiskLevel:        RiskHigh,
				ProductionTypical: 10000000,
				ConfidenceImpact: 0.30,
				Warning:          "S3 PUT requests often 1000x higher in production",
			},

			// NAT Gateway - data transfer is expensive
			"aws_nat_gateway.data_processed_gb": {
				DefaultValue:     100,
				RiskLevel:        RiskCritical,
				ProductionTypical: 5000,
				ConfidenceImpact: 0.40,
				Warning:          "NAT data default (100GB) is typically 50x lower - this is expensive",
			},

			// Data transfer - egress is expensive
			"data_transfer.egress_gb": {
				DefaultValue:     100,
				RiskLevel:        RiskCritical,
				ProductionTypical: 10000,
				ConfidenceImpact: 0.45,
				Warning:          "Egress default (100GB) is typically 100x lower in production",
			},

			// EC2 hours - assume full month
			"aws_instance.monthly_hours": {
				DefaultValue:     730,
				RiskLevel:        RiskLow, // This is actually correct
				ProductionTypical: 730,
				ConfidenceImpact: 0.05,
				Warning:          "",
			},

			// RDS storage
			"aws_db_instance.storage_gb": {
				DefaultValue:     20,
				RiskLevel:        RiskHigh,
				ProductionTypical: 500,
				ConfidenceImpact: 0.30,
				Warning:          "RDS storage default (20GB) is typically 25x lower",
			},

			// ECS
			"aws_ecs_service.desired_count": {
				DefaultValue:     1,
				RiskLevel:        RiskHigh,
				ProductionTypical: 5,
				ConfidenceImpact: 0.25,
				Warning:          "ECS desired_count default (1) is typically 5x lower",
			},
		},
		minImpacts: map[string]float64{
			"storage":       0.25,
			"compute":       0.15,
			"network":       0.30,
			"data_transfer": 0.35,
			"requests":      0.25,
		},
	}
}

// ValidateDefault checks if a default is acceptable and returns warnings
func (p *StrictDefaultPolicy) ValidateDefault(resourceType, attribute string, value interface{}) *DefaultValidation {
	key := resourceType + "." + attribute
	
	validation := &DefaultValidation{
		Key:      key,
		Value:    value,
		Acceptable: true,
		Warnings:   []string{},
	}

	if risk, ok := p.lowBiasDefaults[key]; ok {
		validation.Risk = risk.RiskLevel
		validation.ConfidenceImpact = risk.ConfidenceImpact
		
		if risk.Warning != "" {
			validation.Warnings = append(validation.Warnings, risk.Warning)
		}

		if risk.RiskLevel >= RiskHigh {
			validation.Acceptable = false
			validation.Warnings = append(validation.Warnings, 
				fmt.Sprintf("Consider using production-typical value: %v", risk.ProductionTypical))
		}
	}

	return validation
}

// DefaultValidation is the result of validating a default
type DefaultValidation struct {
	Key              string
	Value            interface{}
	Acceptable       bool
	Risk             RiskLevel
	ConfidenceImpact float64
	Warnings         []string
}

// ApplyToTracker applies the default's confidence impact
func (v *DefaultValidation) ApplyToTracker(tracker *confidence.ConfidenceTracker) {
	if v.ConfidenceImpact > 0 {
		tracker.Apply("usage_default", fmt.Sprintf("%s uses default value", v.Key))
	}
}

// StrictUsageResolver resolves usage with explicit tracking
type StrictUsageResolver struct {
	policy     *StrictDefaultPolicy
	tracker    *AssumptionTracker
	confidence *confidence.ConfidenceTracker
	warnings   []UsageWarning
}

// UsageWarning is a warning about usage estimation
type UsageWarning struct {
	ResourceType string
	Attribute    string
	Value        interface{}
	Risk         RiskLevel
	Message      string
}

// NewStrictUsageResolver creates a resolver
func NewStrictUsageResolver() *StrictUsageResolver {
	return &StrictUsageResolver{
		policy:     NewStrictDefaultPolicy(),
		tracker:    NewAssumptionTracker(),
		confidence: confidence.NewConfidenceTracker(),
		warnings:   []UsageWarning{},
	}
}

// ResolveUsage resolves a usage value, either from overrides or defaults
func (r *StrictUsageResolver) ResolveUsage(
	resourceType, attribute string,
	override interface{},
	defaultValue interface{},
) *ResolvedUsage {
	
	result := &ResolvedUsage{
		Attribute: attribute,
	}

	// If override provided, use it
	if override != nil {
		result.Value = override
		result.Source = UsageSourceOverride
		result.Confidence = 1.0
		return result
	}

	// Using default - validate it
	validation := r.policy.ValidateDefault(resourceType, attribute, defaultValue)
	
	result.Value = defaultValue
	result.Source = UsageSourceDefault
	result.Confidence = 1.0 - validation.ConfidenceImpact
	result.Risk = validation.Risk
	result.Warnings = validation.Warnings

	// Track the assumption
	r.tracker.RecordDefault(
		resourceType,
		attribute,
		defaultValue,
		"",
		validation.ConfidenceImpact,
	)

	// Record warning if high risk
	if validation.Risk >= RiskHigh {
		r.warnings = append(r.warnings, UsageWarning{
			ResourceType: resourceType,
			Attribute:    attribute,
			Value:        defaultValue,
			Risk:         validation.Risk,
			Message:      validation.Warnings[0],
		})
	}

	return result
}

// ResolvedUsage is a resolved usage value
type ResolvedUsage struct {
	Attribute  string
	Value      interface{}
	Source     UsageSource
	Confidence float64
	Risk       RiskLevel
	Warnings   []string
}

// UsageSource indicates where usage came from
type UsageSource int

const (
	UsageSourceOverride   UsageSource = iota // User provided
	UsageSourceDefault                        // Using default
	UsageSourceHistorical                     // From historical data
	UsageSourceInferred                       // Inferred from config
)

// AsFloat returns the value as float64
func (u *ResolvedUsage) AsFloat() float64 {
	switch v := u.Value.(type) {
	case float64:
		return v
	case int:
		return float64(v)
	case int64:
		return float64(v)
	default:
		return 0
	}
}

// GetWarnings returns all warnings from resolution
func (r *StrictUsageResolver) GetWarnings() []UsageWarning {
	return r.warnings
}

// GetAssumptions returns all assumptions made
func (r *StrictUsageResolver) GetAssumptions() []*Assumption {
	return r.tracker.All()
}

// GetConfidenceTracker returns the confidence tracker
func (r *StrictUsageResolver) GetConfidenceTracker() *confidence.ConfidenceTracker {
	return r.confidence
}

// FormatWarnings returns human-readable warnings
func (r *StrictUsageResolver) FormatWarnings() string {
	if len(r.warnings) == 0 {
		return "No usage warnings"
	}

	result := fmt.Sprintf("âš ï¸ %d Usage Warnings:\n", len(r.warnings))
	for i, w := range r.warnings {
		result += fmt.Sprintf("  %d. [%s] %s.%s = %v\n", 
			i+1, w.Risk.String(), w.ResourceType, w.Attribute, w.Value)
		result += fmt.Sprintf("     %s\n", w.Message)
	}
	return result
}

// CalculateTotalRisk returns aggregate risk information
func (r *StrictUsageResolver) CalculateTotalRisk() *AggregateRisk {
	risk := &AggregateRisk{}

	for _, w := range r.warnings {
		switch w.Risk {
		case RiskCritical:
			risk.CriticalCount++
		case RiskHigh:
			risk.HighCount++
		case RiskMedium:
			risk.MediumCount++
		}
	}

	risk.ConfidenceLoss = r.tracker.TotalConfidenceImpact()
	risk.EstimatedBias = r.estimateBias()

	return risk
}

func (r *StrictUsageResolver) estimateBias() determinism.Money {
	// Rough estimate of how much we might be underestimating
	// This is a heuristic based on typical production vs default ratios
	biasMultiplier := 1.0
	for _, w := range r.warnings {
		switch w.Risk {
		case RiskCritical:
			biasMultiplier *= 2.0
		case RiskHigh:
			biasMultiplier *= 1.5
		case RiskMedium:
			biasMultiplier *= 1.2
		}
	}
	// Return estimate that we might be X% low
	// This is informational only
	return determinism.Zero("USD")
}

// AggregateRisk summarizes overall usage risk
type AggregateRisk struct {
	CriticalCount  int
	HighCount      int
	MediumCount    int
	ConfidenceLoss float64
	EstimatedBias  determinism.Money
}

// IsAcceptable returns true if risk is acceptable for production
func (r *AggregateRisk) IsAcceptable() bool {
	return r.CriticalCount == 0 && r.HighCount <= 2
}

// Summary returns a summary string
func (r *AggregateRisk) Summary() string {
	if r.CriticalCount == 0 && r.HighCount == 0 {
		return "Usage defaults are acceptable"
	}
	return fmt.Sprintf("âš ï¸ %d critical, %d high risk defaults - estimate may be significantly low",
		r.CriticalCount, r.HighCount)
}

################################################################################
# FILE: :\good projects\cost estimation\examples\aws-simple\main.tf
# TYPE: hcl
# SIZE: 1876 bytes
################################################################################
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "us-east-1"
}

# EC2 Instance
resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.medium"

  root_block_device {
    volume_type = "gp3"
    volume_size = 30
  }

  tags = {
    Name        = "web-server"
    Environment = "production"
  }
}

# RDS Database
resource "aws_db_instance" "main" {
  identifier        = "main-database"
  engine            = "postgres"
  engine_version    = "15.4"
  instance_class    = "db.t3.medium"
  allocated_storage = 100
  storage_type      = "gp2"

  db_name  = "myapp"
  username = "admin"
  password = "changeme123"

  multi_az            = false
  skip_final_snapshot = true

  tags = {
    Name        = "main-database"
    Environment = "production"
  }
}

# NAT Gateway
resource "aws_nat_gateway" "main" {
  allocation_id = "eipalloc-12345678"
  subnet_id     = "subnet-12345678"

  tags = {
    Name = "main-nat"
  }
}

# EBS Volume
resource "aws_ebs_volume" "data" {
  availability_zone = "us-east-1a"
  size              = 500
  type              = "gp3"
  iops              = 3000
  throughput        = 125

  tags = {
    Name = "data-volume"
  }
}

# Lambda Function
resource "aws_lambda_function" "api" {
  function_name = "api-handler"
  role          = "arn:aws:iam::123456789012:role/lambda-role"
  handler       = "index.handler"
  runtime       = "nodejs18.x"
  memory_size   = 256
  timeout       = 30

  filename = "function.zip"

  tags = {
    Name = "api-lambda"
  }
}

# S3 Bucket
resource "aws_s3_bucket" "assets" {
  bucket = "my-app-assets-bucket"

  tags = {
    Name        = "assets"
    Environment = "production"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\internal\config\config.go
# TYPE: go
# SIZE: 4997 bytes
################################################################################
// Package config provides configuration management.
package config

import (
	"encoding/json"
	"os"
	"path/filepath"

	"terraform-cost/core/types"
	"terraform-cost/internal/logging"
)

// Config is the main application configuration
type Config struct {
	// Version is the configuration version
	Version string `json:"version"`

	// Pricing contains pricing configuration
	Pricing PricingConfig `json:"pricing"`

	// Output contains output configuration
	Output OutputConfig `json:"output"`

	// Cache contains cache configuration
	Cache CacheConfig `json:"cache"`

	// Logging contains logging configuration
	Logging logging.Config `json:"logging"`

	// AWS contains AWS-specific configuration
	AWS AWSConfig `json:"aws,omitempty"`

	// Azure contains Azure-specific configuration  
	Azure AzureConfig `json:"azure,omitempty"`

	// GCP contains GCP-specific configuration
	GCP GCPConfig `json:"gcp,omitempty"`
}

// PricingConfig contains pricing-related settings
type PricingConfig struct {
	// DefaultCurrency is the default currency
	DefaultCurrency types.Currency `json:"default_currency"`

	// CacheEnabled enables pricing caching
	CacheEnabled bool `json:"cache_enabled"`

	// CacheTTLSeconds is how long to cache prices
	CacheTTLSeconds int `json:"cache_ttl_seconds"`

	// DatabasePath is the path to the pricing database
	DatabasePath string `json:"database_path"`

	// RefreshOnStart refreshes pricing on startup
	RefreshOnStart bool `json:"refresh_on_start"`
}

// OutputConfig contains output-related settings
type OutputConfig struct {
	// DefaultFormat is the default output format
	DefaultFormat string `json:"default_format"`

	// ShowDetails shows detailed cost breakdown
	ShowDetails bool `json:"show_details"`

	// ShowConfidence shows confidence scores
	ShowConfidence bool `json:"show_confidence"`

	// GroupBy is the default grouping
	GroupBy string `json:"group_by"`
}

// CacheConfig contains cache-related settings
type CacheConfig struct {
	// Enabled enables caching
	Enabled bool `json:"enabled"`

	// Directory is the cache directory
	Directory string `json:"directory"`

	// MaxSizeMB is the maximum cache size in MB
	MaxSizeMB int `json:"max_size_mb"`
}

// AWSConfig contains AWS-specific settings
type AWSConfig struct {
	// DefaultRegion is the default AWS region
	DefaultRegion string `json:"default_region"`

	// Profile is the AWS profile to use
	Profile string `json:"profile,omitempty"`

	// Regions to include in pricing
	Regions []string `json:"regions,omitempty"`
}

// AzureConfig contains Azure-specific settings
type AzureConfig struct {
	// DefaultRegion is the default Azure region
	DefaultRegion string `json:"default_region"`

	// SubscriptionID is the Azure subscription
	SubscriptionID string `json:"subscription_id,omitempty"`
}

// GCPConfig contains GCP-specific settings
type GCPConfig struct {
	// DefaultRegion is the default GCP region
	DefaultRegion string `json:"default_region"`

	// Project is the GCP project
	Project string `json:"project,omitempty"`
}

// Default returns a default configuration
func Default() *Config {
	homeDir, _ := os.UserHomeDir()
	cacheDir := filepath.Join(homeDir, ".terraform-cost", "cache")
	dbPath := filepath.Join(homeDir, ".terraform-cost", "pricing.db")

	return &Config{
		Version: "1.0",
		Pricing: PricingConfig{
			DefaultCurrency: types.CurrencyUSD,
			CacheEnabled:    true,
			CacheTTLSeconds: 86400, // 24 hours
			DatabasePath:    dbPath,
			RefreshOnStart:  false,
		},
		Output: OutputConfig{
			DefaultFormat:  "cli",
			ShowDetails:    true,
			ShowConfidence: false,
			GroupBy:        "resource",
		},
		Cache: CacheConfig{
			Enabled:   true,
			Directory: cacheDir,
			MaxSizeMB: 100,
		},
		Logging: logging.DefaultConfig(),
		AWS: AWSConfig{
			DefaultRegion: "us-east-1",
		},
		Azure: AzureConfig{
			DefaultRegion: "eastus",
		},
		GCP: GCPConfig{
			DefaultRegion: "us-central1",
		},
	}
}

// Load loads configuration from a file
func Load(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return Default(), nil
		}
		return nil, err
	}

	config := Default()
	if err := json.Unmarshal(data, config); err != nil {
		return nil, err
	}

	return config, nil
}

// Save saves configuration to a file
func (c *Config) Save(path string) error {
	// Ensure directory exists
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	data, err := json.MarshalIndent(c, "", "  ")
	if err != nil {
		return err
	}

	return os.WriteFile(path, data, 0644)
}

// Global configuration instance
var globalConfig = Default()

// Get returns the global configuration
func Get() *Config {
	return globalConfig
}

// Set sets the global configuration
func Set(config *Config) {
	globalConfig = config
}

################################################################################
# FILE: :\good projects\cost estimation\internal\errors\errors.go
# TYPE: go
# SIZE: 3810 bytes
################################################################################
// Package errors provides error handling utilities.
package errors

import (
	"fmt"
)

// Type identifies the category of error
type Type string

const (
	// TypeInput indicates an input validation error
	TypeInput Type = "INPUT_ERROR"

	// TypeParsing indicates a parsing error
	TypeParsing Type = "PARSING_ERROR"

	// TypePricing indicates a pricing resolution error
	TypePricing Type = "PRICING_ERROR"

	// TypePolicy indicates a policy evaluation error
	TypePolicy Type = "POLICY_ERROR"

	// TypeConfig indicates a configuration error
	TypeConfig Type = "CONFIG_ERROR"

	// TypeNetwork indicates a network error
	TypeNetwork Type = "NETWORK_ERROR"

	// TypeInternal indicates an internal error
	TypeInternal Type = "INTERNAL_ERROR"

	// TypeNotFound indicates a resource not found error
	TypeNotFound Type = "NOT_FOUND"

	// TypeNotSupported indicates an unsupported operation
	TypeNotSupported Type = "NOT_SUPPORTED"
)

// Error represents a domain error with context
type Error struct {
	Type    Type                   `json:"type"`
	Message string                 `json:"message"`
	Cause   error                  `json:"-"`
	Context map[string]interface{} `json:"context,omitempty"`
}

// Error implements the error interface
func (e *Error) Error() string {
	if e.Cause != nil {
		return fmt.Sprintf("[%s] %s: %v", e.Type, e.Message, e.Cause)
	}
	return fmt.Sprintf("[%s] %s", e.Type, e.Message)
}

// Unwrap returns the underlying error
func (e *Error) Unwrap() error {
	return e.Cause
}

// Is checks if the error is of a specific type
func (e *Error) Is(t Type) bool {
	return e.Type == t
}

// WithContext adds context to the error
func (e *Error) WithContext(key string, value interface{}) *Error {
	if e.Context == nil {
		e.Context = make(map[string]interface{})
	}
	e.Context[key] = value
	return e
}

// New creates a new error
func New(errType Type, message string) *Error {
	return &Error{
		Type:    errType,
		Message: message,
	}
}

// Newf creates a new formatted error
func Newf(errType Type, format string, args ...interface{}) *Error {
	return &Error{
		Type:    errType,
		Message: fmt.Sprintf(format, args...),
	}
}

// Wrap wraps an error with context
func Wrap(errType Type, message string, cause error) *Error {
	return &Error{
		Type:    errType,
		Message: message,
		Cause:   cause,
	}
}

// Wrapf wraps an error with formatted context
func Wrapf(errType Type, cause error, format string, args ...interface{}) *Error {
	return &Error{
		Type:    errType,
		Message: fmt.Sprintf(format, args...),
		Cause:   cause,
	}
}

// IsType checks if an error is of a specific type
func IsType(err error, t Type) bool {
	if e, ok := err.(*Error); ok {
		return e.Type == t
	}
	return false
}

// Input creates an input error
func Input(message string) *Error {
	return New(TypeInput, message)
}

// Parsing creates a parsing error
func Parsing(message string, cause error) *Error {
	return Wrap(TypeParsing, message, cause)
}

// Pricing creates a pricing error
func Pricing(message string, cause error) *Error {
	return Wrap(TypePricing, message, cause)
}

// Policy creates a policy error
func Policy(message string) *Error {
	return New(TypePolicy, message)
}

// NotFound creates a not found error
func NotFound(resourceType, identifier string) *Error {
	return Newf(TypeNotFound, "%s not found: %s", resourceType, identifier)
}

// NotSupported creates a not supported error
func NotSupported(operation string) *Error {
	return Newf(TypeNotSupported, "operation not supported: %s", operation)
}

// Internal creates an internal error
func Internal(message string, cause error) *Error {
	return Wrap(TypeInternal, message, cause)
}

################################################################################
# FILE: :\good projects\cost estimation\internal\logging\logging.go
# TYPE: go
# SIZE: 3090 bytes
################################################################################
// Package logging provides structured logging utilities.
package logging

import (
	"os"

	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

var (
	// Logger is the global logger instance
	Logger *zap.Logger

	// Sugar is the sugared logger for convenience
	Sugar *zap.SugaredLogger
)

// Config contains logging configuration
type Config struct {
	// Level is the minimum log level
	Level string `json:"level"`

	// Format is the output format (json, console)
	Format string `json:"format"`

	// Output is the output destination (stdout, stderr, file path)
	Output string `json:"output"`

	// Development enables development mode
	Development bool `json:"development"`
}

// DefaultConfig returns sensible defaults
func DefaultConfig() Config {
	return Config{
		Level:       "info",
		Format:      "console",
		Output:      "stderr",
		Development: false,
	}
}

// Initialize sets up the global logger
func Initialize(cfg Config) error {
	level, err := zapcore.ParseLevel(cfg.Level)
	if err != nil {
		level = zapcore.InfoLevel
	}

	var encoder zapcore.Encoder
	encoderConfig := zap.NewProductionEncoderConfig()
	encoderConfig.TimeKey = "timestamp"
	encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder

	if cfg.Format == "console" {
		encoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
		encoder = zapcore.NewConsoleEncoder(encoderConfig)
	} else {
		encoder = zapcore.NewJSONEncoder(encoderConfig)
	}

	var writeSyncer zapcore.WriteSyncer
	switch cfg.Output {
	case "stdout":
		writeSyncer = zapcore.AddSync(os.Stdout)
	case "stderr":
		writeSyncer = zapcore.AddSync(os.Stderr)
	default:
		file, err := os.OpenFile(cfg.Output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
		if err != nil {
			return err
		}
		writeSyncer = zapcore.AddSync(file)
	}

	core := zapcore.NewCore(encoder, writeSyncer, level)

	if cfg.Development {
		Logger = zap.New(core, zap.Development(), zap.AddCaller(), zap.AddStacktrace(zapcore.ErrorLevel))
	} else {
		Logger = zap.New(core, zap.AddCaller())
	}

	Sugar = Logger.Sugar()
	return nil
}

// InitializeDefault sets up the logger with default configuration
func InitializeDefault() {
	_ = Initialize(DefaultConfig())
}

// Sync flushes the logger
func Sync() {
	if Logger != nil {
		_ = Logger.Sync()
	}
}

// With returns a logger with additional fields
func With(fields ...zap.Field) *zap.Logger {
	return Logger.With(fields...)
}

// Debug logs at debug level
func Debug(msg string, fields ...zap.Field) {
	Logger.Debug(msg, fields...)
}

// Info logs at info level
func Info(msg string, fields ...zap.Field) {
	Logger.Info(msg, fields...)
}

// Warn logs at warn level
func Warn(msg string, fields ...zap.Field) {
	Logger.Warn(msg, fields...)
}

// Error logs at error level
func Error(msg string, fields ...zap.Field) {
	Logger.Error(msg, fields...)
}

// Fatal logs at fatal level and exits
func Fatal(msg string, fields ...zap.Field) {
	Logger.Fatal(msg, fields...)
}

func init() {
	InitializeDefault()
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\bad_configs\circular_dependency.tf
# TYPE: hcl
# SIZE: 606 bytes
################################################################################
# Bad Config: Circular dependency

resource "aws_security_group" "circular_a" {
  name   = "circular-a"
  vpc_id = "vpc-12345678"

  ingress {
    from_port       = 80
    to_port         = 80
    protocol        = "tcp"
    security_groups = [aws_security_group.circular_b.id]
  }
}

resource "aws_security_group" "circular_b" {
  name   = "circular-b"
  vpc_id = "vpc-12345678"

  ingress {
    from_port       = 443
    to_port         = 443
    protocol        = "tcp"
    security_groups = [aws_security_group.circular_a.id]
  }
}

# This will cause a Terraform cycle error

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\bad_configs\duplicate_resource.tf
# TYPE: hcl
# SIZE: 316 bytes
################################################################################
# Bad Config: Duplicate resource name

resource "aws_instance" "duplicate" {
  ami           = "ami-12345678"
  instance_type = "t3.micro"
}

# This would be a Terraform error - duplicate resource name
resource "aws_instance" "duplicate" {
  ami           = "ami-87654321"
  instance_type = "t3.small"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\bad_configs\invalid_for_each.tf
# TYPE: hcl
# SIZE: 341 bytes
################################################################################
# Bad Config: Invalid for_each (not map or set)

variable "instance_count" {
  type    = number
  default = 3
}

# for_each requires map or set, not number
resource "aws_instance" "invalid_for_each" {
  for_each = var.instance_count # ERROR: number is not valid

  ami           = "ami-12345678"
  instance_type = "t3.micro"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\bad_configs\missing_required.tf
# TYPE: hcl
# SIZE: 156 bytes
################################################################################
# Bad Config: Missing required attribute

resource "aws_instance" "missing_ami" {
  # Missing required 'ami' attribute
  instance_type = "t3.micro"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\bad_configs\syntax_error.tf
# TYPE: hcl
# SIZE: 195 bytes
################################################################################
# Bad Config: Syntax error

resource "aws_instance" "broken" {
  ami           = "ami-12345678"
  instance_type = "t3.micro"

  tags = {
    Name = "broken"
  # Missing closing brace
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\bad_configs\type_mismatch.tf
# TYPE: hcl
# SIZE: 548 bytes
################################################################################
# Bad Config: Type mismatch

variable "count_value" {
  type    = string  # Should be number
  default = "three" # Invalid for count
}

resource "aws_instance" "type_error" {
  count = var.count_value # ERROR: string to number

  ami           = "ami-12345678"
  instance_type = "t3.micro"
}

variable "for_each_value" {
  type    = number
  default = 5
}

resource "aws_instance" "for_each_error" {
  for_each = var.for_each_value # ERROR: number not valid

  ami           = "ami-12345678"
  instance_type = "t3.micro"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\basic\high_cost.tf
# TYPE: hcl
# SIZE: 1938 bytes
################################################################################
# Basic: High-cost infrastructure pattern

# NAT Gateways (expensive)
resource "aws_nat_gateway" "main" {
  count = 3

  allocation_id = "eipalloc-${count.index}"
  subnet_id     = "subnet-${count.index}"

  tags = {
    Name = "nat-${count.index}"
  }
}

# RDS Multi-AZ (expensive)
resource "aws_db_instance" "production" {
  identifier     = "production-db"
  engine         = "postgres"
  engine_version = "14"
  instance_class = "db.r6g.2xlarge"

  allocated_storage     = 500
  max_allocated_storage = 2000
  storage_type          = "io1"
  iops                  = 10000

  multi_az = true

  backup_retention_period = 30
  storage_encrypted       = true
}

# ElastiCache cluster (medium cost)
resource "aws_elasticache_replication_group" "main" {
  replication_group_id = "main-cache"
  description          = "Main cache cluster"

  node_type          = "cache.r6g.large"
  num_cache_clusters = 3
  engine             = "redis"
  engine_version     = "7.0"

  automatic_failover_enabled = true
  multi_az_enabled           = true
}

# EKS cluster (expensive with nodes)
resource "aws_eks_cluster" "main" {
  name     = "main-cluster"
  role_arn = "arn:aws:iam::123456789:role/eks-cluster-role"

  vpc_config {
    subnet_ids = ["subnet-1", "subnet-2", "subnet-3"]
  }
}

resource "aws_eks_node_group" "main" {
  cluster_name    = aws_eks_cluster.main.name
  node_group_name = "main-nodes"
  node_role_arn   = "arn:aws:iam::123456789:role/eks-node-role"
  subnet_ids      = ["subnet-1", "subnet-2", "subnet-3"]

  scaling_config {
    desired_size = 5
    max_size     = 10
    min_size     = 3
  }

  instance_types = ["m6i.2xlarge"]
}

# Kinesis (usage-based)
resource "aws_kinesis_stream" "events" {
  name             = "event-stream"
  shard_count      = 10
  retention_period = 168

  stream_mode_details {
    stream_mode = "PROVISIONED"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\basic\mixed_resources.tf
# TYPE: hcl
# SIZE: 1891 bytes
################################################################################
# Basic: Mixed resource types for cost estimation

# Compute
resource "aws_instance" "app" {
  count = 3

  ami           = "ami-12345678"
  instance_type = "t3.medium"

  root_block_device {
    volume_size = 30
    volume_type = "gp3"
  }

  tags = {
    Name = "app-${count.index}"
  }
}

# Database
resource "aws_db_instance" "main" {
  identifier     = "main-db"
  engine         = "postgres"
  engine_version = "14.8"
  instance_class = "db.t3.medium"

  allocated_storage     = 100
  max_allocated_storage = 500
  storage_type          = "gp3"

  db_name  = "appdb"
  username = "admin"
  password = "changeme123"

  multi_az            = true
  publicly_accessible = false

  backup_retention_period = 7

  tags = {
    Name = "main-database"
  }
}

# Storage
resource "aws_s3_bucket" "assets" {
  bucket = "my-app-assets-12345"
}

resource "aws_s3_bucket" "logs" {
  bucket = "my-app-logs-12345"
}

# Network
resource "aws_nat_gateway" "main" {
  allocation_id = "eipalloc-12345678"
  subnet_id     = "subnet-12345678"

  tags = {
    Name = "main-nat"
  }
}

resource "aws_lb" "app" {
  name               = "app-lb"
  internal           = false
  load_balancer_type = "application"
  subnets            = ["subnet-12345678", "subnet-87654321"]

  tags = {
    Name = "app-load-balancer"
  }
}

# Cache
resource "aws_elasticache_cluster" "session" {
  cluster_id      = "session-cache"
  engine          = "redis"
  node_type       = "cache.t3.micro"
  num_cache_nodes = 1
  port            = 6379
}

# Lambda
resource "aws_lambda_function" "processor" {
  function_name = "data-processor"
  role          = "arn:aws:iam::123456789:role/lambda-role"
  handler       = "index.handler"
  runtime       = "nodejs18.x"

  memory_size = 256
  timeout     = 30

  filename = "function.zip"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\basic\multiple_resources.tf
# TYPE: hcl
# SIZE: 925 bytes
################################################################################
# Basic Test: Multiple resource types

resource "aws_instance" "web" {
  ami           = "ami-12345678"
  instance_type = "t3.small"

  root_block_device {
    volume_size = 20
    volume_type = "gp3"
  }

  tags = {
    Name = "web-server"
  }
}

resource "aws_ebs_volume" "data" {
  availability_zone = "us-east-1a"
  size              = 100
  type              = "gp3"

  tags = {
    Name = "data-volume"
  }
}

resource "aws_volume_attachment" "data" {
  device_name = "/dev/sdf"
  volume_id   = aws_ebs_volume.data.id
  instance_id = aws_instance.web.id
}

resource "aws_s3_bucket" "logs" {
  bucket = "my-app-logs-bucket"
}

resource "aws_rds_instance" "db" {
  identifier     = "mydb"
  engine         = "mysql"
  engine_version = "8.0"
  instance_class = "db.t3.micro"

  allocated_storage = 20
  storage_type      = "gp2"

  tags = {
    Name = "app-database"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\basic\single_resource.tf
# TYPE: hcl
# SIZE: 225 bytes
################################################################################
# Basic Test: Simple single resource

resource "aws_instance" "simple" {
  ami           = "ami-12345678"
  instance_type = "t3.micro"

  tags = {
    Name        = "simple-instance"
    Environment = "test"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\dynamic_blocks\conditional_dynamic.tf
# TYPE: hcl
# SIZE: 1115 bytes
################################################################################
# Dynamic Block: Conditional dynamic block

variable "enable_logging" {
  type    = bool
  default = true
}

variable "access_logs_bucket" {
  type    = string
  default = "my-access-logs"
}

variable "enable_stickiness" {
  type    = bool
  default = false
}

resource "aws_lb" "conditional_dynamic" {
  name               = "conditional-lb"
  internal           = false
  load_balancer_type = "application"
  subnets            = ["subnet-12345678", "subnet-87654321"]

  # Conditional dynamic block for access logs
  dynamic "access_logs" {
    for_each = var.enable_logging ? [1] : []
    content {
      bucket  = var.access_logs_bucket
      prefix  = "lb-logs"
      enabled = true
    }
  }
}

resource "aws_lb_target_group" "conditional" {
  name     = "conditional-tg"
  port     = 80
  protocol = "HTTP"
  vpc_id   = "vpc-12345678"

  # Conditional stickiness
  dynamic "stickiness" {
    for_each = var.enable_stickiness ? [1] : []
    content {
      type            = "lb_cookie"
      cookie_duration = 86400
      enabled         = true
    }
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\dynamic_blocks\multiple_dynamic.tf
# TYPE: hcl
# SIZE: 1704 bytes
################################################################################
# Dynamic Blocks: Multiple dynamic blocks in one resource

variable "ingress_rules" {
  type = list(object({
    from_port   = number
    to_port     = number
    protocol    = string
    cidr_blocks = list(string)
    description = string
  }))
  default = [
    {
      from_port   = 80
      to_port     = 80
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
      description = "HTTP"
    },
    {
      from_port   = 443
      to_port     = 443
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
      description = "HTTPS"
    }
  ]
}

variable "egress_rules" {
  type = list(object({
    from_port   = number
    to_port     = number
    protocol    = string
    cidr_blocks = list(string)
  }))
  default = [
    {
      from_port   = 0
      to_port     = 0
      protocol    = "-1"
      cidr_blocks = ["0.0.0.0/0"]
    }
  ]
}

resource "aws_security_group" "multi_dynamic" {
  name        = "multi-dynamic-sg"
  description = "Security group with multiple dynamic blocks"
  vpc_id      = "vpc-12345678"

  dynamic "ingress" {
    for_each = var.ingress_rules
    content {
      from_port   = ingress.value.from_port
      to_port     = ingress.value.to_port
      protocol    = ingress.value.protocol
      cidr_blocks = ingress.value.cidr_blocks
      description = ingress.value.description
    }
  }

  dynamic "egress" {
    for_each = var.egress_rules
    content {
      from_port   = egress.value.from_port
      to_port     = egress.value.to_port
      protocol    = egress.value.protocol
      cidr_blocks = egress.value.cidr_blocks
    }
  }

  tags = {
    Name = "multi-dynamic"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\dynamic_blocks\nested_dynamic.tf
# TYPE: hcl
# SIZE: 1438 bytes
################################################################################
# Dynamic Block Test: Nested dynamic blocks

variable "load_balancer_config" {
  type = object({
    listeners = list(object({
      port     = number
      protocol = string
      rules = list(object({
        path    = string
        backend = string
      }))
    }))
  })
  default = {
    listeners = [
      {
        port     = 80
        protocol = "HTTP"
        rules = [
          { path = "/api", backend = "api-backend" },
          { path = "/web", backend = "web-backend" }
        ]
      },
      {
        port     = 443
        protocol = "HTTPS"
        rules = [
          { path = "/api", backend = "api-backend" },
          { path = "/admin", backend = "admin-backend" }
        ]
      }
    ]
  }
}

resource "aws_lb_listener" "main" {
  load_balancer_arn = "arn:aws:elasticloadbalancing:us-east-1:123456789:loadbalancer/app/main/abc123"

  dynamic "listener" {
    for_each = var.load_balancer_config.listeners
    content {
      port     = listener.value.port
      protocol = listener.value.protocol

      dynamic "action" {
        for_each = listener.value.rules
        content {
          type = "forward"

          forward {
            target_group_arn = action.value.backend
          }

          condition {
            path_pattern {
              values = [action.value.path]
            }
          }
        }
      }
    }
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\dynamic_blocks\single_dynamic.tf
# TYPE: hcl
# SIZE: 1055 bytes
################################################################################
# Dynamic Block Test: Single dynamic block

variable "ingress_rules" {
  type = list(object({
    port        = number
    protocol    = string
    cidr_blocks = list(string)
  }))
  default = [
    {
      port        = 80
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    },
    {
      port        = 443
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    },
    {
      port        = 22
      protocol    = "tcp"
      cidr_blocks = ["10.0.0.0/8"]
    }
  ]
}

resource "aws_security_group" "example" {
  name        = "dynamic-sg"
  description = "Security group with dynamic blocks"
  vpc_id      = "vpc-12345678"

  dynamic "ingress" {
    for_each = var.ingress_rules
    content {
      from_port   = ingress.value.port
      to_port     = ingress.value.port
      protocol    = ingress.value.protocol
      cidr_blocks = ingress.value.cidr_blocks
    }
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\circular_reference.tf
# TYPE: hcl
# SIZE: 633 bytes
################################################################################
# Edge Case: Circular reference between resources

resource "aws_security_group" "sg_a" {
  name        = "sg-a"
  description = "Security group A"
  vpc_id      = "vpc-12345678"

  ingress {
    from_port       = 80
    to_port         = 80
    protocol        = "tcp"
    security_groups = [aws_security_group.sg_b.id]
  }
}

resource "aws_security_group" "sg_b" {
  name        = "sg-b"
  description = "Security group B"
  vpc_id      = "vpc-12345678"

  ingress {
    from_port       = 443
    to_port         = 443
    protocol        = "tcp"
    security_groups = [aws_security_group.sg_a.id]
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\complex_locals.tf
# TYPE: hcl
# SIZE: 1283 bytes
################################################################################
# Edge Case: Local values with complex expressions

locals {
  # Nested locals referencing each other
  base_name = "myapp"
  env       = "production"
  full_name = "${local.base_name}-${local.env}"

  # Complex conditional
  instance_size = local.env == "production" ? (
    local.high_availability ? "large" : "medium"
  ) : "small"

  high_availability = local.env == "production"

  # Map transformation
  raw_instances = {
    web    = { count = 3, type = "t3.small" }
    api    = { count = 2, type = "t3.medium" }
    worker = { count = 1, type = "t3.large" }
  }

  # Flatten for iteration
  instance_list = flatten([
    for name, config in local.raw_instances : [
      for i in range(config.count) : {
        name = "${name}-${i}"
        type = config.type
        role = name
      }
    ]
  ])

  # Map by name
  instance_map = {
    for inst in local.instance_list :
    inst.name => inst
  }

  # Sum of counts
  total_instances = sum([for k, v in local.raw_instances : v.count])
}

resource "aws_instance" "from_locals" {
  for_each = local.instance_map

  ami           = "ami-12345678"
  instance_type = each.value.type

  tags = {
    Name = "${local.full_name}-${each.key}"
    Role = each.value.role
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\conditional_resource.tf
# TYPE: hcl
# SIZE: 642 bytes
################################################################################
# Edge Case: Conditional resource (count 0 or 1)

variable "create_instance" {
  type    = bool
  default = true
}

variable "create_bucket" {
  type    = bool
  default = false
}

resource "aws_instance" "conditional" {
  count = var.create_instance ? 1 : 0

  ami           = "ami-12345678"
  instance_type = "t3.micro"
}

resource "aws_s3_bucket" "conditional" {
  count = var.create_bucket ? 1 : 0

  bucket = "my-conditional-bucket"
}

# Resource that depends on conditional resource
resource "aws_eip" "instance_eip" {
  count    = var.create_instance ? 1 : 0
  instance = aws_instance.conditional[0].id
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\data_source_dependency.tf
# TYPE: hcl
# SIZE: 651 bytes
################################################################################
# Edge Case: Data source dependency

data "aws_ami" "latest" {
  most_recent = true

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }

  owners = ["amazon"]
}

data "aws_vpc" "selected" {
  default = true
}

data "aws_availability_zones" "available" {
  state = "available"
}

resource "aws_instance" "from_data" {
  ami               = data.aws_ami.latest.id
  instance_type     = "t3.micro"
  availability_zone = data.aws_availability_zones.available.names[0]

  vpc_security_group_ids = [data.aws_vpc.selected.default_security_group_id]

  tags = {
    Name = "from-data-sources"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\lifecycle.tf
# TYPE: hcl
# SIZE: 553 bytes
################################################################################
# Edge Case: Lifecycle with create_before_destroy

resource "aws_instance" "lifecycle_test" {
  ami           = "ami-12345678"
  instance_type = "t3.micro"

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = false
    ignore_changes        = [tags, user_data]
  }

  tags = {
    Name = "lifecycle-test"
  }
}

resource "aws_launch_template" "lifecycle" {
  name_prefix   = "lifecycle-"
  instance_type = "t3.micro"
  image_id      = "ami-12345678"

  lifecycle {
    create_before_destroy = true
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\moved_import.tf
# TYPE: hcl
# SIZE: 462 bytes
################################################################################
# Edge Case: Resource moved block

# Simulate state moves
moved {
  from = aws_instance.old_name
  to   = aws_instance.new_name
}

resource "aws_instance" "new_name" {
  ami           = "ami-12345678"
  instance_type = "t3.micro"

  tags = {
    Name = "renamed-instance"
  }
}

# Import block
import {
  to = aws_s3_bucket.imported
  id = "my-existing-bucket"
}

resource "aws_s3_bucket" "imported" {
  bucket = "my-existing-bucket"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\null_optional.tf
# TYPE: hcl
# SIZE: 917 bytes
################################################################################
# Edge Case: Null values and optionals

variable "optional_config" {
  type = object({
    enabled       = optional(bool, false)
    instance_type = optional(string)
    volume_size   = optional(number, 20)
  })
  default = {}
}

variable "nullable_string" {
  type    = string
  default = null
}

resource "aws_instance" "optional_test" {
  count = var.optional_config.enabled ? 1 : 0

  ami           = "ami-12345678"
  instance_type = coalesce(var.optional_config.instance_type, "t3.micro")

  root_block_device {
    volume_size = var.optional_config.volume_size
  }

  # Using try() for safe access
  user_data = try(var.nullable_string, "default-user-data")

  tags = {
    Name = "optional-test"
  }
}

# Null resource for testing
resource "null_resource" "example" {
  count = var.nullable_string != null ? 1 : 0

  triggers = {
    value = var.nullable_string
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\self_reference.tf
# TYPE: hcl
# SIZE: 239 bytes
################################################################################
# Edge Case: Self-referencing count

resource "aws_instance" "self_ref" {
  count = length(aws_instance.self_ref) > 0 ? 2 : 1 # This is invalid but should be handled

  ami           = "ami-12345678"
  instance_type = "t3.micro"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\sensitive_values.tf
# TYPE: hcl
# SIZE: 721 bytes
################################################################################
# Edge Case: Sensitive values

variable "db_password" {
  type      = string
  sensitive = true
}

variable "api_key" {
  type      = string
  sensitive = true
  default   = "default-key"
}

resource "aws_db_instance" "sensitive" {
  identifier     = "sensitive-db"
  engine         = "mysql"
  instance_class = "db.t3.micro"

  username = "admin"
  password = var.db_password # Sensitive

  tags = {
    Name = "sensitive-db"
  }
}

resource "aws_secretsmanager_secret" "api" {
  name = "api-credentials"
}

resource "aws_secretsmanager_secret_version" "api" {
  secret_id = aws_secretsmanager_secret.api.id
  secret_string = jsonencode({
    api_key = var.api_key # Sensitive
  })
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\splat_expression.tf
# TYPE: hcl
# SIZE: 790 bytes
################################################################################
# Edge Case: Splat expression and resource references

variable "instance_count" {
  type    = number
  default = 3
}

resource "aws_instance" "cluster" {
  count = var.instance_count

  ami           = "ami-12345678"
  instance_type = "t3.micro"

  tags = {
    Name = "cluster-${count.index}"
  }
}

# Using splat expression
resource "aws_lb_target_group_attachment" "cluster" {
  count = var.instance_count

  target_group_arn = "arn:aws:elasticloadbalancing:us-east-1:123456789:targetgroup/main/abc123"
  target_id        = aws_instance.cluster[count.index].id
  port             = 80
}

# Using splat to get all IDs
output "instance_ids" {
  value = aws_instance.cluster[*].id
}

output "private_ips" {
  value = aws_instance.cluster[*].private_ip
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\terraform_functions.tf
# TYPE: hcl
# SIZE: 974 bytes
################################################################################
# Edge Case: Terraform functions in expressions

locals {
  environment = "production"

  # String functions
  upper_env = upper(local.environment)
  lower_env = lower(local.environment)

  # Collection functions
  instance_types = ["t3.micro", "t3.small", "t3.medium"]
  first_type     = element(local.instance_types, 0)
  type_count     = length(local.instance_types)

  # Numeric functions
  max_cpu = max(2, 4, 8)
  min_cpu = min(2, 4, 8)

  # Conditional
  instance_type = local.environment == "production" ? "t3.large" : "t3.micro"

  # Map functions
  tags = merge(
    {
      Environment = local.environment
    },
    {
      ManagedBy = "terraform"
    }
  )

  # Encoding
  encoded = base64encode("hello world")
}

resource "aws_instance" "with_functions" {
  ami           = "ami-12345678"
  instance_type = local.instance_type

  tags = merge(local.tags, {
    Name = format("web-%s-%d", local.environment, 1)
  })
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\unknown_count.tf
# TYPE: hcl
# SIZE: 280 bytes
################################################################################
# Edge Case: Unknown count value

variable "count_from_external" {
  type = number
  # No default - must be provided
}

resource "aws_instance" "unknown_count" {
  count         = var.count_from_external
  ami           = "ami-12345678"
  instance_type = "t3.micro"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\workspaces.tf
# TYPE: hcl
# SIZE: 901 bytes
################################################################################
# Edge Case: Terraform workspaces

terraform {
  backend "s3" {
    bucket         = "terraform-state"
    key            = "app/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "terraform-locks"
  }
}

locals {
  workspace_config = {
    default = {
      instance_type  = "t3.micro"
      instance_count = 1
    }
    staging = {
      instance_type  = "t3.small"
      instance_count = 2
    }
    production = {
      instance_type  = "t3.medium"
      instance_count = 3
    }
  }

  current_config = local.workspace_config[terraform.workspace]
}

resource "aws_instance" "app" {
  count = local.current_config.instance_count

  ami           = "ami-12345678"
  instance_type = local.current_config.instance_type

  tags = {
    Name        = "app-${terraform.workspace}-${count.index}"
    Environment = terraform.workspace
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\complex_for_each.tf
# TYPE: hcl
# SIZE: 1958 bytes
################################################################################
# Expansion: Complex for_each with nested objects

variable "services" {
  type = map(object({
    cpu         = number
    memory      = number
    ports       = list(number)
    replicas    = number
    environment = map(string)
  }))
  default = {
    api = {
      cpu      = 256
      memory   = 512
      ports    = [8080]
      replicas = 3
      environment = {
        NODE_ENV  = "production"
        LOG_LEVEL = "info"
      }
    }
    worker = {
      cpu      = 512
      memory   = 1024
      ports    = []
      replicas = 2
      environment = {
        QUEUE_URL = "https://sqs.example.com"
      }
    }
    scheduler = {
      cpu         = 128
      memory      = 256
      ports       = []
      replicas    = 1
      environment = {}
    }
  }
}

resource "aws_ecs_task_definition" "services" {
  for_each = var.services

  family                   = each.key
  requires_compatibilities = ["FARGATE"]
  network_mode             = "awsvpc"
  cpu                      = each.value.cpu
  memory                   = each.value.memory

  container_definitions = jsonencode([{
    name      = each.key
    image     = "my-app/${each.key}:latest"
    cpu       = each.value.cpu
    memory    = each.value.memory
    essential = true

    portMappings = [
      for port in each.value.ports : {
        containerPort = port
        hostPort      = port
        protocol      = "tcp"
      }
    ]

    environment = [
      for k, v in each.value.environment : {
        name  = k
        value = v
      }
    ]
  }])
}

resource "aws_ecs_service" "services" {
  for_each = var.services

  name            = each.key
  cluster         = "main-cluster"
  task_definition = aws_ecs_task_definition.services[each.key].arn
  desired_count   = each.value.replicas
  launch_type     = "FARGATE"

  network_configuration {
    subnets = ["subnet-12345678"]
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\count_from_length.tf
# TYPE: hcl
# SIZE: 898 bytes
################################################################################
# Expansion: count depending on length of list

variable "subnets" {
  type = list(object({
    cidr = string
    az   = string
  }))
  default = [
    { cidr = "10.0.1.0/24", az = "us-east-1a" },
    { cidr = "10.0.2.0/24", az = "us-east-1b" },
    { cidr = "10.0.3.0/24", az = "us-east-1c" }
  ]
}

resource "aws_subnet" "from_list" {
  count = length(var.subnets)

  vpc_id            = "vpc-12345678"
  cidr_block        = var.subnets[count.index].cidr
  availability_zone = var.subnets[count.index].az

  tags = {
    Name  = "subnet-${count.index}"
    Index = count.index
  }
}

# Instance per subnet
resource "aws_instance" "per_subnet" {
  count = length(aws_subnet.from_list)

  ami           = "ami-12345678"
  instance_type = "t3.micro"
  subnet_id     = aws_subnet.from_list[count.index].id

  tags = {
    Name = "instance-${count.index}"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\count_variable.tf
# TYPE: hcl
# SIZE: 309 bytes
################################################################################
# Expansion Test: count from variable

variable "instance_count" {
  type    = number
  default = 3
}

resource "aws_instance" "counted" {
  count         = var.instance_count
  ami           = "ami-12345678"
  instance_type = "t3.micro"

  tags = {
    Name = "instance-${count.index}"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\count_zero.tf
# TYPE: hcl
# SIZE: 168 bytes
################################################################################
# Expansion Test: count=0 produces nothing

resource "aws_instance" "zero" {
  count         = 0
  ami           = "ami-12345678"
  instance_type = "t3.micro"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\for_each_fileset.tf
# TYPE: hcl
# SIZE: 672 bytes
################################################################################
# Expansion: for_each with fileset

resource "aws_s3_object" "configs" {
  for_each = fileset("${path.module}/configs", "*.json")

  bucket = "my-config-bucket"
  key    = "configs/${each.value}"
  source = "${path.module}/configs/${each.value}"

  etag = filemd5("${path.module}/configs/${each.value}")
}

resource "aws_lambda_function" "handlers" {
  for_each = fileset("${path.module}/lambdas", "*/handler.py")

  function_name = replace(dirname(each.value), "/", "-")
  role          = "arn:aws:iam::123456789:role/lambda-role"
  handler       = "handler.main"
  runtime       = "python3.9"

  filename = "${path.module}/lambdas/${each.value}"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\for_each_map.tf
# TYPE: hcl
# SIZE: 678 bytes
################################################################################
# Expansion Test: for_each with map

variable "instances" {
  type = map(object({
    instance_type = string
    ami           = string
  }))
  default = {
    web = {
      instance_type = "t3.small"
      ami           = "ami-web12345"
    }
    api = {
      instance_type = "t3.medium"
      ami           = "ami-api12345"
    }
    worker = {
      instance_type = "t3.large"
      ami           = "ami-wrk12345"
    }
  }
}

resource "aws_instance" "multi" {
  for_each      = var.instances
  ami           = each.value.ami
  instance_type = each.value.instance_type

  tags = {
    Name = "instance-${each.key}"
    Role = each.key
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\for_each_set.tf
# TYPE: hcl
# SIZE: 712 bytes
################################################################################
# Expansion Test: for_each with set of strings

variable "availability_zones" {
  type    = set(string)
  default = ["us-east-1a", "us-east-1b", "us-east-1c"]
}

resource "aws_subnet" "main" {
  for_each = var.availability_zones

  vpc_id            = "vpc-12345678"
  cidr_block        = "10.0.${index(tolist(var.availability_zones), each.value)}.0/24"
  availability_zone = each.value

  tags = {
    Name = "subnet-${each.value}"
  }
}

# Resources using the subnets
resource "aws_instance" "per_az" {
  for_each = aws_subnet.main

  ami           = "ami-12345678"
  instance_type = "t3.micro"
  subnet_id     = each.value.id

  tags = {
    Name = "instance-${each.key}"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\for_each_toset.tf
# TYPE: hcl
# SIZE: 552 bytes
################################################################################
# Expansion: for_each with toset() conversion

variable "bucket_names" {
  type    = list(string)
  default = ["logs", "data", "backups", "archives"]
}

resource "aws_s3_bucket" "buckets" {
  for_each = toset(var.bucket_names)

  bucket = "${each.value}-bucket-12345"

  tags = {
    Name    = each.value
    Purpose = each.key
  }
}

# Dependent resource
resource "aws_s3_bucket_versioning" "buckets" {
  for_each = aws_s3_bucket.buckets

  bucket = each.value.id

  versioning_configuration {
    status = "Enabled"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\nested_count_for_each.tf
# TYPE: hcl
# SIZE: 857 bytes
################################################################################
# Expansion Test: Nested count inside for_each

variable "environments" {
  type = map(object({
    replica_count = number
  }))
  default = {
    dev     = { replica_count = 1 }
    staging = { replica_count = 2 }
    prod    = { replica_count = 3 }
  }
}

# Outer for_each
resource "aws_db_instance" "primary" {
  for_each = var.environments

  identifier     = "${each.key}-db-primary"
  engine         = "mysql"
  instance_class = each.key == "prod" ? "db.r5.large" : "db.t3.micro"

  tags = {
    Environment = each.key
    Role        = "primary"
  }
}

# This pattern (count inside module with for_each) is common
module "db_replicas" {
  source   = "./replica"
  for_each = var.environments

  count       = each.value.replica_count
  primary_id  = aws_db_instance.primary[each.key].id
  environment = each.key
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\triple_nested.tf
# TYPE: hcl
# SIZE: 1497 bytes
################################################################################
# Expansion: Triple nested for_each/count

variable "regions" {
  type = map(object({
    availability_zones = list(string)
    instance_per_az    = number
  }))
  default = {
    us-east-1 = {
      availability_zones = ["us-east-1a", "us-east-1b"]
      instance_per_az    = 2
    }
    us-west-2 = {
      availability_zones = ["us-west-2a"]
      instance_per_az    = 3
    }
  }
}

# Level 1: for_each on regions
module "regional" {
  source   = "./regional"
  for_each = var.regions

  region             = each.key
  availability_zones = each.value.availability_zones
  instance_per_az    = each.value.instance_per_az
}

# Simulating what the regional module might contain:
# Level 2: for_each on AZs (conceptually)
# Level 3: count on instances per AZ

# This flattening pattern is common
locals {
  all_instances = flatten([
    for region, config in var.regions : [
      for az in config.availability_zones : [
        for i in range(config.instance_per_az) : {
          region = region
          az     = az
          index  = i
          name   = "${region}-${az}-${i}"
        }
      ]
    ]
  ])
}

resource "aws_instance" "triple_nested" {
  for_each = { for inst in local.all_instances : inst.name => inst }

  ami               = "ami-12345678"
  instance_type     = "t3.micro"
  availability_zone = each.value.az

  tags = {
    Name   = each.key
    Region = each.value.region
    Index  = each.value.index
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\modules\local_module.tf
# TYPE: hcl
# SIZE: 305 bytes
################################################################################
# Module Test: Local module with count

variable "app_count" {
  type    = number
  default = 2
}

module "app" {
  source = "./app"
  count  = var.app_count

  name          = "app-${count.index}"
  instance_type = "t3.micro"
}

output "app_ids" {
  value = module.app[*].instance_id
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\modules\module_count.tf
# TYPE: hcl
# SIZE: 813 bytes
################################################################################
# Module: Passing count to module

variable "create_vpc" {
  type    = bool
  default = true
}

module "vpc" {
  source = "./vpc"
  count  = var.create_vpc ? 1 : 0

  cidr_block = "10.0.0.0/16"
  name       = "main-vpc"
}

# Accessing module with count
resource "aws_subnet" "public" {
  count = var.create_vpc ? 2 : 0

  vpc_id     = module.vpc[0].vpc_id
  cidr_block = "10.0.${count.index}.0/24"

  tags = {
    Name = "public-${count.index}"
  }
}

# Module with count creating multiple modules
variable "environment_count" {
  type    = number
  default = 3
}

module "environment" {
  source = "./environment"
  count  = var.environment_count

  name  = "env-${count.index}"
  index = count.index
}

output "environment_ids" {
  value = module.environment[*].id
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\modules\module_with_outputs.tf
# TYPE: hcl
# SIZE: 942 bytes
################################################################################
# Module: Module with outputs that reference each other

variable "name" {
  type    = string
  default = "test"
}

resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"

  tags = {
    Name = "${var.name}-vpc"
  }
}

resource "aws_subnet" "public" {
  count = 2

  vpc_id     = aws_vpc.main.id
  cidr_block = "10.0.${count.index}.0/24"

  tags = {
    Name = "${var.name}-public-${count.index}"
  }
}

resource "aws_subnet" "private" {
  count = 2

  vpc_id     = aws_vpc.main.id
  cidr_block = "10.0.${count.index + 10}.0/24"

  tags = {
    Name = "${var.name}-private-${count.index}"
  }
}

output "vpc_id" {
  value = aws_vpc.main.id
}

output "public_subnet_ids" {
  value = aws_subnet.public[*].id
}

output "private_subnet_ids" {
  value = aws_subnet.private[*].id
}

output "all_subnet_ids" {
  value = concat(
    aws_subnet.public[*].id,
    aws_subnet.private[*].id
  )
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\modules\nested_modules.tf
# TYPE: hcl
# SIZE: 645 bytes
################################################################################
# Module Test: Nested module with for_each

variable "environments" {
  type = map(object({
    instance_count = number
    instance_type  = string
  }))
  default = {
    dev = {
      instance_count = 1
      instance_type  = "t3.micro"
    }
    staging = {
      instance_count = 2
      instance_type  = "t3.small"
    }
    prod = {
      instance_count = 3
      instance_type  = "t3.medium"
    }
  }
}

module "environment" {
  source   = "./environment"
  for_each = var.environments

  name           = each.key
  instance_count = each.value.instance_count
  instance_type  = each.value.instance_type
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\providers\alias_basic.tf
# TYPE: hcl
# SIZE: 646 bytes
################################################################################
# Provider Test: Multiple regions with aliases

provider "aws" {
  region = "us-east-1"
}

provider "aws" {
  alias  = "west"
  region = "us-west-2"
}

provider "aws" {
  alias  = "eu"
  region = "eu-west-1"
}

resource "aws_instance" "east" {
  ami           = "ami-east12345"
  instance_type = "t3.micro"

  tags = {
    Region = "us-east-1"
  }
}

resource "aws_instance" "west" {
  provider      = aws.west
  ami           = "ami-west12345"
  instance_type = "t3.micro"

  tags = {
    Region = "us-west-2"
  }
}

resource "aws_s3_bucket" "eu_bucket" {
  provider = aws.eu
  bucket   = "my-eu-bucket"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\providers\alias_module_inherit.tf
# TYPE: hcl
# SIZE: 346 bytes
################################################################################
# Provider Test: Module inheriting provider alias

provider "aws" {
  region = "us-east-1"
}

provider "aws" {
  alias  = "west"
  region = "us-west-2"
}

module "app_east" {
  source = "./app"

  name = "app-east"
}

module "app_west" {
  source = "./app"

  providers = {
    aws = aws.west
  }

  name = "app-west"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\providers\multi_region_modules.tf
# TYPE: hcl
# SIZE: 899 bytes
################################################################################
# Module: Passing providers to module

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  alias  = "primary"
  region = "us-east-1"
}

provider "aws" {
  alias  = "dr"
  region = "us-west-2"
}

module "primary_infra" {
  source = "./infra"

  providers = {
    aws = aws.primary
  }

  environment = "primary"
  vpc_cidr    = "10.0.0.0/16"
}

module "dr_infra" {
  source = "./infra"

  providers = {
    aws = aws.dr
  }

  environment = "dr"
  vpc_cidr    = "10.1.0.0/16"
}

# Cross-region peering would reference both
resource "aws_vpc_peering_connection" "primary_to_dr" {
  provider = aws.primary

  vpc_id      = module.primary_infra.vpc_id
  peer_vpc_id = module.dr_infra.vpc_id
  peer_region = "us-west-2"

  tags = {
    Name = "primary-to-dr"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\providers\multiple_same_type.tf
# TYPE: hcl
# SIZE: 1433 bytes
################################################################################
# Providers: Multiple providers same type

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# Default provider
provider "aws" {
  region = "us-east-1"

  default_tags {
    tags = {
      Environment = "production"
      ManagedBy   = "terraform"
    }
  }
}

# Alternative region
provider "aws" {
  alias  = "west"
  region = "us-west-2"

  default_tags {
    tags = {
      Environment = "production"
      ManagedBy   = "terraform"
    }
  }
}

# Cross-account
provider "aws" {
  alias  = "shared"
  region = "us-east-1"

  assume_role {
    role_arn = "arn:aws:iam::987654321:role/terraform-cross-account"
  }
}

# Resources using different providers
resource "aws_s3_bucket" "primary" {
  bucket = "primary-bucket-12345"
}

resource "aws_s3_bucket" "west" {
  provider = aws.west
  bucket   = "west-bucket-12345"
}

resource "aws_s3_bucket" "shared" {
  provider = aws.shared
  bucket   = "shared-bucket-12345"
}

# Replication between regions
resource "aws_s3_bucket_replication_configuration" "primary_to_west" {
  bucket = aws_s3_bucket.primary.id
  role   = "arn:aws:iam::123456789:role/replication-role"

  rule {
    id     = "replicate-to-west"
    status = "Enabled"

    destination {
      bucket        = aws_s3_bucket.west.arn
      storage_class = "STANDARD"
    }
  }
}

################################################################################
#                              END OF FILE                                     #
################################################################################

================================================================================
                                SUMMARY
================================================================================

Total Files Combined: 150
Generated: 2026-01-16 14:06:12
Project: cost estimation

Files by Type:  .go : 98 files
  .tf : 46 files
  .md : 1 files
  .mod : 1 files
  (no extension) : 1 files
  .gitignore : 1 files
  .ps1 : 1 files
  .yml : 1 files

================================================================================
