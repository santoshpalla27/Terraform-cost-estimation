################################################################################
#                                                                              #
#                    TERRAFORM COST ESTIMATION SYSTEM                          #
#                         Combined Source Code                                 #
#                                                                              #
#                    Generated: 2026-01-16 00:49:23                          #
#                                                                              #
################################################################################

================================================================================
                           DIRECTORY STRUCTURE
================================================================================
cost estimation/
|-- adapters/
|   |-- cli/
|   |   +-- adapter.go
|   |-- git/
|   |-- terraform/
|   |   |-- hcl/
|   |   |   +-- scanner.go
|   |   +-- plan/
|   +-- terragrunt/
|-- api/
|   +-- handlers/
|-- clouds/
|   |-- aws/
|   |   |-- assets/
|   |   |   |-- compute.go
|   |   |   |-- database.go
|   |   |   |-- ec2.go
|   |   |   |-- network.go
|   |   |   |-- other.go
|   |   |   +-- storage.go
|   |   |-- pricing/
|   |   |   +-- source.go
|   |   |-- usage/
|   |   |   +-- estimators.go
|   |   +-- plugin.go
|   |-- azure/
|   |-- gcp/
|   +-- registry.go
|-- cmd/
|   |-- cli/
|   |   |-- cmd/
|   |   |   |-- estimate.go
|   |   |   +-- root.go
|   |   +-- main.go
|   +-- server/
|-- core/
|   |-- asset/
|   |   |-- builder.go
|   |   +-- registry.go
|   |-- cost/
|   |   +-- engine.go
|   |-- detection/
|   |   +-- detector.go
|   |-- determinism/
|   |   +-- stable.go
|   |-- engine/
|   |   +-- engine.go
|   |-- expansion/
|   |   |-- expander.go
|   |   +-- expander_test.go
|   |-- expression/
|   |   |-- context.go
|   |   |-- reference.go
|   |   +-- value.go
|   |-- model/
|   |   +-- definition.go
|   |-- output/
|   |   |-- formats/
|   |   +-- formatter.go
|   |-- policy/
|   |   |-- deep_policy.go
|   |   |-- evaluator.go
|   |   +-- full_lineage.go
|   |-- pricing/
|   |   |-- enforcer.go
|   |   |-- resolver.go
|   |   +-- snapshot.go
|   |-- scanner/
|   |   |-- registry.go
|   |   +-- scanner.go
|   |-- terraform/
|   |   |-- dependencies.go
|   |   |-- dynamic.go
|   |   |-- pipeline.go
|   |   |-- provider.go
|   |   |-- strict_unknown.go
|   |   +-- unknown.go
|   |-- types/
|   |   |-- asset.go
|   |   |-- cost.go
|   |   |-- pricing.go
|   |   |-- project.go
|   |   |-- types.go
|   |   +-- usage.go
|   +-- usage/
|       |-- estimator.go
|       +-- registry.go
|-- examples/
|   +-- aws-simple/
|       +-- main.tf
|-- internal/
|   |-- config/
|   |   +-- config.go
|   |-- errors/
|   |   +-- errors.go
|   +-- logging/
|       +-- logging.go
|-- pkg/
|   +-- client/
|-- storage/
|   |-- estimates/
|   +-- pricing/
|-- testdata/
|   |-- expected_outputs/
|   |-- pricing/
|   |   +-- snapshots/
|   +-- terraform/
|       |-- bad_configs/
|       |   |-- missing_required.tf
|       |   +-- syntax_error.tf
|       |-- basic/
|       |   |-- multiple_resources.tf
|       |   +-- single_resource.tf
|       |-- dynamic_blocks/
|       |   |-- nested_dynamic.tf
|       |   +-- single_dynamic.tf
|       |-- edge_cases/
|       |   |-- circular_reference.tf
|       |   |-- conditional_resource.tf
|       |   |-- self_reference.tf
|       |   +-- unknown_count.tf
|       |-- expansion/
|       |   |-- count_variable.tf
|       |   |-- count_zero.tf
|       |   |-- for_each_map.tf
|       |   |-- for_each_set.tf
|       |   +-- nested_count_for_each.tf
|       |-- modules/
|       |   |-- local_module.tf
|       |   +-- nested_modules.tf
|       +-- providers/
|           |-- alias_basic.tf
|           +-- alias_module_inherit.tf
|-- .gitignore
|-- combine-code.ps1
|-- docker-compose.yml
|-- Dockerfile
|-- go.mod
|-- go.sum
|-- infracost-code.txt
+-- README.md

================================================================================
                              SOURCE FILES
================================================================================

################################################################################
# FILE: :\good projects\cost estimation\.gitignore
# TYPE: text
# SIZE: 2585 bytes
################################################################################
# =========================
# Go
# =========================
# Binaries
*.exe
*.exe~
*.dll
*.so
*.dylib
terraform-cost
terraform-cost-server

# Test binary
*.test

# Output of go coverage tool
*.out

# Go workspace file
go.work

# Vendor directory (if not using modules)
# vendor/

# =========================
# IDE / Editor
# =========================
# VS Code
.vscode/
*.code-workspace

# JetBrains (GoLand, IntelliJ)
.idea/
*.iml
*.iws
*.ipr

# Vim
*.swp
*.swo
*~

# Emacs
*~
\#*\#
/.emacs.desktop
/.emacs.desktop.lock
*.elc

# Sublime Text
*.sublime-workspace
*.sublime-project

# =========================
# OS Generated
# =========================
# macOS
.DS_Store
.AppleDouble
.LSOverride
._*
.Spotlight-V100
.Trashes

# Windows
Thumbs.db
Thumbs.db:encryptable
ehthumbs.db
ehthumbs_vista.db
*.stackdump
Desktop.ini
$RECYCLE.BIN/
*.lnk

# Linux
*~

# =========================
# Terraform (test files)
# =========================
*.tfstate
*.tfstate.*
*.tfstate.backup
.terraform/
.terraform.lock.hcl
crash.log
crash.*.log
override.tf
override.tf.json
*_override.tf
*_override.tf.json
.terraformrc
terraform.rc

# =========================
# Application Specific
# =========================
# Local config
.terraform-cost.json
.terraform-cost.yaml
.terraform-cost.yml
config.local.json
config.local.yaml

# Cache
.cache/
cache/
*.cache

# Data directory
data/
*.db
*.sqlite
*.sqlite3

# Pricing data exports
pricing-*.json
pricing-*.csv

# Logs
logs/
*.log

# Temp files
tmp/
temp/
*.tmp

# Build artifacts
dist/
build/

# Coverage reports
coverage/
coverage.html
coverage.txt

# Secrets (NEVER commit these)
secrets/
*.pem
*.key
*.crt
*.p12
*.pfx
.env
.env.*
!.env.example

# =========================
# Docker
# =========================
# Ignore local docker overrides
docker-compose.override.yml
docker-compose.local.yml
.docker/

# =========================
# CI/CD
# =========================
# GitHub Actions local testing
.act/

# =========================
# Testing
# =========================
# Test output
testdata/output/
*.test.json

# Benchmarks
*.bench

# =========================
# Documentation
# =========================
# Generated docs
docs/_build/
site/

# =========================
# Project directories to ignore
# =========================
# User's terraform projects mounted in docker
projects/

# Local examples with real data
examples/local/
examples/private/

################################################################################
# FILE: :\good projects\cost estimation\combine-code.ps1
# TYPE: powershell
# SIZE: 10256 bytes
################################################################################
<#
.SYNOPSIS
    Combines all source code files into a single combined-code.txt file.

.DESCRIPTION
    This script:
    1. Generates a directory tree structure
    2. Combines all relevant source files into a single file
    3. Excludes binary files, dependencies, and build artifacts
    4. Includes file separators with full paths for easy navigation

.PARAMETER OutputFile
    The output file path. Default: combined-code.txt

.PARAMETER ProjectPath
    The project root path. Default: current directory

.EXAMPLE
    .\combine-code.ps1
    .\combine-code.ps1 -OutputFile "all-code.txt" -ProjectPath "D:\my-project"
#>

param(
    [string]$OutputFile = "combined-code.txt",
    [string]$ProjectPath = "."
)

# Resolve to absolute path
$ProjectPath = Resolve-Path $ProjectPath

Write-Host "==================================" -ForegroundColor Cyan
Write-Host "  Code Combiner Script" -ForegroundColor Cyan
Write-Host "==================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "Project Path: $ProjectPath" -ForegroundColor Yellow
Write-Host "Output File:  $OutputFile" -ForegroundColor Yellow
Write-Host ""

# File extensions to include
$IncludeExtensions = @(
    "*.go",
    "*.mod",
    "*.sum",
    "*.tf",
    "*.tfvars",
    "*.json",
    "*.yaml",
    "*.yml",
    "*.toml",
    "*.md",
    "*.txt",
    "*.sh",
    "*.ps1",
    "*.sql",
    "*.hcl",
    "Dockerfile*",
    "docker-compose*",
    "Makefile",
    ".gitignore",
    ".dockerignore"
)

# Directories to exclude
$ExcludeDirectories = @(
    ".git",
    ".idea",
    ".vscode",
    "node_modules",
    "vendor",
    ".terraform",
    "dist",
    "build",
    "bin",
    "__pycache__",
    ".cache",
    "cache",
    "tmp",
    "temp",
    "logs",
    "coverage"
)

# Files to exclude
$ExcludeFiles = @(
    "combined-code.txt",
    "*.exe",
    "*.dll",
    "*.so",
    "*.dylib",
    "*.zip",
    "*.tar",
    "*.gz",
    "*.db",
    "*.sqlite",
    "*.log",
    "*.tfstate",
    "*.tfstate.backup",
    "go.sum",
    "infracost-code.txt"
)

# Create output file and clear if exists
$OutputFullPath = Join-Path $ProjectPath $OutputFile
if (Test-Path $OutputFullPath) {
    Remove-Item $OutputFullPath -Force
}

# =================================
# Section 1: Directory Structure
# =================================
Write-Host "Generating directory structure..." -ForegroundColor Green

$timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
$content = @"
################################################################################
#                                                                              #
#                    TERRAFORM COST ESTIMATION SYSTEM                          #
#                         Combined Source Code                                 #
#                                                                              #
#                    Generated: $timestamp                          #
#                                                                              #
################################################################################

================================================================================
                           DIRECTORY STRUCTURE
================================================================================

"@

# Generate directory tree using ASCII characters
function Get-DirectoryTree {
    param(
        [string]$Path,
        [string]$Prefix = "",
        [int]$MaxDepth = 10,
        [int]$CurrentDepth = 0
    )

    if ($CurrentDepth -ge $MaxDepth) { return "" }

    $output = ""
    $items = Get-ChildItem -Path $Path -Force | Where-Object {
        $item = $_
        $isExcluded = $false
        
        # Check if directory should be excluded
        if ($item.PSIsContainer) {
            foreach ($exclude in $ExcludeDirectories) {
                if ($item.Name -eq $exclude) {
                    $isExcluded = $true
                    break
                }
            }
        }
        
        -not $isExcluded
    } | Sort-Object { -not $_.PSIsContainer }, Name

    $count = $items.Count
    $index = 0

    foreach ($item in $items) {
        $index++
        $isLast = ($index -eq $count)
        
        # Use ASCII characters instead of Unicode
        if ($isLast) {
            $connector = "+-- "
            $extension = "    "
        } else {
            $connector = "|-- "
            $extension = "|   "
        }

        if ($item.PSIsContainer) {
            $output += "$Prefix$connector$($item.Name)/`n"
            $output += Get-DirectoryTree -Path $item.FullName -Prefix "$Prefix$extension" -MaxDepth $MaxDepth -CurrentDepth ($CurrentDepth + 1)
        } else {
            $output += "$Prefix$connector$($item.Name)`n"
        }
    }

    return $output
}

$projectName = Split-Path $ProjectPath -Leaf
$content += "$projectName/`n"
$content += Get-DirectoryTree -Path $ProjectPath

$content += @"

================================================================================
                              SOURCE FILES
================================================================================

"@

# =================================
# Section 2: Combine Source Files
# =================================
Write-Host "Collecting source files..." -ForegroundColor Green

# Collect all files matching our patterns
$allFiles = @()

foreach ($pattern in $IncludeExtensions) {
    $files = Get-ChildItem -Path $ProjectPath -Filter $pattern -Recurse -File -ErrorAction SilentlyContinue | Where-Object {
        $file = $_
        $include = $true
        
        # Check if in excluded directory
        foreach ($excludeDir in $ExcludeDirectories) {
            if ($file.FullName -like "*\$excludeDir\*" -or $file.FullName -like "*/$excludeDir/*") {
                $include = $false
                break
            }
        }
        
        # Check if file should be excluded
        foreach ($excludeFile in $ExcludeFiles) {
            if ($file.Name -like $excludeFile) {
                $include = $false
                break
            }
        }
        
        $include
    }
    
    $allFiles += $files
}

# Remove duplicates and sort
$allFiles = $allFiles | Sort-Object FullName -Unique

Write-Host "Found $($allFiles.Count) files to combine" -ForegroundColor Yellow

# Group files by directory for better organization
$filesByDir = $allFiles | Group-Object { Split-Path $_.FullName -Parent }

$processedCount = 0
foreach ($group in $filesByDir | Sort-Object Name) {
    foreach ($file in $group.Group | Sort-Object Name) {
        $relativePath = $file.FullName.Substring($ProjectPath.Path.Length + 1)
        $processedCount++
        
        Write-Host "  [$processedCount/$($allFiles.Count)] $relativePath" -ForegroundColor Gray
        
        # Determine file type for syntax highlighting hint
        $fileType = switch -Regex ($file.Extension) {
            "\.go$" { "go" }
            "\.tf$|\.hcl$" { "hcl" }
            "\.json$" { "json" }
            "\.ya?ml$" { "yaml" }
            "\.md$" { "markdown" }
            "\.ps1$" { "powershell" }
            "\.sh$" { "bash" }
            "\.sql$" { "sql" }
            default { "text" }
        }
        
        $fileSize = $file.Length
        $separator = @"

################################################################################
# FILE: $relativePath
# TYPE: $fileType
# SIZE: $fileSize bytes
################################################################################

"@
        $content += $separator
        
        try {
            $fileContent = Get-Content -Path $file.FullName -Raw -ErrorAction Stop
            if ($fileContent) {
                $content += $fileContent
                # Ensure file ends with newline
                if (-not $fileContent.EndsWith("`n")) {
                    $content += "`n"
                }
            }
        } catch {
            $content += "# ERROR: Could not read file - $($_.Exception.Message)`n"
        }
    }
}

# =================================
# Section 3: Summary
# =================================
$summaryTimestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
$content += @"

################################################################################
#                              END OF FILE                                     #
################################################################################

================================================================================
                                SUMMARY
================================================================================

Total Files Combined: $($allFiles.Count)
Generated: $summaryTimestamp
Project: $projectName

Files by Type:
"@

# Count files by extension
$extensionCounts = $allFiles | Group-Object Extension | Sort-Object Count -Descending
foreach ($ext in $extensionCounts) {
    $extName = if ($ext.Name) { $ext.Name } else { "(no extension)" }
    $content += "  $extName : $($ext.Count) files`n"
}

$content += @"

================================================================================
"@

# Write to output file
Write-Host ""
Write-Host "Writing output file..." -ForegroundColor Green
$content | Out-File -FilePath $OutputFullPath -Encoding UTF8

# Get output file size
$outputSize = (Get-Item $OutputFullPath).Length
$outputSizeMB = [math]::Round($outputSize / 1MB, 2)
$outputSizeKB = [math]::Round($outputSize / 1KB, 2)

Write-Host ""
Write-Host "==================================" -ForegroundColor Cyan
Write-Host "  Complete!" -ForegroundColor Green
Write-Host "==================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "Output: $OutputFullPath" -ForegroundColor Yellow
Write-Host "Size:   $outputSizeKB KB ($outputSizeMB MB)" -ForegroundColor Yellow
Write-Host "Files:  $($allFiles.Count) combined" -ForegroundColor Yellow
Write-Host ""

################################################################################
# FILE: :\good projects\cost estimation\docker-compose.yml
# TYPE: yaml
# SIZE: 3175 bytes
################################################################################
version: "3.9"

services:
  # =========================
  # CLI Service (for batch jobs)
  # =========================
  terraform-cost:
    build:
      context: .
      dockerfile: Dockerfile
    image: terraform-cost:latest
    container_name: terraform-cost-cli
    volumes:
      # Mount your Terraform projects here
      - ./projects:/projects:ro
      # Persist cache and data
      - terraform-cost-cache:/app/cache
      - terraform-cost-data:/app/data
      # Custom config (optional)
      - ./config:/app/config:ro
    environment:
      - TERRAFORM_COST_LOG_LEVEL=info
      - TERRAFORM_COST_DEFAULT_REGION=us-east-1
    # Override command for different operations
    command: ["estimate", "/projects"]
    networks:
      - terraform-cost-network

  # =========================
  # API Server (future)
  # =========================
  # terraform-cost-api:
  #   build:
  #     context: .
  #     dockerfile: Dockerfile.server
  #   image: terraform-cost-api:latest
  #   container_name: terraform-cost-api
  #   ports:
  #     - "8080:8080"
  #   volumes:
  #     - terraform-cost-cache:/app/cache
  #     - terraform-cost-data:/app/data
  #   environment:
  #     - TERRAFORM_COST_API_PORT=8080
  #     - TERRAFORM_COST_LOG_LEVEL=info
  #   healthcheck:
  #     test: ["CMD", "wget", "-q", "--spider", "http://localhost:8080/health"]
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #     start_period: 10s
  #   networks:
  #     - terraform-cost-network
  #   restart: unless-stopped

  # =========================
  # Pricing Database (future)
  # =========================
  # pricing-db:
  #   image: postgres:16-alpine
  #   container_name: terraform-cost-db
  #   environment:
  #     - POSTGRES_DB=terraform_cost
  #     - POSTGRES_USER=terraform_cost
  #     - POSTGRES_PASSWORD_FILE=/run/secrets/db_password
  #   volumes:
  #     - pricing-db-data:/var/lib/postgresql/data
  #     - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql:ro
  #   secrets:
  #     - db_password
  #   healthcheck:
  #     test: ["CMD-SHELL", "pg_isready -U terraform_cost -d terraform_cost"]
  #     interval: 10s
  #     timeout: 5s
  #     retries: 5
  #   networks:
  #     - terraform-cost-network
  #   restart: unless-stopped

  # =========================
  # Redis Cache (future)
  # =========================
  # cache:
  #   image: redis:7-alpine
  #   container_name: terraform-cost-cache
  #   command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
  #   volumes:
  #     - redis-data:/data
  #   healthcheck:
  #     test: ["CMD", "redis-cli", "ping"]
  #     interval: 10s
  #     timeout: 5s
  #     retries: 5
  #   networks:
  #     - terraform-cost-network
  #   restart: unless-stopped

volumes:
  terraform-cost-cache:
    driver: local
  terraform-cost-data:
    driver: local
  # pricing-db-data:
  #   driver: local
  # redis-data:
  #   driver: local

networks:
  terraform-cost-network:
    driver: bridge

# secrets:
#   db_password:
#     file: ./secrets/db_password.txt

################################################################################
# FILE: :\good projects\cost estimation\Dockerfile
# TYPE: text
# SIZE: 1805 bytes
################################################################################
# =========================
# Build Stage
# =========================
FROM golang:1.22-alpine AS builder

# Install build dependencies
RUN apk add --no-cache git ca-certificates tzdata

# Create non-root user for security
RUN adduser -D -g '' appuser

WORKDIR /build

# Copy go mod files first for better caching
COPY go.mod go.sum ./
RUN go mod download && go mod verify

# Copy source code
COPY . .

# Build the CLI binary
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags='-w -s -extldflags "-static"' \
    -o /build/terraform-cost \
    ./cmd/cli

# Build the server binary (if exists)
# RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
#     -ldflags='-w -s -extldflags "-static"' \
#     -o /build/terraform-cost-server \
#     ./cmd/server

# =========================
# Production Stage
# =========================
FROM alpine:3.19

# Install runtime dependencies
RUN apk add --no-cache ca-certificates tzdata

# Import user from builder
COPY --from=builder /etc/passwd /etc/passwd
COPY --from=builder /etc/group /etc/group

# Create directories
RUN mkdir -p /app/data /app/cache /app/config && \
    chown -R appuser:appuser /app

WORKDIR /app

# Copy binary from builder
COPY --from=builder /build/terraform-cost /app/terraform-cost

# Copy examples for testing
COPY --from=builder /build/examples /app/examples

# Use non-root user
USER appuser

# Environment variables
ENV HOME=/app \
    TERRAFORM_COST_CACHE_DIR=/app/cache \
    TERRAFORM_COST_DATA_DIR=/app/data

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD ["/app/terraform-cost", "version"]

# Default entrypoint
ENTRYPOINT ["/app/terraform-cost"]

# Default command (show help)
CMD ["--help"]

################################################################################
# FILE: :\good projects\cost estimation\go.mod
# TYPE: text
# SIZE: 730 bytes
################################################################################
module terraform-cost

go 1.25.5

require (
	github.com/hashicorp/hcl/v2 v2.24.0
	github.com/shopspring/decimal v1.4.0
	github.com/spf13/cobra v1.10.2
	go.uber.org/zap v1.27.1
)

require (
	github.com/agext/levenshtein v1.2.1 // indirect
	github.com/apparentlymart/go-textseg/v15 v15.0.0 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/mitchellh/go-wordwrap v1.0.1 // indirect
	github.com/spf13/pflag v1.0.9 // indirect
	github.com/zclconf/go-cty v1.16.3 // indirect
	go.uber.org/multierr v1.10.0 // indirect
	golang.org/x/mod v0.17.0 // indirect
	golang.org/x/sync v0.14.0 // indirect
	golang.org/x/text v0.25.0 // indirect
	golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d // indirect
)

################################################################################
# FILE: :\good projects\cost estimation\README.md
# TYPE: markdown
# SIZE: 3871 bytes
################################################################################
# Terraform Cost Estimation System

A production-grade, cloud-agnostic infrastructure cost estimation tool for Terraform configurations.

## Features

- **Cloud-Agnostic Core**: Support for AWS, Azure, and GCP (AWS fully implemented)
- **Asset Graph**: Provider-agnostic infrastructure DAG for diff and explainability
- **Cost Graph**: Full lineage tracking for every cost calculation
- **Reproducible Estimates**: Versioned pricing snapshots
- **Policy Engine**: Budget limits, thresholds, and guardrails
- **Multiple Outputs**: CLI tables, JSON, HTML, PR comments

## Quick Start

### Using Docker (Recommended)

```bash
# Build the image
docker build -t terraform-cost .

# Run estimation on a Terraform project
docker run -v /path/to/your/terraform:/projects terraform-cost estimate /projects

# Using docker-compose
docker-compose run terraform-cost estimate /projects
```

### Building from Source

```bash
# Clone the repository
git clone https://github.com/your-org/terraform-cost.git
cd terraform-cost

# Install dependencies
go mod download

# Build
go build -o terraform-cost ./cmd/cli

# Run
./terraform-cost estimate ./your-terraform-project
```

## Usage

```bash
# Basic estimation
terraform-cost estimate ./my-terraform-project

# JSON output
terraform-cost estimate --format json ./infrastructure

# With custom usage file
terraform-cost estimate --usage usage.yml ./infrastructure

# Show version
terraform-cost version
```

## Project Structure

```
terraform-cost/
â”œâ”€â”€ cmd/                    # CLI and server entry points
â”‚   â”œâ”€â”€ cli/
â”‚   â””â”€â”€ server/
â”œâ”€â”€ core/                   # Cloud-agnostic core engine
â”‚   â”œâ”€â”€ types/              # Domain types
â”‚   â”œâ”€â”€ scanner/            # Infrastructure scanning
â”‚   â”œâ”€â”€ asset/              # Asset graph
â”‚   â”œâ”€â”€ usage/              # Usage estimation
â”‚   â”œâ”€â”€ cost/               # Cost calculation
â”‚   â”œâ”€â”€ pricing/            # Pricing resolution
â”‚   â”œâ”€â”€ policy/             # Policy evaluation
â”‚   â””â”€â”€ output/             # Output formatting
â”œâ”€â”€ clouds/                 # Cloud provider plugins
â”‚   â”œâ”€â”€ aws/
â”‚   â”œâ”€â”€ azure/
â”‚   â””â”€â”€ gcp/
â”œâ”€â”€ adapters/               # External system adapters
â”‚   â””â”€â”€ terraform/
â”œâ”€â”€ internal/               # Internal utilities
â””â”€â”€ examples/               # Example Terraform configs
```

## Supported AWS Resources

| Category   | Resources |
|------------|-----------|
| Compute    | EC2, Auto Scaling, Lambda, ECS, EKS |
| Storage    | S3, EBS, EFS |
| Database   | RDS, DynamoDB, ElastiCache |
| Network    | NAT Gateway, VPC Endpoints, ALB/NLB/ELB |
| Security   | KMS, Secrets Manager |
| Monitoring | CloudWatch Log Groups |

## Architecture

```
Input â†’ Scanner â†’ Asset Graph â†’ Usage Estimation â†’ Cost Graph â†’ Pricing â†’ Policy â†’ Output
```

### Key Design Principles

1. **Hard Separation of Concerns**: Scanners don't know about pricing
2. **Cloud Providers are Plugins**: Core engine is cloud-agnostic
3. **Deterministic & Reproducible**: Every estimate uses versioned pricing
4. **Everything is a Graph**: Enables diff, lineage, and explainability

## Configuration

Create `.terraform-cost.json` in your home directory or project root:

```json
{
  "pricing": {
    "default_currency": "USD",
    "cache_enabled": true
  },
  "output": {
    "default_format": "cli",
    "show_details": true
  },
  "aws": {
    "default_region": "us-east-1"
  }
}
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Run tests: `go test ./...`
5. Submit a pull request

## License

MIT License - see [LICENSE](LICENSE) for details.

################################################################################
# FILE: :\good projects\cost estimation\adapters\cli\adapter.go
# TYPE: go
# SIZE: 10369 bytes
################################################################################
// Package adapter provides thin adapters over the core engine.
// CLI, HTTP, and CI adapters are all thin wrappers.
package adapter

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"time"

	"terraform-cost/core/engine"
	"terraform-cost/core/model"
	"terraform-cost/core/pricing"
	"terraform-cost/core/terraform"
)

// CLIAdapter is a THIN wrapper around the core engine.
// It handles input/output only - all logic is in the engine.
type CLIAdapter struct {
	engine   *engine.Engine
	pipeline *terraform.Pipeline
	output   io.Writer
	format   OutputFormat
}

// OutputFormat specifies the output format
type OutputFormat int

const (
	FormatTable OutputFormat = iota
	FormatJSON
	FormatMarkdown
)

// NewCLIAdapter creates a new CLI adapter
func NewCLIAdapter(eng *engine.Engine, pipeline *terraform.Pipeline) *CLIAdapter {
	return &CLIAdapter{
		engine:   eng,
		pipeline: pipeline,
		output:   os.Stdout,
		format:   FormatTable,
	}
}

// SetOutput sets the output writer
func (a *CLIAdapter) SetOutput(w io.Writer) {
	a.output = w
}

// SetFormat sets the output format
func (a *CLIAdapter) SetFormat(f OutputFormat) {
	a.format = f
}

// CLIRequest is the CLI input
type CLIRequest struct {
	// Path to Terraform project
	Path string

	// Variables from CLI
	Variables map[string]any

	// Snapshot specification
	SnapshotID string
	Provider   string
	Region     string

	// Usage overrides file
	UsageFile string

	// Output options
	Format     string
	ShowLineage bool
}

// Run executes the estimation
func (a *CLIAdapter) Run(ctx context.Context, req *CLIRequest) error {
	// 1. Run Terraform pipeline
	scanInput := &terraform.ScanInput{
		RootPath:  req.Path,
		Workspace: "default",
	}

	pipelineResult, err := a.pipeline.Execute(ctx, scanInput)
	if err != nil {
		return fmt.Errorf("failed to scan terraform: %w", err)
	}

	// 2. Build estimation request
	snapshotReq := engine.SnapshotRequest{
		Provider: req.Provider,
		Region:   req.Region,
	}
	if req.SnapshotID != "" {
		snapshotReq.SnapshotID = pricing.SnapshotID(req.SnapshotID)
	}

	// Load usage overrides if provided
	overrides := make(map[model.InstanceID]map[string]float64)
	if req.UsageFile != "" {
		var err error
		overrides, err = a.loadUsageOverrides(req.UsageFile)
		if err != nil {
			fmt.Fprintf(a.output, "Warning: could not load usage file: %v\n", err)
		}
	}

	// 3. Delegate to engine
	estimateReq := &engine.EstimateRequest{
		Graph:           pipelineResult.Graph,
		SnapshotRequest: snapshotReq,
		UsageOverrides:  overrides,
	}

	result, err := a.engine.Estimate(ctx, estimateReq)
	if err != nil {
		return fmt.Errorf("estimation failed: %w", err)
	}

	// 4. Format and output
	switch a.format {
	case FormatJSON:
		return a.outputJSON(result)
	case FormatMarkdown:
		return a.outputMarkdown(result)
	default:
		return a.outputTable(result, req.ShowLineage)
	}
}

func (a *CLIAdapter) loadUsageOverrides(path string) (map[model.InstanceID]map[string]float64, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var raw map[string]map[string]float64
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, err
	}

	result := make(map[model.InstanceID]map[string]float64)
	for k, v := range raw {
		result[model.InstanceID(k)] = v
	}
	return result, nil
}

func (a *CLIAdapter) outputTable(result *engine.EstimationResult, showLineage bool) error {
	fmt.Fprintln(a.output, "")
	fmt.Fprintln(a.output, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	fmt.Fprintln(a.output, "â•‘                     COST ESTIMATION REPORT                        â•‘")
	fmt.Fprintln(a.output, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	fmt.Fprintln(a.output, "")

	// Snapshot info
	fmt.Fprintf(a.output, "Pricing Snapshot: %s (verified: %s)\n",
		result.Snapshot.ID, result.Snapshot.ContentHash.String())
	fmt.Fprintf(a.output, "Effective Date:   %s\n", result.Snapshot.EffectiveAt.Format(time.RFC3339))
	fmt.Fprintf(a.output, "Provider/Region:  %s / %s\n", result.Snapshot.Provider, result.Snapshot.Region)
	fmt.Fprintln(a.output, "")

	// Instance costs
	fmt.Fprintln(a.output, "COSTS BY INSTANCE")
	fmt.Fprintln(a.output, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
	fmt.Fprintf(a.output, "%-40s %12s %10s\n", "INSTANCE", "MONTHLY", "CONFIDENCE")
	fmt.Fprintln(a.output, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

	result.InstanceCosts.Range(func(id model.InstanceID, cost *engine.InstanceCost) bool {
		confStr := fmt.Sprintf("%.0f%%", cost.Confidence.Score*100)
		if cost.Confidence.Score < 0.7 {
			confStr += " âš "
		}
		fmt.Fprintf(a.output, "%-40s %12s %10s\n",
			truncate(string(cost.Address), 40),
			cost.MonthlyCost.String(),
			confStr)

		// Show components if requested
		if showLineage {
			for _, comp := range cost.Components {
				fmt.Fprintf(a.output, "  â””â”€ %-36s %12s\n",
					comp.Name, comp.MonthlyCost.String())
			}
		}
		return true
	})

	fmt.Fprintln(a.output, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
	fmt.Fprintf(a.output, "%-40s %12s %10s\n",
		"TOTAL",
		result.TotalMonthlyCost.String(),
		fmt.Sprintf("%.0f%%", result.Confidence.Score*100))
	fmt.Fprintln(a.output, "")

	// Warnings
	if len(result.Warnings) > 0 {
		fmt.Fprintln(a.output, "WARNINGS")
		fmt.Fprintln(a.output, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
		for _, w := range result.Warnings {
			fmt.Fprintf(a.output, "âš  %s\n", w)
		}
		fmt.Fprintln(a.output, "")
	}

	// Policy results
	if result.PolicyResult != nil {
		fmt.Fprintln(a.output, "POLICY RESULTS")
		fmt.Fprintln(a.output, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
		for _, p := range result.PolicyResult.Policies {
			status := "âœ“ PASS"
			if !p.Passed {
				status = "âœ— FAIL"
			}
			fmt.Fprintf(a.output, "%s  %s: %s\n", status, p.Name, p.Message)
		}
		fmt.Fprintln(a.output, "")
	}

	return nil
}

func (a *CLIAdapter) outputJSON(result *engine.EstimationResult) error {
	// Convert to JSON-friendly structure
	output := map[string]interface{}{
		"snapshot": map[string]interface{}{
			"id":           result.Snapshot.ID,
			"content_hash": result.Snapshot.ContentHash.Hex(),
			"effective_at": result.Snapshot.EffectiveAt,
			"provider":     result.Snapshot.Provider,
			"region":       result.Snapshot.Region,
		},
		"total_monthly_cost": result.TotalMonthlyCost.StringRaw(),
		"total_hourly_cost":  result.TotalHourlyCost.StringRaw(),
		"confidence":         result.Confidence.Score,
		"instance_count":     result.InstanceCosts.Len(),
		"estimated_at":       result.EstimatedAt,
		"duration_ms":        result.Duration.Milliseconds(),
		"warnings":           result.Warnings,
		"degraded":           result.Degraded,
	}

	// Add instance costs
	instances := make(map[string]interface{})
	result.InstanceCosts.Range(func(id model.InstanceID, cost *engine.InstanceCost) bool {
		components := make([]map[string]interface{}, len(cost.Components))
		for i, c := range cost.Components {
			components[i] = map[string]interface{}{
				"name":         c.Name,
				"monthly_cost": c.MonthlyCost.StringRaw(),
				"hourly_cost":  c.HourlyCost.StringRaw(),
				"usage_value":  c.UsageValue,
				"usage_unit":   c.UsageUnit,
				"confidence":   c.Confidence,
			}
		}

		instances[string(id)] = map[string]interface{}{
			"address":       cost.Address,
			"definition_id": cost.DefinitionID,
			"monthly_cost":  cost.MonthlyCost.StringRaw(),
			"hourly_cost":   cost.HourlyCost.StringRaw(),
			"confidence":    cost.Confidence.Score,
			"components":    components,
		}
		return true
	})
	output["instances"] = instances

	encoder := json.NewEncoder(a.output)
	encoder.SetIndent("", "  ")
	return encoder.Encode(output)
}

func (a *CLIAdapter) outputMarkdown(result *engine.EstimationResult) error {
	fmt.Fprintln(a.output, "# Cost Estimation Report")
	fmt.Fprintln(a.output, "")
	fmt.Fprintf(a.output, "**Total Monthly Cost:** %s\n", result.TotalMonthlyCost.String())
	fmt.Fprintf(a.output, "**Confidence:** %.0f%%\n", result.Confidence.Score*100)
	fmt.Fprintln(a.output, "")

	fmt.Fprintln(a.output, "## Summary")
	fmt.Fprintln(a.output, "")
	fmt.Fprintln(a.output, "| Instance | Monthly Cost | Confidence |")
	fmt.Fprintln(a.output, "|----------|-------------|------------|")

	result.InstanceCosts.Range(func(id model.InstanceID, cost *engine.InstanceCost) bool {
		fmt.Fprintf(a.output, "| `%s` | %s | %.0f%% |\n",
			cost.Address, cost.MonthlyCost.String(), cost.Confidence.Score*100)
		return true
	})

	fmt.Fprintln(a.output, "")
	fmt.Fprintf(a.output, "| **Total** | **%s** | **%.0f%%** |\n",
		result.TotalMonthlyCost.String(), result.Confidence.Score*100)

	return nil
}

func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}

// HTTPAdapter would be similar - thin wrapper delegating to engine
// type HTTPAdapter struct { ... }

// CIAdapter would be similar - outputs in CI-friendly format
// type CIAdapter struct { ... }

################################################################################
# FILE: :\good projects\cost estimation\adapters\terraform\hcl\scanner.go
# TYPE: go
# SIZE: 7554 bytes
################################################################################
// Package hcl provides Terraform HCL parsing.
package hcl

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/hashicorp/hcl/v2"
	"github.com/hashicorp/hcl/v2/hclparse"

	"terraform-cost/core/scanner"
	"terraform-cost/core/types"
)

// Scanner implements the scanner.Scanner interface for Terraform HCL
type Scanner struct {
	parser *hclparse.Parser
}

// NewScanner creates a new HCL scanner
func NewScanner() *Scanner {
	return &Scanner{
		parser: hclparse.NewParser(),
	}
}

// Name returns the scanner name
func (s *Scanner) Name() string {
	return "terraform-hcl"
}

// CanScan determines if this scanner can handle the input
func (s *Scanner) CanScan(ctx context.Context, input *types.ProjectInput) (bool, error) {
	// Look for .tf files
	hasTfFiles := false
	err := filepath.Walk(input.Path, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(path, ".tf") {
			hasTfFiles = true
			return filepath.SkipAll // Found one, that's enough
		}
		return nil
	})

	if err != nil && err != filepath.SkipAll {
		return false, err
	}

	return hasTfFiles, nil
}

// Scan parses HCL files and returns raw assets
func (s *Scanner) Scan(ctx context.Context, input *types.ProjectInput) (*scanner.ScanResult, error) {
	result := &scanner.ScanResult{
		Assets:    make([]types.RawAsset, 0),
		Modules:   make([]scanner.ModuleReference, 0),
		Variables: make(map[string]interface{}),
		Warnings:  make([]scanner.ScanWarning, 0),
		Errors:    make([]scanner.ScanError, 0),
	}

	// Find all .tf files
	var tfFiles []string
	err := filepath.Walk(input.Path, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(path, ".tf") {
			tfFiles = append(tfFiles, path)
		}
		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to walk directory: %w", err)
	}

	// Parse each file
	for _, file := range tfFiles {
		assets, modules, warnings, errs := s.parseFile(ctx, file, input.Path)
		result.Assets = append(result.Assets, assets...)
		result.Modules = append(result.Modules, modules...)
		result.Warnings = append(result.Warnings, warnings...)
		result.Errors = append(result.Errors, errs...)
	}

	// Load tfvars if present
	result.Variables = s.loadVariables(input.Path)

	return result, nil
}

func (s *Scanner) parseFile(ctx context.Context, file, basePath string) ([]types.RawAsset, []scanner.ModuleReference, []scanner.ScanWarning, []scanner.ScanError) {
	var assets []types.RawAsset
	var modules []scanner.ModuleReference
	var warnings []scanner.ScanWarning
	var errors []scanner.ScanError

	src, err := os.ReadFile(file)
	if err != nil {
		errors = append(errors, scanner.ScanError{
			File:    file,
			Message: fmt.Sprintf("failed to read file: %v", err),
			Err:     err,
		})
		return assets, modules, warnings, errors
	}

	hclFile, diags := s.parser.ParseHCL(src, file)
	if diags.HasErrors() {
		for _, diag := range diags {
			if diag.Severity == hcl.DiagError {
				line := 0
				if diag.Subject != nil {
					line = diag.Subject.Start.Line
				}
				errors = append(errors, scanner.ScanError{
					File:    file,
					Line:    line,
					Message: diag.Summary + ": " + diag.Detail,
				})
			}
		}
		return assets, modules, warnings, errors
	}

	// Extract blocks from the file body
	body := hclFile.Body
	content, _, _ := body.PartialContent(&hcl.BodySchema{
		Blocks: []hcl.BlockHeaderSchema{
			{Type: "resource", LabelNames: []string{"type", "name"}},
			{Type: "data", LabelNames: []string{"type", "name"}},
			{Type: "module", LabelNames: []string{"name"}},
			{Type: "variable", LabelNames: []string{"name"}},
			{Type: "locals"},
			{Type: "provider", LabelNames: []string{"name"}},
		},
	})

	relPath, _ := filepath.Rel(basePath, file)

	for _, block := range content.Blocks {
		switch block.Type {
		case "resource":
			asset := s.parseResource(block, relPath, false)
			if asset != nil {
				assets = append(assets, *asset)
			}
		case "data":
			asset := s.parseResource(block, relPath, true)
			if asset != nil {
				assets = append(assets, *asset)
			}
		case "module":
			mod := s.parseModule(block)
			if mod != nil {
				modules = append(modules, *mod)
			}
		}
	}

	return assets, modules, warnings, errors
}

func (s *Scanner) parseResource(block *hcl.Block, file string, isDataSource bool) *types.RawAsset {
	if len(block.Labels) < 2 {
		return nil
	}

	resourceType := block.Labels[0]
	resourceName := block.Labels[1]

	// Determine provider from resource type
	provider := types.ProviderUnknown
	if strings.HasPrefix(resourceType, "aws_") {
		provider = types.ProviderAWS
	} else if strings.HasPrefix(resourceType, "azurerm_") {
		provider = types.ProviderAzure
	} else if strings.HasPrefix(resourceType, "google_") {
		provider = types.ProviderGCP
	}

	// Extract attributes from block body
	attrs := s.extractAttributes(block.Body)

	address := types.ResourceAddress(fmt.Sprintf("%s.%s", resourceType, resourceName))
	if isDataSource {
		address = types.ResourceAddress(fmt.Sprintf("data.%s.%s", resourceType, resourceName))
	}

	line := 0
	if block.DefRange.Start.Line > 0 {
		line = block.DefRange.Start.Line
	}

	return &types.RawAsset{
		Address:      address,
		Provider:     provider,
		Type:         resourceType,
		Name:         resourceName,
		Attributes:   attrs,
		IsDataSource: isDataSource,
		SourceFile:   file,
		SourceLine:   line,
	}
}

func (s *Scanner) parseModule(block *hcl.Block) *scanner.ModuleReference {
	if len(block.Labels) < 1 {
		return nil
	}

	name := block.Labels[0]
	attrs := s.extractAttributes(block.Body)

	source := ""
	if src := attrs.Get("source"); src != nil {
		if srcStr, ok := src.(string); ok {
			source = srcStr
		}
	}

	version := ""
	if ver := attrs.Get("version"); ver != nil {
		if verStr, ok := ver.(string); ok {
			version = verStr
		}
	}

	return &scanner.ModuleReference{
		Key:     name,
		Source:  source,
		Version: version,
	}
}

func (s *Scanner) extractAttributes(body hcl.Body) types.Attributes {
	attrs := make(types.Attributes)

	// Get all attributes from the body
	content, _, _ := body.PartialContent(&hcl.BodySchema{})
	
	for name, attr := range content.Attributes {
		val, diags := attr.Expr.Value(nil)
		if diags.HasErrors() {
			// Mark as computed if we can't evaluate
			attrs[name] = types.Attribute{
				Value:      nil,
				IsComputed: true,
			}
			continue
		}

		attrs[name] = types.Attribute{
			Value: s.ctyToGo(val),
		}
	}

	return attrs
}

func (s *Scanner) ctyToGo(val interface{}) interface{} {
	// This is a simplified conversion
	// In production, use cty.Value methods properly
	return val
}

func (s *Scanner) loadVariables(basePath string) map[string]interface{} {
	vars := make(map[string]interface{})

	// Look for terraform.tfvars
	tfvarsPath := filepath.Join(basePath, "terraform.tfvars")
	if _, err := os.Stat(tfvarsPath); err == nil {
		// Parse tfvars file
		// Simplified - in production, properly parse HCL
	}

	// Look for *.auto.tfvars
	matches, _ := filepath.Glob(filepath.Join(basePath, "*.auto.tfvars"))
	for range matches {
		// Parse each file
	}

	return vars
}

func init() {
	// Register this scanner
	scanner.Register(NewScanner())
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\registry.go
# TYPE: go
# SIZE: 4155 bytes
################################################################################
// Package clouds provides the cloud plugin system.
// Cloud providers are modular plugins that can be added without modifying core.
package clouds

import (
	"fmt"
	"sync"

	"terraform-cost/core/asset"
	"terraform-cost/core/pricing"
	"terraform-cost/core/types"
	"terraform-cost/core/usage"
)

// Plugin defines the interface for a cloud provider plugin
type Plugin interface {
	// Provider returns the cloud provider identifier
	Provider() types.Provider

	// Name returns a human-readable name
	Name() string

	// Description returns a description of the plugin
	Description() string

	// Initialize sets up the plugin
	Initialize() error

	// AssetBuilders returns asset builders for this provider
	AssetBuilders() []asset.Builder

	// UsageEstimators returns usage estimators for this provider
	UsageEstimators() []usage.Estimator

	// PricingSource returns the pricing source for this provider
	PricingSource() pricing.Source

	// SupportedResourceTypes returns all supported resource types
	SupportedResourceTypes() []string

	// SupportedRegions returns all supported regions
	SupportedRegions() []string
}

// Registry manages cloud plugin registration
type Registry struct {
	mu      sync.RWMutex
	plugins map[types.Provider]Plugin
}

// NewRegistry creates a new plugin registry
func NewRegistry() *Registry {
	return &Registry{
		plugins: make(map[types.Provider]Plugin),
	}
}

// Register adds a plugin to the registry
func (r *Registry) Register(plugin Plugin) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.plugins[plugin.Provider()]; exists {
		return fmt.Errorf("plugin already registered: %s", plugin.Provider())
	}

	// Initialize the plugin
	if err := plugin.Initialize(); err != nil {
		return fmt.Errorf("failed to initialize plugin %s: %w", plugin.Provider(), err)
	}

	r.plugins[plugin.Provider()] = plugin
	return nil
}

// GetPlugin returns a plugin by provider
func (r *Registry) GetPlugin(provider types.Provider) (Plugin, bool) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	plugin, ok := r.plugins[provider]
	return plugin, ok
}

// GetAll returns all registered plugins
func (r *Registry) GetAll() []Plugin {
	r.mu.RLock()
	defer r.mu.RUnlock()

	plugins := make([]Plugin, 0, len(r.plugins))
	for _, plugin := range r.plugins {
		plugins = append(plugins, plugin)
	}
	return plugins
}

// Providers returns all registered provider IDs
func (r *Registry) Providers() []types.Provider {
	r.mu.RLock()
	defer r.mu.RUnlock()

	providers := make([]types.Provider, 0, len(r.plugins))
	for p := range r.plugins {
		providers = append(providers, p)
	}
	return providers
}

// RegisterAll registers all components from a plugin to the core registries
func (r *Registry) RegisterAll(
	assetRegistry asset.BuilderRegistry,
	usageRegistry usage.EstimatorRegistry,
	pricingRegistry pricing.SourceRegistry,
) error {
	r.mu.RLock()
	defer r.mu.RUnlock()

	for _, plugin := range r.plugins {
		// Register asset builders
		for _, builder := range plugin.AssetBuilders() {
			if err := assetRegistry.Register(builder); err != nil {
				return fmt.Errorf("failed to register asset builder from %s: %w", plugin.Provider(), err)
			}
		}

		// Register usage estimators
		for _, estimator := range plugin.UsageEstimators() {
			if err := usageRegistry.Register(estimator); err != nil {
				return fmt.Errorf("failed to register usage estimator from %s: %w", plugin.Provider(), err)
			}
		}

		// Register pricing source
		if source := plugin.PricingSource(); source != nil {
			if err := pricingRegistry.Register(source); err != nil {
				return fmt.Errorf("failed to register pricing source from %s: %w", plugin.Provider(), err)
			}
		}
	}

	return nil
}

// Global default registry
var defaultRegistry = NewRegistry()

// RegisterPlugin adds a plugin to the default registry
func RegisterPlugin(plugin Plugin) error {
	return defaultRegistry.Register(plugin)
}

// GetDefaultRegistry returns the default registry
func GetDefaultRegistry() *Registry {
	return defaultRegistry
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\plugin.go
# TYPE: go
# SIZE: 3925 bytes
################################################################################
// Package aws provides the AWS cloud plugin.
package aws

import (
	"terraform-cost/clouds/aws/assets"
	"terraform-cost/clouds/aws/pricing"
	"terraform-cost/clouds/aws/usage"
	"terraform-cost/core/asset"
	corePricing "terraform-cost/core/pricing"
	coreUsage "terraform-cost/core/usage"
	"terraform-cost/core/types"
)

// Plugin implements the AWS cloud plugin
type Plugin struct {
	initialized bool
	region      string
}

// New creates a new AWS plugin
func New() *Plugin {
	return &Plugin{
		region: "us-east-1",
	}
}

// NewWithRegion creates a new AWS plugin with a specific default region
func NewWithRegion(region string) *Plugin {
	return &Plugin{
		region: region,
	}
}

// Provider returns the cloud provider identifier
func (p *Plugin) Provider() types.Provider {
	return types.ProviderAWS
}

// Name returns a human-readable name
func (p *Plugin) Name() string {
	return "Amazon Web Services"
}

// Description returns a description of the plugin
func (p *Plugin) Description() string {
	return "Cost estimation for AWS infrastructure including EC2, RDS, S3, Lambda, and more"
}

// Initialize sets up the plugin
func (p *Plugin) Initialize() error {
	p.initialized = true
	return nil
}

// AssetBuilders returns asset builders for AWS resources
func (p *Plugin) AssetBuilders() []asset.Builder {
	return []asset.Builder{
		// Compute
		assets.NewEC2InstanceBuilder(),
		assets.NewEC2AutoScalingGroupBuilder(),
		assets.NewLambdaFunctionBuilder(),
		assets.NewECSServiceBuilder(),
		assets.NewEKSClusterBuilder(),

		// Storage
		assets.NewS3BucketBuilder(),
		assets.NewEBSVolumeBuilder(),
		assets.NewEFSFileSystemBuilder(),

		// Database
		assets.NewRDSInstanceBuilder(),
		assets.NewRDSClusterBuilder(),
		assets.NewDynamoDBTableBuilder(),
		assets.NewElastiCacheClusterBuilder(),

		// Network
		assets.NewNATGatewayBuilder(),
		assets.NewVPCEndpointBuilder(),
		assets.NewELBBuilder(),
		assets.NewALBBuilder(),
		assets.NewNLBBuilder(),

		// Other
		assets.NewCloudWatchLogGroupBuilder(),
		assets.NewKMSKeyBuilder(),
		assets.NewSecretsManagerSecretBuilder(),
	}
}

// UsageEstimators returns usage estimators for AWS resources
func (p *Plugin) UsageEstimators() []coreUsage.Estimator {
	return []coreUsage.Estimator{
		usage.NewEC2InstanceEstimator(),
		usage.NewS3BucketEstimator(),
		usage.NewRDSInstanceEstimator(),
		usage.NewLambdaFunctionEstimator(),
		usage.NewDynamoDBTableEstimator(),
		usage.NewNATGatewayEstimator(),
		usage.NewEBSVolumeEstimator(),
	}
}

// PricingSource returns the pricing source for AWS
func (p *Plugin) PricingSource() corePricing.Source {
	return pricing.NewAWSPricingSource(p.region)
}

// SupportedResourceTypes returns all supported AWS resource types
func (p *Plugin) SupportedResourceTypes() []string {
	return []string{
		// Compute
		"aws_instance",
		"aws_autoscaling_group",
		"aws_lambda_function",
		"aws_ecs_service",
		"aws_eks_cluster",
		"aws_eks_node_group",

		// Storage
		"aws_s3_bucket",
		"aws_ebs_volume",
		"aws_efs_file_system",

		// Database
		"aws_db_instance",
		"aws_rds_cluster",
		"aws_dynamodb_table",
		"aws_elasticache_cluster",
		"aws_elasticache_replication_group",

		// Network
		"aws_nat_gateway",
		"aws_vpc_endpoint",
		"aws_lb", // ALB/NLB
		"aws_elb",

		// Other
		"aws_cloudwatch_log_group",
		"aws_kms_key",
		"aws_secretsmanager_secret",
	}
}

// SupportedRegions returns all supported AWS regions
func (p *Plugin) SupportedRegions() []string {
	return []string{
		"us-east-1",
		"us-east-2",
		"us-west-1",
		"us-west-2",
		"eu-west-1",
		"eu-west-2",
		"eu-west-3",
		"eu-central-1",
		"eu-north-1",
		"ap-northeast-1",
		"ap-northeast-2",
		"ap-northeast-3",
		"ap-southeast-1",
		"ap-southeast-2",
		"ap-south-1",
		"sa-east-1",
		"ca-central-1",
	}
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\assets\compute.go
# TYPE: go
# SIZE: 5050 bytes
################################################################################
// Package assets - AWS compute asset builders
package assets

import (
	"context"
	"fmt"

	"terraform-cost/core/asset"
	"terraform-cost/core/types"
)

// EC2AutoScalingGroupBuilder builds assets for aws_autoscaling_group
type EC2AutoScalingGroupBuilder struct {
	baseBuilder
}

// NewEC2AutoScalingGroupBuilder creates a new ASG builder
func NewEC2AutoScalingGroupBuilder() asset.Builder {
	return &EC2AutoScalingGroupBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_autoscaling_group",
			category:     types.CategoryCompute,
		},
	}
}

// Build converts a raw ASG into an asset
func (b *EC2AutoScalingGroupBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	return &types.Asset{
		ID:       fmt.Sprintf("aws_autoscaling_group.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryCompute,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"min_size":              raw.Attributes["min_size"],
			"max_size":              raw.Attributes["max_size"],
			"desired_capacity":      raw.Attributes["desired_capacity"],
			"launch_configuration":  raw.Attributes["launch_configuration"],
			"launch_template":       raw.Attributes["launch_template"],
			"mixed_instances_policy": raw.Attributes["mixed_instances_policy"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
	}, nil
}

// LambdaFunctionBuilder builds assets for aws_lambda_function
type LambdaFunctionBuilder struct {
	baseBuilder
}

// NewLambdaFunctionBuilder creates a new Lambda builder
func NewLambdaFunctionBuilder() asset.Builder {
	return &LambdaFunctionBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_lambda_function",
			category:     types.CategoryServerless,
		},
	}
}

// Build converts a raw Lambda function into an asset
func (b *LambdaFunctionBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	memorySize := raw.Attributes.GetInt("memory_size")
	if memorySize == 0 {
		memorySize = 128 // Default
	}

	timeout := raw.Attributes.GetInt("timeout")
	if timeout == 0 {
		timeout = 3 // Default
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_lambda_function.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryServerless,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"memory_size":       {Value: memorySize},
			"timeout":           {Value: timeout},
			"runtime":           raw.Attributes["runtime"],
			"architectures":     raw.Attributes["architectures"],
			"ephemeral_storage": raw.Attributes["ephemeral_storage"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
	}, nil
}

// ECSServiceBuilder builds assets for aws_ecs_service
type ECSServiceBuilder struct {
	baseBuilder
}

// NewECSServiceBuilder creates a new ECS service builder
func NewECSServiceBuilder() asset.Builder {
	return &ECSServiceBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_ecs_service",
			category:     types.CategoryContainer,
		},
	}
}

// Build converts a raw ECS service into an asset
func (b *ECSServiceBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	desiredCount := raw.Attributes.GetInt("desired_count")
	if desiredCount == 0 {
		desiredCount = 1
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_ecs_service.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryContainer,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"desired_count":   {Value: desiredCount},
			"task_definition": raw.Attributes["task_definition"],
			"launch_type":     raw.Attributes["launch_type"],
			"capacity_provider_strategy": raw.Attributes["capacity_provider_strategy"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
	}, nil
}

// EKSClusterBuilder builds assets for aws_eks_cluster
type EKSClusterBuilder struct {
	baseBuilder
}

// NewEKSClusterBuilder creates a new EKS cluster builder
func NewEKSClusterBuilder() asset.Builder {
	return &EKSClusterBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_eks_cluster",
			category:     types.CategoryContainer,
		},
	}
}

// Build converts a raw EKS cluster into an asset
func (b *EKSClusterBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	return &types.Asset{
		ID:       fmt.Sprintf("aws_eks_cluster.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryContainer,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"version": raw.Attributes["version"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
	}, nil
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\assets\database.go
# TYPE: go
# SIZE: 6530 bytes
################################################################################
// Package assets - AWS database asset builders
package assets

import (
	"context"
	"fmt"

	"terraform-cost/core/asset"
	"terraform-cost/core/types"
)

// RDSInstanceBuilder builds assets for aws_db_instance
type RDSInstanceBuilder struct {
	baseBuilder
}

// NewRDSInstanceBuilder creates a new RDS instance builder
func NewRDSInstanceBuilder() asset.Builder {
	return &RDSInstanceBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_db_instance",
			category:     types.CategoryDatabase,
		},
	}
}

// Build converts a raw RDS instance into an asset
func (b *RDSInstanceBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	instanceClass := raw.Attributes.GetString("instance_class")
	if instanceClass == "" {
		instanceClass = "db.t3.micro"
	}

	engine := raw.Attributes.GetString("engine")
	storageType := raw.Attributes.GetString("storage_type")
	if storageType == "" {
		storageType = "gp2"
	}

	allocatedStorage := raw.Attributes.GetInt("allocated_storage")
	if allocatedStorage == 0 {
		allocatedStorage = 20
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_db_instance.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryDatabase,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"instance_class":              {Value: instanceClass},
			"engine":                      {Value: engine},
			"engine_version":              raw.Attributes["engine_version"],
			"storage_type":                {Value: storageType},
			"allocated_storage":           {Value: allocatedStorage},
			"max_allocated_storage":       raw.Attributes["max_allocated_storage"],
			"iops":                        raw.Attributes["iops"],
			"storage_throughput":          raw.Attributes["storage_throughput"],
			"multi_az":                    raw.Attributes["multi_az"],
			"storage_encrypted":           raw.Attributes["storage_encrypted"],
			"performance_insights_enabled": raw.Attributes["performance_insights_enabled"],
			"backup_retention_period":     raw.Attributes["backup_retention_period"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// RDSClusterBuilder builds assets for aws_rds_cluster
type RDSClusterBuilder struct {
	baseBuilder
}

// NewRDSClusterBuilder creates a new RDS cluster builder
func NewRDSClusterBuilder() asset.Builder {
	return &RDSClusterBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_rds_cluster",
			category:     types.CategoryDatabase,
		},
	}
}

// Build converts a raw RDS cluster into an asset
func (b *RDSClusterBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	return &types.Asset{
		ID:       fmt.Sprintf("aws_rds_cluster.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryDatabase,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"engine":                  raw.Attributes["engine"],
			"engine_mode":             raw.Attributes["engine_mode"],
			"engine_version":          raw.Attributes["engine_version"],
			"serverlessv2_scaling_configuration": raw.Attributes["serverlessv2_scaling_configuration"],
			"backup_retention_period": raw.Attributes["backup_retention_period"],
			"storage_encrypted":       raw.Attributes["storage_encrypted"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// DynamoDBTableBuilder builds assets for aws_dynamodb_table
type DynamoDBTableBuilder struct {
	baseBuilder
}

// NewDynamoDBTableBuilder creates a new DynamoDB builder
func NewDynamoDBTableBuilder() asset.Builder {
	return &DynamoDBTableBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_dynamodb_table",
			category:     types.CategoryDatabase,
		},
	}
}

// Build converts a raw DynamoDB table into an asset
func (b *DynamoDBTableBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	billingMode := raw.Attributes.GetString("billing_mode")
	if billingMode == "" {
		billingMode = "PROVISIONED"
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_dynamodb_table.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryDatabase,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"billing_mode":           {Value: billingMode},
			"read_capacity":          raw.Attributes["read_capacity"],
			"write_capacity":         raw.Attributes["write_capacity"],
			"global_secondary_index": raw.Attributes["global_secondary_index"],
			"stream_enabled":         raw.Attributes["stream_enabled"],
			"table_class":            raw.Attributes["table_class"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// ElastiCacheClusterBuilder builds assets for aws_elasticache_cluster
type ElastiCacheClusterBuilder struct {
	baseBuilder
}

// NewElastiCacheClusterBuilder creates a new ElastiCache builder
func NewElastiCacheClusterBuilder() asset.Builder {
	return &ElastiCacheClusterBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_elasticache_cluster",
			category:     types.CategoryDatabase,
		},
	}
}

// Build converts a raw ElastiCache cluster into an asset
func (b *ElastiCacheClusterBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	nodeType := raw.Attributes.GetString("node_type")
	if nodeType == "" {
		nodeType = "cache.t3.micro"
	}

	numCacheNodes := raw.Attributes.GetInt("num_cache_nodes")
	if numCacheNodes == 0 {
		numCacheNodes = 1
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_elasticache_cluster.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryDatabase,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"node_type":       {Value: nodeType},
			"num_cache_nodes": {Value: numCacheNodes},
			"engine":          raw.Attributes["engine"],
			"engine_version":  raw.Attributes["engine_version"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\assets\ec2.go
# TYPE: go
# SIZE: 5341 bytes
################################################################################
// Package assets provides AWS asset builders.
package assets

import (
	"context"
	"fmt"

	"terraform-cost/core/asset"
	"terraform-cost/core/types"
)

// baseBuilder provides common functionality for AWS builders
type baseBuilder struct {
	resourceType string
	category     types.AssetCategory
}

func (b *baseBuilder) Provider() types.Provider {
	return types.ProviderAWS
}

func (b *baseBuilder) ResourceType() string {
	return b.resourceType
}

func (b *baseBuilder) Category() types.AssetCategory {
	return b.category
}

// EC2InstanceBuilder builds assets for aws_instance resources
type EC2InstanceBuilder struct {
	baseBuilder
}

// NewEC2InstanceBuilder creates a new EC2 instance builder
func NewEC2InstanceBuilder() asset.Builder {
	return &EC2InstanceBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_instance",
			category:     types.CategoryCompute,
		},
	}
}

// Build converts a raw EC2 instance into an asset
func (b *EC2InstanceBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	instanceType := raw.Attributes.GetString("instance_type")
	if instanceType == "" {
		instanceType = "t3.micro" // Default
	}

	ami := raw.Attributes.GetString("ami")
	az := raw.Attributes.GetString("availability_zone")

	// Extract region from AZ
	region := ""
	if len(az) > 0 {
		region = az[:len(az)-1]
	}

	asset := &types.Asset{
		ID:       fmt.Sprintf("aws_instance.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryCompute,
		Type:     raw.Type,
		Name:     raw.Name,
		Region:   types.Region(region),
		Attributes: types.Attributes{
			"instance_type": {Value: instanceType},
			"ami":           {Value: ami},
			"tenancy":       raw.Attributes["tenancy"],
			"ebs_optimized": raw.Attributes["ebs_optimized"],
			"monitoring":    raw.Attributes["monitoring"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}

	// Add root block device as child
	if rootBlock := raw.Attributes.Get("root_block_device"); rootBlock != nil {
		if rbdList, ok := rootBlock.([]interface{}); ok && len(rbdList) > 0 {
			if rbd, ok := rbdList[0].(map[string]interface{}); ok {
				child := &types.Asset{
					ID:       fmt.Sprintf("%s.root_block_device", asset.ID),
					Address:  types.ResourceAddress(fmt.Sprintf("%s.root_block_device", raw.Address)),
					Provider: types.ProviderAWS,
					Category: types.CategoryStorage,
					Type:     "aws_ebs_volume",
					Name:     "root",
					Parent:   asset,
					Attributes: types.Attributes{
						"volume_type": {Value: getMapString(rbd, "volume_type", "gp3")},
						"volume_size": {Value: getMapInt(rbd, "volume_size", 8)},
						"iops":        {Value: getMapInt(rbd, "iops", 0)},
						"throughput":  {Value: getMapInt(rbd, "throughput", 0)},
						"encrypted":   {Value: getMapBool(rbd, "encrypted", false)},
					},
				}
				asset.Children = append(asset.Children, child)
			}
		}
	}

	// Add additional EBS volumes as children
	if ebsBlocks := raw.Attributes.Get("ebs_block_device"); ebsBlocks != nil {
		if ebsList, ok := ebsBlocks.([]interface{}); ok {
			for i, ebs := range ebsList {
				if ebsMap, ok := ebs.(map[string]interface{}); ok {
					deviceName := getMapString(ebsMap, "device_name", fmt.Sprintf("/dev/sd%c", 'b'+i))
					child := &types.Asset{
						ID:       fmt.Sprintf("%s.ebs_block_device.%d", asset.ID, i),
						Address:  types.ResourceAddress(fmt.Sprintf("%s.ebs_block_device[%d]", raw.Address, i)),
						Provider: types.ProviderAWS,
						Category: types.CategoryStorage,
						Type:     "aws_ebs_volume",
						Name:     deviceName,
						Parent:   asset,
						Attributes: types.Attributes{
							"device_name": {Value: deviceName},
							"volume_type": {Value: getMapString(ebsMap, "volume_type", "gp3")},
							"volume_size": {Value: getMapInt(ebsMap, "volume_size", 8)},
							"iops":        {Value: getMapInt(ebsMap, "iops", 0)},
							"throughput":  {Value: getMapInt(ebsMap, "throughput", 0)},
							"encrypted":   {Value: getMapBool(ebsMap, "encrypted", false)},
						},
					}
					asset.Children = append(asset.Children, child)
				}
			}
		}
	}

	return asset, nil
}

// Helper functions
func extractTags(attrs types.Attributes) map[string]string {
	tags := make(map[string]string)
	if tagsAttr := attrs.Get("tags"); tagsAttr != nil {
		if tagsMap, ok := tagsAttr.(map[string]interface{}); ok {
			for k, v := range tagsMap {
				if s, ok := v.(string); ok {
					tags[k] = s
				}
			}
		}
	}
	return tags
}

func getMapString(m map[string]interface{}, key, defaultVal string) string {
	if v, ok := m[key]; ok {
		if s, ok := v.(string); ok {
			return s
		}
	}
	return defaultVal
}

func getMapInt(m map[string]interface{}, key string, defaultVal int) int {
	if v, ok := m[key]; ok {
		switch n := v.(type) {
		case int:
			return n
		case int64:
			return int(n)
		case float64:
			return int(n)
		}
	}
	return defaultVal
}

func getMapBool(m map[string]interface{}, key string, defaultVal bool) bool {
	if v, ok := m[key]; ok {
		if b, ok := v.(bool); ok {
			return b
		}
	}
	return defaultVal
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\assets\network.go
# TYPE: go
# SIZE: 4609 bytes
################################################################################
// Package assets - AWS network asset builders
package assets

import (
	"context"
	"fmt"

	"terraform-cost/core/asset"
	"terraform-cost/core/types"
)

// NATGatewayBuilder builds assets for aws_nat_gateway
type NATGatewayBuilder struct {
	baseBuilder
}

// NewNATGatewayBuilder creates a new NAT Gateway builder
func NewNATGatewayBuilder() asset.Builder {
	return &NATGatewayBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_nat_gateway",
			category:     types.CategoryNetwork,
		},
	}
}

// Build converts a raw NAT Gateway into an asset
func (b *NATGatewayBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	return &types.Asset{
		ID:       fmt.Sprintf("aws_nat_gateway.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryNetwork,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"connectivity_type": raw.Attributes["connectivity_type"],
			"subnet_id":         raw.Attributes["subnet_id"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// VPCEndpointBuilder builds assets for aws_vpc_endpoint
type VPCEndpointBuilder struct {
	baseBuilder
}

// NewVPCEndpointBuilder creates a new VPC Endpoint builder
func NewVPCEndpointBuilder() asset.Builder {
	return &VPCEndpointBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_vpc_endpoint",
			category:     types.CategoryNetwork,
		},
	}
}

// Build converts a raw VPC Endpoint into an asset
func (b *VPCEndpointBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	vpcEndpointType := raw.Attributes.GetString("vpc_endpoint_type")
	if vpcEndpointType == "" {
		vpcEndpointType = "Gateway"
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_vpc_endpoint.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryNetwork,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"vpc_endpoint_type": {Value: vpcEndpointType},
			"service_name":      raw.Attributes["service_name"],
			"vpc_id":            raw.Attributes["vpc_id"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// ELBBuilder builds assets for aws_elb (Classic)
type ELBBuilder struct {
	baseBuilder
}

// NewELBBuilder creates a new ELB builder
func NewELBBuilder() asset.Builder {
	return &ELBBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_elb",
			category:     types.CategoryNetwork,
		},
	}
}

// Build converts a raw ELB into an asset
func (b *ELBBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	return &types.Asset{
		ID:       fmt.Sprintf("aws_elb.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryNetwork,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"internal": raw.Attributes["internal"],
			"listener": raw.Attributes["listener"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// ALBBuilder builds assets for aws_lb (Application)
type ALBBuilder struct {
	baseBuilder
}

// NewALBBuilder creates a new ALB builder
func NewALBBuilder() asset.Builder {
	return &ALBBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_lb",
			category:     types.CategoryNetwork,
		},
	}
}

// Build converts a raw ALB/NLB into an asset
func (b *ALBBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	loadBalancerType := raw.Attributes.GetString("load_balancer_type")
	if loadBalancerType == "" {
		loadBalancerType = "application"
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_lb.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryNetwork,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"load_balancer_type": {Value: loadBalancerType},
			"internal":           raw.Attributes["internal"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// NLBBuilder builds assets for aws_lb (Network) - alias to ALBBuilder
func NewNLBBuilder() asset.Builder {
	return NewALBBuilder()
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\assets\other.go
# TYPE: go
# SIZE: 3785 bytes
################################################################################
// Package assets - AWS other asset builders
package assets

import (
	"context"
	"fmt"

	"terraform-cost/core/asset"
	"terraform-cost/core/types"
)

// CloudWatchLogGroupBuilder builds assets for aws_cloudwatch_log_group
type CloudWatchLogGroupBuilder struct {
	baseBuilder
}

// NewCloudWatchLogGroupBuilder creates a new CloudWatch Log Group builder
func NewCloudWatchLogGroupBuilder() asset.Builder {
	return &CloudWatchLogGroupBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_cloudwatch_log_group",
			category:     types.CategoryMonitoring,
		},
	}
}

// Build converts a raw CloudWatch Log Group into an asset
func (b *CloudWatchLogGroupBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	retentionDays := raw.Attributes.GetInt("retention_in_days")
	// 0 means never expire

	return &types.Asset{
		ID:       fmt.Sprintf("aws_cloudwatch_log_group.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryMonitoring,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"retention_in_days": {Value: retentionDays},
			"kms_key_id":        raw.Attributes["kms_key_id"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// KMSKeyBuilder builds assets for aws_kms_key
type KMSKeyBuilder struct {
	baseBuilder
}

// NewKMSKeyBuilder creates a new KMS Key builder
func NewKMSKeyBuilder() asset.Builder {
	return &KMSKeyBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_kms_key",
			category:     types.CategorySecurity,
		},
	}
}

// Build converts a raw KMS Key into an asset
func (b *KMSKeyBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	keySpec := raw.Attributes.GetString("customer_master_key_spec")
	if keySpec == "" {
		keySpec = "SYMMETRIC_DEFAULT"
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_kms_key.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategorySecurity,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"customer_master_key_spec": {Value: keySpec},
			"key_usage":                raw.Attributes["key_usage"],
			"is_enabled":               raw.Attributes["is_enabled"],
			"multi_region":              raw.Attributes["multi_region"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// SecretsManagerSecretBuilder builds assets for aws_secretsmanager_secret
type SecretsManagerSecretBuilder struct {
	baseBuilder
}

// NewSecretsManagerSecretBuilder creates a new Secrets Manager builder
func NewSecretsManagerSecretBuilder() asset.Builder {
	return &SecretsManagerSecretBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_secretsmanager_secret",
			category:     types.CategorySecurity,
		},
	}
}

// Build converts a raw Secrets Manager Secret into an asset
func (b *SecretsManagerSecretBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	return &types.Asset{
		ID:       fmt.Sprintf("aws_secretsmanager_secret.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategorySecurity,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"recovery_window_in_days": raw.Attributes["recovery_window_in_days"],
			"kms_key_id":              raw.Attributes["kms_key_id"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\assets\storage.go
# TYPE: go
# SIZE: 4249 bytes
################################################################################
// Package assets - AWS storage asset builders
package assets

import (
	"context"
	"fmt"

	"terraform-cost/core/asset"
	"terraform-cost/core/types"
)

// S3BucketBuilder builds assets for aws_s3_bucket
type S3BucketBuilder struct {
	baseBuilder
}

// NewS3BucketBuilder creates a new S3 bucket builder
func NewS3BucketBuilder() asset.Builder {
	return &S3BucketBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_s3_bucket",
			category:     types.CategoryStorage,
		},
	}
}

// Build converts a raw S3 bucket into an asset
func (b *S3BucketBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	return &types.Asset{
		ID:       fmt.Sprintf("aws_s3_bucket.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryStorage,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"bucket": raw.Attributes["bucket"],
			"acl":    raw.Attributes["acl"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// EBSVolumeBuilder builds assets for aws_ebs_volume
type EBSVolumeBuilder struct {
	baseBuilder
}

// NewEBSVolumeBuilder creates a new EBS volume builder
func NewEBSVolumeBuilder() asset.Builder {
	return &EBSVolumeBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_ebs_volume",
			category:     types.CategoryStorage,
		},
	}
}

// Build converts a raw EBS volume into an asset
func (b *EBSVolumeBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	volumeType := raw.Attributes.GetString("type")
	if volumeType == "" {
		volumeType = "gp3"
	}

	size := raw.Attributes.GetInt("size")
	if size == 0 {
		size = 8
	}

	az := raw.Attributes.GetString("availability_zone")
	region := ""
	if len(az) > 0 {
		region = az[:len(az)-1]
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_ebs_volume.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryStorage,
		Type:     raw.Type,
		Name:     raw.Name,
		Region:   types.Region(region),
		Attributes: types.Attributes{
			"type":              {Value: volumeType},
			"size":              {Value: size},
			"iops":              raw.Attributes["iops"],
			"throughput":        raw.Attributes["throughput"],
			"encrypted":         raw.Attributes["encrypted"],
			"availability_zone": {Value: az},
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

// EFSFileSystemBuilder builds assets for aws_efs_file_system
type EFSFileSystemBuilder struct {
	baseBuilder
}

// NewEFSFileSystemBuilder creates a new EFS builder
func NewEFSFileSystemBuilder() asset.Builder {
	return &EFSFileSystemBuilder{
		baseBuilder: baseBuilder{
			resourceType: "aws_efs_file_system",
			category:     types.CategoryStorage,
		},
	}
}

// Build converts a raw EFS file system into an asset
func (b *EFSFileSystemBuilder) Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error) {
	throughputMode := raw.Attributes.GetString("throughput_mode")
	if throughputMode == "" {
		throughputMode = "bursting"
	}

	performanceMode := raw.Attributes.GetString("performance_mode")
	if performanceMode == "" {
		performanceMode = "generalPurpose"
	}

	return &types.Asset{
		ID:       fmt.Sprintf("aws_efs_file_system.%s", raw.Name),
		Address:  raw.Address,
		Provider: types.ProviderAWS,
		Category: types.CategoryStorage,
		Type:     raw.Type,
		Name:     raw.Name,
		Attributes: types.Attributes{
			"throughput_mode":                  {Value: throughputMode},
			"performance_mode":                 {Value: performanceMode},
			"provisioned_throughput_in_mibps":  raw.Attributes["provisioned_throughput_in_mibps"],
			"encrypted":                        raw.Attributes["encrypted"],
			"lifecycle_policy":                 raw.Attributes["lifecycle_policy"],
		},
		Metadata: types.AssetMetadata{
			Source: raw.SourceFile,
			Line:   raw.SourceLine,
		},
		Tags: extractTags(raw.Attributes),
	}, nil
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\pricing\source.go
# TYPE: go
# SIZE: 7230 bytes
################################################################################
// Package pricing provides AWS pricing source.
package pricing

import (
	"context"
	"fmt"
	"time"

	"github.com/shopspring/decimal"

	corePricing "terraform-cost/core/pricing"
	"terraform-cost/core/types"
)

// AWSPricingSource fetches pricing from AWS Pricing API
type AWSPricingSource struct {
	defaultRegion string
	// In production, this would use the AWS SDK
	// client *pricing.Client
}

// NewAWSPricingSource creates a new AWS pricing source
func NewAWSPricingSource(region string) corePricing.Source {
	return &AWSPricingSource{
		defaultRegion: region,
	}
}

// Provider returns AWS
func (s *AWSPricingSource) Provider() types.Provider {
	return types.ProviderAWS
}

// FetchRates retrieves rates for the given keys
func (s *AWSPricingSource) FetchRates(ctx context.Context, keys []types.RateKey) ([]types.Rate, error) {
	rates := make([]types.Rate, 0, len(keys))

	for _, key := range keys {
		rate, err := s.fetchRate(ctx, key)
		if err != nil {
			continue // Skip missing rates
		}
		rates = append(rates, rate)
	}

	return rates, nil
}

// FetchAll retrieves all rates for a region
func (s *AWSPricingSource) FetchAll(ctx context.Context, region string) ([]types.Rate, error) {
	// In production, this would call the AWS Pricing API
	// For now, return common defaults
	return s.getDefaultRates(region), nil
}

// SupportedRegions returns the list of supported AWS regions
func (s *AWSPricingSource) SupportedRegions() []string {
	return []string{
		"us-east-1", "us-east-2", "us-west-1", "us-west-2",
		"eu-west-1", "eu-west-2", "eu-west-3", "eu-central-1",
		"ap-northeast-1", "ap-northeast-2", "ap-southeast-1", "ap-southeast-2",
		"ap-south-1", "sa-east-1", "ca-central-1",
	}
}

func (s *AWSPricingSource) fetchRate(ctx context.Context, key types.RateKey) (types.Rate, error) {
	// In production, this would call the AWS Pricing API
	// For now, return hardcoded defaults for common resources

	switch key.Service {
	case "EC2":
		return s.getEC2Rate(key)
	case "RDS":
		return s.getRDSRate(key)
	case "S3":
		return s.getS3Rate(key)
	case "Lambda":
		return s.getLambdaRate(key)
	case "NAT Gateway":
		return s.getNATGatewayRate(key)
	case "EBS":
		return s.getEBSRate(key)
	default:
		return types.Rate{}, fmt.Errorf("unknown service: %s", key.Service)
	}
}

func (s *AWSPricingSource) getEC2Rate(key types.RateKey) (types.Rate, error) {
	// Instance type pricing (On-Demand, us-east-1)
	instancePricing := map[string]float64{
		"t3.micro":    0.0104,
		"t3.small":    0.0208,
		"t3.medium":   0.0416,
		"t3.large":    0.0832,
		"t3.xlarge":   0.1664,
		"t3.2xlarge":  0.3328,
		"m5.large":    0.096,
		"m5.xlarge":   0.192,
		"m5.2xlarge":  0.384,
		"m5.4xlarge":  0.768,
		"c5.large":    0.085,
		"c5.xlarge":   0.17,
		"c5.2xlarge":  0.34,
		"r5.large":    0.126,
		"r5.xlarge":   0.252,
		"r5.2xlarge":  0.504,
	}

	instanceType := key.Attributes["instance_type"]
	price, ok := instancePricing[instanceType]
	if !ok {
		price = 0.10 // Default
	}

	return types.Rate{
		Key:           key,
		Price:         decimal.NewFromFloat(price),
		Unit:          "hour",
		Currency:      types.CurrencyUSD,
		EffectiveFrom: time.Now().AddDate(0, -1, 0),
	}, nil
}

func (s *AWSPricingSource) getRDSRate(key types.RateKey) (types.Rate, error) {
	// RDS instance pricing (Single-AZ, us-east-1)
	instancePricing := map[string]float64{
		"db.t3.micro":   0.017,
		"db.t3.small":   0.034,
		"db.t3.medium":  0.068,
		"db.t3.large":   0.136,
		"db.m5.large":   0.171,
		"db.m5.xlarge":  0.342,
		"db.m5.2xlarge": 0.684,
		"db.r5.large":   0.24,
		"db.r5.xlarge":  0.48,
		"db.r5.2xlarge": 0.96,
	}

	instanceClass := key.Attributes["instance_class"]
	price, ok := instancePricing[instanceClass]
	if !ok {
		price = 0.10 // Default
	}

	return types.Rate{
		Key:           key,
		Price:         decimal.NewFromFloat(price),
		Unit:          "hour",
		Currency:      types.CurrencyUSD,
		EffectiveFrom: time.Now().AddDate(0, -1, 0),
	}, nil
}

func (s *AWSPricingSource) getS3Rate(key types.RateKey) (types.Rate, error) {
	// S3 pricing (Standard, us-east-1)
	storageClass := key.Attributes["storage_class"]
	if storageClass == "" {
		storageClass = "STANDARD"
	}

	prices := map[string]float64{
		"STANDARD":            0.023,  // per GB-month
		"STANDARD_IA":         0.0125,
		"ONEZONE_IA":          0.01,
		"GLACIER":             0.004,
		"GLACIER_DEEP_ARCHIVE": 0.00099,
	}

	price, ok := prices[storageClass]
	if !ok {
		price = 0.023
	}

	return types.Rate{
		Key:           key,
		Price:         decimal.NewFromFloat(price),
		Unit:          "GB-month",
		Currency:      types.CurrencyUSD,
		EffectiveFrom: time.Now().AddDate(0, -1, 0),
	}, nil
}

func (s *AWSPricingSource) getLambdaRate(key types.RateKey) (types.Rate, error) {
	// Lambda is priced per GB-second and per request
	rateType := key.Attributes["rate_type"]

	switch rateType {
	case "requests":
		return types.Rate{
			Key:           key,
			Price:         decimal.NewFromFloat(0.0000002), // $0.20 per 1M requests
			Unit:          "request",
			Currency:      types.CurrencyUSD,
			EffectiveFrom: time.Now().AddDate(0, -1, 0),
		}, nil
	case "duration":
		return types.Rate{
			Key:           key,
			Price:         decimal.NewFromFloat(0.0000166667), // per GB-second
			Unit:          "GB-second",
			Currency:      types.CurrencyUSD,
			EffectiveFrom: time.Now().AddDate(0, -1, 0),
		}, nil
	default:
		return types.Rate{}, fmt.Errorf("unknown Lambda rate type")
	}
}

func (s *AWSPricingSource) getNATGatewayRate(key types.RateKey) (types.Rate, error) {
	rateType := key.Attributes["rate_type"]

	switch rateType {
	case "hourly":
		return types.Rate{
			Key:           key,
			Price:         decimal.NewFromFloat(0.045), // per hour
			Unit:          "hour",
			Currency:      types.CurrencyUSD,
			EffectiveFrom: time.Now().AddDate(0, -1, 0),
		}, nil
	case "data":
		return types.Rate{
			Key:           key,
			Price:         decimal.NewFromFloat(0.045), // per GB processed
			Unit:          "GB",
			Currency:      types.CurrencyUSD,
			EffectiveFrom: time.Now().AddDate(0, -1, 0),
		}, nil
	default:
		return types.Rate{}, fmt.Errorf("unknown NAT Gateway rate type")
	}
}

func (s *AWSPricingSource) getEBSRate(key types.RateKey) (types.Rate, error) {
	// EBS pricing per GB-month
	volumeType := key.Attributes["volume_type"]

	prices := map[string]float64{
		"gp3":      0.08,
		"gp2":      0.10,
		"io1":      0.125,
		"io2":      0.125,
		"st1":      0.045,
		"sc1":      0.015,
		"standard": 0.05,
	}

	price, ok := prices[volumeType]
	if !ok {
		price = 0.10
	}

	return types.Rate{
		Key:           key,
		Price:         decimal.NewFromFloat(price),
		Unit:          "GB-month",
		Currency:      types.CurrencyUSD,
		EffectiveFrom: time.Now().AddDate(0, -1, 0),
	}, nil
}

func (s *AWSPricingSource) getDefaultRates(region string) []types.Rate {
	// Return a set of common default rates
	// In production, this would be fetched from AWS
	return []types.Rate{}
}

################################################################################
# FILE: :\good projects\cost estimation\clouds\aws\usage\estimators.go
# TYPE: go
# SIZE: 10814 bytes
################################################################################
// Package usage provides AWS usage estimators.
package usage

import (
	"context"

	"terraform-cost/core/types"
	coreUsage "terraform-cost/core/usage"
)

// baseEstimator provides common functionality for AWS estimators
type baseEstimator struct {
	resourceType string
}

func (e *baseEstimator) Provider() types.Provider {
	return types.ProviderAWS
}

func (e *baseEstimator) ResourceType() string {
	return e.resourceType
}

// EC2InstanceEstimator estimates usage for aws_instance
type EC2InstanceEstimator struct {
	baseEstimator
}

// NewEC2InstanceEstimator creates a new EC2 instance estimator
func NewEC2InstanceEstimator() coreUsage.Estimator {
	return &EC2InstanceEstimator{
		baseEstimator: baseEstimator{resourceType: "aws_instance"},
	}
}

// Estimate produces usage vectors for an EC2 instance
func (e *EC2InstanceEstimator) Estimate(ctx context.Context, asset *types.Asset, uctx *coreUsage.Context) ([]types.UsageVector, error) {
	// Default: 24/7 operation = 730 hours/month
	monthlyHours := 730.0
	confidence := 0.8

	// Check for overrides
	if uctx != nil && uctx.Profile != nil {
		if overrides := uctx.Profile.GetOverrides(asset.Address); len(overrides) > 0 {
			return overrides, nil
		}
	}

	// Adjust based on environment
	if uctx != nil && uctx.Environment == "development" {
		// Dev environments typically run 8 hours/day, 5 days/week
		monthlyHours = 8 * 5 * 4 // ~160 hours
		confidence = 0.6
	}

	return []types.UsageVector{
		{
			Metric:      types.MetricMonthlyHours,
			Value:       monthlyHours,
			Confidence:  confidence,
			Source:      types.SourceDefault,
			Description: "Estimated monthly runtime hours",
		},
	}, nil
}

// S3BucketEstimator estimates usage for aws_s3_bucket
type S3BucketEstimator struct {
	baseEstimator
}

// NewS3BucketEstimator creates a new S3 bucket estimator
func NewS3BucketEstimator() coreUsage.Estimator {
	return &S3BucketEstimator{
		baseEstimator: baseEstimator{resourceType: "aws_s3_bucket"},
	}
}

// Estimate produces usage vectors for an S3 bucket
func (e *S3BucketEstimator) Estimate(ctx context.Context, asset *types.Asset, uctx *coreUsage.Context) ([]types.UsageVector, error) {
	// Check for overrides
	if uctx != nil && uctx.Profile != nil {
		if overrides := uctx.Profile.GetOverrides(asset.Address); len(overrides) > 0 {
			return overrides, nil
		}
	}

	// Default estimates - these should be overridden in production
	return []types.UsageVector{
		{
			Metric:      types.MetricMonthlyGBStorage,
			Value:       100, // 100 GB default
			Confidence:  0.3, // Low confidence - highly variable
			Source:      types.SourceDefault,
			Description: "Estimated monthly storage in GB",
		},
		{
			Metric:      types.MetricMonthlyGetOperations,
			Value:       100000, // 100k GET requests
			Confidence:  0.3,
			Source:      types.SourceDefault,
			Description: "Estimated monthly GET requests",
		},
		{
			Metric:      types.MetricMonthlyPutOperations,
			Value:       10000, // 10k PUT requests
			Confidence:  0.3,
			Source:      types.SourceDefault,
			Description: "Estimated monthly PUT requests",
		},
		{
			Metric:      types.MetricMonthlyGBTransferOut,
			Value:       10, // 10 GB transfer out
			Confidence:  0.3,
			Source:      types.SourceDefault,
			Description: "Estimated monthly data transfer out in GB",
		},
	}, nil
}

// RDSInstanceEstimator estimates usage for aws_db_instance
type RDSInstanceEstimator struct {
	baseEstimator
}

// NewRDSInstanceEstimator creates a new RDS instance estimator
func NewRDSInstanceEstimator() coreUsage.Estimator {
	return &RDSInstanceEstimator{
		baseEstimator: baseEstimator{resourceType: "aws_db_instance"},
	}
}

// Estimate produces usage vectors for an RDS instance
func (e *RDSInstanceEstimator) Estimate(ctx context.Context, asset *types.Asset, uctx *coreUsage.Context) ([]types.UsageVector, error) {
	// Check for overrides
	if uctx != nil && uctx.Profile != nil {
		if overrides := uctx.Profile.GetOverrides(asset.Address); len(overrides) > 0 {
			return overrides, nil
		}
	}

	// Get storage from attributes
	storage := asset.Attributes.GetInt("allocated_storage")
	if storage == 0 {
		storage = 20
	}

	return []types.UsageVector{
		{
			Metric:      types.MetricMonthlyHours,
			Value:       730, // 24/7
			Confidence:  0.9,
			Source:      types.SourceDefault,
			Description: "Database typically runs 24/7",
		},
		{
			Metric:      types.MetricMonthlyGBStorage,
			Value:       float64(storage),
			Confidence:  0.95,
			Source:      types.SourceTerraform,
			Description: "Storage from Terraform configuration",
		},
		{
			Metric:      types.MetricMonthlyBackupStorageGB,
			Value:       float64(storage), // Assume backup equals storage
			Confidence:  0.5,
			Source:      types.SourceDefault,
			Description: "Estimated backup storage",
		},
	}, nil
}

// LambdaFunctionEstimator estimates usage for aws_lambda_function
type LambdaFunctionEstimator struct {
	baseEstimator
}

// NewLambdaFunctionEstimator creates a new Lambda function estimator
func NewLambdaFunctionEstimator() coreUsage.Estimator {
	return &LambdaFunctionEstimator{
		baseEstimator: baseEstimator{resourceType: "aws_lambda_function"},
	}
}

// Estimate produces usage vectors for a Lambda function
func (e *LambdaFunctionEstimator) Estimate(ctx context.Context, asset *types.Asset, uctx *coreUsage.Context) ([]types.UsageVector, error) {
	// Check for overrides
	if uctx != nil && uctx.Profile != nil {
		if overrides := uctx.Profile.GetOverrides(asset.Address); len(overrides) > 0 {
			return overrides, nil
		}
	}

	memorySize := asset.Attributes.GetInt("memory_size")
	if memorySize == 0 {
		memorySize = 128
	}

	timeout := asset.Attributes.GetInt("timeout")
	if timeout == 0 {
		timeout = 3
	}

	// Default: 1 million invocations, average 500ms duration
	invocations := 1000000.0
	avgDurationMs := float64(timeout) * 1000 * 0.5 // 50% of timeout

	return []types.UsageVector{
		{
			Metric:      types.MetricMonthlyInvocations,
			Value:       invocations,
			Confidence:  0.3, // Very variable
			Source:      types.SourceDefault,
			Description: "Estimated monthly invocations",
		},
		{
			Metric:      types.MetricMonthlyDurationMs,
			Value:       avgDurationMs,
			Confidence:  0.3,
			Source:      types.SourceDefault,
			Description: "Average execution duration in ms",
		},
		{
			Metric:      types.MetricMonthlyGBSeconds,
			Value:       (float64(memorySize) / 1024) * (avgDurationMs / 1000) * invocations,
			Confidence:  0.3,
			Source:      types.SourceDefault,
			Description: "Compute GB-seconds",
		},
	}, nil
}

// DynamoDBTableEstimator estimates usage for aws_dynamodb_table
type DynamoDBTableEstimator struct {
	baseEstimator
}

// NewDynamoDBTableEstimator creates a new DynamoDB table estimator
func NewDynamoDBTableEstimator() coreUsage.Estimator {
	return &DynamoDBTableEstimator{
		baseEstimator: baseEstimator{resourceType: "aws_dynamodb_table"},
	}
}

// Estimate produces usage vectors for a DynamoDB table
func (e *DynamoDBTableEstimator) Estimate(ctx context.Context, asset *types.Asset, uctx *coreUsage.Context) ([]types.UsageVector, error) {
	// Check for overrides
	if uctx != nil && uctx.Profile != nil {
		if overrides := uctx.Profile.GetOverrides(asset.Address); len(overrides) > 0 {
			return overrides, nil
		}
	}

	billingMode := asset.Attributes.GetString("billing_mode")

	vectors := []types.UsageVector{
		{
			Metric:      types.MetricMonthlyGBStorage,
			Value:       10, // 10 GB default
			Confidence:  0.3,
			Source:      types.SourceDefault,
			Description: "Estimated table storage",
		},
	}

	if billingMode == "PAY_PER_REQUEST" {
		vectors = append(vectors,
			types.UsageVector{
				Metric:      types.MetricMonthlyReadRequests,
				Value:       1000000,
				Confidence:  0.3,
				Source:      types.SourceDefault,
				Description: "Estimated read request units",
			},
			types.UsageVector{
				Metric:      types.MetricMonthlyWriteRequests,
				Value:       100000,
				Confidence:  0.3,
				Source:      types.SourceDefault,
				Description: "Estimated write request units",
			},
		)
	}

	return vectors, nil
}

// NATGatewayEstimator estimates usage for aws_nat_gateway
type NATGatewayEstimator struct {
	baseEstimator
}

// NewNATGatewayEstimator creates a new NAT Gateway estimator
func NewNATGatewayEstimator() coreUsage.Estimator {
	return &NATGatewayEstimator{
		baseEstimator: baseEstimator{resourceType: "aws_nat_gateway"},
	}
}

// Estimate produces usage vectors for a NAT Gateway
func (e *NATGatewayEstimator) Estimate(ctx context.Context, asset *types.Asset, uctx *coreUsage.Context) ([]types.UsageVector, error) {
	// Check for overrides
	if uctx != nil && uctx.Profile != nil {
		if overrides := uctx.Profile.GetOverrides(asset.Address); len(overrides) > 0 {
			return overrides, nil
		}
	}

	return []types.UsageVector{
		{
			Metric:      types.MetricMonthlyHours,
			Value:       730, // 24/7
			Confidence:  0.95,
			Source:      types.SourceDefault,
			Description: "NAT Gateway runs continuously",
		},
		{
			Metric:      types.MetricMonthlyGB,
			Value:       100, // 100 GB data processed
			Confidence:  0.3,
			Source:      types.SourceDefault,
			Description: "Estimated data processed through NAT",
		},
	}, nil
}

// EBSVolumeEstimator estimates usage for aws_ebs_volume
type EBSVolumeEstimator struct {
	baseEstimator
}

// NewEBSVolumeEstimator creates a new EBS volume estimator
func NewEBSVolumeEstimator() coreUsage.Estimator {
	return &EBSVolumeEstimator{
		baseEstimator: baseEstimator{resourceType: "aws_ebs_volume"},
	}
}

// Estimate produces usage vectors for an EBS volume
func (e *EBSVolumeEstimator) Estimate(ctx context.Context, asset *types.Asset, uctx *coreUsage.Context) ([]types.UsageVector, error) {
	// Check for overrides
	if uctx != nil && uctx.Profile != nil {
		if overrides := uctx.Profile.GetOverrides(asset.Address); len(overrides) > 0 {
			return overrides, nil
		}
	}

	size := asset.Attributes.GetInt("size")
	if size == 0 {
		size = 8
	}

	return []types.UsageVector{
		{
			Metric:      types.MetricMonthlyGBStorage,
			Value:       float64(size),
			Confidence:  0.95,
			Source:      types.SourceTerraform,
			Description: "Volume size from Terraform configuration",
		},
		{
			Metric:      types.MetricMonthlySnapshots,
			Value:       1, // One snapshot per month
			Confidence:  0.5,
			Source:      types.SourceDefault,
			Description: "Estimated monthly snapshots",
		},
	}, nil
}

################################################################################
# FILE: :\good projects\cost estimation\cmd\cli\main.go
# TYPE: go
# SIZE: 207 bytes
################################################################################
// Package main is the entry point for terraform-cost CLI.
package main

import (
	"os"

	"terraform-cost/cmd/cli/cmd"
)

func main() {
	if err := cmd.Execute(); err != nil {
		os.Exit(1)
	}
}

################################################################################
# FILE: :\good projects\cost estimation\cmd\cli\cmd\estimate.go
# TYPE: go
# SIZE: 12916 bytes
################################################################################
// Package cmd - estimate command
package cmd

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/shopspring/decimal"
	"github.com/spf13/cobra"

	"terraform-cost/clouds"
	"terraform-cost/clouds/aws"
	"terraform-cost/core/asset"
	"terraform-cost/core/output"
	"terraform-cost/core/scanner"
	"terraform-cost/core/types"
	"terraform-cost/internal/logging"
)

var (
	outputFormat string
	usageFile    string
	showDetails  bool
	region       string
)

// estimateCmd represents the estimate command
var estimateCmd = &cobra.Command{
	Use:   "estimate [path]",
	Short: "Estimate costs for a Terraform project",
	Long: `Analyze Terraform configurations and produce cost estimates.

The path can be a directory containing .tf files or a Terraform plan JSON file.

Examples:
  terraform-cost estimate .
  terraform-cost estimate ./infrastructure
  terraform-cost estimate --format json ./my-project
  terraform-cost estimate --usage usage.yml ./my-project`,
	Args: cobra.MaximumNArgs(1),
	RunE: runEstimate,
}

func init() {
	estimateCmd.Flags().StringVarP(&outputFormat, "format", "f", "cli", "output format (cli, json, html, markdown)")
	estimateCmd.Flags().StringVarP(&usageFile, "usage", "u", "", "usage file for custom usage estimates")
	estimateCmd.Flags().BoolVarP(&showDetails, "details", "d", true, "show detailed cost breakdown")
	estimateCmd.Flags().StringVarP(&region, "region", "r", "", "default AWS region")
}

func runEstimate(cmd *cobra.Command, args []string) error {
	ctx := context.Background()
	startTime := time.Now()

	// Determine path
	path := "."
	if len(args) > 0 {
		path = args[0]
	}

	// Validate path exists
	if _, err := os.Stat(path); os.IsNotExist(err) {
		return fmt.Errorf("path does not exist: %s", path)
	}

	logging.Info("Starting cost estimation")

	// Initialize cloud plugins
	if err := initializePlugins(); err != nil {
		return fmt.Errorf("failed to initialize plugins: %w", err)
	}

	// Create project input
	input := &types.ProjectInput{
		ID:     fmt.Sprintf("estimate-%d", time.Now().Unix()),
		Path:   path,
		Source: types.SourceCLI,
		Metadata: types.InputMetadata{
			Timestamp: time.Now(),
		},
	}

	// Scan the project
	fmt.Println("Scanning Terraform files...")
	scanResult, err := scanner.GetDefault().DetectAndScan(ctx, input)
	if err != nil {
		return fmt.Errorf("failed to scan project: %w", err)
	}

	if scanResult.HasErrors() {
		fmt.Printf("Warning: %d errors during scanning\n", len(scanResult.Errors))
		for _, e := range scanResult.Errors {
			fmt.Printf("  %s:%d: %s\n", e.File, e.Line, e.Message)
		}
	}

	if len(scanResult.Assets) == 0 {
		fmt.Println("No resources found in the project.")
		return nil
	}

	fmt.Printf("Found %d resources\n\n", len(scanResult.Assets))

	// Build asset graph
	graph := buildAssetGraph(ctx, scanResult.Assets)

	// Calculate costs (simplified)
	costGraph := calculateCosts(graph)

	// Create estimation result
	result := &output.EstimationResult{
		CostGraph:  costGraph,
		AssetGraph: graph,
		Confidence: 0.7,
		Metadata: output.EstimationMetadata{
			Timestamp: time.Now().Format(time.RFC3339),
			Duration:  time.Since(startTime).String(),
			Version:   "0.1.0",
			Source:    types.SourceCLI,
		},
	}

	// Output results
	printResults(result)

	return nil
}

func initializePlugins() error {
	// Register AWS plugin
	awsPlugin := aws.New()
	if region != "" {
		awsPlugin = aws.NewWithRegion(region)
	}
	
	if err := clouds.RegisterPlugin(awsPlugin); err != nil {
		return err
	}

	return nil
}

func buildAssetGraph(ctx context.Context, rawAssets []types.RawAsset) *types.AssetGraph {
	graph := types.NewAssetGraph()
	builderRegistry := asset.GetDefaultBuilderRegistry()

	// Register AWS builders
	awsPlugin := aws.New()
	for _, builder := range awsPlugin.AssetBuilders() {
		builderRegistry.Register(builder)
	}

	for _, raw := range rawAssets {
		builder, ok := builderRegistry.GetBuilder(raw.Provider, raw.Type)
		if !ok {
			// No builder for this resource type - create a generic asset
			asset := &types.Asset{
				ID:         fmt.Sprintf("%s.%s", raw.Type, raw.Name),
				Address:    raw.Address,
				Provider:   raw.Provider,
				Category:   types.CategoryOther,
				Type:       raw.Type,
				Name:       raw.Name,
				Attributes: raw.Attributes,
				Metadata: types.AssetMetadata{
					Source: raw.SourceFile,
					Line:   raw.SourceLine,
				},
			}
			graph.Add(asset)
			continue
		}

		asset, err := builder.Build(ctx, &raw)
		if err != nil {
			fmt.Printf("Warning: failed to build asset %s: %v\n", raw.Address, err)
			continue
		}

		graph.Add(asset)
	}

	return graph
}

func calculateCosts(graph *types.AssetGraph) *types.CostGraph {
	costGraph := types.NewCostGraph(types.CurrencyUSD)

	graph.Walk(func(asset *types.Asset) error {
		// Calculate cost for this asset
		units := calculateAssetCost(asset)
		for _, unit := range units {
			costGraph.AddCostUnit(unit, asset)
		}
		return nil
	})

	costGraph.Summarize()
	return costGraph
}

func calculateAssetCost(asset *types.Asset) []*types.CostUnit {
	var units []*types.CostUnit

	// Simplified cost calculation based on resource type
	switch asset.Type {
	case "aws_instance":
		instanceType := asset.Attributes.GetString("instance_type")
		if instanceType == "" {
			instanceType = "t3.micro"
		}
		hourlyRate := getEC2HourlyRate(instanceType)
		monthlyHours := decimal.NewFromInt(730)
		monthlyCost := hourlyRate.Mul(monthlyHours)

		units = append(units, &types.CostUnit{
			ID:       fmt.Sprintf("%s-compute", asset.ID),
			Label:    fmt.Sprintf("EC2 Instance (%s)", instanceType),
			Measure:  "hours",
			Quantity: monthlyHours,
			Rate:     hourlyRate,
			Amount:   monthlyCost,
			Currency: types.CurrencyUSD,
			Lineage: types.CostLineage{
				AssetID:      asset.ID,
				AssetAddress: asset.Address,
				Formula:      "hourly_rate * 730 hours/month",
			},
		})

	case "aws_db_instance":
		instanceClass := asset.Attributes.GetString("instance_class")
		if instanceClass == "" {
			instanceClass = "db.t3.micro"
		}
		hourlyRate := getRDSHourlyRate(instanceClass)
		monthlyHours := decimal.NewFromInt(730)
		monthlyCost := hourlyRate.Mul(monthlyHours)

		units = append(units, &types.CostUnit{
			ID:       fmt.Sprintf("%s-compute", asset.ID),
			Label:    fmt.Sprintf("RDS Instance (%s)", instanceClass),
			Measure:  "hours",
			Quantity: monthlyHours,
			Rate:     hourlyRate,
			Amount:   monthlyCost,
			Currency: types.CurrencyUSD,
			Lineage: types.CostLineage{
				AssetID:      asset.ID,
				AssetAddress: asset.Address,
				Formula:      "hourly_rate * 730 hours/month",
			},
		})

		// Add storage cost
		storage := asset.Attributes.GetInt("allocated_storage")
		if storage > 0 {
			storageRate := decimal.NewFromFloat(0.115) // gp2 per GB-month
			storageCost := storageRate.Mul(decimal.NewFromInt(int64(storage)))
			units = append(units, &types.CostUnit{
				ID:       fmt.Sprintf("%s-storage", asset.ID),
				Label:    "RDS Storage (gp2)",
				Measure:  "GB-month",
				Quantity: decimal.NewFromInt(int64(storage)),
				Rate:     storageRate,
				Amount:   storageCost,
				Currency: types.CurrencyUSD,
				Lineage: types.CostLineage{
					AssetID:      asset.ID,
					AssetAddress: asset.Address,
					Formula:      "storage_gb * $0.115/GB-month",
				},
			})
		}

	case "aws_nat_gateway":
		hourlyRate := decimal.NewFromFloat(0.045)
		monthlyHours := decimal.NewFromInt(730)
		monthlyCost := hourlyRate.Mul(monthlyHours)

		units = append(units, &types.CostUnit{
			ID:       fmt.Sprintf("%s-hourly", asset.ID),
			Label:    "NAT Gateway",
			Measure:  "hours",
			Quantity: monthlyHours,
			Rate:     hourlyRate,
			Amount:   monthlyCost,
			Currency: types.CurrencyUSD,
			Lineage: types.CostLineage{
				AssetID:      asset.ID,
				AssetAddress: asset.Address,
				Formula:      "$0.045/hour * 730 hours/month",
			},
		})

	case "aws_ebs_volume":
		volumeType := asset.Attributes.GetString("type")
		if volumeType == "" {
			volumeType = "gp3"
		}
		size := asset.Attributes.GetInt("size")
		if size == 0 {
			size = 8
		}
		rate := getEBSRate(volumeType)
		amount := rate.Mul(decimal.NewFromInt(int64(size)))

		units = append(units, &types.CostUnit{
			ID:       fmt.Sprintf("%s-storage", asset.ID),
			Label:    fmt.Sprintf("EBS Volume (%s)", volumeType),
			Measure:  "GB-month",
			Quantity: decimal.NewFromInt(int64(size)),
			Rate:     rate,
			Amount:   amount,
			Currency: types.CurrencyUSD,
			Lineage: types.CostLineage{
				AssetID:      asset.ID,
				AssetAddress: asset.Address,
				Formula:      fmt.Sprintf("$%.3f/GB-month * %d GB", rate.InexactFloat64(), size),
			},
		})

	case "aws_lambda_function":
		// Lambda free tier: 1M requests, 400K GB-seconds
		// Just show a minimal cost for estimation
		units = append(units, &types.CostUnit{
			ID:       fmt.Sprintf("%s-compute", asset.ID),
			Label:    "Lambda Function (usage-based)",
			Measure:  "invocations",
			Quantity: decimal.NewFromInt(1000000),
			Rate:     decimal.NewFromFloat(0.0000002),
			Amount:   decimal.NewFromFloat(0.20),
			Currency: types.CurrencyUSD,
			Lineage: types.CostLineage{
				AssetID:      asset.ID,
				AssetAddress: asset.Address,
				Formula:      "Usage-based pricing (1M requests estimate)",
				Assumptions:  []string{"Estimated 1M invocations/month"},
			},
		})
	}

	return units
}

func getEC2HourlyRate(instanceType string) decimal.Decimal {
	rates := map[string]float64{
		"t3.micro":   0.0104,
		"t3.small":   0.0208,
		"t3.medium":  0.0416,
		"t3.large":   0.0832,
		"t3.xlarge":  0.1664,
		"m5.large":   0.096,
		"m5.xlarge":  0.192,
		"c5.large":   0.085,
		"r5.large":   0.126,
	}
	if rate, ok := rates[instanceType]; ok {
		return decimal.NewFromFloat(rate)
	}
	return decimal.NewFromFloat(0.10) // Default
}

func getRDSHourlyRate(instanceClass string) decimal.Decimal {
	rates := map[string]float64{
		"db.t3.micro":   0.017,
		"db.t3.small":   0.034,
		"db.t3.medium":  0.068,
		"db.m5.large":   0.171,
		"db.r5.large":   0.24,
	}
	if rate, ok := rates[instanceClass]; ok {
		return decimal.NewFromFloat(rate)
	}
	return decimal.NewFromFloat(0.10) // Default
}

func getEBSRate(volumeType string) decimal.Decimal {
	rates := map[string]float64{
		"gp3": 0.08,
		"gp2": 0.10,
		"io1": 0.125,
		"st1": 0.045,
		"sc1": 0.015,
	}
	if rate, ok := rates[volumeType]; ok {
		return decimal.NewFromFloat(rate)
	}
	return decimal.NewFromFloat(0.10) // Default
}

func printResults(result *output.EstimationResult) {
	fmt.Println("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
	fmt.Println("â”‚                        COST ESTIMATION SUMMARY                         â”‚")
	fmt.Println("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")

	// Print by resource
	for assetID, agg := range result.CostGraph.ByAsset {
		if len(agg.Units) == 0 {
			continue
		}
		fmt.Printf("â”‚ %-50s %20s â”‚\n", 
			truncate(assetID, 50), 
			fmt.Sprintf("$%.2f/month", agg.MonthlyCost.InexactFloat64()))
		
		if showDetails {
			for _, unit := range agg.Units {
				fmt.Printf("â”‚   â””â”€ %-46s %20s â”‚\n",
					truncate(unit.Label, 46),
					fmt.Sprintf("$%.2f", unit.Amount.InexactFloat64()))
			}
		}
	}

	fmt.Println("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")
	fmt.Printf("â”‚ %-50s %20s â”‚\n", 
		"TOTAL MONTHLY ESTIMATE",
		fmt.Sprintf("$%.2f", result.CostGraph.TotalMonthlyCost.InexactFloat64()))
	fmt.Printf("â”‚ %-50s %20s â”‚\n",
		"TOTAL HOURLY ESTIMATE",
		fmt.Sprintf("$%.4f", result.CostGraph.TotalHourlyCost.InexactFloat64()))
	fmt.Println("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")

	fmt.Printf("\nEstimation completed in %s\n", result.Metadata.Duration)
	fmt.Printf("Confidence: %.0f%%\n", result.Confidence*100)
}

func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}

################################################################################
# FILE: :\good projects\cost estimation\cmd\cli\cmd\root.go
# TYPE: go
# SIZE: 2116 bytes
################################################################################
// Package cmd provides the CLI commands for terraform-cost.
package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"

	"terraform-cost/internal/config"
	"terraform-cost/internal/logging"
)

var (
	cfgFile string
	verbose bool
)

// rootCmd represents the base command
var rootCmd = &cobra.Command{
	Use:   "terraform-cost",
	Short: "Estimate costs for Terraform infrastructure",
	Long: `terraform-cost is a cloud-agnostic infrastructure cost estimation tool.

It analyzes Terraform configurations and produces accurate, reproducible
cost estimates with full lineage tracking.

Examples:
  terraform-cost estimate ./my-terraform-project
  terraform-cost estimate --format json ./infrastructure
  terraform-cost diff main..feature-branch`,
}

// Execute runs the CLI
func Execute() error {
	return rootCmd.Execute()
}

func init() {
	cobra.OnInitialize(initConfig)

	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is $HOME/.terraform-cost.json)")
	rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "v", false, "enable verbose output")

	// Add subcommands
	rootCmd.AddCommand(estimateCmd)
	rootCmd.AddCommand(versionCmd)
	rootCmd.AddCommand(configCmd)
}

func initConfig() {
	if cfgFile != "" {
		cfg, err := config.Load(cfgFile)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
			os.Exit(1)
		}
		config.Set(cfg)
	}

	// Initialize logging
	cfg := config.Get()
	if verbose {
		cfg.Logging.Level = "debug"
	}
	if err := logging.Initialize(cfg.Logging); err != nil {
		fmt.Fprintf(os.Stderr, "Error initializing logging: %v\n", err)
	}
}

// versionCmd prints version information
var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Print version information",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("terraform-cost version 0.1.0")
	},
}

// configCmd manages configuration
var configCmd = &cobra.Command{
	Use:   "config",
	Short: "Manage configuration",
	Run: func(cmd *cobra.Command, args []string) {
		cmd.Help()
	},
}

################################################################################
# FILE: :\good projects\cost estimation\core\asset\builder.go
# TYPE: go
# SIZE: 2788 bytes
################################################################################
// Package asset provides the asset graph builder interface and types.
// This package builds the provider-agnostic infrastructure DAG.
package asset

import (
	"context"

	"terraform-cost/core/types"
)

// Builder constructs Asset nodes from RawAssets
type Builder interface {
	// Provider returns the cloud provider this builder handles
	Provider() types.Provider

	// ResourceType returns the resource type (e.g., "aws_instance")
	ResourceType() string

	// Build converts a RawAsset into an Asset
	Build(ctx context.Context, raw *types.RawAsset) (*types.Asset, error)

	// Category returns the asset category for this resource type
	Category() types.AssetCategory
}

// GraphBuilder builds an AssetGraph from raw assets
type GraphBuilder interface {
	// Build constructs an asset graph from raw assets
	Build(ctx context.Context, raw []types.RawAsset) (*types.AssetGraph, error)
}

// BuilderRegistry manages asset builder registration
type BuilderRegistry interface {
	// Register adds a builder to the registry
	Register(builder Builder) error

	// GetBuilder returns a builder for a specific provider and resource type
	GetBuilder(provider types.Provider, resourceType string) (Builder, bool)

	// GetProviderBuilders returns all builders for a provider
	GetProviderBuilders(provider types.Provider) []Builder

	// GetAllResourceTypes returns all registered resource types
	GetAllResourceTypes() []string
}

// BuildOptions configures asset building behavior
type BuildOptions struct {
	// ExpandCount expands count meta-argument into separate assets
	ExpandCount bool

	// ExpandForEach expands for_each meta-argument into separate assets
	ExpandForEach bool

	// ResolveReferences attempts to resolve resource references
	ResolveReferences bool

	// IncludeDataSources includes data sources in the graph
	IncludeDataSources bool
}

// DefaultBuildOptions returns sensible default build options
func DefaultBuildOptions() BuildOptions {
	return BuildOptions{
		ExpandCount:        true,
		ExpandForEach:      true,
		ResolveReferences:  true,
		IncludeDataSources: false,
	}
}

// BuildContext provides context for asset building
type BuildContext struct {
	// Options are the build options
	Options BuildOptions

	// Variables are resolved Terraform variables
	Variables map[string]interface{}

	// Providers are provider configurations
	Providers map[string]ProviderConfig
}

// ProviderConfig contains provider configuration
type ProviderConfig struct {
	// Name is the provider name
	Name string

	// Alias is the provider alias
	Alias string

	// Region is the provider region
	Region string

	// Config contains provider-specific configuration
	Config map[string]interface{}
}

################################################################################
# FILE: :\good projects\cost estimation\core\asset\registry.go
# TYPE: go
# SIZE: 2613 bytes
################################################################################
// Package asset - Asset builder registry
package asset

import (
	"fmt"
	"sync"

	"terraform-cost/core/types"
)

// DefaultBuilderRegistry is the default implementation of BuilderRegistry
type DefaultBuilderRegistry struct {
	mu       sync.RWMutex
	builders map[string]Builder // key: provider/resource_type
	byType   map[string][]Builder
}

// NewBuilderRegistry creates a new builder registry
func NewBuilderRegistry() *DefaultBuilderRegistry {
	return &DefaultBuilderRegistry{
		builders: make(map[string]Builder),
		byType:   make(map[string][]Builder),
	}
}

// Register adds a builder to the registry
func (r *DefaultBuilderRegistry) Register(builder Builder) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := makeKey(builder.Provider(), builder.ResourceType())
	if _, exists := r.builders[key]; exists {
		return fmt.Errorf("builder already registered: %s", key)
	}

	r.builders[key] = builder
	r.byType[builder.ResourceType()] = append(r.byType[builder.ResourceType()], builder)
	return nil
}

// GetBuilder returns a builder for a specific provider and resource type
func (r *DefaultBuilderRegistry) GetBuilder(provider types.Provider, resourceType string) (Builder, bool) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	key := makeKey(provider, resourceType)
	builder, ok := r.builders[key]
	return builder, ok
}

// GetProviderBuilders returns all builders for a provider
func (r *DefaultBuilderRegistry) GetProviderBuilders(provider types.Provider) []Builder {
	r.mu.RLock()
	defer r.mu.RUnlock()

	var builders []Builder
	prefix := string(provider) + "/"
	for key, builder := range r.builders {
		if len(key) > len(prefix) && key[:len(prefix)] == prefix {
			builders = append(builders, builder)
		}
	}
	return builders
}

// GetAllResourceTypes returns all registered resource types
func (r *DefaultBuilderRegistry) GetAllResourceTypes() []string {
	r.mu.RLock()
	defer r.mu.RUnlock()

	types := make([]string, 0, len(r.byType))
	for t := range r.byType {
		types = append(types, t)
	}
	return types
}

func makeKey(provider types.Provider, resourceType string) string {
	return string(provider) + "/" + resourceType
}

// Global default registry
var defaultBuilderRegistry = NewBuilderRegistry()

// RegisterBuilder adds a builder to the default registry
func RegisterBuilder(builder Builder) error {
	return defaultBuilderRegistry.Register(builder)
}

// GetDefaultBuilderRegistry returns the default builder registry
func GetDefaultBuilderRegistry() *DefaultBuilderRegistry {
	return defaultBuilderRegistry
}

################################################################################
# FILE: :\good projects\cost estimation\core\cost\engine.go
# TYPE: go
# SIZE: 2177 bytes
################################################################################
// Package cost provides the cost graph engine interface.
// This package transforms assets + usage into billable cost units.
package cost

import (
	"context"

	"terraform-cost/core/types"
	"terraform-cost/core/usage"
)

// Engine transforms assets and usage into cost graphs
type Engine interface {
	// Calculate produces a cost graph from an asset graph and usage data
	Calculate(ctx context.Context, assets *types.AssetGraph, usage map[string]*usage.EstimationResult, pricing *types.PricingResult) (*types.CostGraph, error)
}

// Calculator calculates costs for a specific resource type
type Calculator interface {
	// Provider returns the cloud provider
	Provider() types.Provider

	// ResourceType returns the resource type this calculator handles
	ResourceType() string

	// Calculate produces cost units for an asset
	Calculate(ctx context.Context, asset *types.Asset, usage []types.UsageVector, pricing *types.PricingResult) ([]*types.CostUnit, error)
}

// CalculatorRegistry manages cost calculator registration
type CalculatorRegistry interface {
	// Register adds a calculator to the registry
	Register(calculator Calculator) error

	// GetCalculator returns a calculator for a provider and resource type
	GetCalculator(provider types.Provider, resourceType string) (Calculator, bool)

	// GetProviderCalculators returns all calculators for a provider
	GetProviderCalculators(provider types.Provider) []Calculator
}

// FormulaContext provides context for cost formula evaluation
type FormulaContext struct {
	// Asset is the asset being priced
	Asset *types.Asset

	// Usage contains usage vectors for the asset
	Usage []types.UsageVector

	// Pricing contains resolved prices
	Pricing *types.PricingResult

	// Region is the deployment region
	Region types.Region
}

// Formula represents a cost calculation formula
type Formula interface {
	// Name returns the formula name
	Name() string

	// Calculate evaluates the formula
	Calculate(ctx *FormulaContext) ([]*types.CostUnit, error)

	// RateKeys returns the rate keys needed for this formula
	RateKeys(ctx *FormulaContext) []types.RateKey
}

################################################################################
# FILE: :\good projects\cost estimation\core\detection\detector.go
# TYPE: go
# SIZE: 1582 bytes
################################################################################
// Package detection provides project detection interfaces.
// This package determines what type of IaC project is being analyzed.
package detection

import (
	"context"

	"terraform-cost/core/types"
)

// Detector identifies project types
type Detector interface {
	// Name returns the detector identifier
	Name() string

	// Detect determines if the input matches this detector's project type
	Detect(ctx context.Context, path string) (*types.DetectedProject, error)

	// ProjectType returns the project type this detector handles
	ProjectType() types.ProjectType

	// Priority returns the detection priority (higher = checked first)
	Priority() int
}

// Registry manages detector registration
type Registry interface {
	// Register adds a detector to the registry
	Register(detector Detector) error

	// GetDetector returns a detector by name
	GetDetector(name string) (Detector, bool)

	// GetAll returns all registered detectors
	GetAll() []Detector

	// Detect finds the first matching detector and returns its result
	Detect(ctx context.Context, path string) (*types.DetectedProject, error)

	// DetectAll runs all detectors and returns all matches
	DetectAll(ctx context.Context, path string) ([]*types.DetectedProject, error)
}

// DetectionResult contains detection output
type DetectionResult struct {
	// Project is the detected project
	Project *types.DetectedProject

	// Detector is the detector that matched
	Detector string

	// Alternatives are other possible matches
	Alternatives []*types.DetectedProject
}

################################################################################
# FILE: :\good projects\cost estimation\core\determinism\stable.go
# TYPE: go
# SIZE: 7581 bytes
################################################################################
// Package determinism provides primitives for guaranteeing deterministic execution.
// All code must use these primitives instead of Go built-ins for maps, IDs, etc.
package determinism

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"sort"
	"sync"

	"github.com/shopspring/decimal"
)

// StableMap is a map that guarantees iteration order (sorted by key).
// Use this instead of map[K]V for all cases where iteration matters.
type StableMap[K comparable, V any] struct {
	mu      sync.RWMutex
	keys    []K
	values  map[K]V
	keyFunc func(K) string // For custom ordering
}

// NewStableMap creates a new StableMap
func NewStableMap[K comparable, V any]() *StableMap[K, V] {
	return &StableMap[K, V]{
		values: make(map[K]V),
	}
}

// NewStableMapWithKeyFunc creates a StableMap with custom key ordering
func NewStableMapWithKeyFunc[K comparable, V any](keyFunc func(K) string) *StableMap[K, V] {
	return &StableMap[K, V]{
		values:  make(map[K]V),
		keyFunc: keyFunc,
	}
}

// Set adds or updates a key-value pair
func (m *StableMap[K, V]) Set(key K, value V) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if _, exists := m.values[key]; !exists {
		m.keys = append(m.keys, key)
		m.sortKeys()
	}
	m.values[key] = value
}

// Get retrieves a value by key
func (m *StableMap[K, V]) Get(key K) (V, bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	val, ok := m.values[key]
	return val, ok
}

// Delete removes a key
func (m *StableMap[K, V]) Delete(key K) {
	m.mu.Lock()
	defer m.mu.Unlock()

	delete(m.values, key)
	// Remove from keys slice
	for i, k := range m.keys {
		if any(k) == any(key) {
			m.keys = append(m.keys[:i], m.keys[i+1:]...)
			break
		}
	}
}

// Range iterates in stable sorted order
func (m *StableMap[K, V]) Range(fn func(K, V) bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	for _, k := range m.keys {
		if !fn(k, m.values[k]) {
			break
		}
	}
}

// Keys returns all keys in sorted order
func (m *StableMap[K, V]) Keys() []K {
	m.mu.RLock()
	defer m.mu.RUnlock()
	result := make([]K, len(m.keys))
	copy(result, m.keys)
	return result
}

// Len returns the number of entries
func (m *StableMap[K, V]) Len() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return len(m.values)
}

func (m *StableMap[K, V]) sortKeys() {
	sort.Slice(m.keys, func(i, j int) bool {
		if m.keyFunc != nil {
			return m.keyFunc(m.keys[i]) < m.keyFunc(m.keys[j])
		}
		return fmt.Sprint(m.keys[i]) < fmt.Sprint(m.keys[j])
	})
}

// StableID is a hash-based unique identifier that's deterministic
type StableID string

// IDGenerator generates stable, deterministic IDs
type IDGenerator struct {
	namespace string
}

// NewIDGenerator creates an ID generator with a namespace
func NewIDGenerator(namespace string) *IDGenerator {
	return &IDGenerator{namespace: namespace}
}

// Generate creates a stable ID from inputs
func (g *IDGenerator) Generate(parts ...string) StableID {
	h := sha256.New()
	h.Write([]byte(g.namespace))
	h.Write([]byte{0}) // Separator
	for _, part := range parts {
		h.Write([]byte(part))
		h.Write([]byte{0}) // Separator
	}
	return StableID(hex.EncodeToString(h.Sum(nil))[:16])
}

// ContentHash is a SHA-256 hash for content integrity
type ContentHash [32]byte

// ComputeHash computes a content hash from bytes
func ComputeHash(data []byte) ContentHash {
	return sha256.Sum256(data)
}

// Hex returns the hash as a hex string
func (h ContentHash) Hex() string {
	return hex.EncodeToString(h[:])
}

// String implements Stringer
func (h ContentHash) String() string {
	return h.Hex()[:16] + "..."
}

// Money represents a monetary amount with full precision.
// NEVER use float64 for money calculations.
type Money struct {
	amount   decimal.Decimal
	currency string
}

// NewMoney creates a Money from a decimal string
func NewMoney(amount string, currency string) (Money, error) {
	d, err := decimal.NewFromString(amount)
	if err != nil {
		return Money{}, err
	}
	return Money{amount: d, currency: currency}, nil
}

// NewMoneyFromFloat creates Money from float64 (use sparingly)
func NewMoneyFromFloat(amount float64, currency string) Money {
	return Money{amount: decimal.NewFromFloat(amount), currency: currency}
}

// NewMoneyFromDecimal creates Money from decimal
func NewMoneyFromDecimal(amount decimal.Decimal, currency string) Money {
	return Money{amount: amount, currency: currency}
}

// Zero creates zero money
func Zero(currency string) Money {
	return Money{amount: decimal.Zero, currency: currency}
}

// Amount returns the decimal amount
func (m Money) Amount() decimal.Decimal {
	return m.amount
}

// Currency returns the currency code
func (m Money) Currency() string {
	return m.currency
}

// Add adds two monetary amounts
func (m Money) Add(other Money) Money {
	if m.currency != other.currency {
		panic(fmt.Sprintf("cannot add %s and %s", m.currency, other.currency))
	}
	return Money{amount: m.amount.Add(other.amount), currency: m.currency}
}

// Sub subtracts monetary amounts
func (m Money) Sub(other Money) Money {
	if m.currency != other.currency {
		panic(fmt.Sprintf("cannot subtract %s and %s", m.currency, other.currency))
	}
	return Money{amount: m.amount.Sub(other.amount), currency: m.currency}
}

// Mul multiplies by a scalar
func (m Money) Mul(factor decimal.Decimal) Money {
	return Money{amount: m.amount.Mul(factor), currency: m.currency}
}

// MulFloat multiplies by a float64 scalar
func (m Money) MulFloat(factor float64) Money {
	return Money{amount: m.amount.Mul(decimal.NewFromFloat(factor)), currency: m.currency}
}

// Div divides by a scalar
func (m Money) Div(divisor decimal.Decimal) Money {
	return Money{amount: m.amount.Div(divisor), currency: m.currency}
}

// IsZero returns true if amount is zero
func (m Money) IsZero() bool {
	return m.amount.IsZero()
}

// IsNegative returns true if amount is negative
func (m Money) IsNegative() bool {
	return m.amount.IsNegative()
}

// Cmp compares two monetary amounts
func (m Money) Cmp(other Money) int {
	if m.currency != other.currency {
		panic(fmt.Sprintf("cannot compare %s and %s", m.currency, other.currency))
	}
	return m.amount.Cmp(other.amount)
}

// String returns formatted money (2 decimal places)
func (m Money) String() string {
	return fmt.Sprintf("%s %s", m.amount.StringFixed(2), m.currency)
}

// StringRaw returns the raw decimal string (full precision)
func (m Money) StringRaw() string {
	return m.amount.String()
}

// Float64 returns float64 (only for display, never for calculation)
func (m Money) Float64() float64 {
	f, _ := m.amount.Float64()
	return f
}

// SortSlice sorts a slice in a stable, deterministic manner
func SortSlice[T any](slice []T, less func(a, b T) bool) {
	sort.SliceStable(slice, func(i, j int) bool {
		return less(slice[i], slice[j])
	})
}

// SortStrings sorts strings in place
func SortStrings(s []string) {
	sort.Strings(s)
}

// SortedMap returns a sorted copy of map keys
func SortedKeys[K comparable, V any](m map[K]V) []K {
	keys := make([]K, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Slice(keys, func(i, j int) bool {
		return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j])
	})
	return keys
}

// RangeMapSorted iterates over a map in sorted key order
func RangeMapSorted[K comparable, V any](m map[K]V, fn func(K, V) bool) {
	for _, k := range SortedKeys(m) {
		if !fn(k, m[k]) {
			break
		}
	}
}

################################################################################
# FILE: :\good projects\cost estimation\core\engine\engine.go
# TYPE: go
# SIZE: 13444 bytes
################################################################################
// Package engine provides the API-primary estimation engine.
// CLI is a thin wrapper around this engine.
package engine

import (
	"context"
	"fmt"
	"time"

	"terraform-cost/core/determinism"
	"terraform-cost/core/model"
	"terraform-cost/core/pricing"
)

// Engine is the primary API for cost estimation.
// All other interfaces (CLI, HTTP, CI) are thin wrappers.
type Engine struct {
	// Required dependencies
	pricingResolver PricingResolver
	usageEstimator  UsageEstimator
	policyEvaluator PolicyEvaluator

	// Plugin registry
	cloudPlugins map[string]CloudPlugin

	// Configuration
	config EngineConfig
}

// EngineConfig configures the estimation engine
type EngineConfig struct {
	// Default region for pricing
	DefaultRegion string

	// Unknown handling
	UnknownCountDefault int
	UnknownBehavior     UnknownBehavior

	// Confidence thresholds
	MinConfidenceForEstimate float64
}

// UnknownBehavior defines how to handle unknown values
type UnknownBehavior int

const (
	// UnknownPropagate marks results as uncertain (correct behavior)
	UnknownPropagate UnknownBehavior = iota
	// UnknownFail returns an error on unknowns
	UnknownFail
)

// PricingResolver resolves pricing - MUST use snapshots
type PricingResolver interface {
	// GetSnapshot returns a pricing snapshot - never "latest" implicitly
	GetSnapshot(ctx context.Context, req SnapshotRequest) (*pricing.PricingSnapshot, error)

	// LookupRate finds a rate within a snapshot
	LookupRate(snapshot *pricing.PricingSnapshot, resourceType, component string, attrs map[string]string) (*pricing.RateEntry, error)
}

// SnapshotRequest specifies which snapshot to retrieve
type SnapshotRequest struct {
	// SnapshotID is preferred if known
	SnapshotID pricing.SnapshotID

	// Otherwise, specify provider and region
	Provider string
	Region   string

	// AsOf specifies point-in-time (nil = latest known)
	AsOf *time.Time
}

// UsageEstimator estimates usage for instances
type UsageEstimator interface {
	Estimate(ctx context.Context, instance *model.AssetInstance) (*UsageResult, error)
}

// UsageResult contains estimated usage with confidence
type UsageResult struct {
	Metrics    map[string]UsageMetric
	Source     pricing.UsageSource
	Confidence float64
}

// UsageMetric is a single usage estimate
type UsageMetric struct {
	Name       string
	Value      float64
	Unit       string
	Confidence float64
	IsUnknown  bool
}

// PolicyEvaluator evaluates cost policies
type PolicyEvaluator interface {
	Evaluate(ctx context.Context, result *EstimationResult) (*PolicyResult, error)
}

// CloudPlugin provides cloud-specific cost mapping
type CloudPlugin interface {
	Provider() string
	MapInstance(instance *model.AssetInstance) ([]CostComponent, error)
}

// CostComponent is a billable component of an instance
type CostComponent struct {
	Name         string
	ResourceType string
	Unit         string
	Attributes   map[string]string
}

// NewEngine creates a new estimation engine
func NewEngine(
	pricingResolver PricingResolver,
	usageEstimator UsageEstimator,
	policyEvaluator PolicyEvaluator,
	config EngineConfig,
) *Engine {
	return &Engine{
		pricingResolver: pricingResolver,
		usageEstimator:  usageEstimator,
		policyEvaluator: policyEvaluator,
		cloudPlugins:    make(map[string]CloudPlugin),
		config:          config,
	}
}

// RegisterPlugin registers a cloud plugin
func (e *Engine) RegisterPlugin(plugin CloudPlugin) {
	e.cloudPlugins[plugin.Provider()] = plugin
}

// EstimateRequest is the input to estimation
type EstimateRequest struct {
	// REQUIRED: Instance graph to estimate
	Graph *model.InstanceGraph

	// REQUIRED: Pricing snapshot to use
	SnapshotRequest SnapshotRequest

	// Optional: Usage overrides per instance
	UsageOverrides map[model.InstanceID]map[string]float64

	// Optional: Policy configuration
	PolicyConfig map[string]any
}

// EstimationResult is the output of estimation
type EstimationResult struct {
	// Pricing snapshot used (for reproducibility)
	Snapshot *SnapshotReference

	// Costs per INSTANCE (not definition)
	InstanceCosts *determinism.StableMap[model.InstanceID, *InstanceCost]

	// Aggregated totals
	TotalMonthlyCost determinism.Money
	TotalHourlyCost  determinism.Money

	// Overall confidence
	Confidence CostConfidence

	// Warnings and degradations
	Warnings []string
	Degraded bool

	// Policy results (if evaluated)
	PolicyResult *PolicyResult

	// Timing
	EstimatedAt time.Time
	Duration    time.Duration
}

// SnapshotReference is an immutable reference to the pricing snapshot used
type SnapshotReference struct {
	ID          pricing.SnapshotID
	ContentHash determinism.ContentHash
	EffectiveAt time.Time
	Provider    string
	Region      string
}

// InstanceCost is the cost for a SINGLE INSTANCE (not definition)
type InstanceCost struct {
	// Instance identity
	InstanceID model.InstanceID
	Address    model.InstanceAddress

	// Link to definition (for grouping)
	DefinitionID model.DefinitionID

	// Cost components
	Components []*ComponentCost

	// Roll-ups
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money

	// Confidence for THIS instance
	Confidence CostConfidence

	// Full lineage for explainability
	Lineage []*pricing.CostLineage
}

// ComponentCost is a single cost component
type ComponentCost struct {
	Name        string
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money

	// Rate used
	RateID  pricing.RateID
	RateKey pricing.RateKey

	// Usage applied
	UsageValue float64
	UsageUnit  string

	// Formula
	Formula pricing.FormulaApplication

	// Confidence
	Confidence float64
}

// CostConfidence tracks estimation confidence
type CostConfidence struct {
	Score   float64 // 0.0 - 1.0
	Factors []ConfidenceFactor
}

// ConfidenceFactor explains why confidence is reduced
type ConfidenceFactor struct {
	Reason      string
	Impact      float64 // How much this reduces confidence
	Component   string  // Which component affected
	IsUnknown   bool    // Is this due to an unknown value?
}

// PolicyResult is the output of policy evaluation
type PolicyResult struct {
	Passed   bool
	Policies []PolicyOutcome
}

// PolicyOutcome is the result of a single policy
type PolicyOutcome struct {
	Name    string
	Passed  bool
	Message string

	// Deep context for explainability
	AffectedInstances []model.InstanceID
	CostImpact        determinism.Money
	LineageRefs       []*pricing.CostLineage
}

// Estimate performs the estimation
func (e *Engine) Estimate(ctx context.Context, req *EstimateRequest) (*EstimationResult, error) {
	start := time.Now()

	// REQUIRED: Validate inputs
	if req.Graph == nil {
		return nil, fmt.Errorf("instance graph is required")
	}

	// REQUIRED: Get pricing snapshot
	snapshot, err := e.pricingResolver.GetSnapshot(ctx, req.SnapshotRequest)
	if err != nil {
		return nil, fmt.Errorf("failed to get pricing snapshot: %w", err)
	}

	// Verify snapshot integrity
	if !snapshot.Verify() {
		return nil, fmt.Errorf("pricing snapshot failed integrity check")
	}

	result := &EstimationResult{
		Snapshot: &SnapshotReference{
			ID:          snapshot.ID,
			ContentHash: snapshot.ContentHash,
			EffectiveAt: snapshot.EffectiveAt,
			Provider:    snapshot.Provider,
			Region:      snapshot.Region,
		},
		InstanceCosts:    determinism.NewStableMap[model.InstanceID, *InstanceCost](),
		TotalMonthlyCost: determinism.Zero("USD"),
		TotalHourlyCost:  determinism.Zero("USD"),
		Confidence:       CostConfidence{Score: 1.0},
		EstimatedAt:      time.Now().UTC(),
	}

	// Process each INSTANCE (not definition)
	for _, inst := range req.Graph.Instances() {
		instanceCost, err := e.estimateInstance(ctx, inst, snapshot, req.UsageOverrides)
		if err != nil {
			result.Warnings = append(result.Warnings,
				fmt.Sprintf("%s: %v", inst.Address, err))
			result.Degraded = true
			continue
		}

		result.InstanceCosts.Set(inst.ID, instanceCost)
		result.TotalMonthlyCost = result.TotalMonthlyCost.Add(instanceCost.MonthlyCost)
		result.TotalHourlyCost = result.TotalHourlyCost.Add(instanceCost.HourlyCost)

		// Compound confidence
		result.Confidence.Score *= instanceCost.Confidence.Score
	}

	// Evaluate policies with full context
	if e.policyEvaluator != nil {
		policyResult, err := e.policyEvaluator.Evaluate(ctx, result)
		if err != nil {
			result.Warnings = append(result.Warnings,
				fmt.Sprintf("policy evaluation failed: %v", err))
		} else {
			result.PolicyResult = policyResult
		}
	}

	result.Duration = time.Since(start)
	return result, nil
}

func (e *Engine) estimateInstance(
	ctx context.Context,
	inst *model.AssetInstance,
	snapshot *pricing.PricingSnapshot,
	overrides map[model.InstanceID]map[string]float64,
) (*InstanceCost, error) {
	result := &InstanceCost{
		InstanceID:   inst.ID,
		Address:      inst.Address,
		DefinitionID: inst.DefinitionID,
		Components:   []*ComponentCost{},
		MonthlyCost:  determinism.Zero("USD"),
		HourlyCost:   determinism.Zero("USD"),
		Confidence:   CostConfidence{Score: 1.0},
		Lineage:      []*pricing.CostLineage{},
	}

	// Get cloud plugin
	plugin, ok := e.cloudPlugins[inst.Provider.Type]
	if !ok {
		return result, fmt.Errorf("no plugin for provider %s", inst.Provider.Type)
	}

	// Map instance to cost components
	components, err := plugin.MapInstance(inst)
	if err != nil {
		return result, err
	}

	// Get usage estimates
	usage, err := e.usageEstimator.Estimate(ctx, inst)
	if err != nil {
		result.Confidence.Factors = append(result.Confidence.Factors, ConfidenceFactor{
			Reason: "usage estimation failed",
			Impact: 0.3,
		})
		usage = &UsageResult{Confidence: 0.5}
	}

	// Apply overrides if present
	instanceOverrides := overrides[inst.ID]

	// Price each component
	for _, comp := range components {
		compCost, lineage := e.priceComponent(comp, inst, snapshot, usage, instanceOverrides)
		result.Components = append(result.Components, compCost)
		result.MonthlyCost = result.MonthlyCost.Add(compCost.MonthlyCost)
		result.HourlyCost = result.HourlyCost.Add(compCost.HourlyCost)
		result.Lineage = append(result.Lineage, lineage)

		// Track confidence factors
		if compCost.Confidence < 1.0 {
			result.Confidence.Factors = append(result.Confidence.Factors, ConfidenceFactor{
				Reason:    "reduced component confidence",
				Impact:    1.0 - compCost.Confidence,
				Component: comp.Name,
			})
		}
	}

	// Calculate overall confidence
	result.Confidence.Score = e.calculateConfidence(result)

	return result, nil
}

func (e *Engine) priceComponent(
	comp CostComponent,
	inst *model.AssetInstance,
	snapshot *pricing.PricingSnapshot,
	usage *UsageResult,
	overrides map[string]float64,
) (*ComponentCost, *pricing.CostLineage) {
	result := &ComponentCost{
		Name:       comp.Name,
		Confidence: 1.0,
	}

	lineage := &pricing.CostLineage{
		InstanceID: string(inst.ID),
		Component:  comp.Name,
		SnapshotID: snapshot.ID,
		Timestamp:  time.Now().UTC(),
	}

	// Look up rate
	rate, ok := snapshot.LookupRate(comp.ResourceType, comp.Name, comp.Attributes)
	if !ok {
		// Rate not found - degraded estimation
		result.Confidence = 0.0
		lineage.Confidence = 0.0
		return result, lineage
	}

	result.RateID = rate.ID
	result.RateKey = rate.Key
	lineage.RateID = rate.ID
	lineage.RateKey = rate.Key

	// Get usage value
	usageValue := 730.0 // Default monthly hours
	usageUnit := "hours"
	usageConfidence := 1.0

	if metric, ok := usage.Metrics[comp.Name]; ok {
		if metric.IsUnknown {
			// UNKNOWN: propagate, don't guess
			result.Confidence *= 0.5
			usageConfidence = 0.5
			lineage.Confidence = 0.5
		} else {
			usageValue = metric.Value
			usageUnit = metric.Unit
			usageConfidence = metric.Confidence
		}
	}

	// Apply override if present
	if override, ok := overrides[comp.Name]; ok {
		usageValue = override
		usageConfidence = 1.0 // User-provided is trusted
	}

	result.UsageValue = usageValue
	result.UsageUnit = usageUnit

	// Calculate cost
	monthlyCost := determinism.NewMoneyFromDecimal(
		rate.Price.Mul(determinism.NewMoneyFromFloat(usageValue, "USD").Amount()),
		rate.Currency,
	)
	hourlyCost := monthlyCost.Div(determinism.NewMoneyFromFloat(730.0, "USD").Amount())

	result.MonthlyCost = monthlyCost
	result.HourlyCost = hourlyCost
	result.Confidence *= usageConfidence

	// Record formula
	result.Formula = pricing.FormulaApplication{
		Name:       "usage_based",
		Expression: fmt.Sprintf("%s * %s", rate.Price.String(), usageUnit),
		Inputs: map[string]string{
			"rate":  rate.Price.String(),
			"usage": fmt.Sprintf("%.2f", usageValue),
			"unit":  usageUnit,
		},
		Output: monthlyCost.StringRaw(),
	}
	lineage.Formula = result.Formula
	lineage.Usage = pricing.UsageLineage{
		Source:     usage.Source,
		Confidence: usageConfidence,
	}
	lineage.Confidence = result.Confidence

	return result, lineage
}

func (e *Engine) calculateConfidence(ic *InstanceCost) float64 {
	if len(ic.Components) == 0 {
		return 0.0
	}

	total := 0.0
	for _, c := range ic.Components {
		total += c.Confidence
	}
	return total / float64(len(ic.Components))
}

################################################################################
# FILE: :\good projects\cost estimation\core\expansion\expander.go
# TYPE: go
# SIZE: 10260 bytes
################################################################################
// Package expansion provides instance expansion for count and for_each.
// This is a clean-room implementation based on Terraform semantics.
package expansion

import (
	"fmt"
	"sort"

	"terraform-cost/core/expression"
	"terraform-cost/core/types"
)

// InstanceKey represents the index/key for an expanded instance
type InstanceKey struct {
	// Type indicates whether this is a numeric or string key
	Type KeyType
	// NumValue is set for count-based expansion
	NumValue int
	// StrValue is set for for_each-based expansion
	StrValue string
}

// KeyType indicates the type of instance key
type KeyType int

const (
	KeyTypeNone KeyType = iota
	KeyTypeInt
	KeyTypeString
)

// String returns the key as an address suffix
func (k InstanceKey) String() string {
	switch k.Type {
	case KeyTypeInt:
		return fmt.Sprintf("[%d]", k.NumValue)
	case KeyTypeString:
		return fmt.Sprintf("[%q]", k.StrValue)
	default:
		return ""
	}
}

// Value returns the key as an expression Value
func (k InstanceKey) Value() expression.Value {
	switch k.Type {
	case KeyTypeInt:
		return expression.NumberFromInt(int64(k.NumValue))
	case KeyTypeString:
		return expression.String(k.StrValue)
	default:
		return expression.Null()
	}
}

// AssetInstance represents an expanded instance of an asset
type AssetInstance struct {
	// Base is the original asset definition
	Base *types.Asset

	// Key is the instance index/key (from count or for_each)
	Key InstanceKey

	// Address is the full address including index
	Address types.ResourceAddress

	// EachValue is the element value for for_each (nil for count)
	EachValue expression.Value

	// Attributes are the resolved attributes for this instance
	Attributes types.Attributes

	// Metadata about the expansion
	Metadata InstanceMetadata
}

// InstanceMetadata contains information about how the instance was created
type InstanceMetadata struct {
	// ExpansionType indicates how this instance was created
	ExpansionType ExpansionType

	// OriginalAddress is the address before expansion
	OriginalAddress types.ResourceAddress

	// IsKnown indicates whether the expansion count was deterministic
	IsKnown bool

	// Warning is set if expansion produced a warning
	Warning string
}

// ExpansionType indicates the type of expansion
type ExpansionType int

const (
	ExpansionNone     ExpansionType = iota // No expansion (single instance)
	ExpansionCount                         // count meta-argument
	ExpansionForEach                       // for_each meta-argument
	ExpansionUnknown                       // Expansion couldn't be determined
)

// Expander expands assets with count/for_each into instances
type Expander struct {
	// DefaultCountOnUnknown is the count to assume when count is unknown
	DefaultCountOnUnknown int
}

// NewExpander creates a new instance expander
func NewExpander() *Expander {
	return &Expander{
		DefaultCountOnUnknown: 1,
	}
}

// Expand expands a single asset into instances
func (e *Expander) Expand(asset *types.Asset, ctx *expression.Context) ([]*AssetInstance, error) {
	// Check for count meta-argument
	if countAttr := asset.Attributes.Get("count"); countAttr != nil {
		return e.expandCount(asset, countAttr, ctx)
	}

	// Check for for_each meta-argument
	if forEachAttr := asset.Attributes.Get("for_each"); forEachAttr != nil {
		return e.expandForEach(asset, forEachAttr, ctx)
	}

	// No expansion - return single instance
	return []*AssetInstance{
		{
			Base:       asset,
			Key:        InstanceKey{Type: KeyTypeNone},
			Address:    asset.Address,
			Attributes: asset.Attributes,
			Metadata: InstanceMetadata{
				ExpansionType:   ExpansionNone,
				OriginalAddress: asset.Address,
				IsKnown:         true,
			},
		},
	}, nil
}

// expandCount handles count-based expansion
func (e *Expander) expandCount(asset *types.Asset, countVal interface{}, ctx *expression.Context) ([]*AssetInstance, error) {
	count, isKnown := e.resolveCount(countVal, ctx)

	if count == 0 {
		// count = 0 means no instances
		return []*AssetInstance{}, nil
	}

	instances := make([]*AssetInstance, count)
	for i := 0; i < count; i++ {
		key := InstanceKey{Type: KeyTypeInt, NumValue: i}
		addr := types.ResourceAddress(fmt.Sprintf("%s[%d]", asset.Address, i))

		// Create evaluation context for this instance
		instanceCtx := ctx.Clone()
		instanceCtx.SetCountIndex(i)

		instances[i] = &AssetInstance{
			Base:       asset,
			Key:        key,
			Address:    addr,
			Attributes: asset.Attributes,
			Metadata: InstanceMetadata{
				ExpansionType:   ExpansionCount,
				OriginalAddress: asset.Address,
				IsKnown:         isKnown,
			},
		}

		if !isKnown {
			instances[i].Metadata.Warning = "count could not be determined; assuming 1"
		}
	}

	return instances, nil
}

// resolveCount attempts to resolve a count value to an integer
func (e *Expander) resolveCount(countVal interface{}, ctx *expression.Context) (int, bool) {
	// If it's already an int, use it
	if n, ok := countVal.(int); ok {
		return n, true
	}

	// If it's a float, convert
	if f, ok := countVal.(float64); ok {
		return int(f), true
	}

	// If it's an expression.Value, extract
	if v, ok := countVal.(expression.Value); ok {
		if v.IsUnknown() {
			return e.DefaultCountOnUnknown, false
		}
		if n, err := v.AsInt(); err == nil {
			return int(n), true
		}
	}

	// If it's a string reference, try to resolve
	if s, ok := countVal.(string); ok {
		ref, err := expression.ParseReference(s)
		if err == nil && ctx != nil {
			resolved, err := ctx.Resolve(ref)
			if err == nil && !resolved.IsUnknown() {
				if n, err := resolved.AsInt(); err == nil {
					return int(n), true
				}
			}
		}
	}

	// Cannot determine count
	return e.DefaultCountOnUnknown, false
}

// expandForEach handles for_each-based expansion
func (e *Expander) expandForEach(asset *types.Asset, forEachVal interface{}, ctx *expression.Context) ([]*AssetInstance, error) {
	keys, values, isKnown := e.resolveForEach(forEachVal, ctx)

	if len(keys) == 0 {
		return []*AssetInstance{}, nil
	}

	instances := make([]*AssetInstance, len(keys))
	for i, key := range keys {
		instanceKey := InstanceKey{Type: KeyTypeString, StrValue: key}
		addr := types.ResourceAddress(fmt.Sprintf("%s[%q]", asset.Address, key))

		// Create evaluation context for this instance
		instanceCtx := ctx.Clone()
		instanceCtx.SetEach(key, values[key])

		instances[i] = &AssetInstance{
			Base:       asset,
			Key:        instanceKey,
			Address:    addr,
			EachValue:  values[key],
			Attributes: asset.Attributes,
			Metadata: InstanceMetadata{
				ExpansionType:   ExpansionForEach,
				OriginalAddress: asset.Address,
				IsKnown:         isKnown,
			},
		}

		if !isKnown {
			instances[i].Metadata.Warning = "for_each could not be determined"
		}
	}

	return instances, nil
}

// resolveForEach attempts to resolve a for_each value to keys and values
func (e *Expander) resolveForEach(forEachVal interface{}, ctx *expression.Context) ([]string, map[string]expression.Value, bool) {
	values := make(map[string]expression.Value)

	// If it's already a map
	if m, ok := forEachVal.(map[string]interface{}); ok {
		keys := make([]string, 0, len(m))
		for k, v := range m {
			keys = append(keys, k)
			values[k] = expression.FromGo(v)
		}
		sort.Strings(keys)
		return keys, values, true
	}

	// If it's a set/list of strings
	if list, ok := forEachVal.([]interface{}); ok {
		keys := make([]string, 0, len(list))
		for _, item := range list {
			if s, ok := item.(string); ok {
				keys = append(keys, s)
				values[s] = expression.String(s)
			}
		}
		sort.Strings(keys)
		return keys, values, true
	}

	// If it's an expression.Value
	if v, ok := forEachVal.(expression.Value); ok {
		if v.IsUnknown() {
			return nil, nil, false
		}

		// Try as map
		if m, err := v.AsMap(); err == nil {
			keys := make([]string, 0, len(m))
			for k := range m {
				keys = append(keys, k)
				values[k] = m[k]
			}
			sort.Strings(keys)
			return keys, values, true
		}

		// Try as list
		if list, err := v.AsList(); err == nil {
			keys := make([]string, 0, len(list))
			for _, item := range list {
				if s, err := item.AsString(); err == nil {
					keys = append(keys, s)
					values[s] = expression.String(s)
				}
			}
			sort.Strings(keys)
			return keys, values, true
		}
	}

	// Cannot determine for_each
	return nil, nil, false
}

// ExpandAll expands all assets in a graph
func (e *Expander) ExpandAll(assets []*types.Asset, ctx *expression.Context) ([]*AssetInstance, error) {
	var allInstances []*AssetInstance

	for _, asset := range assets {
		instances, err := e.Expand(asset, ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to expand %s: %w", asset.Address, err)
		}
		allInstances = append(allInstances, instances...)
	}

	return allInstances, nil
}

// ExpandedGraph represents an asset graph with all instances expanded
type ExpandedGraph struct {
	// Instances is the list of all expanded instances
	Instances []*AssetInstance

	// ByAddress indexes instances by their full address
	ByAddress map[types.ResourceAddress]*AssetInstance

	// ByBaseAddress groups instances by their base address (before expansion)
	ByBaseAddress map[types.ResourceAddress][]*AssetInstance

	// Warnings collects expansion warnings
	Warnings []string
}

// NewExpandedGraph creates an expanded graph from instances
func NewExpandedGraph(instances []*AssetInstance) *ExpandedGraph {
	g := &ExpandedGraph{
		Instances:     instances,
		ByAddress:     make(map[types.ResourceAddress]*AssetInstance),
		ByBaseAddress: make(map[types.ResourceAddress][]*AssetInstance),
	}

	for _, inst := range instances {
		g.ByAddress[inst.Address] = inst
		g.ByBaseAddress[inst.Metadata.OriginalAddress] = append(
			g.ByBaseAddress[inst.Metadata.OriginalAddress], inst,
		)

		if inst.Metadata.Warning != "" {
			g.Warnings = append(g.Warnings, fmt.Sprintf("%s: %s", inst.Address, inst.Metadata.Warning))
		}
	}

	return g
}

################################################################################
# FILE: :\good projects\cost estimation\core\expansion\expander_test.go
# TYPE: go
# SIZE: 8167 bytes
################################################################################
package expansion

import (
	"testing"

	"terraform-cost/core/expression"
	"terraform-cost/core/types"
)

// TestCountExpansion tests count-based expansion behavior
func TestCountExpansion(t *testing.T) {
	expander := NewExpander()
	ctx := expression.NewContext()

	tests := []struct {
		name          string
		countValue    interface{}
		expectedCount int
		isKnown       bool
	}{
		{
			name:          "count=0 produces nothing",
			countValue:    0,
			expectedCount: 0,
			isKnown:       true,
		},
		{
			name:          "count=1 produces one instance",
			countValue:    1,
			expectedCount: 1,
			isKnown:       true,
		},
		{
			name:          "count=3 produces three instances",
			countValue:    3,
			expectedCount: 3,
			isKnown:       true,
		},
		{
			name:          "count=5 produces five instances",
			countValue:    5,
			expectedCount: 5,
			isKnown:       true,
		},
		{
			name:          "unknown count produces default with warning",
			countValue:    expression.Unknown(),
			expectedCount: 1,
			isKnown:       false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			asset := &types.Asset{
				Address: "aws_instance.test",
				Type:    "aws_instance",
				Name:    "test",
				Attributes: types.Attributes{
					"count": {Value: tt.countValue},
				},
			}

			instances, err := expander.Expand(asset, ctx)
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			if len(instances) != tt.expectedCount {
				t.Errorf("expected %d instances, got %d", tt.expectedCount, len(instances))
			}

			// Verify instance addresses
			for i, inst := range instances {
				expectedKey := i
				if inst.Key.NumValue != expectedKey {
					t.Errorf("instance %d: expected key %d, got %d", i, expectedKey, inst.Key.NumValue)
				}

				if inst.Metadata.IsKnown != tt.isKnown {
					t.Errorf("instance %d: expected isKnown=%v, got %v", i, tt.isKnown, inst.Metadata.IsKnown)
				}

				if !tt.isKnown && inst.Metadata.Warning == "" {
					t.Errorf("instance %d: expected warning for unknown count", i)
				}
			}
		})
	}
}

// TestForEachExpansion tests for_each-based expansion behavior
func TestForEachExpansion(t *testing.T) {
	expander := NewExpander()
	ctx := expression.NewContext()

	tests := []struct {
		name         string
		forEachValue interface{}
		expectedKeys []string
		isKnown      bool
	}{
		{
			name:         "empty map produces nothing",
			forEachValue: map[string]interface{}{},
			expectedKeys: []string{},
			isKnown:      true,
		},
		{
			name: "map with one key",
			forEachValue: map[string]interface{}{
				"web": "value1",
			},
			expectedKeys: []string{"web"},
			isKnown:      true,
		},
		{
			name: "map with multiple keys",
			forEachValue: map[string]interface{}{
				"a": 1,
				"b": 2,
				"c": 3,
			},
			expectedKeys: []string{"a", "b", "c"}, // sorted
			isKnown:      true,
		},
		{
			name:         "set as list of strings",
			forEachValue: []interface{}{"alpha", "beta", "gamma"},
			expectedKeys: []string{"alpha", "beta", "gamma"},
			isKnown:      true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			asset := &types.Asset{
				Address: "aws_instance.multi",
				Type:    "aws_instance",
				Name:    "multi",
				Attributes: types.Attributes{
					"for_each": {Value: tt.forEachValue},
				},
			}

			instances, err := expander.Expand(asset, ctx)
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			if len(instances) != len(tt.expectedKeys) {
				t.Errorf("expected %d instances, got %d", len(tt.expectedKeys), len(instances))
			}

			// Verify instance keys (they should be sorted)
			for i, inst := range instances {
				if i >= len(tt.expectedKeys) {
					break
				}
				expectedKey := tt.expectedKeys[i]
				if inst.Key.StrValue != expectedKey {
					t.Errorf("instance %d: expected key %q, got %q", i, expectedKey, inst.Key.StrValue)
				}

				if inst.Key.Type != KeyTypeString {
					t.Errorf("instance %d: expected string key type, got %v", i, inst.Key.Type)
				}
			}
		})
	}
}

// TestNoExpansion tests that assets without count/for_each produce single instance
func TestNoExpansion(t *testing.T) {
	expander := NewExpander()
	ctx := expression.NewContext()

	asset := &types.Asset{
		Address: "aws_instance.single",
		Type:    "aws_instance",
		Name:    "single",
		Attributes: types.Attributes{
			"instance_type": {Value: "t3.micro"},
		},
	}

	instances, err := expander.Expand(asset, ctx)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if len(instances) != 1 {
		t.Errorf("expected 1 instance, got %d", len(instances))
	}

	if instances[0].Key.Type != KeyTypeNone {
		t.Errorf("expected no key type, got %v", instances[0].Key.Type)
	}

	if instances[0].Address != asset.Address {
		t.Errorf("expected address %s, got %s", asset.Address, instances[0].Address)
	}

	if instances[0].Metadata.ExpansionType != ExpansionNone {
		t.Errorf("expected ExpansionNone, got %v", instances[0].Metadata.ExpansionType)
	}
}

// TestInstanceAddresses tests that addresses are correctly formatted
func TestInstanceAddresses(t *testing.T) {
	expander := NewExpander()
	ctx := expression.NewContext()

	// Test count addresses
	countAsset := &types.Asset{
		Address:    "aws_instance.counted",
		Type:       "aws_instance",
		Name:       "counted",
		Attributes: types.Attributes{"count": {Value: 2}},
	}

	countInstances, _ := expander.Expand(countAsset, ctx)
	expectedAddrs := []types.ResourceAddress{
		"aws_instance.counted[0]",
		"aws_instance.counted[1]",
	}

	for i, inst := range countInstances {
		if inst.Address != expectedAddrs[i] {
			t.Errorf("count instance %d: expected address %s, got %s", i, expectedAddrs[i], inst.Address)
		}
	}

	// Test for_each addresses
	forEachAsset := &types.Asset{
		Address: "aws_instance.named",
		Type:    "aws_instance",
		Name:    "named",
		Attributes: types.Attributes{
			"for_each": {Value: map[string]interface{}{"web": 1, "api": 2}},
		},
	}

	forEachInstances, _ := expander.Expand(forEachAsset, ctx)

	// Check that addresses are quoted correctly
	for _, inst := range forEachInstances {
		addrStr := string(inst.Address)
		if inst.Key.StrValue == "api" {
			if addrStr != `aws_instance.named["api"]` {
				t.Errorf("expected address aws_instance.named[\"api\"], got %s", addrStr)
			}
		}
		if inst.Key.StrValue == "web" {
			if addrStr != `aws_instance.named["web"]` {
				t.Errorf("expected address aws_instance.named[\"web\"], got %s", addrStr)
			}
		}
	}
}

// TestExpandedGraph tests the expanded graph construction
func TestExpandedGraph(t *testing.T) {
	instances := []*AssetInstance{
		{
			Address: "aws_instance.test[0]",
			Key:     InstanceKey{Type: KeyTypeInt, NumValue: 0},
			Metadata: InstanceMetadata{
				OriginalAddress: "aws_instance.test",
				ExpansionType:   ExpansionCount,
			},
		},
		{
			Address: "aws_instance.test[1]",
			Key:     InstanceKey{Type: KeyTypeInt, NumValue: 1},
			Metadata: InstanceMetadata{
				OriginalAddress: "aws_instance.test",
				ExpansionType:   ExpansionCount,
			},
		},
		{
			Address: "aws_s3_bucket.single",
			Key:     InstanceKey{Type: KeyTypeNone},
			Metadata: InstanceMetadata{
				OriginalAddress: "aws_s3_bucket.single",
				ExpansionType:   ExpansionNone,
			},
		},
	}

	graph := NewExpandedGraph(instances)

	if len(graph.Instances) != 3 {
		t.Errorf("expected 3 instances, got %d", len(graph.Instances))
	}

	// Test ByAddress lookup
	inst, ok := graph.ByAddress["aws_instance.test[0]"]
	if !ok {
		t.Error("ByAddress lookup failed for aws_instance.test[0]")
	}
	if inst.Key.NumValue != 0 {
		t.Errorf("expected key value 0, got %d", inst.Key.NumValue)
	}

	// Test ByBaseAddress grouping
	baseInstances := graph.ByBaseAddress["aws_instance.test"]
	if len(baseInstances) != 2 {
		t.Errorf("expected 2 instances for base address, got %d", len(baseInstances))
	}
}

################################################################################
# FILE: :\good projects\cost estimation\core\expression\context.go
# TYPE: go
# SIZE: 9151 bytes
################################################################################
// Package expression - Evaluation context
package expression

import (
	"fmt"
	"sync"
)

// Context provides values for expression evaluation
type Context struct {
	mu sync.RWMutex

	// Variables from tfvars, defaults, CLI
	variables map[string]Value

	// Locals computed from local blocks
	locals map[string]Value

	// Resources indexed by address
	resources map[string]Value

	// Data sources indexed by address
	dataSources map[string]Value

	// Modules indexed by key
	modules map[string]*Context

	// Parent context for nested modules
	parent *Context

	// Module path for this context
	modulePath string

	// Workspace name
	workspace string

	// Path values
	pathModule string
	pathRoot   string
	pathCwd    string

	// Count/for_each context (when evaluating inside a resource)
	countIndex *int
	eachKey    *string
	eachValue  Value

	// Self reference (when evaluating provisioners)
	self Value
}

// NewContext creates a new evaluation context
func NewContext() *Context {
	return &Context{
		variables:   make(map[string]Value),
		locals:      make(map[string]Value),
		resources:   make(map[string]Value),
		dataSources: make(map[string]Value),
		modules:     make(map[string]*Context),
		workspace:   "default",
	}
}

// NewChildContext creates a child context for a module
func (c *Context) NewChildContext(modulePath string) *Context {
	child := NewContext()
	child.parent = c
	child.modulePath = modulePath
	child.workspace = c.workspace
	child.pathRoot = c.pathRoot
	child.pathCwd = c.pathCwd
	return child
}

// SetVariable sets a variable value
func (c *Context) SetVariable(name string, value Value) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.variables[name] = value
}

// SetVariables sets multiple variables
func (c *Context) SetVariables(vars map[string]Value) {
	c.mu.Lock()
	defer c.mu.Unlock()
	for k, v := range vars {
		c.variables[k] = v
	}
}

// SetLocal sets a local value
func (c *Context) SetLocal(name string, value Value) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.locals[name] = value
}

// SetResource sets a resource's computed values
func (c *Context) SetResource(address string, value Value) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.resources[address] = value
}

// SetDataSource sets a data source's values
func (c *Context) SetDataSource(address string, value Value) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.dataSources[address] = value
}

// SetModule adds a child module context
func (c *Context) SetModule(key string, child *Context) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.modules[key] = child
}

// SetWorkspace sets the workspace name
func (c *Context) SetWorkspace(name string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.workspace = name
}

// SetPaths sets the path.module, path.root, path.cwd values
func (c *Context) SetPaths(module, root, cwd string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.pathModule = module
	c.pathRoot = root
	c.pathCwd = cwd
}

// SetCountIndex sets the count.index value for resource evaluation
func (c *Context) SetCountIndex(index int) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.countIndex = &index
}

// SetEach sets the each.key and each.value for for_each evaluation
func (c *Context) SetEach(key string, value Value) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.eachKey = &key
	c.eachValue = value
}

// SetSelf sets the self reference value
func (c *Context) SetSelf(value Value) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.self = value
}

// ClearIterators clears count/for_each context
func (c *Context) ClearIterators() {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.countIndex = nil
	c.eachKey = nil
	c.eachValue = Null()
}

// Resolve resolves a reference to a value
func (c *Context) Resolve(ref *Reference) (Value, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	switch ref.Kind {
	case RefVariable:
		return c.resolveVariable(ref)
	case RefLocal:
		return c.resolveLocal(ref)
	case RefResource:
		return c.resolveResource(ref)
	case RefData:
		return c.resolveDataSource(ref)
	case RefModule:
		return c.resolveModule(ref)
	case RefSelf:
		return c.resolveSelf(ref)
	case RefCount:
		return c.resolveCount(ref)
	case RefEach:
		return c.resolveEach(ref)
	case RefPath:
		return c.resolvePath(ref)
	case RefTerraform:
		return c.resolveTerraform(ref)
	default:
		return Unknown(), fmt.Errorf("unknown reference kind: %v", ref.Kind)
	}
}

func (c *Context) resolveVariable(ref *Reference) (Value, error) {
	val, ok := c.variables[ref.Key]
	if !ok {
		return Unknown(), fmt.Errorf("undefined variable: %s", ref.Key)
	}
	return c.traverseValue(val, ref)
}

func (c *Context) resolveLocal(ref *Reference) (Value, error) {
	val, ok := c.locals[ref.Key]
	if !ok {
		return Unknown(), fmt.Errorf("undefined local: %s", ref.Key)
	}
	return c.traverseValue(val, ref)
}

func (c *Context) resolveResource(ref *Reference) (Value, error) {
	// Build address with optional index
	addr := ref.Subject
	if ref.Index != nil {
		addr = ref.ResourceAddress()
	}

	val, ok := c.resources[addr]
	if !ok {
		// Resource not yet computed - return unknown
		return Unknown(), nil
	}
	return c.traverseValue(val, ref)
}

func (c *Context) resolveDataSource(ref *Reference) (Value, error) {
	addr := ref.ResourceAddress()
	val, ok := c.dataSources[addr]
	if !ok {
		// Data source not yet computed - return unknown
		return Unknown(), nil
	}
	return c.traverseValue(val, ref)
}

func (c *Context) resolveModule(ref *Reference) (Value, error) {
	child, ok := c.modules[ref.Key]
	if !ok {
		return Unknown(), fmt.Errorf("undefined module: %s", ref.Key)
	}

	// Module references access outputs
	if ref.Attribute != "" {
		// Look for output in child context
		// Outputs would be stored in a special location
		outputVal, ok := child.locals["__output_"+ref.Attribute]
		if !ok {
			return Unknown(), nil
		}
		return outputVal, nil
	}

	// Return the whole module context as an object
	return Unknown(), nil
}

func (c *Context) resolveSelf(ref *Reference) (Value, error) {
	if c.self.IsNull() {
		return Unknown(), fmt.Errorf("self is not available in this context")
	}
	return c.traverseValue(c.self, ref)
}

func (c *Context) resolveCount(ref *Reference) (Value, error) {
	if ref.Attribute != "index" {
		return Unknown(), fmt.Errorf("count only has 'index' attribute")
	}
	if c.countIndex == nil {
		return Unknown(), fmt.Errorf("count.index not available in this context")
	}
	return NumberFromInt(int64(*c.countIndex)), nil
}

func (c *Context) resolveEach(ref *Reference) (Value, error) {
	switch ref.Attribute {
	case "key":
		if c.eachKey == nil {
			return Unknown(), fmt.Errorf("each.key not available in this context")
		}
		return String(*c.eachKey), nil
	case "value":
		if c.eachKey == nil {
			return Unknown(), fmt.Errorf("each.value not available in this context")
		}
		return c.eachValue, nil
	default:
		return Unknown(), fmt.Errorf("each only has 'key' and 'value' attributes")
	}
}

func (c *Context) resolvePath(ref *Reference) (Value, error) {
	switch ref.Attribute {
	case "module":
		return String(c.pathModule), nil
	case "root":
		return String(c.pathRoot), nil
	case "cwd":
		return String(c.pathCwd), nil
	default:
		return Unknown(), fmt.Errorf("path.%s is not a valid path reference", ref.Attribute)
	}
}

func (c *Context) resolveTerraform(ref *Reference) (Value, error) {
	switch ref.Attribute {
	case "workspace":
		return String(c.workspace), nil
	default:
		return Unknown(), fmt.Errorf("terraform.%s is not a valid terraform reference", ref.Attribute)
	}
}

// traverseValue follows attribute access path through a value
func (c *Context) traverseValue(val Value, ref *Reference) (Value, error) {
	// If we have an attribute to access, traverse
	if ref.Attribute != "" {
		attr, err := val.GetAttr(ref.Attribute)
		if err != nil {
			return Unknown(), nil // Unknown attributes
		}
		val = attr
	}

	// Traverse remaining path
	for _, seg := range ref.Remaining {
		attr, err := val.GetAttr(seg)
		if err != nil {
			return Unknown(), nil
		}
		val = attr
	}

	return val, nil
}

// Clone creates a copy of the context
func (c *Context) Clone() *Context {
	c.mu.RLock()
	defer c.mu.RUnlock()

	clone := NewContext()
	clone.parent = c.parent
	clone.modulePath = c.modulePath
	clone.workspace = c.workspace
	clone.pathModule = c.pathModule
	clone.pathRoot = c.pathRoot
	clone.pathCwd = c.pathCwd

	for k, v := range c.variables {
		clone.variables[k] = v
	}
	for k, v := range c.locals {
		clone.locals[k] = v
	}
	for k, v := range c.resources {
		clone.resources[k] = v
	}
	for k, v := range c.dataSources {
		clone.dataSources[k] = v
	}
	for k, v := range c.modules {
		clone.modules[k] = v
	}

	if c.countIndex != nil {
		idx := *c.countIndex
		clone.countIndex = &idx
	}
	if c.eachKey != nil {
		key := *c.eachKey
		clone.eachKey = &key
		clone.eachValue = c.eachValue
	}
	clone.self = c.self

	return clone
}

################################################################################
# FILE: :\good projects\cost estimation\core\expression\reference.go
# TYPE: go
# SIZE: 7976 bytes
################################################################################
// Package expression - Reference parsing and resolution
package expression

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
)

// ReferenceKind identifies the type of reference
type ReferenceKind int

const (
	RefUnknown ReferenceKind = iota
	RefVariable      // var.name
	RefLocal         // local.name
	RefResource      // resource_type.name or resource_type.name[index]
	RefData          // data.type.name
	RefModule        // module.name
	RefOutput        // output.name (within modules)
	RefSelf          // self.attr
	RefCount         // count.index
	RefEach          // each.key or each.value
	RefPath          // path.module, path.root, path.cwd
	RefTerraform     // terraform.workspace
)

// Reference represents a reference to another value in HCL
type Reference struct {
	Kind       ReferenceKind
	Subject    string   // The full subject (e.g., "aws_instance.web")
	Key        string   // Primary key (e.g., "web" for aws_instance.web)
	Type       string   // Resource type (e.g., "aws_instance")
	Attribute  string   // Attribute being accessed (e.g., "id")
	Index      *Index   // Optional index for count/for_each
	Remaining  []string // Remaining path segments
	RawString  string   // Original reference string
}

// Index represents a count or for_each index
type Index struct {
	IsNumeric bool
	NumValue  int
	StrValue  string
	IsUnknown bool
}

// NewNumericIndex creates a numeric index
func NewNumericIndex(n int) *Index {
	return &Index{IsNumeric: true, NumValue: n}
}

// NewStringIndex creates a string index
func NewStringIndex(s string) *Index {
	return &Index{IsNumeric: false, StrValue: s}
}

// UnknownIndex creates an unknown index
func UnknownIndex() *Index {
	return &Index{IsUnknown: true}
}

// String returns the index as a string
func (idx *Index) String() string {
	if idx == nil {
		return ""
	}
	if idx.IsUnknown {
		return "[?]"
	}
	if idx.IsNumeric {
		return fmt.Sprintf("[%d]", idx.NumValue)
	}
	return fmt.Sprintf("[%q]", idx.StrValue)
}

// ParseReference parses a reference string into structured form
func ParseReference(ref string) (*Reference, error) {
	ref = strings.TrimSpace(ref)
	if ref == "" {
		return nil, fmt.Errorf("empty reference")
	}

	result := &Reference{RawString: ref}

	// Split by dots, but handle indices specially
	parts := splitReference(ref)
	if len(parts) == 0 {
		return nil, fmt.Errorf("invalid reference: %s", ref)
	}

	// Determine reference kind from first part
	switch parts[0] {
	case "var":
		result.Kind = RefVariable
		if len(parts) < 2 {
			return nil, fmt.Errorf("variable reference requires name: %s", ref)
		}
		result.Key = parts[1]
		result.Subject = "var." + result.Key
		if len(parts) > 2 {
			result.Remaining = parts[2:]
		}

	case "local":
		result.Kind = RefLocal
		if len(parts) < 2 {
			return nil, fmt.Errorf("local reference requires name: %s", ref)
		}
		result.Key = parts[1]
		result.Subject = "local." + result.Key
		if len(parts) > 2 {
			result.Remaining = parts[2:]
		}

	case "data":
		result.Kind = RefData
		if len(parts) < 3 {
			return nil, fmt.Errorf("data reference requires type and name: %s", ref)
		}
		result.Type = parts[1]
		result.Key, result.Index = parseKeyAndIndex(parts[2])
		result.Subject = fmt.Sprintf("data.%s.%s", result.Type, result.Key)
		if len(parts) > 3 {
			result.Remaining = parts[3:]
		}

	case "module":
		result.Kind = RefModule
		if len(parts) < 2 {
			return nil, fmt.Errorf("module reference requires name: %s", ref)
		}
		result.Key, result.Index = parseKeyAndIndex(parts[1])
		result.Subject = "module." + result.Key
		if len(parts) > 2 {
			result.Remaining = parts[2:]
		}

	case "self":
		result.Kind = RefSelf
		result.Subject = "self"
		if len(parts) > 1 {
			result.Attribute = parts[1]
			result.Remaining = parts[2:]
		}

	case "count":
		result.Kind = RefCount
		result.Subject = "count"
		if len(parts) > 1 && parts[1] == "index" {
			result.Attribute = "index"
		}

	case "each":
		result.Kind = RefEach
		result.Subject = "each"
		if len(parts) > 1 {
			result.Attribute = parts[1] // key or value
		}

	case "path":
		result.Kind = RefPath
		result.Subject = "path"
		if len(parts) > 1 {
			result.Attribute = parts[1] // module, root, cwd
		}

	case "terraform":
		result.Kind = RefTerraform
		result.Subject = "terraform"
		if len(parts) > 1 {
			result.Attribute = parts[1] // workspace
		}

	default:
		// Assume it's a resource reference: type.name
		result.Kind = RefResource
		result.Type = parts[0]
		if len(parts) < 2 {
			return nil, fmt.Errorf("resource reference requires name: %s", ref)
		}
		result.Key, result.Index = parseKeyAndIndex(parts[1])
		result.Subject = fmt.Sprintf("%s.%s", result.Type, result.Key)
		if len(parts) > 2 {
			result.Remaining = parts[2:]
		}
	}

	// Extract attribute from remaining if present
	if len(result.Remaining) > 0 {
		result.Attribute = result.Remaining[0]
		result.Remaining = result.Remaining[1:]
	}

	return result, nil
}

// splitReference splits a reference by dots, handling index brackets
func splitReference(ref string) []string {
	var parts []string
	var current strings.Builder
	inBracket := 0

	for _, ch := range ref {
		switch ch {
		case '[':
			inBracket++
			current.WriteRune(ch)
		case ']':
			inBracket--
			current.WriteRune(ch)
		case '.':
			if inBracket > 0 {
				current.WriteRune(ch)
			} else {
				if current.Len() > 0 {
					parts = append(parts, current.String())
					current.Reset()
				}
			}
		default:
			current.WriteRune(ch)
		}
	}

	if current.Len() > 0 {
		parts = append(parts, current.String())
	}

	return parts
}

// indexPattern matches [0], [1], ["key"], etc.
var indexPattern = regexp.MustCompile(`^([^[]+)\[(.+)\]$`)

// parseKeyAndIndex extracts key and optional index from "name[index]"
func parseKeyAndIndex(s string) (string, *Index) {
	matches := indexPattern.FindStringSubmatch(s)
	if matches == nil {
		return s, nil
	}

	key := matches[1]
	indexStr := matches[2]

	// Try numeric index
	if n, err := strconv.Atoi(indexStr); err == nil {
		return key, NewNumericIndex(n)
	}

	// Try string index (quoted)
	if strings.HasPrefix(indexStr, "\"") && strings.HasSuffix(indexStr, "\"") {
		return key, NewStringIndex(indexStr[1 : len(indexStr)-1])
	}

	// Unknown/computed index
	return key, UnknownIndex()
}

// Address returns the full address including index
func (r *Reference) Address() string {
	addr := r.Subject
	if r.Index != nil {
		addr += r.Index.String()
	}
	if r.Attribute != "" {
		addr += "." + r.Attribute
	}
	for _, rem := range r.Remaining {
		addr += "." + rem
	}
	return addr
}

// ResourceAddress returns just the resource address without attribute
func (r *Reference) ResourceAddress() string {
	addr := r.Subject
	if r.Index != nil {
		addr += r.Index.String()
	}
	return addr
}

// String returns the reference as a string
func (r *Reference) String() string {
	return r.Address()
}

// ExtractReferences finds all references in a string (simple heuristic)
func ExtractReferences(s string) []*Reference {
	// Pattern for common reference formats
	patterns := []string{
		`var\.[a-zA-Z_][a-zA-Z0-9_]*`,
		`local\.[a-zA-Z_][a-zA-Z0-9_]*`,
		`data\.[a-zA-Z_][a-zA-Z0-9_]*\.[a-zA-Z_][a-zA-Z0-9_]*`,
		`module\.[a-zA-Z_][a-zA-Z0-9_]*`,
		`[a-zA-Z_][a-zA-Z0-9_]*\.[a-zA-Z_][a-zA-Z0-9_]*(\[[^\]]+\])?(\.[a-zA-Z_][a-zA-Z0-9_]*)*`,
	}

	var refs []*Reference
	seen := make(map[string]bool)

	for _, pat := range patterns {
		re := regexp.MustCompile(pat)
		matches := re.FindAllString(s, -1)
		for _, m := range matches {
			if seen[m] {
				continue
			}
			seen[m] = true

			ref, err := ParseReference(m)
			if err == nil {
				refs = append(refs, ref)
			}
		}
	}

	return refs
}

################################################################################
# FILE: :\good projects\cost estimation\core\expression\value.go
# TYPE: go
# SIZE: 9189 bytes
################################################################################
// Package expression provides HCL expression evaluation.
// This is a clean-room implementation based on Terraform semantics.
package expression

import (
	"fmt"
	"math/big"
	"reflect"
	"strings"
)

// ValueKind represents the type of a value
type ValueKind int

const (
	KindNull ValueKind = iota
	KindBool
	KindNumber
	KindString
	KindList
	KindMap
	KindObject
	KindUnknown   // Value exists but is not yet known
	KindSensitive // Value is marked sensitive
)

// Value represents a Terraform/HCL value with type information
type Value struct {
	kind      ValueKind
	boolVal   bool
	numberVal *big.Float
	stringVal string
	listVal   []Value
	mapVal    map[string]Value
	marks     []ValueMark
}

// ValueMark represents metadata about a value
type ValueMark int

const (
	MarkNone ValueMark = iota
	MarkSensitive
	MarkUnknown
	MarkDynamic
)

// Null creates a null value
func Null() Value {
	return Value{kind: KindNull}
}

// Bool creates a boolean value
func Bool(v bool) Value {
	return Value{kind: KindBool, boolVal: v}
}

// Number creates a numeric value
func Number(v float64) Value {
	return Value{kind: KindNumber, numberVal: big.NewFloat(v)}
}

// NumberFromInt creates a numeric value from an integer
func NumberFromInt(v int64) Value {
	return Value{kind: KindNumber, numberVal: big.NewFloat(float64(v))}
}

// String creates a string value
func String(v string) Value {
	return Value{kind: KindString, stringVal: v}
}

// List creates a list value
func List(elements ...Value) Value {
	return Value{kind: KindList, listVal: elements}
}

// Map creates a map value
func Map(elements map[string]Value) Value {
	return Value{kind: KindMap, mapVal: elements}
}

// Unknown creates an unknown value (computed at runtime)
func Unknown() Value {
	return Value{kind: KindUnknown}
}

// UnknownWithType creates an unknown value with a type hint
func UnknownWithType(kind ValueKind) Value {
	v := Value{kind: kind, marks: []ValueMark{MarkUnknown}}
	return v
}

// FromGo converts a Go value to a Value
func FromGo(v interface{}) Value {
	if v == nil {
		return Null()
	}

	switch val := v.(type) {
	case bool:
		return Bool(val)
	case int:
		return NumberFromInt(int64(val))
	case int64:
		return NumberFromInt(val)
	case float64:
		return Number(val)
	case string:
		return String(val)
	case []interface{}:
		elements := make([]Value, len(val))
		for i, e := range val {
			elements[i] = FromGo(e)
		}
		return List(elements...)
	case map[string]interface{}:
		elements := make(map[string]Value)
		for k, e := range val {
			elements[k] = FromGo(e)
		}
		return Map(elements)
	default:
		// Try reflection for other types
		rv := reflect.ValueOf(v)
		switch rv.Kind() {
		case reflect.Slice, reflect.Array:
			elements := make([]Value, rv.Len())
			for i := 0; i < rv.Len(); i++ {
				elements[i] = FromGo(rv.Index(i).Interface())
			}
			return List(elements...)
		case reflect.Map:
			elements := make(map[string]Value)
			iter := rv.MapRange()
			for iter.Next() {
				k := fmt.Sprintf("%v", iter.Key().Interface())
				elements[k] = FromGo(iter.Value().Interface())
			}
			return Map(elements)
		}
		// Fallback to string representation
		return String(fmt.Sprintf("%v", v))
	}
}

// Kind returns the value kind
func (v Value) Kind() ValueKind {
	return v.kind
}

// IsNull returns true if value is null
func (v Value) IsNull() bool {
	return v.kind == KindNull
}

// IsUnknown returns true if value is unknown
func (v Value) IsUnknown() bool {
	if v.kind == KindUnknown {
		return true
	}
	for _, m := range v.marks {
		if m == MarkUnknown {
			return true
		}
	}
	return false
}

// IsSensitive returns true if value is sensitive
func (v Value) IsSensitive() bool {
	for _, m := range v.marks {
		if m == MarkSensitive {
			return true
		}
	}
	return false
}

// IsKnown returns true if value is not unknown and not null
func (v Value) IsKnown() bool {
	return !v.IsUnknown() && !v.IsNull()
}

// AsBool returns the boolean value
func (v Value) AsBool() (bool, error) {
	if v.kind != KindBool {
		return false, fmt.Errorf("value is %v, not bool", v.kind)
	}
	return v.boolVal, nil
}

// AsNumber returns the numeric value as float64
func (v Value) AsNumber() (float64, error) {
	if v.kind != KindNumber {
		return 0, fmt.Errorf("value is %v, not number", v.kind)
	}
	f, _ := v.numberVal.Float64()
	return f, nil
}

// AsInt returns the numeric value as int64
func (v Value) AsInt() (int64, error) {
	if v.kind != KindNumber {
		return 0, fmt.Errorf("value is %v, not number", v.kind)
	}
	f, _ := v.numberVal.Float64()
	return int64(f), nil
}

// AsString returns the string value
func (v Value) AsString() (string, error) {
	if v.kind != KindString {
		return "", fmt.Errorf("value is %v, not string", v.kind)
	}
	return v.stringVal, nil
}

// AsList returns the list elements
func (v Value) AsList() ([]Value, error) {
	if v.kind != KindList {
		return nil, fmt.Errorf("value is %v, not list", v.kind)
	}
	return v.listVal, nil
}

// AsMap returns the map elements
func (v Value) AsMap() (map[string]Value, error) {
	if v.kind != KindMap && v.kind != KindObject {
		return nil, fmt.Errorf("value is %v, not map", v.kind)
	}
	return v.mapVal, nil
}

// Length returns the length for lists/maps/strings
func (v Value) Length() (int, error) {
	switch v.kind {
	case KindString:
		return len(v.stringVal), nil
	case KindList:
		return len(v.listVal), nil
	case KindMap, KindObject:
		return len(v.mapVal), nil
	default:
		return 0, fmt.Errorf("cannot get length of %v", v.kind)
	}
}

// Index gets an element by index (for lists)
func (v Value) Index(i int) (Value, error) {
	if v.kind != KindList {
		return Null(), fmt.Errorf("cannot index %v", v.kind)
	}
	if i < 0 || i >= len(v.listVal) {
		return Null(), fmt.Errorf("index %d out of range [0, %d)", i, len(v.listVal))
	}
	return v.listVal[i], nil
}

// GetAttr gets an attribute by name (for maps/objects)
func (v Value) GetAttr(name string) (Value, error) {
	if v.kind != KindMap && v.kind != KindObject {
		return Null(), fmt.Errorf("cannot get attribute of %v", v.kind)
	}
	val, ok := v.mapVal[name]
	if !ok {
		return Null(), nil // Missing attributes are null
	}
	return val, nil
}

// Equals compares values for equality
func (v Value) Equals(other Value) bool {
	if v.kind != other.kind {
		return false
	}

	switch v.kind {
	case KindNull:
		return true
	case KindBool:
		return v.boolVal == other.boolVal
	case KindNumber:
		return v.numberVal.Cmp(other.numberVal) == 0
	case KindString:
		return v.stringVal == other.stringVal
	case KindList:
		if len(v.listVal) != len(other.listVal) {
			return false
		}
		for i := range v.listVal {
			if !v.listVal[i].Equals(other.listVal[i]) {
				return false
			}
		}
		return true
	case KindMap, KindObject:
		if len(v.mapVal) != len(other.mapVal) {
			return false
		}
		for k, val := range v.mapVal {
			otherVal, ok := other.mapVal[k]
			if !ok || !val.Equals(otherVal) {
				return false
			}
		}
		return true
	case KindUnknown:
		return false // Unknowns are never equal
	default:
		return false
	}
}

// ToGo converts the value to a Go interface{}
func (v Value) ToGo() interface{} {
	switch v.kind {
	case KindNull:
		return nil
	case KindBool:
		return v.boolVal
	case KindNumber:
		f, _ := v.numberVal.Float64()
		return f
	case KindString:
		return v.stringVal
	case KindList:
		result := make([]interface{}, len(v.listVal))
		for i, e := range v.listVal {
			result[i] = e.ToGo()
		}
		return result
	case KindMap, KindObject:
		result := make(map[string]interface{})
		for k, e := range v.mapVal {
			result[k] = e.ToGo()
		}
		return result
	case KindUnknown:
		return nil // Unknown converts to nil
	default:
		return nil
	}
}

// String returns a string representation
func (v Value) String() string {
	switch v.kind {
	case KindNull:
		return "null"
	case KindBool:
		if v.boolVal {
			return "true"
		}
		return "false"
	case KindNumber:
		return v.numberVal.Text('f', -1)
	case KindString:
		return fmt.Sprintf("%q", v.stringVal)
	case KindList:
		parts := make([]string, len(v.listVal))
		for i, e := range v.listVal {
			parts[i] = e.String()
		}
		return "[" + strings.Join(parts, ", ") + "]"
	case KindMap, KindObject:
		parts := make([]string, 0, len(v.mapVal))
		for k, e := range v.mapVal {
			parts = append(parts, fmt.Sprintf("%q = %s", k, e.String()))
		}
		return "{" + strings.Join(parts, ", ") + "}"
	case KindUnknown:
		return "(unknown)"
	default:
		return "(invalid)"
	}
}

// MarkAsSensitive returns a copy of the value marked as sensitive
func (v Value) MarkAsSensitive() Value {
	newVal := v
	newVal.marks = append(newVal.marks, MarkSensitive)
	return newVal
}

// MarkAsUnknown returns a copy of the value marked as unknown
func (v Value) MarkAsUnknown() Value {
	newVal := v
	newVal.marks = append(newVal.marks, MarkUnknown)
	return newVal
}

################################################################################
# FILE: :\good projects\cost estimation\core\model\definition.go
# TYPE: go
# SIZE: 11788 bytes
################################################################################
// Package model provides the core domain model with strict separation
// between definitions (static) and instances (expanded).
package model

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"sort"
	"time"
)

// DefinitionID uniquely identifies an asset definition (hash-based, stable)
type DefinitionID string

// InstanceID uniquely identifies an expanded instance
type InstanceID string

// InstanceAddress is the full Terraform address with index
// Examples: "aws_instance.web[0]", "module.app.aws_s3_bucket.data[\"logs\"]"
type InstanceAddress string

// DefinitionAddress is the address without index
// Examples: "aws_instance.web", "module.app.aws_s3_bucket.data"
type DefinitionAddress string

// ProviderKey identifies a provider configuration
// Examples: "aws", "aws.west", "google.europe"
type ProviderKey string

// ResourceType is the Terraform resource type
// Examples: "aws_instance", "google_compute_instance"
type ResourceType string

// InstanceKey represents the index for count/for_each
type InstanceKey struct {
	Type     KeyType
	IntValue int
	StrValue string
}

// KeyType indicates how an instance was indexed
type KeyType int

const (
	KeyTypeNone   KeyType = iota // No expansion (single instance)
	KeyTypeInt                   // count expansion: [0], [1], ...
	KeyTypeString                // for_each expansion: ["key"], ...
)

// String returns the key as an address suffix
func (k InstanceKey) String() string {
	switch k.Type {
	case KeyTypeInt:
		return fmt.Sprintf("[%d]", k.IntValue)
	case KeyTypeString:
		return fmt.Sprintf("[%q]", k.StrValue)
	default:
		return ""
	}
}

// SourceLocation tracks where in the source files something was defined
type SourceLocation struct {
	File      string
	StartLine int
	EndLine   int
	Module    string // Module path, empty for root
}

// Expression represents an unevaluated HCL expression
type Expression struct {
	Raw         string   // Original HCL text
	References  []string // Extracted references
	IsLiteral   bool     // True if no references
	LiteralVal  any      // Value if literal
}

// IsStatic returns true if the expression has no dependencies
func (e Expression) IsStatic() bool {
	return e.IsLiteral || len(e.References) == 0
}

// DynamicBlock represents a Terraform dynamic block
type DynamicBlock struct {
	Name      string     // Block type being generated
	ForEach   Expression // Iterator expression
	Iterator  string     // Iterator variable name (default: Name)
	Content   map[string]Expression
	Labels    []Expression
}

// LifecycleConfig holds lifecycle meta-argument values
type LifecycleConfig struct {
	CreateBeforeDestroy bool
	PreventDestroy      bool
	IgnoreChanges       []string
	ReplaceTriggeredBy  []string
}

// AssetDefinition is the STATIC Terraform resource/data block.
// This is what's written in .tf files, before any expansion.
type AssetDefinition struct {
	// Identity
	ID       DefinitionID      // Hash of address + provider + source location
	Address  DefinitionAddress // aws_instance.web
	Provider ProviderKey       // aws, aws.west
	Type     ResourceType      // aws_instance
	Name     string            // web
	Mode     ResourceMode      // managed, data

	// Meta-arguments (unevaluated)
	Count     *Expression   // count meta-argument
	ForEach   *Expression   // for_each meta-argument
	DependsOn []string      // Explicit dependencies
	Lifecycle LifecycleConfig

	// Attributes (may contain expressions)
	Attributes map[string]Expression

	// Dynamic blocks (must be expanded)
	DynamicBlocks []DynamicBlock

	// Provisioners (for cost implications like null_resource)
	Provisioners []Provisioner

	// Source tracking
	Location SourceLocation
}

// ResourceMode indicates managed resource vs data source
type ResourceMode int

const (
	ModeManaged ResourceMode = iota
	ModeData
)

// Provisioner represents a provisioner block
type Provisioner struct {
	Type       string // local-exec, remote-exec, file
	When       string // create, destroy
	OnFailure  string // continue, fail
	Attributes map[string]Expression
}

// ComputeID generates a stable ID for the definition
func (d *AssetDefinition) ComputeID() DefinitionID {
	h := sha256.New()
	h.Write([]byte(d.Address))
	h.Write([]byte(d.Provider))
	h.Write([]byte(fmt.Sprintf("%s:%d", d.Location.File, d.Location.StartLine)))
	return DefinitionID(hex.EncodeToString(h.Sum(nil))[:16])
}

// HasExpansion returns true if count or for_each is set
func (d *AssetDefinition) HasExpansion() bool {
	return d.Count != nil || d.ForEach != nil
}

// ResolvedAttribute is a fully evaluated attribute value
type ResolvedAttribute struct {
	Value     any           // Concrete value
	IsUnknown bool          // True if value couldn't be determined
	Reason    UnknownReason // Why it's unknown
	Sensitive bool          // Marked as sensitive
}

// UnknownReason explains why a value couldn't be determined
type UnknownReason int

const (
	ReasonKnown             UnknownReason = iota // Value is known
	ReasonComputedAtApply                        // Depends on infrastructure state
	ReasonDataSourcePending                      // Data source not yet evaluated
	ReasonCyclicReference                        // Circular dependency
	ReasonMissingVariable                        // Variable not provided
	ReasonExpressionError                        // Evaluation failed
)

// ResolvedProvider is a fully resolved provider configuration
type ResolvedProvider struct {
	Type       string            // aws, google, azurerm
	Alias      string            // Optional alias
	Region     string            // Resolved region
	Attributes map[string]any    // Other provider config
}

// AssetInstance is a CONCRETE, EXPANDED instance.
// This is what we actually cost - after count/for_each expansion.
type AssetInstance struct {
	// Identity
	ID           InstanceID        // Globally unique, hash-based
	DefinitionID DefinitionID      // Links back to definition
	Address      InstanceAddress   // aws_instance.web[0]

	// Instance-specific
	Key          InstanceKey       // The expansion key (0, "prod", etc.)

	// Fully resolved values (no expressions)
	Attributes   map[string]ResolvedAttribute

	// Provider after alias resolution
	Provider     ResolvedProvider

	// Dependencies after resolution (instance-level)
	Dependencies []InstanceID

	// Derived from dynamic blocks
	DynamicData  map[string][]map[string]ResolvedAttribute

	// Metadata
	Metadata     InstanceMetadata
}

// InstanceMetadata contains instance-level metadata
type InstanceMetadata struct {
	CreatedAt     time.Time
	Source        InstanceSource
	IsPlaceholder bool   // True if created for unknown expansion
	Warning       string // Any warning during expansion
}

// InstanceSource tracks how the instance was created
type InstanceSource int

const (
	SourceHCL         InstanceSource = iota // From .tf files
	SourcePlanJSON                          // From terraform plan JSON
	SourceState                             // From terraform state
	SourcePlaceholder                       // Synthetic for unknown count
)

// ComputeID generates a stable ID for the instance
func (i *AssetInstance) ComputeID() InstanceID {
	h := sha256.New()
	h.Write([]byte(i.DefinitionID))
	h.Write([]byte(i.Key.String()))
	return InstanceID(hex.EncodeToString(h.Sum(nil))[:16])
}

// GetAttribute returns an attribute value, handling unknowns
func (i *AssetInstance) GetAttribute(name string) (any, bool, UnknownReason) {
	attr, ok := i.Attributes[name]
	if !ok {
		return nil, false, ReasonKnown
	}
	return attr.Value, !attr.IsUnknown, attr.Reason
}

// InstanceEdge represents a dependency between instances
type InstanceEdge struct {
	From   InstanceID
	To     InstanceID
	Type   EdgeType
}

// EdgeType indicates the type of dependency
type EdgeType int

const (
	EdgeExplicit  EdgeType = iota // depends_on
	EdgeImplicit                  // Reference-based
	EdgeProvider                  // Provider dependency
)

// InstanceGraph is a DAG of AssetInstances.
// All operations happen on instances, NOT definitions.
type InstanceGraph struct {
	// Core data (use sorted access only)
	instances map[InstanceID]*AssetInstance
	edges     []InstanceEdge

	// Indexes (maintained automatically)
	byAddress    map[InstanceAddress]*AssetInstance
	byDefinition map[DefinitionID][]*AssetInstance

	// Computed on demand
	topologicalOrder []InstanceID
	orderValid       bool
}

// NewInstanceGraph creates an empty instance graph
func NewInstanceGraph() *InstanceGraph {
	return &InstanceGraph{
		instances:    make(map[InstanceID]*AssetInstance),
		byAddress:    make(map[InstanceAddress]*AssetInstance),
		byDefinition: make(map[DefinitionID][]*AssetInstance),
	}
}

// AddInstance adds an instance to the graph
func (g *InstanceGraph) AddInstance(inst *AssetInstance) {
	g.instances[inst.ID] = inst
	g.byAddress[inst.Address] = inst
	g.byDefinition[inst.DefinitionID] = append(g.byDefinition[inst.DefinitionID], inst)
	g.orderValid = false
}

// AddEdge adds a dependency edge
func (g *InstanceGraph) AddEdge(from, to InstanceID, edgeType EdgeType) {
	g.edges = append(g.edges, InstanceEdge{From: from, To: to, Type: edgeType})
	g.orderValid = false
}

// Instances returns all instances in stable, sorted order
func (g *InstanceGraph) Instances() []*AssetInstance {
	ids := make([]InstanceID, 0, len(g.instances))
	for id := range g.instances {
		ids = append(ids, id)
	}
	sort.Slice(ids, func(i, j int) bool {
		return ids[i] < ids[j]
	})

	result := make([]*AssetInstance, len(ids))
	for i, id := range ids {
		result[i] = g.instances[id]
	}
	return result
}

// ByAddress looks up an instance by its full address
func (g *InstanceGraph) ByAddress(addr InstanceAddress) (*AssetInstance, bool) {
	inst, ok := g.byAddress[addr]
	return inst, ok
}

// ByDefinition returns all instances expanded from a definition
func (g *InstanceGraph) ByDefinition(defID DefinitionID) []*AssetInstance {
	instances := g.byDefinition[defID]
	// Return sorted copy
	sorted := make([]*AssetInstance, len(instances))
	copy(sorted, instances)
	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i].Address < sorted[j].Address
	})
	return sorted
}

// TopologicalOrder returns instances in dependency order
func (g *InstanceGraph) TopologicalOrder() []InstanceID {
	if g.orderValid {
		return g.topologicalOrder
	}

	// Kahn's algorithm for topological sort
	inDegree := make(map[InstanceID]int)
	for id := range g.instances {
		inDegree[id] = 0
	}
	for _, edge := range g.edges {
		inDegree[edge.To]++
	}

	// Find all nodes with no incoming edges
	queue := make([]InstanceID, 0)
	for id, degree := range inDegree {
		if degree == 0 {
			queue = append(queue, id)
		}
	}
	sort.Slice(queue, func(i, j int) bool { return queue[i] < queue[j] })

	result := make([]InstanceID, 0, len(g.instances))
	for len(queue) > 0 {
		// Pop (stable: always take first)
		node := queue[0]
		queue = queue[1:]
		result = append(result, node)

		// Reduce in-degree for neighbors
		for _, edge := range g.edges {
			if edge.From == node {
				inDegree[edge.To]--
				if inDegree[edge.To] == 0 {
					queue = append(queue, edge.To)
					sort.Slice(queue, func(i, j int) bool { return queue[i] < queue[j] })
				}
			}
		}
	}

	g.topologicalOrder = result
	g.orderValid = true
	return result
}

// Size returns the number of instances
func (g *InstanceGraph) Size() int {
	return len(g.instances)
}

################################################################################
# FILE: :\good projects\cost estimation\core\output\formatter.go
# TYPE: go
# SIZE: 4597 bytes
################################################################################
// Package output provides output formatting interfaces.
// This package produces human and machine-readable outputs.
package output

import (
	"io"

	"terraform-cost/core/policy"
	"terraform-cost/core/types"
)

// Format represents output format type
type Format string

const (
	// FormatCLI is a human-readable CLI table
	FormatCLI Format = "cli"

	// FormatJSON is machine-readable JSON
	FormatJSON Format = "json"

	// FormatHTML is an HTML report
	FormatHTML Format = "html"

	// FormatMarkdown is a markdown report
	FormatMarkdown Format = "markdown"

	// FormatPR is a PR comment format
	FormatPR Format = "pr"
)

// Formatter produces output in a specific format
type Formatter interface {
	// Format returns the format type
	Format() Format

	// Render produces output for the given result
	Render(w io.Writer, result *EstimationResult) error
}

// EstimationResult contains the complete estimation output
type EstimationResult struct {
	// CostGraph is the calculated cost graph
	CostGraph *types.CostGraph `json:"cost_graph"`

	// AssetGraph is the source asset graph
	AssetGraph *types.AssetGraph `json:"asset_graph,omitempty"`

	// PolicyResult contains policy evaluation results
	PolicyResult *policy.EvaluationResult `json:"policy_result,omitempty"`

	// PricingSnapshot identifies the pricing data used
	PricingSnapshot *types.PricingSnapshot `json:"pricing_snapshot"`

	// UsageProfile is the usage profile that was applied
	UsageProfile *types.UsageProfile `json:"usage_profile,omitempty"`

	// Assumptions documents estimation assumptions
	Assumptions []Assumption `json:"assumptions,omitempty"`

	// Confidence is the overall confidence level (0.0 to 1.0)
	Confidence float64 `json:"confidence"`

	// Metadata contains execution context
	Metadata EstimationMetadata `json:"metadata"`

	// Diff contains comparison with previous estimate
	Diff *EstimationDiff `json:"diff,omitempty"`
}

// Assumption documents an estimation assumption
type Assumption struct {
	// Resource is the resource this assumption applies to
	Resource types.ResourceAddress `json:"resource,omitempty"`

	// Category is the assumption category
	Category string `json:"category"`

	// Description explains the assumption
	Description string `json:"description"`

	// Impact describes the potential impact
	Impact string `json:"impact,omitempty"`

	// Confidence is the confidence in this assumption
	Confidence float64 `json:"confidence,omitempty"`
}

// EstimationMetadata contains execution context
type EstimationMetadata struct {
	// Timestamp is when the estimation was performed
	Timestamp string `json:"timestamp"`

	// Duration is how long the estimation took
	Duration string `json:"duration"`

	// InputHash is a hash of the input for caching
	InputHash string `json:"input_hash"`

	// SnapshotID is the pricing snapshot ID
	SnapshotID string `json:"snapshot_id"`

	// Version is the tool version
	Version string `json:"version"`

	// Source is the input source
	Source types.InputSource `json:"source"`

	// Environment is the target environment
	Environment string `json:"environment,omitempty"`
}

// EstimationDiff contains comparison with a previous estimate
type EstimationDiff struct {
	// Previous is the previous cost
	Previous types.CostGraph `json:"previous"`

	// Added are new resources
	Added []DiffItem `json:"added,omitempty"`

	// Removed are removed resources
	Removed []DiffItem `json:"removed,omitempty"`

	// Changed are resources with cost changes
	Changed []DiffItem `json:"changed,omitempty"`

	// TotalChange is the difference in total cost
	TotalChange string `json:"total_change"`

	// PercentChange is the percentage change
	PercentChange float64 `json:"percent_change"`
}

// DiffItem represents a single diff entry
type DiffItem struct {
	// Resource is the resource address
	Resource string `json:"resource"`

	// PreviousCost is the old cost
	PreviousCost string `json:"previous_cost,omitempty"`

	// CurrentCost is the new cost
	CurrentCost string `json:"current_cost,omitempty"`

	// Change is the cost difference
	Change string `json:"change,omitempty"`
}

// FormatterRegistry manages formatter registration
type FormatterRegistry interface {
	// Register adds a formatter to the registry
	Register(formatter Formatter) error

	// GetFormatter returns a formatter for a format type
	GetFormatter(format Format) (Formatter, bool)

	// GetAll returns all registered formatters
	GetAll() []Formatter
}

################################################################################
# FILE: :\good projects\cost estimation\core\policy\deep_policy.go
# TYPE: go
# SIZE: 12552 bytes
################################################################################
// Package policy provides the policy evaluation engine with deep context access.
// Policies can access cost lineage, usage confidence, and instance identity.
package policy

import (
	"context"
	"fmt"
	"sort"

	"terraform-cost/core/determinism"
	"terraform-cost/core/model"
	"terraform-cost/core/pricing"
)

// DeepEvaluator evaluates cost policies with full context access
type DeepEvaluator struct {
	policies []DeepPolicy
}

// NewDeepEvaluator creates a new policy evaluator
func NewDeepEvaluator() *DeepEvaluator {
	return &DeepEvaluator{
		policies: []DeepPolicy{},
	}
}

// Register adds a policy
func (e *DeepEvaluator) Register(p DeepPolicy) {
	e.policies = append(e.policies, p)
}

// DeepPolicy is an interface for cost policies with deep context
type DeepPolicy interface {
	Name() string
	Evaluate(ctx context.Context, input *PolicyInput) (*PolicyOutput, error)
}

// PolicyInput provides DEEP context for policy evaluation
type PolicyInput struct {
	// Instance costs (per-instance, not aggregated)
	InstanceCosts map[model.InstanceID]*InstanceCostDetail

	// Total costs
	TotalMonthlyCost determinism.Money
	TotalHourlyCost  determinism.Money

	// Confidence information
	OverallConfidence float64
	LowConfidenceItems []LowConfidenceItem

	// Unknowns
	UnknownValues []UnknownValueInfo

	// Definitions (for grouping)
	Definitions map[model.DefinitionID]*model.AssetDefinition

	// Full lineage for tracing
	AllLineage []*pricing.CostLineage

	// Pricing snapshot used
	Snapshot *pricing.PricingSnapshot
}

// InstanceCostDetail provides deep detail for a single instance
type InstanceCostDetail struct {
	// Instance identity
	InstanceID   model.InstanceID
	Address      model.InstanceAddress
	DefinitionID model.DefinitionID
	InstanceKey  model.InstanceKey

	// Provider and region
	Provider string
	Region   string

	// Costs
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money
	Components  []ComponentDetail

	// Confidence
	Confidence float64
	Factors    []ConfidenceFactor

	// Full lineage
	Lineage []*pricing.CostLineage

	// Usage information
	Usage UsageInfo

	// Tags/labels for targeting
	Tags map[string]string
}

// ComponentDetail provides detail for a cost component
type ComponentDetail struct {
	Name        string
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money

	// Rate used
	Rate RateInfo

	// Usage
	UsageValue float64
	UsageUnit  string

	// Formula applied
	Formula pricing.FormulaApplication

	// Confidence
	Confidence float64
}

// RateInfo describes the pricing rate used
type RateInfo struct {
	ID       pricing.RateID
	Key      pricing.RateKey
	Price    string
	Unit     string
	Currency string
}

// UsageInfo provides usage details
type UsageInfo struct {
	Source      pricing.UsageSource
	Confidence  float64
	Assumptions []string
	Overridden  bool
}

// ConfidenceFactor explains why confidence is reduced
type ConfidenceFactor struct {
	Reason    string
	Impact    float64
	Component string
	IsUnknown bool
}

// LowConfidenceItem identifies items with low confidence
type LowConfidenceItem struct {
	InstanceID model.InstanceID
	Address    model.InstanceAddress
	Component  string
	Confidence float64
	Reason     string
}

// UnknownValueInfo describes an unknown value
type UnknownValueInfo struct {
	Address string
	Reason  string
	Impact  string
}

// PolicyOutput is the result of a single policy
type PolicyOutput struct {
	Passed  bool
	Message string

	// Affected instances (for targeting)
	AffectedInstances []model.InstanceID

	// Cost impact
	AffectedCost determinism.Money

	// Lineage references (for explainability)
	LineageRefs []*pricing.CostLineage

	// Suggested actions
	Suggestions []string
}

// DeepResult is the complete result of all policies
type DeepResult struct {
	Passed   bool
	Policies []DeepPolicyResult
}

// DeepPolicyResult is the result of a single policy
type DeepPolicyResult struct {
	Name    string
	Passed  bool
	Message string

	AffectedInstances []model.InstanceID
	AffectedCost      determinism.Money
	LineageRefs       []*pricing.CostLineage
	Suggestions       []string
}

// Evaluate runs all policies
func (e *DeepEvaluator) Evaluate(ctx context.Context, input *PolicyInput) (*DeepResult, error) {
	result := &DeepResult{
		Passed:   true,
		Policies: make([]DeepPolicyResult, 0, len(e.policies)),
	}

	for _, p := range e.policies {
		output, err := p.Evaluate(ctx, input)
		if err != nil {
			return nil, fmt.Errorf("policy %s failed: %w", p.Name(), err)
		}

		pr := DeepPolicyResult{
			Name:              p.Name(),
			Passed:            output.Passed,
			Message:           output.Message,
			AffectedInstances: output.AffectedInstances,
			AffectedCost:      output.AffectedCost,
			LineageRefs:       output.LineageRefs,
			Suggestions:       output.Suggestions,
		}
		result.Policies = append(result.Policies, pr)

		if !output.Passed {
			result.Passed = false
		}
	}

	return result, nil
}

// BudgetPolicy checks if total cost exceeds a budget
type BudgetPolicy struct {
	name          string
	monthlyBudget determinism.Money
	threshold     float64 // 0.0-1.0, warn when at this percentage
}

// NewBudgetPolicy creates a budget policy
func NewBudgetPolicy(name string, monthlyBudget determinism.Money, threshold float64) *BudgetPolicy {
	return &BudgetPolicy{
		name:          name,
		monthlyBudget: monthlyBudget,
		threshold:     threshold,
	}
}

func (p *BudgetPolicy) Name() string { return p.name }

func (p *BudgetPolicy) Evaluate(ctx context.Context, input *PolicyInput) (*PolicyOutput, error) {
	output := &PolicyOutput{
		Passed: true,
	}

	// Check if over budget
	if input.TotalMonthlyCost.Cmp(p.monthlyBudget) > 0 {
		output.Passed = false
		output.Message = fmt.Sprintf("Monthly cost $%s exceeds budget $%s",
			input.TotalMonthlyCost.String(), p.monthlyBudget.String())

		// Find top cost contributors
		output.AffectedInstances = p.findTopContributors(input, 5)
		output.AffectedCost = input.TotalMonthlyCost.Sub(p.monthlyBudget)
		output.Suggestions = []string{
			"Consider using smaller instance types",
			"Review usage assumptions for accuracy",
			"Check for unused resources",
		}
	} else {
		// Check threshold warning
		thresholdAmount := p.monthlyBudget.MulFloat(p.threshold)
		if input.TotalMonthlyCost.Cmp(thresholdAmount) > 0 {
			output.Message = fmt.Sprintf("Monthly cost $%s is at %.0f%% of budget $%s",
				input.TotalMonthlyCost.String(),
				(input.TotalMonthlyCost.Float64()/p.monthlyBudget.Float64())*100,
				p.monthlyBudget.String())
		} else {
			output.Message = fmt.Sprintf("Monthly cost $%s is within budget $%s",
				input.TotalMonthlyCost.String(), p.monthlyBudget.String())
		}
	}

	return output, nil
}

func (p *BudgetPolicy) findTopContributors(input *PolicyInput, n int) []model.InstanceID {
	// Sort instances by cost
	type costItem struct {
		id   model.InstanceID
		cost determinism.Money
	}

	items := make([]costItem, 0, len(input.InstanceCosts))
	for id, detail := range input.InstanceCosts {
		items = append(items, costItem{id: id, cost: detail.MonthlyCost})
	}

	sort.Slice(items, func(i, j int) bool {
		return items[i].cost.Cmp(items[j].cost) > 0
	})

	result := make([]model.InstanceID, 0, n)
	for i := 0; i < n && i < len(items); i++ {
		result = append(result, items[i].id)
	}
	return result
}

// ConfidencePolicy checks if estimation confidence is acceptable
type ConfidencePolicy struct {
	name          string
	minConfidence float64
}

// NewConfidencePolicy creates a confidence policy
func NewConfidencePolicy(name string, minConfidence float64) *ConfidencePolicy {
	return &ConfidencePolicy{
		name:          name,
		minConfidence: minConfidence,
	}
}

func (p *ConfidencePolicy) Name() string { return p.name }

func (p *ConfidencePolicy) Evaluate(ctx context.Context, input *PolicyInput) (*PolicyOutput, error) {
	output := &PolicyOutput{
		Passed: true,
	}

	if input.OverallConfidence < p.minConfidence {
		output.Passed = false
		output.Message = fmt.Sprintf("Estimation confidence %.2f%% is below minimum %.2f%%",
			input.OverallConfidence*100, p.minConfidence*100)

		// Find low confidence items
		for _, item := range input.LowConfidenceItems {
			output.AffectedInstances = append(output.AffectedInstances, item.InstanceID)
		}

		// Collect lineage for affected items
		for _, lineage := range input.AllLineage {
			if lineage.Confidence < p.minConfidence {
				output.LineageRefs = append(output.LineageRefs, lineage)
			}
		}

		output.Suggestions = []string{
			"Provide usage overrides for low-confidence components",
			"Check that all required variables are provided",
			"Review unknown values in the configuration",
		}
	} else {
		output.Message = fmt.Sprintf("Estimation confidence %.2f%% meets minimum %.2f%%",
			input.OverallConfidence*100, p.minConfidence*100)
	}

	return output, nil
}

// ResourceTypePolicy checks limits on specific resource types
type ResourceTypePolicy struct {
	name         string
	resourceType string
	maxInstances int
	maxCost      *determinism.Money
}

// NewResourceTypePolicy creates a resource type policy
func NewResourceTypePolicy(name, resourceType string, maxInstances int, maxCost *determinism.Money) *ResourceTypePolicy {
	return &ResourceTypePolicy{
		name:         name,
		resourceType: resourceType,
		maxInstances: maxInstances,
		maxCost:      maxCost,
	}
}

func (p *ResourceTypePolicy) Name() string { return p.name }

func (p *ResourceTypePolicy) Evaluate(ctx context.Context, input *PolicyInput) (*PolicyOutput, error) {
	output := &PolicyOutput{
		Passed: true,
	}

	// Count instances and sum cost for this resource type
	var count int
	totalCost := determinism.Zero("USD")
	affected := []model.InstanceID{}

	for id, detail := range input.InstanceCosts {
		// Check if this instance matches the resource type
		addr := string(detail.Address)
		if len(addr) >= len(p.resourceType) && addr[:len(p.resourceType)] == p.resourceType {
			count++
			totalCost = totalCost.Add(detail.MonthlyCost)
			affected = append(affected, id)
		}
	}

	// Check instance count
	if p.maxInstances > 0 && count > p.maxInstances {
		output.Passed = false
		output.Message = fmt.Sprintf("%s: %d instances exceeds limit of %d",
			p.resourceType, count, p.maxInstances)
		output.AffectedInstances = affected
	}

	// Check cost
	if p.maxCost != nil && totalCost.Cmp(*p.maxCost) > 0 {
		output.Passed = false
		if output.Message != "" {
			output.Message += "; "
		}
		output.Message += fmt.Sprintf("%s cost $%s exceeds limit $%s",
			p.resourceType, totalCost.String(), p.maxCost.String())
		output.AffectedInstances = affected
		output.AffectedCost = totalCost.Sub(*p.maxCost)
	}

	if output.Passed {
		output.Message = fmt.Sprintf("%s: %d instances, $%s/month - within limits",
			p.resourceType, count, totalCost.String())
	}

	return output, nil
}

// TagRequirementPolicy checks that instances have required tags
type TagRequirementPolicy struct {
	name         string
	requiredTags []string
}

// NewTagRequirementPolicy creates a tag requirement policy
func NewTagRequirementPolicy(name string, requiredTags []string) *TagRequirementPolicy {
	return &TagRequirementPolicy{
		name:         name,
		requiredTags: requiredTags,
	}
}

func (p *TagRequirementPolicy) Name() string { return p.name }

func (p *TagRequirementPolicy) Evaluate(ctx context.Context, input *PolicyInput) (*PolicyOutput, error) {
	output := &PolicyOutput{
		Passed: true,
	}

	missingTags := make(map[model.InstanceID][]string)

	for id, detail := range input.InstanceCosts {
		for _, req := range p.requiredTags {
			if _, ok := detail.Tags[req]; !ok {
				missingTags[id] = append(missingTags[id], req)
			}
		}
	}

	if len(missingTags) > 0 {
		output.Passed = false
		output.Message = fmt.Sprintf("%d instances missing required tags", len(missingTags))

		for id := range missingTags {
			output.AffectedInstances = append(output.AffectedInstances, id)
		}

		output.Suggestions = []string{
			"Add required tags: " + fmt.Sprintf("%v", p.requiredTags),
		}
	} else {
		output.Message = "All instances have required tags"
	}

	return output, nil
}

################################################################################
# FILE: :\good projects\cost estimation\core\policy\evaluator.go
# TYPE: go
# SIZE: 4143 bytes
################################################################################
// Package policy provides the policy evaluation interface.
// This package enforces cost guardrails before deployment.
package policy

import (
	"context"

	"terraform-cost/core/types"
)

// Rule defines a single policy rule
type Rule interface {
	// Name returns the rule identifier
	Name() string

	// Description returns a human-readable description
	Description() string

	// Evaluate checks the rule against the cost graph
	// prev is the previous cost graph for diff-based policies (can be nil)
	Evaluate(ctx context.Context, current *types.CostGraph, prev *types.CostGraph) (*RuleResult, error)
}

// RuleResult contains the evaluation output for a single rule
type RuleResult struct {
	// RuleName is the rule that was evaluated
	RuleName string `json:"rule_name"`

	// Passed indicates if the rule passed
	Passed bool `json:"passed"`

	// Severity is the rule severity
	Severity Severity `json:"severity"`

	// Message is a human-readable result message
	Message string `json:"message"`

	// Details contains additional context
	Details map[string]interface{} `json:"details,omitempty"`

	// Violations lists specific violations
	Violations []Violation `json:"violations,omitempty"`
}

// Violation represents a specific policy violation
type Violation struct {
	// Resource is the violating resource
	Resource string `json:"resource"`

	// Message describes the violation
	Message string `json:"message"`

	// Details contains additional context
	Details map[string]interface{} `json:"details,omitempty"`
}

// Severity levels for policy violations
type Severity string

const (
	// SeverityInfo is informational only
	SeverityInfo Severity = "info"

	// SeverityWarning is a warning that doesn't block
	SeverityWarning Severity = "warning"

	// SeverityError is an error but doesn't block
	SeverityError Severity = "error"

	// SeverityBlock blocks deployment
	SeverityBlock Severity = "block"
)

// Evaluator runs all policy rules
type Evaluator interface {
	// RegisterRule adds a rule to the evaluator
	RegisterRule(rule Rule) error

	// Evaluate runs all rules and returns results
	Evaluate(ctx context.Context, current *types.CostGraph, prev *types.CostGraph) (*EvaluationResult, error)

	// EvaluateRules runs specific rules
	EvaluateRules(ctx context.Context, ruleNames []string, current *types.CostGraph, prev *types.CostGraph) (*EvaluationResult, error)
}

// EvaluationResult contains all rule results
type EvaluationResult struct {
	// Results contains individual rule results
	Results []*RuleResult `json:"results"`

	// PassedCount is the number of passed rules
	PassedCount int `json:"passed_count"`

	// FailedCount is the number of failed rules
	FailedCount int `json:"failed_count"`

	// Blocked indicates if any rule blocks deployment
	Blocked bool `json:"blocked"`

	// BlockReason explains why deployment is blocked
	BlockReason string `json:"block_reason,omitempty"`
}

// HasFailures returns true if any rules failed
func (r *EvaluationResult) HasFailures() bool {
	return r.FailedCount > 0
}

// GetBlockingRules returns rules that block deployment
func (r *EvaluationResult) GetBlockingRules() []*RuleResult {
	var blocking []*RuleResult
	for _, result := range r.Results {
		if !result.Passed && result.Severity == SeverityBlock {
			blocking = append(blocking, result)
		}
	}
	return blocking
}

// PolicyConfig contains policy configuration
type PolicyConfig struct {
	// Rules are the rules to evaluate
	Rules []RuleConfig `json:"rules"`

	// StopOnBlock stops evaluation on first blocking rule
	StopOnBlock bool `json:"stop_on_block"`
}

// RuleConfig contains configuration for a specific rule
type RuleConfig struct {
	// Name is the rule name
	Name string `json:"name"`

	// Enabled indicates if the rule is enabled
	Enabled bool `json:"enabled"`

	// Severity overrides the default severity
	Severity *Severity `json:"severity,omitempty"`

	// Parameters contains rule-specific parameters
	Parameters map[string]interface{} `json:"parameters,omitempty"`
}

################################################################################
# FILE: :\good projects\cost estimation\core\policy\full_lineage.go
# TYPE: go
# SIZE: 9983 bytes
################################################################################
// Package policy - Full lineage access for policies
// Policies can see the COMPLETE derivation chain.
package policy

import (
	"fmt"

	"terraform-cost/core/determinism"
	"terraform-cost/core/model"
	"terraform-cost/core/pricing"
)

// FullLineageContext provides COMPLETE cost derivation information to policies
type FullLineageContext struct {
	// Per-instance costs with full derivation
	Instances map[model.InstanceID]*InstanceLineage

	// Rollups
	TotalMonthlyCost determinism.Money
	TotalHourlyCost  determinism.Money

	// Confidence breakdown
	OverallConfidence    float64
	ConfidenceByInstance map[model.InstanceID]float64
	ConfidenceByComponent map[string]float64

	// Unknown tracking
	Unknowns []UnknownInfo
	UnknownsByInstance map[model.InstanceID][]UnknownInfo

	// Snapshot reference
	Snapshot SnapshotInfo
}

// InstanceLineage is the FULL derivation for a single instance
type InstanceLineage struct {
	// Instance identity
	InstanceID   model.InstanceID
	Address      model.InstanceAddress
	DefinitionID model.DefinitionID
	InstanceKey  model.InstanceKey

	// Provider context
	Provider string
	Region   string

	// Cost summary
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money
	Confidence  float64

	// FULL component breakdown
	Components []ComponentLineage

	// Resource tags
	Tags map[string]string

	// Unknowns affecting this instance
	Unknowns []UnknownInfo

	// Degradation reasons
	DegradedParts []DegradationInfo
}

// ComponentLineage is the FULL derivation for a cost component
type ComponentLineage struct {
	// Component identity
	Name        string
	ResourceType string

	// Cost
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money
	Confidence  float64

	// RATE: Which pricing rate was used
	Rate RateLineage

	// USAGE: Where usage data came from
	Usage UsageLineage

	// FORMULA: How cost was calculated
	Formula FormulaLineage

	// Is this component degraded?
	IsDegraded       bool
	DegradationReason string
}

// RateLineage tracks the pricing rate used
type RateLineage struct {
	// Rate identity
	RateID      pricing.RateID
	RateKey     pricing.RateKey

	// Rate details
	Price       string
	Unit        string
	Currency    string
	Description string

	// Tier info (for tiered pricing)
	Tier        *TierInfo

	// Was this rate found?
	Found       bool
	MissingReason string
}

// TierInfo describes pricing tier
type TierInfo struct {
	TierIndex   int
	StartUsage  string
	EndUsage    string
	TierPrice   string
}

// UsageLineage tracks where usage data came from
type UsageLineage struct {
	// Source of usage data
	Source UsageSourceType

	// The value used
	Value       float64
	Unit        string

	// Confidence in this value
	Confidence  float64

	// Was this overridden by user?
	IsOverridden bool

	// Profile used (if any)
	Profile     string

	// Assumptions made
	Assumptions []string

	// Was this unknown?
	IsUnknown   bool
	UnknownReason string
}

// UsageSourceType indicates where usage came from
type UsageSourceType int

const (
	UsageFromDefault UsageSourceType = iota
	UsageFromProfile
	UsageFromOverride
	UsageFromHistorical
	UsageFromEstimate
	UsageUnknown
)

// String returns the source name
func (s UsageSourceType) String() string {
	switch s {
	case UsageFromDefault:
		return "default"
	case UsageFromProfile:
		return "profile"
	case UsageFromOverride:
		return "override"
	case UsageFromHistorical:
		return "historical"
	case UsageFromEstimate:
		return "estimate"
	case UsageUnknown:
		return "unknown"
	default:
		return "unknown"
	}
}

// FormulaLineage tracks how cost was calculated
type FormulaLineage struct {
	// Formula name
	Name       string

	// Readable expression
	Expression string

	// All inputs used
	Inputs     map[string]FormulaInput

	// The output
	Output     string
}

// FormulaInput is a single input to a formula
type FormulaInput struct {
	Name       string
	Value      string
	Source     string // "rate", "usage", "constant"
	Confidence float64
}

// UnknownInfo describes an unknown value
type UnknownInfo struct {
	// What is unknown
	Address   string
	Component string
	Attribute string

	// Why it's unknown
	Reason    string

	// Impact on cost
	Impact    UnknownImpact
}

// UnknownImpact describes how an unknown affects cost
type UnknownImpact int

const (
	ImpactHigh   UnknownImpact = iota // Cost is unreliable
	ImpactMedium                       // Cost is approximate
	ImpactLow                          // Cost is slightly affected
)

// String returns the impact level
func (i UnknownImpact) String() string {
	switch i {
	case ImpactHigh:
		return "high"
	case ImpactMedium:
		return "medium"
	case ImpactLow:
		return "low"
	default:
		return "unknown"
	}
}

// DegradationInfo describes why a cost is degraded
type DegradationInfo struct {
	Component string
	Reason    string
	Impact    float64
}

// SnapshotInfo is the pricing snapshot reference
type SnapshotInfo struct {
	ID          pricing.SnapshotID
	ContentHash string
	Provider    string
	Region      string
	CreatedAt   string
	EffectiveAt string
	IsStale     bool
}

// LineageAwarePolicy is a policy that uses full lineage
type LineageAwarePolicy interface {
	Name() string
	EvaluateWithLineage(ctx *FullLineageContext) (*LineageAwarePolicyResult, error)
}

// LineageAwarePolicyResult is the result of a lineage-aware policy
type LineageAwarePolicyResult struct {
	Passed  bool
	Message string

	// What was analyzed
	AnalyzedInstances int
	AnalyzedComponents int

	// What failed
	FailedInstances   []model.InstanceID
	FailedComponents  []string

	// Cost impact
	AffectedCost determinism.Money

	// Full lineage for failures (for explainability)
	FailureLineage []*InstanceLineage

	// Recommendations
	Recommendations []string
}

// UsageConfidencePolicy fails if usage confidence is too low
type UsageConfidencePolicy struct {
	name          string
	minConfidence float64
}

// NewUsageConfidencePolicy creates a usage confidence policy
func NewUsageConfidencePolicy(name string, minConfidence float64) *UsageConfidencePolicy {
	return &UsageConfidencePolicy{name: name, minConfidence: minConfidence}
}

// Name returns the policy name
func (p *UsageConfidencePolicy) Name() string { return p.name }

// EvaluateWithLineage evaluates with full lineage access
func (p *UsageConfidencePolicy) EvaluateWithLineage(ctx *FullLineageContext) (*LineageAwarePolicyResult, error) {
	result := &LineageAwarePolicyResult{
		Passed: true,
	}

	var lowConfidenceInstances []*InstanceLineage
	var lowConfidenceComponents []string

	for _, inst := range ctx.Instances {
		result.AnalyzedInstances++

		for _, comp := range inst.Components {
			result.AnalyzedComponents++

			// Check USAGE confidence specifically
			if comp.Usage.Confidence < p.minConfidence {
				result.Passed = false

				if !containsID(result.FailedInstances, inst.InstanceID) {
					result.FailedInstances = append(result.FailedInstances, inst.InstanceID)
					lowConfidenceInstances = append(lowConfidenceInstances, inst)
				}

				lowConfidenceComponents = append(lowConfidenceComponents,
					string(inst.Address)+"/"+comp.Name)

				result.AffectedCost = result.AffectedCost.Add(comp.MonthlyCost)
			}
		}
	}

	if !result.Passed {
		result.Message = fmt.Sprintf(
			"%d components have usage confidence below %.0f%%",
			len(lowConfidenceComponents), p.minConfidence*100)

		result.FailedComponents = lowConfidenceComponents
		result.FailureLineage = lowConfidenceInstances

		result.Recommendations = []string{
			"Provide usage overrides for low-confidence components",
			"Use a usage profile to set expected values",
			"Review assumptions in the usage estimation",
		}
	} else {
		result.Message = fmt.Sprintf(
			"All %d components meet %.0f%% usage confidence",
			result.AnalyzedComponents, p.minConfidence*100)
	}

	return result, nil
}

// FormulaAuditPolicy checks that all formulas are documented
type FormulaAuditPolicy struct {
	name string
}

// NewFormulaAuditPolicy creates a formula audit policy
func NewFormulaAuditPolicy(name string) *FormulaAuditPolicy {
	return &FormulaAuditPolicy{name: name}
}

// Name returns the policy name
func (p *FormulaAuditPolicy) Name() string { return p.name }

// EvaluateWithLineage evaluates with full lineage access
func (p *FormulaAuditPolicy) EvaluateWithLineage(ctx *FullLineageContext) (*LineageAwarePolicyResult, error) {
	result := &LineageAwarePolicyResult{
		Passed: true,
	}

	var undocumentedFormulas []string

	for _, inst := range ctx.Instances {
		result.AnalyzedInstances++

		for _, comp := range inst.Components {
			result.AnalyzedComponents++

			// Check formula documentation
			if comp.Formula.Name == "" || comp.Formula.Expression == "" {
				result.Passed = false

				if !containsID(result.FailedInstances, inst.InstanceID) {
					result.FailedInstances = append(result.FailedInstances, inst.InstanceID)
				}

				undocumentedFormulas = append(undocumentedFormulas,
					string(inst.Address)+"/"+comp.Name)
			}
		}
	}

	if !result.Passed {
		result.Message = fmt.Sprintf(
			"%d formulas are undocumented",
			len(undocumentedFormulas))

		result.FailedComponents = undocumentedFormulas

		result.Recommendations = []string{
			"Ensure all pricing formulas are documented",
			"Review cost calculation logic",
		}
	} else {
		result.Message = fmt.Sprintf(
			"All %d formulas are documented",
			result.AnalyzedComponents)
	}

	return result, nil
}

func containsID(slice []model.InstanceID, id model.InstanceID) bool {
	for _, item := range slice {
		if item == id {
			return true
		}
	}
	return false
}

################################################################################
# FILE: :\good projects\cost estimation\core\pricing\enforcer.go
# TYPE: go
# SIZE: 7864 bytes
################################################################################
// Package pricing - Mandatory snapshot enforcement
// No cost can be computed without a valid, verified snapshot.
package pricing

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"terraform-cost/core/determinism"
)

// ErrNoSnapshot is returned when no pricing snapshot is available
var ErrNoSnapshot = errors.New("pricing snapshot required but not provided")

// ErrSnapshotInvalid is returned when snapshot fails verification
var ErrSnapshotInvalid = errors.New("pricing snapshot failed integrity verification")

// ErrSnapshotExpired is returned when snapshot is too old
var ErrSnapshotExpired = errors.New("pricing snapshot has expired")

// ErrRateNotFound is returned when a rate is not in the snapshot
var ErrRateNotFound = errors.New("rate not found in pricing snapshot")

// EnforcedResolver wraps a pricing resolver with mandatory snapshot enforcement.
// It is IMPOSSIBLE to get pricing without a valid snapshot.
type EnforcedResolver struct {
	store         SnapshotStore
	maxAge        time.Duration
	strictMode    bool
	mu            sync.RWMutex
	activeSnapshot *PricingSnapshot
}

// SnapshotStore provides snapshot storage
type SnapshotStore interface {
	// Get retrieves a specific snapshot by ID
	Get(ctx context.Context, id SnapshotID) (*PricingSnapshot, error)

	// GetLatest retrieves the latest snapshot for a provider/region
	// Returns error if no snapshot exists
	GetLatest(ctx context.Context, provider, region string) (*PricingSnapshot, error)

	// Store saves a snapshot
	Store(ctx context.Context, snapshot *PricingSnapshot) error
}

// EnforcedResolverConfig configures the enforced resolver
type EnforcedResolverConfig struct {
	// MaxAge is the maximum age of a snapshot before it's considered expired
	MaxAge time.Duration

	// StrictMode fails on any missing rate (vs degraded estimation)
	StrictMode bool
}

// NewEnforcedResolver creates a resolver that REQUIRES snapshots
func NewEnforcedResolver(store SnapshotStore, config EnforcedResolverConfig) *EnforcedResolver {
	maxAge := config.MaxAge
	if maxAge == 0 {
		maxAge = 24 * time.Hour // Default: 24 hours
	}
	return &EnforcedResolver{
		store:      store,
		maxAge:     maxAge,
		strictMode: config.StrictMode,
	}
}

// SnapshotRequest specifies which snapshot to use
type SnapshotRequest struct {
	// SnapshotID - if provided, use this specific snapshot
	SnapshotID SnapshotID

	// Otherwise, find latest for provider/region
	Provider string
	Region   string

	// AllowExpired allows using expired snapshots (with warning)
	AllowExpired bool
}

// ResolveResult contains the resolution result
type ResolveResult struct {
	// Snapshot used (ALWAYS set on success)
	Snapshot *PricingSnapshot

	// Rate found (nil if not found)
	Rate *RateEntry

	// Status
	Found   bool
	Reason  string
	Warning string
}

// GetSnapshot retrieves a snapshot - NEVER returns nil snapshot on success
func (r *EnforcedResolver) GetSnapshot(ctx context.Context, req SnapshotRequest) (*PricingSnapshot, error) {
	var snapshot *PricingSnapshot
	var err error

	// Try specific ID first
	if req.SnapshotID != "" {
		snapshot, err = r.store.Get(ctx, req.SnapshotID)
		if err != nil {
			return nil, fmt.Errorf("failed to get snapshot %s: %w", req.SnapshotID, err)
		}
	} else if req.Provider != "" && req.Region != "" {
		snapshot, err = r.store.GetLatest(ctx, req.Provider, req.Region)
		if err != nil {
			return nil, fmt.Errorf("no snapshot for %s/%s: %w", req.Provider, req.Region, ErrNoSnapshot)
		}
	} else {
		return nil, ErrNoSnapshot
	}

	if snapshot == nil {
		return nil, ErrNoSnapshot
	}

	// Verify integrity
	if !snapshot.Verify() {
		return nil, ErrSnapshotInvalid
	}

	// Check expiry
	if time.Since(snapshot.CreatedAt) > r.maxAge {
		if !req.AllowExpired {
			return nil, fmt.Errorf("%w: snapshot is %v old (max: %v)",
				ErrSnapshotExpired, time.Since(snapshot.CreatedAt), r.maxAge)
		}
	}

	return snapshot, nil
}

// LookupRate finds a rate in a snapshot - snapshot is REQUIRED
func (r *EnforcedResolver) LookupRate(
	snapshot *PricingSnapshot,
	resourceType, component string,
	attrs map[string]string,
) (*ResolveResult, error) {
	if snapshot == nil {
		return nil, ErrNoSnapshot
	}

	result := &ResolveResult{
		Snapshot: snapshot,
	}

	rate, found := snapshot.LookupRate(resourceType, component, attrs)
	if !found {
		result.Found = false
		result.Reason = fmt.Sprintf("no rate for %s/%s in snapshot %s", resourceType, component, snapshot.ID)

		if r.strictMode {
			return result, ErrRateNotFound
		}
		return result, nil
	}

	result.Found = true
	result.Rate = rate
	return result, nil
}

// MustHaveSnapshot ensures a snapshot exists or panics - for critical paths
func MustHaveSnapshot(snapshot *PricingSnapshot) {
	if snapshot == nil {
		panic("BUG: pricing snapshot is nil - this should never happen")
	}
}

// CostCalculation tracks a cost calculation with mandatory snapshot reference
type CostCalculation struct {
	// MANDATORY: Snapshot reference
	SnapshotID   SnapshotID
	SnapshotHash determinism.ContentHash

	// The calculation
	InstanceID  string
	Component   string
	MonthlyCost determinism.Money
	HourlyCost  determinism.Money

	// Rate used
	RateID  RateID
	RateKey RateKey

	// Formula applied
	Formula FormulaApplication

	// Confidence (reduced if rate was missing or usage unknown)
	Confidence float64

	// Degradation info
	IsDegraded    bool
	DegradedParts []DegradedPart
}

// DegradedPart describes why a calculation was degraded
type DegradedPart struct {
	Component string
	Reason    DegradationReason
	Message   string
}

// DegradationReason explains why estimation is degraded
type DegradationReason int

const (
	ReasonRateMissing DegradationReason = iota
	ReasonUsageUnknown
	ReasonResourceUnknown
	ReasonSnapshotStale
)

// String returns the reason name
func (r DegradationReason) String() string {
	switch r {
	case ReasonRateMissing:
		return "rate_missing"
	case ReasonUsageUnknown:
		return "usage_unknown"
	case ReasonResourceUnknown:
		return "resource_unknown"
	case ReasonSnapshotStale:
		return "snapshot_stale"
	default:
		return "unknown"
	}
}

// InMemorySnapshotStore is a simple in-memory store for testing
type InMemorySnapshotStore struct {
	mu        sync.RWMutex
	snapshots map[SnapshotID]*PricingSnapshot
	latest    map[string]*PricingSnapshot // key: provider:region
}

// NewInMemorySnapshotStore creates an in-memory store
func NewInMemorySnapshotStore() *InMemorySnapshotStore {
	return &InMemorySnapshotStore{
		snapshots: make(map[SnapshotID]*PricingSnapshot),
		latest:    make(map[string]*PricingSnapshot),
	}
}

// Get retrieves a snapshot by ID
func (s *InMemorySnapshotStore) Get(ctx context.Context, id SnapshotID) (*PricingSnapshot, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	snap, ok := s.snapshots[id]
	if !ok {
		return nil, ErrNoSnapshot
	}
	return snap, nil
}

// GetLatest retrieves the latest snapshot for provider/region
func (s *InMemorySnapshotStore) GetLatest(ctx context.Context, provider, region string) (*PricingSnapshot, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	key := provider + ":" + region
	snap, ok := s.latest[key]
	if !ok {
		return nil, ErrNoSnapshot
	}
	return snap, nil
}

// Store saves a snapshot
func (s *InMemorySnapshotStore) Store(ctx context.Context, snapshot *PricingSnapshot) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.snapshots[snapshot.ID] = snapshot
	key := snapshot.Provider + ":" + snapshot.Region
	// Update latest if this is newer
	if existing, ok := s.latest[key]; !ok || snapshot.CreatedAt.After(existing.CreatedAt) {
		s.latest[key] = snapshot
	}
	return nil
}

################################################################################
# FILE: :\good projects\cost estimation\core\pricing\resolver.go
# TYPE: go
# SIZE: 3323 bytes
################################################################################
// Package pricing provides the pricing resolution interface.
// This package resolves prices from cache, database, and cloud APIs.
package pricing

import (
	"context"

	"terraform-cost/core/types"
)

// Resolver resolves pricing for rate keys
type Resolver interface {
	// Resolve fetches rates for the given keys
	Resolve(ctx context.Context, keys []types.RateKey, snapshot *types.PricingSnapshot) (*types.PricingResult, error)

	// GetSnapshot returns the current pricing snapshot for a provider/region
	GetSnapshot(ctx context.Context, provider types.Provider, region string) (*types.PricingSnapshot, error)

	// RefreshSnapshot updates pricing data from cloud APIs
	RefreshSnapshot(ctx context.Context, provider types.Provider, region string) (*types.PricingSnapshot, error)
}

// Cache provides in-memory pricing caching
type Cache interface {
	// Get retrieves a rate from cache
	Get(key types.RateKey) (*types.Rate, bool)

	// Set stores a rate in cache
	Set(key types.RateKey, rate *types.Rate)

	// GetMulti retrieves multiple rates
	GetMulti(keys []types.RateKey) map[string]*types.Rate

	// SetMulti stores multiple rates
	SetMulti(rates map[string]*types.Rate)

	// Invalidate removes a rate from cache
	Invalidate(key types.RateKey)

	// Clear removes all cached rates
	Clear()

	// Size returns the number of cached entries
	Size() int
}

// Store provides persistent pricing storage
type Store interface {
	// GetRates retrieves rates from storage
	GetRates(ctx context.Context, keys []types.RateKey, snapshotID string) ([]types.Rate, error)

	// SaveRates stores rates in storage
	SaveRates(ctx context.Context, rates []types.Rate) error

	// GetSnapshot retrieves a pricing snapshot
	GetSnapshot(ctx context.Context, id string) (*types.PricingSnapshot, error)

	// SaveSnapshot stores a pricing snapshot
	SaveSnapshot(ctx context.Context, snapshot *types.PricingSnapshot) error

	// GetLatestSnapshot returns the most recent snapshot for a provider/region
	GetLatestSnapshot(ctx context.Context, provider types.Provider, region string) (*types.PricingSnapshot, error)

	// ListSnapshots returns all snapshots for a provider/region
	ListSnapshots(ctx context.Context, provider types.Provider, region string) ([]types.PricingSnapshot, error)
}

// Source fetches pricing from external cloud APIs
type Source interface {
	// Provider returns the cloud provider
	Provider() types.Provider

	// FetchRates retrieves rates for the given keys
	FetchRates(ctx context.Context, keys []types.RateKey) ([]types.Rate, error)

	// FetchAll retrieves all rates for a region
	FetchAll(ctx context.Context, region string) ([]types.Rate, error)

	// SupportedRegions returns the list of supported regions
	SupportedRegions() []string
}

// SourceRegistry manages pricing source registration
type SourceRegistry interface {
	// Register adds a source to the registry
	Register(source Source) error

	// GetSource returns a source for a provider
	GetSource(provider types.Provider) (Source, bool)

	// GetAll returns all registered sources
	GetAll() []Source
}

// CompositeResolver implements Resolver using cache, store, and sources
type CompositeResolver struct {
	Cache   Cache
	Store   Store
	Sources SourceRegistry
}

################################################################################
# FILE: :\good projects\cost estimation\core\pricing\snapshot.go
# TYPE: go
# SIZE: 11387 bytes
################################################################################
// Package pricing provides immutable pricing snapshots with content hashing.
package pricing

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"sort"
	"time"

	"github.com/shopspring/decimal"

	"terraform-cost/core/determinism"
)

// SnapshotID uniquely identifies a pricing snapshot
type SnapshotID string

// RateID uniquely identifies a rate within a snapshot
type RateID string

// PricingSnapshot is IMMUTABLE after creation.
// It represents a point-in-time capture of pricing data.
type PricingSnapshot struct {
	// Identity
	ID          SnapshotID              // UUID or hash-based
	ContentHash determinism.ContentHash // SHA-256 of all rates
	CreatedAt   time.Time               // When snapshot was created
	EffectiveAt time.Time               // When prices became effective
	ExpiresAt   *time.Time              // Optional expiry (for cached data)

	// Source information
	Source      PricingSource
	Region      string
	Provider    string // aws, azure, gcp

	// The actual rates (sorted for determinism)
	rates       []RateEntry
	rateIndex   map[RateKey]*RateEntry

	// Coverage information
	Coverage    SnapshotCoverage

	// Immutability flag
	sealed      bool
}

// PricingSource indicates where pricing data came from
type PricingSource int

const (
	SourceCloudAPI    PricingSource = iota // From cloud provider API
	SourceLocalCache                       // From local cache
	SourceDatabase                         // From pricing database
	SourceManual                           // Manually specified
	SourceDefault                          // Hardcoded defaults
)

// String returns the source name
func (s PricingSource) String() string {
	switch s {
	case SourceCloudAPI:
		return "cloud_api"
	case SourceLocalCache:
		return "local_cache"
	case SourceDatabase:
		return "database"
	case SourceManual:
		return "manual"
	case SourceDefault:
		return "default"
	default:
		return "unknown"
	}
}

// RateKey uniquely identifies a rate
type RateKey struct {
	ResourceType string // aws_instance
	Component    string // Compute, Storage
	UsageType    string // BoxUsage, DataTransfer
	Attributes   string // Serialized attributes (instance_type=t3.micro)
}

// String returns a deterministic string representation
func (k RateKey) String() string {
	return k.ResourceType + "/" + k.Component + "/" + k.UsageType + "/" + k.Attributes
}

// RateEntry is a single pricing rate
type RateEntry struct {
	ID          RateID
	Key         RateKey
	Price       decimal.Decimal // Price per unit
	Unit        string          // hour, GB, request
	Currency    string          // USD
	Description string
	Tiers       []RateTier // For tiered pricing
	Conditions  []RateCondition
}

// RateTier represents a tier in tiered pricing
type RateTier struct {
	StartUsage decimal.Decimal // Start of tier
	EndUsage   *decimal.Decimal // End of tier (nil = unlimited)
	Price      decimal.Decimal  // Price in this tier
}

// RateCondition is a condition that must match for the rate
type RateCondition struct {
	Attribute string
	Operator  string // eq, neq, contains, prefix
	Value     string
}

// Bytes returns deterministic bytes for hashing
func (r *RateEntry) Bytes() []byte {
	// Use JSON for deterministic serialization
	data, _ := json.Marshal(map[string]interface{}{
		"key":      r.Key.String(),
		"price":    r.Price.String(),
		"unit":     r.Unit,
		"currency": r.Currency,
	})
	return data
}

// SnapshotCoverage tracks what's included and what's missing
type SnapshotCoverage struct {
	IncludedServices []string
	ResourceTypes    int
	TotalRates       int
	MissingRates     []MissingRate
	CoveragePercent  float64 // Estimated coverage
}

// MissingRate documents an EXPLICIT missing rate
type MissingRate struct {
	ResourceType string
	Component    string
	Reason       MissingReason
	Message      string // Human-readable explanation
}

// MissingReason explains why a rate is missing
type MissingReason int

const (
	ReasonNotInAPI           MissingReason = iota // API doesn't provide this
	ReasonRegionNotSupported                       // Region not available
	ReasonServiceNotImpl                           // We haven't implemented this
	ReasonRateLimitHit                             // API rate limit
	ReasonParseError                               // Couldn't parse response
	ReasonNotApplicable                            // Resource is free
)

// String returns the reason name
func (r MissingReason) String() string {
	switch r {
	case ReasonNotInAPI:
		return "not_in_api"
	case ReasonRegionNotSupported:
		return "region_not_supported"
	case ReasonServiceNotImpl:
		return "not_implemented"
	case ReasonRateLimitHit:
		return "rate_limit"
	case ReasonParseError:
		return "parse_error"
	case ReasonNotApplicable:
		return "not_applicable"
	default:
		return "unknown"
	}
}

// SnapshotBuilder builds a pricing snapshot
type SnapshotBuilder struct {
	provider    string
	region      string
	source      PricingSource
	effectiveAt time.Time
	rates       []RateEntry
	missing     []MissingRate
	services    map[string]bool
}

// NewSnapshotBuilder creates a new builder
func NewSnapshotBuilder(provider, region string) *SnapshotBuilder {
	return &SnapshotBuilder{
		provider:    provider,
		region:      region,
		source:      SourceDefault,
		effectiveAt: time.Now().UTC(),
		services:    make(map[string]bool),
	}
}

// WithSource sets the pricing source
func (b *SnapshotBuilder) WithSource(source PricingSource) *SnapshotBuilder {
	b.source = source
	return b
}

// WithEffectiveAt sets the effective date
func (b *SnapshotBuilder) WithEffectiveAt(t time.Time) *SnapshotBuilder {
	b.effectiveAt = t
	return b
}

// AddRate adds a rate to the snapshot
func (b *SnapshotBuilder) AddRate(key RateKey, price decimal.Decimal, unit, currency string) *SnapshotBuilder {
	b.rates = append(b.rates, RateEntry{
		Key:      key,
		Price:    price,
		Unit:     unit,
		Currency: currency,
	})
	b.services[key.ResourceType] = true
	return b
}

// AddMissing documents a missing rate
func (b *SnapshotBuilder) AddMissing(resourceType, component string, reason MissingReason, message string) *SnapshotBuilder {
	b.missing = append(b.missing, MissingRate{
		ResourceType: resourceType,
		Component:    component,
		Reason:       reason,
		Message:      message,
	})
	return b
}

// Build creates an immutable snapshot
func (b *SnapshotBuilder) Build() *PricingSnapshot {
	// Sort rates for deterministic ordering
	sort.Slice(b.rates, func(i, j int) bool {
		return b.rates[i].Key.String() < b.rates[j].Key.String()
	})

	// Generate IDs for each rate
	idGen := determinism.NewIDGenerator("rate")
	for i := range b.rates {
		b.rates[i].ID = RateID(idGen.Generate(b.rates[i].Key.String()))
	}

	// Build index
	index := make(map[RateKey]*RateEntry)
	for i := range b.rates {
		index[b.rates[i].Key] = &b.rates[i]
	}

	// Collect services
	services := make([]string, 0, len(b.services))
	for svc := range b.services {
		services = append(services, svc)
	}
	sort.Strings(services)

	// Create snapshot
	snap := &PricingSnapshot{
		CreatedAt:   time.Now().UTC(),
		EffectiveAt: b.effectiveAt,
		Source:      b.source,
		Region:      b.region,
		Provider:    b.provider,
		rates:       b.rates,
		rateIndex:   index,
		Coverage: SnapshotCoverage{
			IncludedServices: services,
			ResourceTypes:    len(b.services),
			TotalRates:       len(b.rates),
			MissingRates:     b.missing,
		},
	}

	// Compute content hash
	snap.ContentHash = snap.computeHash()

	// Generate ID from hash
	snap.ID = SnapshotID(hex.EncodeToString(snap.ContentHash[:8]))

	// Seal the snapshot
	snap.sealed = true

	return snap
}

// computeHash creates a content hash of all rates
func (s *PricingSnapshot) computeHash() determinism.ContentHash {
	h := sha256.New()
	h.Write([]byte(s.Provider))
	h.Write([]byte(s.Region))
	h.Write([]byte(s.EffectiveAt.Format(time.RFC3339)))
	for _, rate := range s.rates {
		h.Write(rate.Bytes())
	}
	var hash determinism.ContentHash
	copy(hash[:], h.Sum(nil))
	return hash
}

// GetRate looks up a rate by key
func (s *PricingSnapshot) GetRate(key RateKey) (*RateEntry, bool) {
	rate, ok := s.rateIndex[key]
	return rate, ok
}

// LookupRate finds a rate by resource type and component
func (s *PricingSnapshot) LookupRate(resourceType, component string, attrs map[string]string) (*RateEntry, bool) {
	// Serialize attributes deterministically
	attrKeys := determinism.SortedKeys(attrs)
	var attrStr string
	for _, k := range attrKeys {
		if attrStr != "" {
			attrStr += ","
		}
		attrStr += k + "=" + attrs[k]
	}

	key := RateKey{
		ResourceType: resourceType,
		Component:    component,
		Attributes:   attrStr,
	}
	return s.GetRate(key)
}

// Rates returns all rates in sorted order
func (s *PricingSnapshot) Rates() []RateEntry {
	result := make([]RateEntry, len(s.rates))
	copy(result, s.rates)
	return result
}

// Verify checks content hash integrity
func (s *PricingSnapshot) Verify() bool {
	computed := s.computeHash()
	return computed == s.ContentHash
}

// CostEstimate MUST reference a snapshot
type CostEstimate struct {
	// Snapshot reference (mandatory)
	SnapshotID   SnapshotID
	SnapshotHash determinism.ContentHash // For verification

	// The estimate
	InstanceID   string
	Component    string
	MonthlyCost  determinism.Money
	HourlyCost   determinism.Money

	// Lineage (see Gap 5)
	Lineage      *CostLineage
}

// CostLineage tracks the full derivation chain (Gap 5)
type CostLineage struct {
	// What was priced
	InstanceID  string
	Component   string

	// Pricing source
	SnapshotID  SnapshotID
	RateID      RateID
	RateKey     RateKey

	// Formula applied
	Formula     FormulaApplication

	// Usage input
	Usage       UsageLineage

	// Derived costs (for aggregated)
	DerivedFrom []*CostLineage

	// Confidence
	Confidence  float64 // 0.0 - 1.0

	// Timestamp
	Timestamp   time.Time
}

// FormulaApplication tracks how cost was calculated
type FormulaApplication struct {
	Name       string            // "hourly_compute"
	Expression string            // "rate * hours * quantity"
	Inputs     map[string]string // rate=0.10, hours=730, quantity=3
	Output     string            // 219.00
}

// UsageLineage tracks usage source
type UsageLineage struct {
	Source      UsageSource
	Profile     string   // "production", "dev"
	Confidence  float64  // 0.0 - 1.0
	Assumptions []string // ["assumed 75% utilization"]
}

// UsageSource indicates where usage data came from
type UsageSource int

const (
	UsageDefault   UsageSource = iota // Hardcoded defaults
	UsageOverride                     // User provided
	UsageEstimated                    // ML/heuristic estimated
	UsageActual                       // Historical actual
)

// String returns the source name
func (s UsageSource) String() string {
	switch s {
	case UsageDefault:
		return "default"
	case UsageOverride:
		return "override"
	case UsageEstimated:
		return "estimated"
	case UsageActual:
		return "actual"
	default:
		return "unknown"
	}
}

################################################################################
# FILE: :\good projects\cost estimation\core\scanner\registry.go
# TYPE: go
# SIZE: 2844 bytes
################################################################################
// Package scanner - Registry for scanner implementations
package scanner

import (
	"context"
	"fmt"
	"sync"

	"terraform-cost/core/types"
)

// Registry manages scanner registration and lookup
type Registry interface {
	// Register adds a scanner to the registry
	Register(scanner Scanner) error

	// GetScanner returns a scanner by name
	GetScanner(name string) (Scanner, bool)

	// GetAll returns all registered scanners
	GetAll() []Scanner

	// DetectAndScan finds the appropriate scanner and scans the input
	DetectAndScan(ctx context.Context, input *types.ProjectInput) (*ScanResult, error)
}

// DefaultRegistry is the default scanner registry implementation
type DefaultRegistry struct {
	mu       sync.RWMutex
	scanners map[string]Scanner
	order    []string // maintains registration order for priority
}

// NewRegistry creates a new scanner registry
func NewRegistry() *DefaultRegistry {
	return &DefaultRegistry{
		scanners: make(map[string]Scanner),
		order:    make([]string, 0),
	}
}

// Register adds a scanner to the registry
func (r *DefaultRegistry) Register(scanner Scanner) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	name := scanner.Name()
	if _, exists := r.scanners[name]; exists {
		return fmt.Errorf("scanner already registered: %s", name)
	}

	r.scanners[name] = scanner
	r.order = append(r.order, name)
	return nil
}

// GetScanner returns a scanner by name
func (r *DefaultRegistry) GetScanner(name string) (Scanner, bool) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	scanner, ok := r.scanners[name]
	return scanner, ok
}

// GetAll returns all registered scanners in registration order
func (r *DefaultRegistry) GetAll() []Scanner {
	r.mu.RLock()
	defer r.mu.RUnlock()

	scanners := make([]Scanner, 0, len(r.order))
	for _, name := range r.order {
		if scanner, ok := r.scanners[name]; ok {
			scanners = append(scanners, scanner)
		}
	}
	return scanners
}

// DetectAndScan finds the first scanner that can handle the input and runs it
func (r *DefaultRegistry) DetectAndScan(ctx context.Context, input *types.ProjectInput) (*ScanResult, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	for _, name := range r.order {
		scanner := r.scanners[name]

		canScan, err := scanner.CanScan(ctx, input)
		if err != nil {
			continue // Skip scanners that error on detection
		}

		if canScan {
			return scanner.Scan(ctx, input)
		}
	}

	return nil, fmt.Errorf("no scanner found for input: %s", input.Path)
}

// Global default registry
var defaultRegistry = NewRegistry()

// Register adds a scanner to the default registry
func Register(scanner Scanner) error {
	return defaultRegistry.Register(scanner)
}

// GetDefault returns the default registry
func GetDefault() *DefaultRegistry {
	return defaultRegistry
}

################################################################################
# FILE: :\good projects\cost estimation\core\scanner\scanner.go
# TYPE: go
# SIZE: 2917 bytes
################################################################################
// Package scanner defines the interface for infrastructure scanners.
// Scanners parse IaC configurations into RawAsset descriptors.
// NO pricing or cost logic belongs here.
package scanner

import (
	"context"

	"terraform-cost/core/types"
)

// Scanner parses infrastructure code into raw assets
type Scanner interface {
	// Name returns the scanner identifier
	Name() string

	// CanScan determines if this scanner can handle the input
	CanScan(ctx context.Context, input *types.ProjectInput) (bool, error)

	// Scan parses the input and returns raw assets
	Scan(ctx context.Context, input *types.ProjectInput) (*ScanResult, error)
}

// ScanResult contains the output of a scan operation
type ScanResult struct {
	// Assets are the parsed infrastructure resources
	Assets []types.RawAsset `json:"assets"`

	// Modules are referenced modules
	Modules []ModuleReference `json:"modules,omitempty"`

	// Variables are the resolved variables
	Variables map[string]interface{} `json:"variables,omitempty"`

	// Warnings are non-fatal issues encountered
	Warnings []ScanWarning `json:"warnings,omitempty"`

	// Errors are parsing errors
	Errors []ScanError `json:"errors,omitempty"`
}

// ModuleReference tracks module dependencies
type ModuleReference struct {
	// Source is the module source (registry, git, local)
	Source string `json:"source"`

	// Version is the module version constraint
	Version string `json:"version,omitempty"`

	// Path is the local path to the module
	Path string `json:"path"`

	// Key is the module key in the configuration
	Key string `json:"key"`
}

// ScanWarning represents a non-fatal scanning issue
type ScanWarning struct {
	// File is the file where the warning occurred
	File string `json:"file"`

	// Line is the line number
	Line int `json:"line,omitempty"`

	// Message describes the warning
	Message string `json:"message"`

	// Code is a warning code for programmatic handling
	Code string `json:"code,omitempty"`
}

// ScanError represents a scanning error
type ScanError struct {
	// File is the file where the error occurred
	File string `json:"file"`

	// Line is the line number
	Line int `json:"line,omitempty"`

	// Message describes the error
	Message string `json:"message"`

	// Code is an error code for programmatic handling
	Code string `json:"code,omitempty"`

	// Err is the underlying error
	Err error `json:"-"`
}

// Error implements the error interface
func (e ScanError) Error() string {
	return e.Message
}

// Unwrap returns the underlying error
func (e ScanError) Unwrap() error {
	return e.Err
}

// HasErrors returns true if there are any errors
func (r *ScanResult) HasErrors() bool {
	return len(r.Errors) > 0
}

// HasWarnings returns true if there are any warnings
func (r *ScanResult) HasWarnings() bool {
	return len(r.Warnings) > 0
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\dependencies.go
# TYPE: go
# SIZE: 8737 bytes
################################################################################
// Package terraform - Dependency graph and depends_on handling
package terraform

import (
	"sort"
	"strings"

	"terraform-cost/core/determinism"
	"terraform-cost/core/model"
)

// DependencyResolver builds the dependency graph between instances
type DependencyResolver struct {
	// Instance index for lookups
	instanceByAddr  map[model.InstanceAddress]*model.AssetInstance
	instanceByDefn  map[model.DefinitionID][]*model.AssetInstance
}

// NewDependencyResolver creates a new resolver
func NewDependencyResolver() *DependencyResolver {
	return &DependencyResolver{
		instanceByAddr: make(map[model.InstanceAddress]*model.AssetInstance),
		instanceByDefn: make(map[model.DefinitionID][]*model.AssetInstance),
	}
}

// ResolveDependencies builds all dependency edges
func (r *DependencyResolver) ResolveDependencies(
	instances []*model.AssetInstance,
	definitions map[model.DefinitionID]*model.AssetDefinition,
) []model.InstanceEdge {
	// Build indexes
	r.buildIndexes(instances)

	var edges []model.InstanceEdge

	for _, inst := range instances {
		def := definitions[inst.DefinitionID]
		if def == nil {
			continue
		}

		// 1. Explicit depends_on
		explicitEdges := r.resolveExplicitDeps(inst, def.DependsOn)
		edges = append(edges, explicitEdges...)

		// 2. Implicit reference-based dependencies
		implicitEdges := r.resolveImplicitDeps(inst, def)
		edges = append(edges, implicitEdges...)

		// 3. Provider dependencies
		providerEdges := r.resolveProviderDeps(inst)
		edges = append(edges, providerEdges...)
	}

	// Sort edges for determinism
	sort.Slice(edges, func(i, j int) bool {
		if edges[i].From != edges[j].From {
			return edges[i].From < edges[j].From
		}
		return edges[i].To < edges[j].To
	})

	// Deduplicate
	return r.deduplicate(edges)
}

func (r *DependencyResolver) buildIndexes(instances []*model.AssetInstance) {
	for _, inst := range instances {
		r.instanceByAddr[inst.Address] = inst
		r.instanceByDefn[inst.DefinitionID] = append(r.instanceByDefn[inst.DefinitionID], inst)
	}
}

// resolveExplicitDeps handles depends_on meta-argument
func (r *DependencyResolver) resolveExplicitDeps(
	inst *model.AssetInstance,
	dependsOn []string,
) []model.InstanceEdge {
	var edges []model.InstanceEdge

	for _, dep := range dependsOn {
		// depends_on references definitions, not instances
		// We need to create edges to ALL instances of that definition
		targetInstances := r.findInstancesByAddress(dep)
		for _, target := range targetInstances {
			if target.ID != inst.ID { // No self-loops
				edges = append(edges, model.InstanceEdge{
					From: inst.ID,
					To:   target.ID,
					Type: model.EdgeExplicit,
				})
			}
		}
	}

	return edges
}

// resolveImplicitDeps finds dependencies from attribute references
func (r *DependencyResolver) resolveImplicitDeps(
	inst *model.AssetInstance,
	def *model.AssetDefinition,
) []model.InstanceEdge {
	var edges []model.InstanceEdge

	// Collect all references from attributes
	for _, expr := range def.Attributes {
		for _, ref := range expr.References {
			// Parse reference to find target
			targetAddr := r.parseRefToAddress(ref)
			if targetAddr == "" {
				continue
			}

			targetInstances := r.findInstancesByAddress(targetAddr)
			for _, target := range targetInstances {
				if target.ID != inst.ID {
					edges = append(edges, model.InstanceEdge{
						From: inst.ID,
						To:   target.ID,
						Type: model.EdgeImplicit,
					})
				}
			}
		}
	}

	return edges
}

// resolveProviderDeps creates edges for provider requirements
func (r *DependencyResolver) resolveProviderDeps(inst *model.AssetInstance) []model.InstanceEdge {
	// Provider dependencies are generally implicit in Terraform
	// but we track them for completeness
	return nil
}

// findInstancesByAddress finds instances matching an address pattern
func (r *DependencyResolver) findInstancesByAddress(addr string) []*model.AssetInstance {
	var result []*model.AssetInstance

	// First try exact match
	if inst, ok := r.instanceByAddr[model.InstanceAddress(addr)]; ok {
		return []*model.AssetInstance{inst}
	}

	// Try as definition address (returns all instances)
	for instAddr, inst := range r.instanceByAddr {
		// Check if instance address starts with the definition address
		if strings.HasPrefix(string(instAddr), addr+"[") || string(instAddr) == addr {
			result = append(result, inst)
		}
	}

	// Sort for determinism
	sort.Slice(result, func(i, j int) bool {
		return result[i].Address < result[j].Address
	})

	return result
}

// parseRefToAddress extracts the resource address from a reference
// e.g., "aws_instance.web.id" -> "aws_instance.web"
// e.g., "module.app.aws_s3_bucket.data" -> "module.app.aws_s3_bucket.data"
func (r *DependencyResolver) parseRefToAddress(ref string) string {
	parts := strings.Split(ref, ".")

	// Skip variable/local references
	if len(parts) < 2 {
		return ""
	}

	switch parts[0] {
	case "var", "local", "path", "terraform":
		return "" // Not a resource reference
	case "data":
		if len(parts) >= 3 {
			return strings.Join(parts[:3], ".")
		}
	case "module":
		// Find where the resource part starts
		for i := 0; i < len(parts)-1; i += 2 {
			if parts[i] != "module" {
				// parts[i] is the resource type
				return strings.Join(parts[:i+2], ".")
			}
		}
	default:
		// Regular resource reference
		if len(parts) >= 2 {
			return parts[0] + "." + parts[1]
		}
	}

	return ""
}

func (r *DependencyResolver) deduplicate(edges []model.InstanceEdge) []model.InstanceEdge {
	seen := make(map[string]bool)
	result := make([]model.InstanceEdge, 0, len(edges))

	for _, e := range edges {
		key := string(e.From) + "->" + string(e.To)
		if !seen[key] {
			seen[key] = true
			result = append(result, e)
		}
	}

	return result
}

// TopologicalSort sorts instances in dependency order
func TopologicalSort(instances []*model.AssetInstance, edges []model.InstanceEdge) []model.InstanceID {
	// Build adjacency list
	adj := make(map[model.InstanceID][]model.InstanceID)
	inDegree := make(map[model.InstanceID]int)

	for _, inst := range instances {
		adj[inst.ID] = []model.InstanceID{}
		inDegree[inst.ID] = 0
	}

	for _, edge := range edges {
		adj[edge.From] = append(adj[edge.From], edge.To)
		inDegree[edge.To]++
	}

	// Kahn's algorithm with stable ordering
	var queue []model.InstanceID
	for id, degree := range inDegree {
		if degree == 0 {
			queue = append(queue, id)
		}
	}
	determinism.SortSlice(queue, func(a, b model.InstanceID) bool {
		return a < b
	})

	var result []model.InstanceID
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		result = append(result, node)

		for _, neighbor := range adj[node] {
			inDegree[neighbor]--
			if inDegree[neighbor] == 0 {
				queue = append(queue, neighbor)
				determinism.SortSlice(queue, func(a, b model.InstanceID) bool {
					return a < b
				})
			}
		}
	}

	// Check for cycles
	if len(result) != len(instances) {
		// Cycle detected - return what we have
		// Caller should handle this error case
	}

	return result
}

// DetectCycles finds all cycles in the dependency graph
func DetectCycles(instances []*model.AssetInstance, edges []model.InstanceEdge) [][]model.InstanceID {
	// Build adjacency list
	adj := make(map[model.InstanceID][]model.InstanceID)
	for _, inst := range instances {
		adj[inst.ID] = []model.InstanceID{}
	}
	for _, edge := range edges {
		adj[edge.From] = append(adj[edge.From], edge.To)
	}

	// DFS-based cycle detection
	var cycles [][]model.InstanceID
	color := make(map[model.InstanceID]int) // 0=white, 1=gray, 2=black
	parent := make(map[model.InstanceID]model.InstanceID)

	var dfs func(node model.InstanceID)
	dfs = func(node model.InstanceID) {
		color[node] = 1 // Gray

		for _, neighbor := range adj[node] {
			if color[neighbor] == 1 {
				// Back edge found - cycle detected
				cycle := []model.InstanceID{neighbor}
				for n := node; n != neighbor; n = parent[n] {
					cycle = append([]model.InstanceID{n}, cycle...)
				}
				cycles = append(cycles, cycle)
			} else if color[neighbor] == 0 {
				parent[neighbor] = node
				dfs(neighbor)
			}
		}

		color[node] = 2 // Black
	}

	// Sort nodes for deterministic traversal
	nodes := make([]model.InstanceID, 0, len(adj))
	for id := range adj {
		nodes = append(nodes, id)
	}
	determinism.SortSlice(nodes, func(a, b model.InstanceID) bool {
		return a < b
	})

	for _, node := range nodes {
		if color[node] == 0 {
			dfs(node)
		}
	}

	return cycles
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\dynamic.go
# TYPE: go
# SIZE: 6073 bytes
################################################################################
// Package terraform - Dynamic block expansion
package terraform

import (
	"fmt"
	"sort"

	"terraform-cost/core/model"
)

// DynamicBlockExpander handles Terraform dynamic blocks
type DynamicBlockExpander struct{}

// NewDynamicBlockExpander creates a new expander
func NewDynamicBlockExpander() *DynamicBlockExpander {
	return &DynamicBlockExpander{}
}

// ExpandDynamicBlocks expands all dynamic blocks in a definition
func (e *DynamicBlockExpander) ExpandDynamicBlocks(
	def *model.AssetDefinition,
	evalCtx *EvalContext,
) (map[string][]map[string]model.ResolvedAttribute, []string) {
	result := make(map[string][]map[string]model.ResolvedAttribute)
	var warnings []string

	for _, dyn := range def.DynamicBlocks {
		blocks, warn := e.expandSingle(dyn, evalCtx)
		if warn != "" {
			warnings = append(warnings, warn)
		}
		result[dyn.Name] = blocks
	}

	return result, warnings
}

func (e *DynamicBlockExpander) expandSingle(
	dyn model.DynamicBlock,
	evalCtx *EvalContext,
) ([]map[string]model.ResolvedAttribute, string) {
	// Resolve the for_each expression
	forEachValue, ok := e.resolveForEach(dyn.ForEach, evalCtx)
	if !ok {
		return nil, fmt.Sprintf("dynamic %q: for_each could not be resolved", dyn.Name)
	}

	// Determine iterator name (default to block name)
	iterator := dyn.Iterator
	if iterator == "" {
		iterator = dyn.Name
	}

	var blocks []map[string]model.ResolvedAttribute

	// Iterate based on type
	switch v := forEachValue.(type) {
	case []any:
		for i, item := range v {
			block := e.expandContent(dyn.Content, iterator, i, item, evalCtx)
			blocks = append(blocks, block)
		}
	case map[string]any:
		// Sort keys for determinism
		keys := make([]string, 0, len(v))
		for k := range v {
			keys = append(keys, k)
		}
		sort.Strings(keys)

		for _, key := range keys {
			block := e.expandContent(dyn.Content, iterator, key, v[key], evalCtx)
			blocks = append(blocks, block)
		}
	default:
		return nil, fmt.Sprintf("dynamic %q: for_each must be list or map", dyn.Name)
	}

	return blocks, ""
}

func (e *DynamicBlockExpander) resolveForEach(expr model.Expression, ctx *EvalContext) (any, bool) {
	if expr.IsLiteral {
		return expr.LiteralVal, true
	}

	// Evaluate expression
	if ctx != nil {
		val, err := ctx.Evaluate(expr)
		if err != nil {
			return nil, false
		}
		return val, true
	}

	return nil, false
}

func (e *DynamicBlockExpander) expandContent(
	content map[string]model.Expression,
	iterator string,
	key any,
	value any,
	parentCtx *EvalContext,
) map[string]model.ResolvedAttribute {
	// Create child context with iterator variables
	ctx := parentCtx.Clone()
	ctx.SetLocal(iterator+".key", key)
	ctx.SetLocal(iterator+".value", value)

	result := make(map[string]model.ResolvedAttribute)

	for name, expr := range content {
		if expr.IsLiteral {
			result[name] = model.ResolvedAttribute{
				Value:     expr.LiteralVal,
				IsUnknown: false,
			}
		} else {
			// Try to evaluate with iterator context
			val, err := ctx.Evaluate(expr)
			if err != nil {
				result[name] = model.ResolvedAttribute{
					IsUnknown: true,
					Reason:    model.ReasonExpressionError,
				}
			} else {
				result[name] = model.ResolvedAttribute{
					Value:     val,
					IsUnknown: false,
				}
			}
		}
	}

	return result
}

// EvalContext provides evaluation context for expressions
type EvalContext struct {
	variables map[string]any
	locals    map[string]any
	resources map[string]any
	data      map[string]any
	parent    *EvalContext
}

// NewEvalContext creates a new evaluation context
func NewEvalContext() *EvalContext {
	return &EvalContext{
		variables: make(map[string]any),
		locals:    make(map[string]any),
		resources: make(map[string]any),
		data:      make(map[string]any),
	}
}

// Clone creates a child context
func (c *EvalContext) Clone() *EvalContext {
	return &EvalContext{
		variables: make(map[string]any),
		locals:    make(map[string]any),
		resources: make(map[string]any),
		data:      make(map[string]any),
		parent:    c,
	}
}

// SetLocal sets a local value
func (c *EvalContext) SetLocal(name string, value any) {
	c.locals[name] = value
}

// GetLocal gets a local value (searching parent chain)
func (c *EvalContext) GetLocal(name string) (any, bool) {
	if val, ok := c.locals[name]; ok {
		return val, true
	}
	if c.parent != nil {
		return c.parent.GetLocal(name)
	}
	return nil, false
}

// Evaluate evaluates an expression in this context
func (c *EvalContext) Evaluate(expr model.Expression) (any, error) {
	if expr.IsLiteral {
		return expr.LiteralVal, nil
	}

	// Parse references and resolve
	for _, ref := range expr.References {
		// Try to resolve reference
		// This is simplified - real implementation would parse the reference
		if val, ok := c.GetLocal(ref); ok {
			return val, nil
		}
	}

	return nil, fmt.Errorf("cannot evaluate expression: %s", expr.Raw)
}

// NestedDynamicBlock handles nested dynamic blocks (dynamic within dynamic)
type NestedDynamicBlock struct {
	Parent  string
	Block   model.DynamicBlock
}

// ExpandNested expands nested dynamic blocks
func (e *DynamicBlockExpander) ExpandNested(
	nested []NestedDynamicBlock,
	parentBlocks map[string][]map[string]model.ResolvedAttribute,
	evalCtx *EvalContext,
) map[string][]map[string]model.ResolvedAttribute {
	// For each parent block instance, expand child dynamics
	result := make(map[string][]map[string]model.ResolvedAttribute)

	for _, n := range nested {
		parentInstances := parentBlocks[n.Parent]
		for _, parentAttrs := range parentInstances {
			// Create context with parent block values
			childCtx := evalCtx.Clone()
			for k, v := range parentAttrs {
				childCtx.SetLocal(n.Parent+"."+k, v.Value)
			}

			// Expand the nested block
			blocks, _ := e.expandSingle(n.Block, childCtx)
			result[n.Block.Name] = append(result[n.Block.Name], blocks...)
		}
	}

	return result
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\pipeline.go
# TYPE: go
# SIZE: 14732 bytes
################################################################################
// Package terraform provides a formal evaluation pipeline with strict phase separation.
// Phases: PARSE â†’ EVALUATE â†’ RESOLVE â†’ EXPAND â†’ BUILD
package terraform

import (
	"context"
	"fmt"
	"sort"

	"terraform-cost/core/determinism"
	"terraform-cost/core/model"
)

// Phase represents a distinct stage in evaluation
type Phase int

const (
	PhaseParse    Phase = iota // Parse HCL into raw blocks
	PhaseEvaluate              // Evaluate expressions
	PhaseResolve               // Resolve variables, locals, data sources
	PhaseExpand                // Expand count/for_each
	PhaseBuild                 // Build instance graph
)

// String returns the phase name
func (p Phase) String() string {
	switch p {
	case PhaseParse:
		return "parse"
	case PhaseEvaluate:
		return "evaluate"
	case PhaseResolve:
		return "resolve"
	case PhaseExpand:
		return "expand"
	case PhaseBuild:
		return "build"
	default:
		return "unknown"
	}
}

// Pipeline orchestrates all evaluation phases in strict order
type Pipeline struct {
	parser    *Parser
	evaluator *Evaluator
	resolver  *Resolver
	expander  *Expander
	builder   *GraphBuilder

	// Options
	opts PipelineOptions
}

// PipelineOptions configures pipeline behavior
type PipelineOptions struct {
	// Workspace name (default: "default")
	Workspace string

	// Variables from CLI/environment
	Variables map[string]any

	// Target resources (partial apply)
	Targets []string

	// Continue on errors
	ContinueOnError bool

	// Provider defaults
	DefaultProviders map[string]ProviderConfig

	// Unknown handling
	UnknownCountDefault int
}

// NewPipeline creates a new evaluation pipeline
func NewPipeline(opts PipelineOptions) *Pipeline {
	if opts.Workspace == "" {
		opts.Workspace = "default"
	}
	if opts.UnknownCountDefault == 0 {
		opts.UnknownCountDefault = 1
	}

	return &Pipeline{
		parser:    NewParser(),
		evaluator: NewEvaluator(),
		resolver:  NewResolver(opts.Variables),
		expander:  NewExpander(opts.UnknownCountDefault),
		builder:   NewGraphBuilder(),
		opts:      opts,
	}
}

// PipelineResult is the output of the pipeline
type PipelineResult struct {
	Graph    *model.InstanceGraph
	Warnings []Warning
	Errors   []Error
	Stats    PipelineStats
}

// PipelineStats tracks statistics from the pipeline run
type PipelineStats struct {
	DefinitionsFound int
	InstancesCreated int
	EdgesCreated     int
	UnknownValues    int
	ParseDuration    int64 // milliseconds
	TotalDuration    int64
}

// Warning is a non-fatal issue
type Warning struct {
	Phase   Phase
	Address string
	Message string
}

// Error is a fatal issue (may be recoverable if ContinueOnError)
type Error struct {
	Phase   Phase
	Address string
	Message string
	Cause   error
}

// Execute runs all phases in strict order
func (p *Pipeline) Execute(ctx context.Context, input *ScanInput) (*PipelineResult, error) {
	result := &PipelineResult{
		Warnings: []Warning{},
		Errors:   []Error{},
	}

	// Phase 1: Parse
	parsed, err := p.runParse(ctx, input, result)
	if err != nil && !p.opts.ContinueOnError {
		return result, fmt.Errorf("parse phase failed: %w", err)
	}

	// Phase 2: Evaluate expressions
	evaluated, err := p.runEvaluate(ctx, parsed, result)
	if err != nil && !p.opts.ContinueOnError {
		return result, fmt.Errorf("evaluate phase failed: %w", err)
	}

	// Phase 3: Resolve variables, locals, data sources
	resolved, err := p.runResolve(ctx, evaluated, result)
	if err != nil && !p.opts.ContinueOnError {
		return result, fmt.Errorf("resolve phase failed: %w", err)
	}

	// Phase 4: Expand instances
	expanded, err := p.runExpand(ctx, resolved, result)
	if err != nil && !p.opts.ContinueOnError {
		return result, fmt.Errorf("expand phase failed: %w", err)
	}

	// Phase 5: Build instance graph
	graph, err := p.runBuild(ctx, expanded, result)
	if err != nil {
		return result, fmt.Errorf("build phase failed: %w", err)
	}

	result.Graph = graph
	result.Stats.DefinitionsFound = len(parsed.Definitions)
	result.Stats.InstancesCreated = graph.Size()
	return result, nil
}

// ScanInput is the input to the pipeline
type ScanInput struct {
	RootPath    string
	Files       []string
	ModulePaths []string
	Workspace   string
}

// ParsedModule represents parsed HCL content
type ParsedModule struct {
	Path        string
	Definitions []*model.AssetDefinition
	Variables   []*VariableBlock
	Locals      []*LocalBlock
	Outputs     []*OutputBlock
	Providers   []*ProviderBlock
	Modules     []*ModuleCall
	DataSources []*model.AssetDefinition
}

// VariableBlock is a Terraform variable
type VariableBlock struct {
	Name        string
	Type        string
	Default     any
	Description string
	Sensitive   bool
	Validation  []ValidationRule
}

// LocalBlock is a Terraform local
type LocalBlock struct {
	Name       string
	Expression model.Expression
}

// OutputBlock is a Terraform output
type OutputBlock struct {
	Name        string
	Expression  model.Expression
	Description string
	Sensitive   bool
	DependsOn   []string
}

// ProviderBlock is a Terraform provider configuration
type ProviderBlock struct {
	Type       string
	Alias      string
	Attributes map[string]model.Expression
}

// ProviderConfig is a resolved provider
type ProviderConfig struct {
	Type   string
	Alias  string
	Region string
	Config map[string]any
}

// ModuleCall is a Terraform module block
type ModuleCall struct {
	Name       string
	Source     string
	Version    string
	Count      *model.Expression
	ForEach    *model.Expression
	Providers  map[string]string // Provider aliases
	Inputs     map[string]model.Expression
	DependsOn  []string
}

// ValidationRule is a variable validation
type ValidationRule struct {
	Condition    model.Expression
	ErrorMessage string
}

// runParse executes the parse phase
func (p *Pipeline) runParse(ctx context.Context, input *ScanInput, result *PipelineResult) (*ParsedModule, error) {
	return p.parser.Parse(ctx, input)
}

// EvaluatedModule has expressions partially evaluated
type EvaluatedModule struct {
	*ParsedModule
	// Local values computed
	ComputedLocals map[string]any
	// Provider configs resolved
	ResolvedProviders map[string]ProviderConfig
}

func (p *Pipeline) runEvaluate(ctx context.Context, parsed *ParsedModule, result *PipelineResult) (*EvaluatedModule, error) {
	return p.evaluator.Evaluate(ctx, parsed)
}

// ResolvedModule has all references resolved
type ResolvedModule struct {
	*EvaluatedModule
	// Variable values after resolution
	ResolvedVariables map[string]any
	// Data sources evaluated (some may be unknown)
	ResolvedData map[string]ResolvedData
}

// ResolvedData is a resolved data source
type ResolvedData struct {
	Address    string
	Attributes map[string]model.ResolvedAttribute
	IsKnown    bool
}

func (p *Pipeline) runResolve(ctx context.Context, evaluated *EvaluatedModule, result *PipelineResult) (*ResolvedModule, error) {
	return p.resolver.Resolve(ctx, evaluated)
}

// ExpandedModule has all count/for_each expanded
type ExpandedModule struct {
	*ResolvedModule
	// Instances after expansion
	Instances []*model.AssetInstance
}

func (p *Pipeline) runExpand(ctx context.Context, resolved *ResolvedModule, result *PipelineResult) (*ExpandedModule, error) {
	return p.expander.Expand(ctx, resolved, result)
}

func (p *Pipeline) runBuild(ctx context.Context, expanded *ExpandedModule, result *PipelineResult) (*model.InstanceGraph, error) {
	return p.builder.Build(ctx, expanded)
}

// Parser handles Phase 1: Parse
type Parser struct{}

func NewParser() *Parser { return &Parser{} }

func (p *Parser) Parse(ctx context.Context, input *ScanInput) (*ParsedModule, error) {
	// Implementation would use HCL parser
	// For now, return skeleton
	return &ParsedModule{
		Path:        input.RootPath,
		Definitions: []*model.AssetDefinition{},
		Variables:   []*VariableBlock{},
		Locals:      []*LocalBlock{},
	}, nil
}

// Evaluator handles Phase 2: Evaluate
type Evaluator struct{}

func NewEvaluator() *Evaluator { return &Evaluator{} }

func (e *Evaluator) Evaluate(ctx context.Context, parsed *ParsedModule) (*EvaluatedModule, error) {
	result := &EvaluatedModule{
		ParsedModule:      parsed,
		ComputedLocals:    make(map[string]any),
		ResolvedProviders: make(map[string]ProviderConfig),
	}

	// Evaluate locals in dependency order
	// Resolve provider configurations

	return result, nil
}

// Resolver handles Phase 3: Resolve
type Resolver struct {
	inputVars map[string]any
}

func NewResolver(vars map[string]any) *Resolver {
	if vars == nil {
		vars = make(map[string]any)
	}
	return &Resolver{inputVars: vars}
}

func (r *Resolver) Resolve(ctx context.Context, evaluated *EvaluatedModule) (*ResolvedModule, error) {
	result := &ResolvedModule{
		EvaluatedModule:   evaluated,
		ResolvedVariables: make(map[string]any),
		ResolvedData:      make(map[string]ResolvedData),
	}

	// Resolve variables from inputs, defaults, environment
	for _, v := range evaluated.Variables {
		if val, ok := r.inputVars[v.Name]; ok {
			result.ResolvedVariables[v.Name] = val
		} else if v.Default != nil {
			result.ResolvedVariables[v.Name] = v.Default
		}
	}

	return result, nil
}

// Expander handles Phase 4: Expand
type Expander struct {
	defaultCount int
}

func NewExpander(defaultCount int) *Expander {
	return &Expander{defaultCount: defaultCount}
}

func (e *Expander) Expand(ctx context.Context, resolved *ResolvedModule, result *PipelineResult) (*ExpandedModule, error) {
	expanded := &ExpandedModule{
		ResolvedModule: resolved,
		Instances:      []*model.AssetInstance{},
	}

	idGen := determinism.NewIDGenerator("inst")

	for _, def := range resolved.Definitions {
		instances, warnings := e.expandDefinition(def, resolved, idGen)
		expanded.Instances = append(expanded.Instances, instances...)

		for _, w := range warnings {
			result.Warnings = append(result.Warnings, Warning{
				Phase:   PhaseExpand,
				Address: string(def.Address),
				Message: w,
			})
		}
	}

	// Sort instances for determinism
	sort.Slice(expanded.Instances, func(i, j int) bool {
		return expanded.Instances[i].Address < expanded.Instances[j].Address
	})

	return expanded, nil
}

func (e *Expander) expandDefinition(def *model.AssetDefinition, resolved *ResolvedModule, idGen *determinism.IDGenerator) ([]*model.AssetInstance, []string) {
	var warnings []string

	// Handle count
	if def.Count != nil {
		count, known := e.resolveCount(def.Count, resolved)
		if !known {
			warnings = append(warnings, fmt.Sprintf("count could not be determined, assuming %d", e.defaultCount))
			count = e.defaultCount
		}

		instances := make([]*model.AssetInstance, count)
		for i := 0; i < count; i++ {
			addr := model.InstanceAddress(fmt.Sprintf("%s[%d]", def.Address, i))
			instances[i] = &model.AssetInstance{
				ID:           model.InstanceID(idGen.Generate(string(def.ID), fmt.Sprintf("%d", i))),
				DefinitionID: def.ID,
				Address:      addr,
				Key:          model.InstanceKey{Type: model.KeyTypeInt, IntValue: i},
				Attributes:   e.resolveAttributes(def, i, "", resolved),
			}
		}
		return instances, warnings
	}

	// Handle for_each
	if def.ForEach != nil {
		keys, known := e.resolveForEach(def.ForEach, resolved)
		if !known {
			warnings = append(warnings, "for_each could not be determined")
			return []*model.AssetInstance{}, warnings
		}

		// Sort keys for determinism
		sort.Strings(keys)

		instances := make([]*model.AssetInstance, len(keys))
		for i, key := range keys {
			addr := model.InstanceAddress(fmt.Sprintf("%s[%q]", def.Address, key))
			instances[i] = &model.AssetInstance{
				ID:           model.InstanceID(idGen.Generate(string(def.ID), key)),
				DefinitionID: def.ID,
				Address:      addr,
				Key:          model.InstanceKey{Type: model.KeyTypeString, StrValue: key},
				Attributes:   e.resolveAttributes(def, 0, key, resolved),
			}
		}
		return instances, warnings
	}

	// No expansion - single instance
	return []*model.AssetInstance{
		{
			ID:           model.InstanceID(idGen.Generate(string(def.ID))),
			DefinitionID: def.ID,
			Address:      model.InstanceAddress(def.Address),
			Key:          model.InstanceKey{Type: model.KeyTypeNone},
			Attributes:   e.resolveAttributes(def, 0, "", resolved),
		},
	}, warnings
}

func (e *Expander) resolveCount(expr *model.Expression, resolved *ResolvedModule) (int, bool) {
	if expr.IsLiteral {
		if n, ok := expr.LiteralVal.(int); ok {
			return n, true
		}
		if f, ok := expr.LiteralVal.(float64); ok {
			return int(f), true
		}
	}
	// Would need full expression evaluation
	return 0, false
}

func (e *Expander) resolveForEach(expr *model.Expression, resolved *ResolvedModule) ([]string, bool) {
	if expr.IsLiteral {
		switch v := expr.LiteralVal.(type) {
		case map[string]any:
			keys := make([]string, 0, len(v))
			for k := range v {
				keys = append(keys, k)
			}
			return keys, true
		case []any:
			keys := make([]string, len(v))
			for i, item := range v {
				if s, ok := item.(string); ok {
					keys[i] = s
				}
			}
			return keys, true
		}
	}
	return nil, false
}

func (e *Expander) resolveAttributes(def *model.AssetDefinition, countIdx int, eachKey string, resolved *ResolvedModule) map[string]model.ResolvedAttribute {
	result := make(map[string]model.ResolvedAttribute)

	for name, expr := range def.Attributes {
		// Skip meta-arguments
		if name == "count" || name == "for_each" || name == "depends_on" || name == "lifecycle" || name == "provider" {
			continue
		}

		if expr.IsLiteral {
			result[name] = model.ResolvedAttribute{
				Value:     expr.LiteralVal,
				IsUnknown: false,
			}
		} else {
			// Mark as unknown for now
			result[name] = model.ResolvedAttribute{
				IsUnknown: true,
				Reason:    model.ReasonComputedAtApply,
			}
		}
	}

	return result
}

// GraphBuilder handles Phase 5: Build
type GraphBuilder struct{}

func NewGraphBuilder() *GraphBuilder { return &GraphBuilder{} }

func (b *GraphBuilder) Build(ctx context.Context, expanded *ExpandedModule) (*model.InstanceGraph, error) {
	graph := model.NewInstanceGraph()

	// Add all instances
	for _, inst := range expanded.Instances {
		graph.AddInstance(inst)
	}

	// Build dependency edges from depends_on and references
	// This requires analyzing instance dependencies

	return graph, nil
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\provider.go
# TYPE: go
# SIZE: 6912 bytes
################################################################################
// Package terraform - Provider configuration and alias resolution
package terraform

import (
	"fmt"
	"sort"
	"strings"

	"terraform-cost/core/model"
)

// ProviderResolver handles provider configuration and alias inheritance
type ProviderResolver struct {
	// Resolved providers by key (type.alias)
	providers map[string]ProviderConfig

	// Provider inheritance chain
	inheritance map[string]string // child -> parent

	// Default regions per provider type
	defaultRegions map[string]string
}

// NewProviderResolver creates a new resolver
func NewProviderResolver() *ProviderResolver {
	return &ProviderResolver{
		providers:   make(map[string]ProviderConfig),
		inheritance: make(map[string]string),
		defaultRegions: map[string]string{
			"aws":     "us-east-1",
			"azurerm": "eastus",
			"google":  "us-central1",
		},
	}
}

// AddProvider registers a provider configuration
func (r *ProviderResolver) AddProvider(cfg ProviderConfig) {
	key := r.providerKey(cfg.Type, cfg.Alias)
	r.providers[key] = cfg
}

// SetInheritance sets up module provider inheritance
// modulePath is the child module, providerMap maps child aliases to parent aliases
func (r *ProviderResolver) SetInheritance(modulePath string, providerMap map[string]string) {
	for childAlias, parentAlias := range providerMap {
		childKey := modulePath + ":" + childAlias
		r.inheritance[childKey] = parentAlias
	}
}

// Resolve determines the provider configuration for a resource
func (r *ProviderResolver) Resolve(
	resourceType string,
	explicitProvider string,
	modulePath string,
) (model.ResolvedProvider, error) {
	// Determine provider type from resource type
	providerType := r.providerTypeFromResource(resourceType)

	// Determine provider key
	providerKey := r.determineProviderKey(providerType, explicitProvider, modulePath)

	// Look up provider
	cfg, ok := r.providers[providerKey]
	if !ok {
		// Fall back to default provider
		cfg = r.defaultProvider(providerType)
	}

	return model.ResolvedProvider{
		Type:       cfg.Type,
		Alias:      cfg.Alias,
		Region:     cfg.Region,
		Attributes: cfg.Config,
	}, nil
}

// providerTypeFromResource extracts provider type from resource type
// e.g., "aws_instance" -> "aws", "google_compute_instance" -> "google"
func (r *ProviderResolver) providerTypeFromResource(resourceType string) string {
	parts := strings.SplitN(resourceType, "_", 2)
	if len(parts) < 1 {
		return ""
	}
	return parts[0]
}

// providerKey creates a unique key for a provider
func (r *ProviderResolver) providerKey(providerType, alias string) string {
	if alias == "" {
		return providerType
	}
	return providerType + "." + alias
}

// determineProviderKey determines which provider to use
func (r *ProviderResolver) determineProviderKey(
	providerType string,
	explicitProvider string,
	modulePath string,
) string {
	// If explicit provider specified, use it
	if explicitProvider != "" {
		// Check if it needs inheritance lookup
		if modulePath != "" {
			inheritKey := modulePath + ":" + explicitProvider
			if inherited, ok := r.inheritance[inheritKey]; ok {
				return inherited
			}
		}
		return explicitProvider
	}

	// Check module-level provider inheritance
	if modulePath != "" {
		// Walk up the module tree looking for provider
		for path := modulePath; path != ""; path = r.parentModule(path) {
			inheritKey := path + ":" + providerType
			if inherited, ok := r.inheritance[inheritKey]; ok {
				return inherited
			}
		}
	}

	// Default to un-aliased provider
	return providerType
}

// parentModule returns the parent module path
func (r *ProviderResolver) parentModule(path string) string {
	parts := strings.Split(path, ".")
	if len(parts) <= 1 {
		return ""
	}
	return strings.Join(parts[:len(parts)-1], ".")
}

// defaultProvider returns a default provider config
func (r *ProviderResolver) defaultProvider(providerType string) ProviderConfig {
	region := r.defaultRegions[providerType]
	if region == "" {
		region = "us-east-1" // Fallback
	}
	return ProviderConfig{
		Type:   providerType,
		Alias:  "",
		Region: region,
		Config: map[string]any{},
	}
}

// ResolveAllProviders resolves providers for all instances
func (r *ProviderResolver) ResolveAllProviders(
	instances []*model.AssetInstance,
	definitions map[model.DefinitionID]*model.AssetDefinition,
) error {
	for _, inst := range instances {
		def := definitions[inst.DefinitionID]
		if def == nil {
			continue
		}

		// Get explicit provider from definition
		explicitProvider := ""
		if provAttr, ok := def.Attributes["provider"]; ok && provAttr.IsLiteral {
			if s, ok := provAttr.LiteralVal.(string); ok {
				explicitProvider = s
			}
		}

		// Extract module path from address
		modulePath := r.modulePathFromAddress(string(def.Address))

		// Resolve provider
		resolved, err := r.Resolve(string(def.Type), explicitProvider, modulePath)
		if err != nil {
			return fmt.Errorf("failed to resolve provider for %s: %w", inst.Address, err)
		}

		inst.Provider = resolved
	}

	return nil
}

// modulePathFromAddress extracts module path from resource address
// e.g., "module.foo.module.bar.aws_instance.web" -> "module.foo.module.bar"
func (r *ProviderResolver) modulePathFromAddress(addr string) string {
	parts := strings.Split(addr, ".")
	var moduleParts []string

	for i := 0; i < len(parts)-2; i += 2 {
		if parts[i] == "module" {
			moduleParts = append(moduleParts, "module."+parts[i+1])
		} else {
			break
		}
	}

	return strings.Join(moduleParts, ".")
}

// Providers returns all registered providers in sorted order
func (r *ProviderResolver) Providers() []ProviderConfig {
	keys := make([]string, 0, len(r.providers))
	for k := range r.providers {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	result := make([]ProviderConfig, len(keys))
	for i, k := range keys {
		result[i] = r.providers[k]
	}
	return result
}

// ExtractRegion extracts region from provider config or resource attributes
func (r *ProviderResolver) ExtractRegion(
	inst *model.AssetInstance,
	def *model.AssetDefinition,
) string {
	// First check instance provider
	if inst.Provider.Region != "" {
		return inst.Provider.Region
	}

	// Check resource attributes for region
	if regionAttr, ok := inst.Attributes["region"]; ok && !regionAttr.IsUnknown {
		if s, ok := regionAttr.Value.(string); ok {
			return s
		}
	}

	// Check availability_zone and derive region
	if azAttr, ok := inst.Attributes["availability_zone"]; ok && !azAttr.IsUnknown {
		if s, ok := azAttr.Value.(string); ok {
			// Remove the AZ suffix (e.g., "us-east-1a" -> "us-east-1")
			if len(s) > 1 {
				return s[:len(s)-1]
			}
		}
	}

	// Fall back to provider default
	return r.defaultRegions[inst.Provider.Type]
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\strict_unknown.go
# TYPE: go
# SIZE: 10833 bytes
################################################################################
// Package terraform - Strict unknown value semantics
// Unknowns NEVER collapse. They ALWAYS propagate. Cost ALWAYS degrades.
package terraform

import (
	"fmt"
)

// StrictUnknown represents an unknown value that CANNOT be collapsed.
// This is not a nil, not a zero, not an empty string - it is EXPLICITLY unknown.
type StrictUnknown struct {
	// Why this is unknown
	Reason UnknownReason

	// What type we expected
	ExpectedType ValueType

	// Where it came from
	Source string

	// What depends on this
	DependentCount int

	// How many levels deep (for debugging)
	PropagationDepth int
}

// IsUnknown always returns true for StrictUnknown
func (u *StrictUnknown) IsUnknown() bool { return true }

// String returns a debug representation
func (u *StrictUnknown) String() string {
	return fmt.Sprintf("(unknown: %s from %s)", u.Reason, u.Source)
}

// StrictValue is a value that is EITHER known OR unknown, never both, never nil.
type StrictValue struct {
	known   interface{}
	unknown *StrictUnknown
}

// MustBeKnown panics if the value is unknown - use for programming errors only
func (v StrictValue) MustBeKnown(context string) interface{} {
	if v.IsUnknown() {
		panic(fmt.Sprintf("BUG: expected known value but got unknown in %s: %s", context, v.unknown.String()))
	}
	return v.known
}

// StrictKnown creates a known value
func StrictKnown(val interface{}) StrictValue {
	if val == nil {
		// nil is a VALID known value (null)
		return StrictValue{known: nil, unknown: nil}
	}
	return StrictValue{known: val, unknown: nil}
}

// StrictUnknownValue creates an unknown value
func StrictUnknownValue(reason UnknownReason, expectedType ValueType, source string) StrictValue {
	return StrictValue{
		unknown: &StrictUnknown{
			Reason:       reason,
			ExpectedType: expectedType,
			Source:       source,
		},
	}
}

// IsKnown returns true ONLY if value is known
func (v StrictValue) IsKnown() bool {
	return v.unknown == nil
}

// IsUnknown returns true ONLY if value is unknown
func (v StrictValue) IsUnknown() bool {
	return v.unknown != nil
}

// Get returns the value if known, nil if unknown
// IMPORTANT: Check IsKnown() first!
func (v StrictValue) Get() interface{} {
	if v.IsUnknown() {
		return nil
	}
	return v.known
}

// GetUnknown returns the unknown info
func (v StrictValue) GetUnknown() *StrictUnknown {
	return v.unknown
}

// Propagate creates a NEW unknown that depends on this one
// The original unknown is preserved, depth is increased
func (v StrictValue) Propagate(newSource string) StrictValue {
	if v.IsKnown() {
		return v // Known values don't propagate
	}
	return StrictValue{
		unknown: &StrictUnknown{
			Reason:           ReasonDependsOnUnknown,
			ExpectedType:     v.unknown.ExpectedType,
			Source:           fmt.Sprintf("%s (via %s)", newSource, v.unknown.Source),
			PropagationDepth: v.unknown.PropagationDepth + 1,
		},
	}
}

// UnknownSet tracks all unresolved unknowns in a context
type UnknownSet struct {
	unknowns map[string]*StrictUnknown
}

// NewUnknownSet creates an empty unknown set
func NewUnknownSet() *UnknownSet {
	return &UnknownSet{
		unknowns: make(map[string]*StrictUnknown),
	}
}

// Add records an unknown
func (s *UnknownSet) Add(address string, u *StrictUnknown) {
	s.unknowns[address] = u
}

// Has checks if an address is unknown
func (s *UnknownSet) Has(address string) bool {
	_, ok := s.unknowns[address]
	return ok
}

// Get returns the unknown for an address
func (s *UnknownSet) Get(address string) *StrictUnknown {
	return s.unknowns[address]
}

// Merge combines two unknown sets
func (s *UnknownSet) Merge(other *UnknownSet) {
	if other == nil {
		return
	}
	for k, v := range other.unknowns {
		s.unknowns[k] = v
	}
}

// Count returns the number of unknowns
func (s *UnknownSet) Count() int {
	return len(s.unknowns)
}

// All returns all unknowns
func (s *UnknownSet) All() map[string]*StrictUnknown {
	result := make(map[string]*StrictUnknown)
	for k, v := range s.unknowns {
		result[k] = v
	}
	return result
}

// UnknownPropagator ensures unknowns propagate through operations
type UnknownPropagator struct {
	set *UnknownSet
}

// NewUnknownPropagator creates a propagator
func NewUnknownPropagator() *UnknownPropagator {
	return &UnknownPropagator{
		set: NewUnknownSet(),
	}
}

// CheckAndPropagate checks if any input is unknown, and if so returns propagated unknown
func (p *UnknownPropagator) CheckAndPropagate(inputs []StrictValue, operation string) (StrictValue, bool) {
	for _, input := range inputs {
		if input.IsUnknown() {
			// Any unknown input â†’ entire result is unknown
			propagated := input.Propagate(operation)
			return propagated, true
		}
	}
	return StrictValue{}, false
}

// Set returns the underlying unknown set
func (p *UnknownPropagator) Set() *UnknownSet {
	return p.set
}

// StrictArithmetic performs arithmetic that respects unknowns
type StrictArithmetic struct{}

// Add adds two values - if either is unknown, result is unknown
func (StrictArithmetic) Add(a, b StrictValue) StrictValue {
	if a.IsUnknown() {
		return a.Propagate("add.left")
	}
	if b.IsUnknown() {
		return b.Propagate("add.right")
	}

	// Both known - do arithmetic
	aNum, aOk := toFloat(a.Get())
	bNum, bOk := toFloat(b.Get())
	if !aOk || !bOk {
		return StrictUnknownValue(ReasonExpressionError, TypeNumber, "add: non-numeric operand")
	}
	return StrictKnown(aNum + bNum)
}

// Mul multiplies two values - if either is unknown, result is unknown
func (StrictArithmetic) Mul(a, b StrictValue) StrictValue {
	if a.IsUnknown() {
		return a.Propagate("mul.left")
	}
	if b.IsUnknown() {
		return b.Propagate("mul.right")
	}

	aNum, aOk := toFloat(a.Get())
	bNum, bOk := toFloat(b.Get())
	if !aOk || !bOk {
		return StrictUnknownValue(ReasonExpressionError, TypeNumber, "mul: non-numeric operand")
	}
	return StrictKnown(aNum * bNum)
}

// Div divides two values - if either is unknown, result is unknown
func (StrictArithmetic) Div(a, b StrictValue) StrictValue {
	if a.IsUnknown() {
		return a.Propagate("div.left")
	}
	if b.IsUnknown() {
		return b.Propagate("div.right")
	}

	aNum, aOk := toFloat(a.Get())
	bNum, bOk := toFloat(b.Get())
	if !aOk || !bOk {
		return StrictUnknownValue(ReasonExpressionError, TypeNumber, "div: non-numeric operand")
	}
	if bNum == 0 {
		return StrictUnknownValue(ReasonExpressionError, TypeNumber, "div: division by zero")
	}
	return StrictKnown(aNum / bNum)
}

func toFloat(v interface{}) (float64, bool) {
	switch n := v.(type) {
	case float64:
		return n, true
	case float32:
		return float64(n), true
	case int:
		return float64(n), true
	case int64:
		return float64(n), true
	case int32:
		return float64(n), true
	default:
		return 0, false
	}
}

// StrictCondition evaluates conditions respecting unknowns
type StrictCondition struct{}

// IfThenElse evaluates a conditional - if condition is unknown, result is unknown
func (StrictCondition) IfThenElse(condition, thenVal, elseVal StrictValue) StrictValue {
	if condition.IsUnknown() {
		// Unknown condition â†’ result is unknown
		return condition.Propagate("condition")
	}

	// Condition is known - evaluate
	cond, ok := condition.Get().(bool)
	if !ok {
		return StrictUnknownValue(ReasonExpressionError, TypeUnknown, "if: non-boolean condition")
	}

	if cond {
		return thenVal
	}
	return elseVal
}

// Equals compares two values - if either is unknown, result is unknown
func (StrictCondition) Equals(a, b StrictValue) StrictValue {
	if a.IsUnknown() {
		return a.Propagate("equals.left")
	}
	if b.IsUnknown() {
		return b.Propagate("equals.right")
	}
	return StrictKnown(a.Get() == b.Get())
}

// StrictList handles list operations with unknown propagation
type StrictList struct{}

// Index gets an element - if list or index is unknown, result is unknown
func (StrictList) Index(list StrictValue, index StrictValue) StrictValue {
	if list.IsUnknown() {
		return list.Propagate("list.index")
	}
	if index.IsUnknown() {
		return index.Propagate("list.index")
	}

	l, ok := list.Get().([]interface{})
	if !ok {
		return StrictUnknownValue(ReasonExpressionError, TypeUnknown, "index: not a list")
	}

	idx, ok := toInt(index.Get())
	if !ok {
		return StrictUnknownValue(ReasonExpressionError, TypeUnknown, "index: non-integer index")
	}

	if idx < 0 || idx >= len(l) {
		return StrictUnknownValue(ReasonExpressionError, TypeUnknown, "index: out of bounds")
	}

	return StrictKnown(l[idx])
}

// Length gets list length - if list is unknown, result is unknown
func (StrictList) Length(list StrictValue) StrictValue {
	if list.IsUnknown() {
		return list.Propagate("list.length")
	}

	switch v := list.Get().(type) {
	case []interface{}:
		return StrictKnown(len(v))
	case string:
		return StrictKnown(len(v))
	case map[string]interface{}:
		return StrictKnown(len(v))
	default:
		return StrictUnknownValue(ReasonExpressionError, TypeNumber, "length: unsupported type")
	}
}

func toInt(v interface{}) (int, bool) {
	switch n := v.(type) {
	case int:
		return n, true
	case int64:
		return int(n), true
	case float64:
		return int(n), true
	default:
		return 0, false
	}
}

// CostDegradation tracks how costs are degraded due to unknowns
type CostDegradation struct {
	IsDegraded bool
	Confidence float64 // 0.0 - 1.0

	Reasons []DegradationReason
}

// DegradationReason explains why cost is degraded
type DegradationReason struct {
	Component string
	Reason    string
	Impact    float64 // How much this reduces confidence
	IsUnknown bool    // Is this due to an unknown value?
}

// NewCostDegradation creates a fresh (non-degraded) state
func NewCostDegradation() *CostDegradation {
	return &CostDegradation{
		IsDegraded: false,
		Confidence: 1.0,
		Reasons:    []DegradationReason{},
	}
}

// RecordUnknown records that an unknown caused degradation
func (d *CostDegradation) RecordUnknown(component, source string, impact float64) {
	d.IsDegraded = true
	d.Confidence *= (1.0 - impact)
	d.Reasons = append(d.Reasons, DegradationReason{
		Component: component,
		Reason:    fmt.Sprintf("unknown value: %s", source),
		Impact:    impact,
		IsUnknown: true,
	})
}

// RecordMissing records that a missing value caused degradation
func (d *CostDegradation) RecordMissing(component, what string, impact float64) {
	d.IsDegraded = true
	d.Confidence *= (1.0 - impact)
	d.Reasons = append(d.Reasons, DegradationReason{
		Component: component,
		Reason:    fmt.Sprintf("missing: %s", what),
		Impact:    impact,
		IsUnknown: false,
	})
}

################################################################################
# FILE: :\good projects\cost estimation\core\terraform\unknown.go
# TYPE: go
# SIZE: 13736 bytes
################################################################################
// Package terraform - Unknown value propagation
// Implements correct Terraform unknown semantics: unknowns MUST propagate, never collapse.
package terraform

import (
	"fmt"

	"terraform-cost/core/model"
)

// UnknownValue represents a value that cannot be determined at plan time.
// This is a FIRST-CLASS type, not a nil or empty value.
type UnknownValue struct {
	// Type hint for the expected type
	ExpectedType ValueType

	// Why this value is unknown
	Reason UnknownReason

	// Source of the unknown (for debugging)
	Source string

	// Depth tracks how many levels of unknowns we've propagated through
	Depth int
}

// ValueType indicates the expected type of an unknown value
type ValueType int

const (
	TypeUnknown ValueType = iota
	TypeString
	TypeNumber
	TypeBool
	TypeList
	TypeMap
	TypeObject
)

// UnknownReason explains WHY a value is unknown
type UnknownReason int

const (
	// ReasonComputedAtApply - value computed during terraform apply
	ReasonComputedAtApply UnknownReason = iota

	// ReasonDataSourcePending - data source not yet evaluated
	ReasonDataSourcePending

	// ReasonVariableNotProvided - required variable with no default
	ReasonVariableNotProvided

	// ReasonDependsOnUnknown - depends on another unknown value
	ReasonDependsOnUnknown

	// ReasonExpressionError - expression couldn't be evaluated
	ReasonExpressionError

	// ReasonResourceNotCreated - resource doesn't exist yet
	ReasonResourceNotCreated
)

// String returns human-readable reason
func (r UnknownReason) String() string {
	switch r {
	case ReasonComputedAtApply:
		return "computed at apply time"
	case ReasonDataSourcePending:
		return "data source not yet evaluated"
	case ReasonVariableNotProvided:
		return "required variable not provided"
	case ReasonDependsOnUnknown:
		return "depends on unknown value"
	case ReasonExpressionError:
		return "expression evaluation failed"
	case ReasonResourceNotCreated:
		return "resource not yet created"
	default:
		return "unknown reason"
	}
}

// Value is a wrapper that can hold either a known value or an unknown
type Value struct {
	known   interface{}
	unknown *UnknownValue
}

// Known creates a known value
func Known(v interface{}) Value {
	return Value{known: v}
}

// Unknown creates an unknown value
func Unknown(reason UnknownReason, source string) Value {
	return Value{
		unknown: &UnknownValue{
			Reason: reason,
			Source: source,
			Depth:  0,
		},
	}
}

// UnknownWithType creates a typed unknown
func UnknownWithType(t ValueType, reason UnknownReason, source string) Value {
	return Value{
		unknown: &UnknownValue{
			ExpectedType: t,
			Reason:       reason,
			Source:       source,
			Depth:        0,
		},
	}
}

// IsKnown returns true if value is known
func (v Value) IsKnown() bool {
	return v.unknown == nil
}

// IsUnknown returns true if value is unknown
func (v Value) IsUnknown() bool {
	return v.unknown != nil
}

// Get returns the known value or nil
func (v Value) Get() interface{} {
	if v.IsUnknown() {
		return nil
	}
	return v.known
}

// GetUnknown returns the unknown info
func (v Value) GetUnknown() *UnknownValue {
	return v.unknown
}

// PropagateUnknown creates a new unknown that depends on this one
func (v Value) PropagateUnknown(newSource string) Value {
	if v.IsKnown() {
		return v // Nothing to propagate
	}

	return Value{
		unknown: &UnknownValue{
			ExpectedType: v.unknown.ExpectedType,
			Reason:       ReasonDependsOnUnknown,
			Source:       fmt.Sprintf("%s (from %s)", newSource, v.unknown.Source),
			Depth:        v.unknown.Depth + 1,
		},
	}
}

// UnknownAwareAttribute wraps an attribute that may be unknown
type UnknownAwareAttribute struct {
	Value     Value
	Sensitive bool
	Source    model.SourceLocation
}

// UnknownTracker tracks unknowns throughout the evaluation pipeline
type UnknownTracker struct {
	unknowns map[string]*UnknownValue
}

// NewUnknownTracker creates a new tracker
func NewUnknownTracker() *UnknownTracker {
	return &UnknownTracker{
		unknowns: make(map[string]*UnknownValue),
	}
}

// Track records an unknown value
func (t *UnknownTracker) Track(address string, u *UnknownValue) {
	t.unknowns[address] = u
}

// IsUnknown checks if an address is unknown
func (t *UnknownTracker) IsUnknown(address string) bool {
	_, ok := t.unknowns[address]
	return ok
}

// Get returns unknown info for an address
func (t *UnknownTracker) Get(address string) *UnknownValue {
	return t.unknowns[address]
}

// All returns all tracked unknowns
func (t *UnknownTracker) All() map[string]*UnknownValue {
	// Return copy
	result := make(map[string]*UnknownValue)
	for k, v := range t.unknowns {
		result[k] = v
	}
	return result
}

// Count returns the number of unknowns
func (t *UnknownTracker) Count() int {
	return len(t.unknowns)
}

// UnknownAwareExpander expands resources with proper unknown handling
type UnknownAwareExpander struct {
	tracker *UnknownTracker

	// What to do when count/for_each is unknown
	behavior UnknownExpansionBehavior
}

// UnknownExpansionBehavior defines how to handle unknown count/for_each
type UnknownExpansionBehavior int

const (
	// BehaviorPlaceholder creates a single placeholder instance
	BehaviorPlaceholder UnknownExpansionBehavior = iota

	// BehaviorSkip skips the resource entirely
	BehaviorSkip

	// BehaviorError returns an error
	BehaviorError
)

// NewUnknownAwareExpander creates a new expander
func NewUnknownAwareExpander(behavior UnknownExpansionBehavior) *UnknownAwareExpander {
	return &UnknownAwareExpander{
		tracker:  NewUnknownTracker(),
		behavior: behavior,
	}
}

// ExpandWithUnknowns expands a definition, properly handling unknowns
func (e *UnknownAwareExpander) ExpandWithUnknowns(
	def *model.AssetDefinition,
	ctx *EvalContext,
) ([]*model.AssetInstance, *ExpansionResult) {
	result := &ExpansionResult{
		Warnings: []string{},
		Unknowns: []*UnknownValue{},
	}

	// Check for count
	if def.Count != nil {
		countVal := e.evaluateExpression(*def.Count, ctx)

		if countVal.IsUnknown() {
			// UNKNOWN COUNT: do not guess!
			e.tracker.Track(string(def.Address)+".count", countVal.GetUnknown())
			result.Unknowns = append(result.Unknowns, countVal.GetUnknown())
			result.Warnings = append(result.Warnings,
				fmt.Sprintf("count is unknown: %s", countVal.GetUnknown().Reason))

			switch e.behavior {
			case BehaviorPlaceholder:
				return e.createPlaceholderInstance(def, countVal.GetUnknown()), result
			case BehaviorSkip:
				return []*model.AssetInstance{}, result
			case BehaviorError:
				result.Error = fmt.Errorf("unknown count not allowed")
				return nil, result
			}
		}

		// Known count
		count, ok := countVal.Get().(int)
		if !ok {
			if f, ok := countVal.Get().(float64); ok {
				count = int(f)
			}
		}
		return e.expandCount(def, count, ctx), result
	}

	// Check for for_each
	if def.ForEach != nil {
		forEachVal := e.evaluateExpression(*def.ForEach, ctx)

		if forEachVal.IsUnknown() {
			// UNKNOWN FOR_EACH: do not guess!
			e.tracker.Track(string(def.Address)+".for_each", forEachVal.GetUnknown())
			result.Unknowns = append(result.Unknowns, forEachVal.GetUnknown())
			result.Warnings = append(result.Warnings,
				fmt.Sprintf("for_each is unknown: %s", forEachVal.GetUnknown().Reason))

			switch e.behavior {
			case BehaviorPlaceholder:
				return e.createPlaceholderInstance(def, forEachVal.GetUnknown()), result
			case BehaviorSkip:
				return []*model.AssetInstance{}, result
			case BehaviorError:
				result.Error = fmt.Errorf("unknown for_each not allowed")
				return nil, result
			}
		}

		return e.expandForEach(def, forEachVal.Get(), ctx), result
	}

	// No expansion
	return []*model.AssetInstance{e.createSingleInstance(def, ctx)}, result
}

// ExpansionResult contains the result of expansion
type ExpansionResult struct {
	Warnings []string
	Unknowns []*UnknownValue
	Error    error
}

func (e *UnknownAwareExpander) evaluateExpression(expr model.Expression, ctx *EvalContext) Value {
	if expr.IsLiteral {
		return Known(expr.LiteralVal)
	}

	// Check if any references are unknown
	for _, ref := range expr.References {
		if u := e.tracker.Get(ref); u != nil {
			return Unknown(ReasonDependsOnUnknown, ref)
		}
	}

	// Try to evaluate
	if ctx != nil {
		val, err := ctx.Evaluate(expr)
		if err != nil {
			return Unknown(ReasonExpressionError, expr.Raw)
		}
		return Known(val)
	}

	return Unknown(ReasonExpressionError, expr.Raw)
}

func (e *UnknownAwareExpander) createPlaceholderInstance(
	def *model.AssetDefinition,
	u *UnknownValue,
) []*model.AssetInstance {
	inst := &model.AssetInstance{
		ID:           model.InstanceID(fmt.Sprintf("%s:placeholder", def.ID)),
		DefinitionID: def.ID,
		Address:      model.InstanceAddress(fmt.Sprintf("%s[?]", def.Address)),
		Key:          model.InstanceKey{Type: model.KeyTypeNone},
		Attributes:   make(map[string]model.ResolvedAttribute),
		Metadata: model.InstanceMetadata{
			IsPlaceholder: true,
			Warning:       fmt.Sprintf("placeholder for unknown expansion: %s", u.Reason),
		},
	}

	// Mark all attributes as unknown
	for name := range def.Attributes {
		inst.Attributes[name] = model.ResolvedAttribute{
			IsUnknown: true,
			Reason:    model.ReasonComputedAtApply,
		}
	}

	return []*model.AssetInstance{inst}
}

func (e *UnknownAwareExpander) createSingleInstance(
	def *model.AssetDefinition,
	ctx *EvalContext,
) *model.AssetInstance {
	inst := &model.AssetInstance{
		ID:           model.InstanceID(def.ID),
		DefinitionID: def.ID,
		Address:      model.InstanceAddress(def.Address),
		Key:          model.InstanceKey{Type: model.KeyTypeNone},
		Attributes:   e.resolveAttributes(def, ctx),
	}
	return inst
}

func (e *UnknownAwareExpander) expandCount(
	def *model.AssetDefinition,
	count int,
	ctx *EvalContext,
) []*model.AssetInstance {
	instances := make([]*model.AssetInstance, count)
	for i := 0; i < count; i++ {
		instances[i] = &model.AssetInstance{
			ID:           model.InstanceID(fmt.Sprintf("%s:%d", def.ID, i)),
			DefinitionID: def.ID,
			Address:      model.InstanceAddress(fmt.Sprintf("%s[%d]", def.Address, i)),
			Key:          model.InstanceKey{Type: model.KeyTypeInt, IntValue: i},
			Attributes:   e.resolveAttributesWithCount(def, i, ctx),
		}
	}
	return instances
}

func (e *UnknownAwareExpander) expandForEach(
	def *model.AssetDefinition,
	forEach interface{},
	ctx *EvalContext,
) []*model.AssetInstance {
	var instances []*model.AssetInstance

	switch v := forEach.(type) {
	case map[string]interface{}:
		for key, value := range v {
			instances = append(instances, &model.AssetInstance{
				ID:           model.InstanceID(fmt.Sprintf("%s:%s", def.ID, key)),
				DefinitionID: def.ID,
				Address:      model.InstanceAddress(fmt.Sprintf("%s[%q]", def.Address, key)),
				Key:          model.InstanceKey{Type: model.KeyTypeString, StrValue: key},
				Attributes:   e.resolveAttributesWithEach(def, key, value, ctx),
			})
		}
	case []interface{}:
		for i, item := range v {
			if key, ok := item.(string); ok {
				instances = append(instances, &model.AssetInstance{
					ID:           model.InstanceID(fmt.Sprintf("%s:%s", def.ID, key)),
					DefinitionID: def.ID,
					Address:      model.InstanceAddress(fmt.Sprintf("%s[%q]", def.Address, key)),
					Key:          model.InstanceKey{Type: model.KeyTypeString, StrValue: key},
					Attributes:   e.resolveAttributesWithEach(def, key, item, ctx),
				})
			} else {
				// Use index as fallback
				instances = append(instances, &model.AssetInstance{
					ID:           model.InstanceID(fmt.Sprintf("%s:%d", def.ID, i)),
					DefinitionID: def.ID,
					Address:      model.InstanceAddress(fmt.Sprintf("%s[%d]", def.Address, i)),
					Key:          model.InstanceKey{Type: model.KeyTypeInt, IntValue: i},
					Attributes:   e.resolveAttributesWithEach(def, i, item, ctx),
				})
			}
		}
	}

	return instances
}

func (e *UnknownAwareExpander) resolveAttributes(
	def *model.AssetDefinition,
	ctx *EvalContext,
) map[string]model.ResolvedAttribute {
	result := make(map[string]model.ResolvedAttribute)

	for name, expr := range def.Attributes {
		if name == "count" || name == "for_each" || name == "depends_on" || name == "lifecycle" || name == "provider" {
			continue
		}

		val := e.evaluateExpression(expr, ctx)
		if val.IsUnknown() {
			result[name] = model.ResolvedAttribute{
				IsUnknown: true,
				Reason:    model.UnknownReason(val.GetUnknown().Reason),
			}
		} else {
			result[name] = model.ResolvedAttribute{
				Value:     val.Get(),
				IsUnknown: false,
			}
		}
	}

	return result
}

func (e *UnknownAwareExpander) resolveAttributesWithCount(
	def *model.AssetDefinition,
	index int,
	ctx *EvalContext,
) map[string]model.ResolvedAttribute {
	// Clone context and add count.index
	childCtx := ctx.Clone()
	childCtx.SetLocal("count.index", index)
	return e.resolveAttributes(def, childCtx)
}

func (e *UnknownAwareExpander) resolveAttributesWithEach(
	def *model.AssetDefinition,
	key interface{},
	value interface{},
	ctx *EvalContext,
) map[string]model.ResolvedAttribute {
	childCtx := ctx.Clone()
	childCtx.SetLocal("each.key", key)
	childCtx.SetLocal("each.value", value)
	return e.resolveAttributes(def, childCtx)
}

// Tracker returns the unknown tracker
func (e *UnknownAwareExpander) Tracker() *UnknownTracker {
	return e.tracker
}

################################################################################
# FILE: :\good projects\cost estimation\core\types\asset.go
# TYPE: go
# SIZE: 6162 bytes
################################################################################
// Package types - Asset domain types
package types

// RawAsset represents a parsed infrastructure resource before graph construction.
// This is the output of scanners - no pricing or cost information here.
type RawAsset struct {
	// Address is the Terraform resource address
	Address ResourceAddress `json:"address"`

	// Provider is the cloud provider (aws, azure, gcp)
	Provider Provider `json:"provider"`

	// Type is the resource type (e.g., "aws_instance", "aws_s3_bucket")
	Type string `json:"type"`

	// Name is the resource name from the Terraform configuration
	Name string `json:"name"`

	// Attributes contains all resource attributes
	Attributes Attributes `json:"attributes"`

	// Module is the module path (empty for root module)
	Module string `json:"module,omitempty"`

	// Count is the count value if using count meta-argument
	Count int `json:"count,omitempty"`

	// ForEach contains the for_each keys if using for_each meta-argument
	ForEach []string `json:"for_each,omitempty"`

	// IsDataSource indicates if this is a data source, not a resource
	IsDataSource bool `json:"is_data_source"`

	// SourceFile is the file where this resource is defined
	SourceFile string `json:"source_file,omitempty"`

	// SourceLine is the line number in the source file
	SourceLine int `json:"source_line,omitempty"`
}

// Asset represents a node in the Asset Graph.
// This is the normalized, provider-agnostic representation of infrastructure.
type Asset struct {
	// ID is a unique identifier for this asset
	ID string `json:"id"`

	// Address is the original Terraform resource address
	Address ResourceAddress `json:"address"`

	// Provider is the cloud provider
	Provider Provider `json:"provider"`

	// Category groups assets by function (compute, storage, network, etc.)
	Category AssetCategory `json:"category"`

	// Type is the resource type
	Type string `json:"type"`

	// Name is the resource name
	Name string `json:"name"`

	// Attributes contains normalized resource attributes
	Attributes Attributes `json:"attributes"`

	// Children contains child assets (e.g., EBS volumes attached to an EC2 instance)
	Children []*Asset `json:"children,omitempty"`

	// Parent is the parent asset (nil for root-level assets)
	Parent *Asset `json:"-"`

	// Dependencies lists assets this asset depends on
	Dependencies []*Asset `json:"-"`

	// Metadata contains additional information about the asset
	Metadata AssetMetadata `json:"metadata"`

	// Region is the deployment region
	Region Region `json:"region,omitempty"`

	// Tags are resource tags
	Tags map[string]string `json:"tags,omitempty"`
}

// AssetCategory groups assets by their primary function
type AssetCategory string

const (
	CategoryCompute    AssetCategory = "compute"
	CategoryStorage    AssetCategory = "storage"
	CategoryNetwork    AssetCategory = "network"
	CategoryDatabase   AssetCategory = "database"
	CategoryContainer  AssetCategory = "container"
	CategoryServerless AssetCategory = "serverless"
	CategorySecurity   AssetCategory = "security"
	CategoryMonitoring AssetCategory = "monitoring"
	CategoryAI         AssetCategory = "ai_ml"
	CategoryOther      AssetCategory = "other"
)

// String returns the string representation
func (c AssetCategory) String() string {
	return string(c)
}

// AssetMetadata contains asset-specific metadata
type AssetMetadata struct {
	// Source is the file path where the asset is defined
	Source string `json:"source,omitempty"`

	// Line is the line number in the source file
	Line int `json:"line,omitempty"`

	// IsDataSource indicates if this originated from a data source
	IsDataSource bool `json:"is_data_source"`

	// ModulePath is the module path
	ModulePath string `json:"module_path,omitempty"`

	// Index is the count or for_each index
	Index string `json:"index,omitempty"`
}

// AssetGraph represents the complete infrastructure as a directed acyclic graph
type AssetGraph struct {
	// Roots contains top-level assets (no parent)
	Roots []*Asset `json:"roots"`

	// ByID provides O(1) lookup by asset ID
	ByID map[string]*Asset `json:"-"`

	// ByAddress provides lookup by Terraform address
	ByAddress map[ResourceAddress]*Asset `json:"-"`

	// ByProvider groups assets by cloud provider
	ByProvider map[Provider][]*Asset `json:"-"`

	// ByCategory groups assets by category
	ByCategory map[AssetCategory][]*Asset `json:"-"`

	// Metadata contains graph-level metadata
	Metadata GraphMetadata `json:"metadata"`
}

// GraphMetadata contains metadata about the asset graph
type GraphMetadata struct {
	// TotalAssets is the total count of assets
	TotalAssets int `json:"total_assets"`

	// Providers lists all providers in the graph
	Providers []Provider `json:"providers"`

	// Modules lists all module paths
	Modules []string `json:"modules,omitempty"`
}

// NewAssetGraph creates a new empty asset graph
func NewAssetGraph() *AssetGraph {
	return &AssetGraph{
		Roots:      make([]*Asset, 0),
		ByID:       make(map[string]*Asset),
		ByAddress:  make(map[ResourceAddress]*Asset),
		ByProvider: make(map[Provider][]*Asset),
		ByCategory: make(map[AssetCategory][]*Asset),
	}
}

// Add adds an asset to the graph
func (g *AssetGraph) Add(asset *Asset) {
	g.ByID[asset.ID] = asset
	g.ByAddress[asset.Address] = asset
	g.ByProvider[asset.Provider] = append(g.ByProvider[asset.Provider], asset)
	g.ByCategory[asset.Category] = append(g.ByCategory[asset.Category], asset)

	if asset.Parent == nil {
		g.Roots = append(g.Roots, asset)
	}

	g.Metadata.TotalAssets++
}

// Walk traverses all assets in the graph, calling fn for each
func (g *AssetGraph) Walk(fn func(*Asset) error) error {
	for _, root := range g.Roots {
		if err := walkAsset(root, fn); err != nil {
			return err
		}
	}
	return nil
}

func walkAsset(asset *Asset, fn func(*Asset) error) error {
	if err := fn(asset); err != nil {
		return err
	}
	for _, child := range asset.Children {
		if err := walkAsset(child, fn); err != nil {
			return err
		}
	}
	return nil
}

################################################################################
# FILE: :\good projects\cost estimation\core\types\cost.go
# TYPE: go
# SIZE: 7583 bytes
################################################################################
// Package types - Cost graph types
package types

import "github.com/shopspring/decimal"

// Currency represents a currency code
type Currency string

const (
	CurrencyUSD Currency = "USD"
	CurrencyEUR Currency = "EUR"
	CurrencyGBP Currency = "GBP"
)

// String returns the string representation
func (c Currency) String() string {
	return string(c)
}

// RateKey uniquely identifies a pricing rate
type RateKey struct {
	// Provider is the cloud provider
	Provider Provider `json:"provider"`

	// Service is the cloud service (e.g., "EC2", "S3")
	Service string `json:"service"`

	// ProductFamily is the product family (e.g., "Compute Instance", "Storage")
	ProductFamily string `json:"product_family"`

	// Region is the cloud region
	Region string `json:"region"`

	// Attributes contains SKU-specific attributes
	Attributes map[string]string `json:"attributes,omitempty"`
}

// String returns a string representation for caching/lookup
func (k RateKey) String() string {
	return string(k.Provider) + "/" + k.Service + "/" + k.ProductFamily + "/" + k.Region
}

// CostUnit represents a single billable line item
type CostUnit struct {
	// ID uniquely identifies this cost unit
	ID string `json:"id"`

	// Label is a human-readable label
	Label string `json:"label"`

	// Description provides additional context
	Description string `json:"description,omitempty"`

	// Measure is the billing unit (e.g., "GB-month", "hours", "requests")
	Measure string `json:"measure"`

	// Quantity is the usage quantity
	Quantity decimal.Decimal `json:"quantity"`

	// RateKey identifies the pricing rate
	RateKey RateKey `json:"rate_key"`

	// Rate is the unit price
	Rate decimal.Decimal `json:"rate"`

	// Amount is the calculated cost (Quantity * Rate)
	Amount decimal.Decimal `json:"amount"`

	// Currency is the cost currency
	Currency Currency `json:"currency"`

	// Lineage tracks why this cost exists
	Lineage CostLineage `json:"lineage"`

	// IsSubcost indicates if this is a sub-component of a larger cost
	IsSubcost bool `json:"is_subcost,omitempty"`
}

// CostLineage tracks the origin and calculation of a cost
type CostLineage struct {
	// AssetID links to the source asset
	AssetID string `json:"asset_id"`

	// AssetAddress is the Terraform resource address
	AssetAddress ResourceAddress `json:"asset_address"`

	// Formula describes how the cost was calculated
	Formula string `json:"formula"`

	// UsageVector is the usage data used in calculation
	UsageVector *UsageVector `json:"usage_vector,omitempty"`

	// Assumptions lists assumptions made during calculation
	Assumptions []string `json:"assumptions,omitempty"`
}

// CostAggregate groups cost units by a dimension
type CostAggregate struct {
	// ID uniquely identifies this aggregate
	ID string `json:"id"`

	// Label is a human-readable label
	Label string `json:"label"`

	// Description provides additional context
	Description string `json:"description,omitempty"`

	// Units contains the cost units in this aggregate
	Units []*CostUnit `json:"units,omitempty"`

	// Children contains child aggregates
	Children []*CostAggregate `json:"children,omitempty"`

	// MonthlyCost is the calculated monthly total
	MonthlyCost decimal.Decimal `json:"monthly_cost"`

	// HourlyCost is the calculated hourly cost
	HourlyCost decimal.Decimal `json:"hourly_cost"`

	// Currency is the cost currency
	Currency Currency `json:"currency"`
}

// Add adds a cost unit to the aggregate
func (a *CostAggregate) Add(unit *CostUnit) {
	a.Units = append(a.Units, unit)
	a.MonthlyCost = a.MonthlyCost.Add(unit.Amount)
}

// Total returns the total monthly cost
func (a *CostAggregate) Total() decimal.Decimal {
	total := a.MonthlyCost
	for _, child := range a.Children {
		total = total.Add(child.Total())
	}
	return total
}

// CostGraph represents the complete cost model as a graph
type CostGraph struct {
	// Root is the top-level aggregate
	Root *CostAggregate `json:"root"`

	// ByAsset groups costs by asset ID
	ByAsset map[string]*CostAggregate `json:"by_asset,omitempty"`

	// ByProvider groups costs by cloud provider
	ByProvider map[Provider]*CostAggregate `json:"by_provider,omitempty"`

	// ByService groups costs by service
	ByService map[string]*CostAggregate `json:"by_service,omitempty"`

	// ByCategory groups costs by asset category
	ByCategory map[AssetCategory]*CostAggregate `json:"by_category,omitempty"`

	// TotalMonthlyCost is the overall monthly total
	TotalMonthlyCost decimal.Decimal `json:"total_monthly_cost"`

	// TotalHourlyCost is the overall hourly total
	TotalHourlyCost decimal.Decimal `json:"total_hourly_cost"`

	// Currency is the primary currency
	Currency Currency `json:"currency"`

	// Metadata contains graph-level information
	Metadata CostGraphMetadata `json:"metadata"`
}

// CostGraphMetadata contains metadata about the cost graph
type CostGraphMetadata struct {
	// PricingSnapshotID is the pricing snapshot used
	PricingSnapshotID string `json:"pricing_snapshot_id"`

	// CreatedAt is when the graph was created
	CreatedAt string `json:"created_at"`

	// AssetCount is the number of priced assets
	AssetCount int `json:"asset_count"`

	// CostUnitCount is the total number of cost units
	CostUnitCount int `json:"cost_unit_count"`

	// MissingPrices lists rate keys that couldn't be resolved
	MissingPrices []RateKey `json:"missing_prices,omitempty"`
}

// NewCostGraph creates a new empty cost graph
func NewCostGraph(currency Currency) *CostGraph {
	return &CostGraph{
		Root: &CostAggregate{
			ID:       "root",
			Label:    "Total",
			Currency: currency,
		},
		ByAsset:    make(map[string]*CostAggregate),
		ByProvider: make(map[Provider]*CostAggregate),
		ByService:  make(map[string]*CostAggregate),
		ByCategory: make(map[AssetCategory]*CostAggregate),
		Currency:   currency,
	}
}

// AddCostUnit adds a cost unit to the graph with proper indexing
func (g *CostGraph) AddCostUnit(unit *CostUnit, asset *Asset) {
	// Add to root
	g.Root.Add(unit)

	// Add to by-asset index
	if _, ok := g.ByAsset[asset.ID]; !ok {
		g.ByAsset[asset.ID] = &CostAggregate{
			ID:       asset.ID,
			Label:    string(asset.Address),
			Currency: g.Currency,
		}
	}
	g.ByAsset[asset.ID].Add(unit)

	// Add to by-provider index
	if _, ok := g.ByProvider[asset.Provider]; !ok {
		g.ByProvider[asset.Provider] = &CostAggregate{
			ID:       string(asset.Provider),
			Label:    string(asset.Provider),
			Currency: g.Currency,
		}
	}
	g.ByProvider[asset.Provider].Add(unit)

	// Add to by-service index
	service := unit.RateKey.Service
	if _, ok := g.ByService[service]; !ok {
		g.ByService[service] = &CostAggregate{
			ID:       service,
			Label:    service,
			Currency: g.Currency,
		}
	}
	g.ByService[service].Add(unit)

	// Add to by-category index
	if _, ok := g.ByCategory[asset.Category]; !ok {
		g.ByCategory[asset.Category] = &CostAggregate{
			ID:       string(asset.Category),
			Label:    string(asset.Category),
			Currency: g.Currency,
		}
	}
	g.ByCategory[asset.Category].Add(unit)

	// Update totals
	g.TotalMonthlyCost = g.TotalMonthlyCost.Add(unit.Amount)
	g.Metadata.CostUnitCount++
}

// Summarize recalculates all totals in the graph
func (g *CostGraph) Summarize() {
	g.TotalMonthlyCost = g.Root.Total()
	// Convert to hourly (730 hours/month)
	g.TotalHourlyCost = g.TotalMonthlyCost.Div(decimal.NewFromInt(730))
}

################################################################################
# FILE: :\good projects\cost estimation\core\types\pricing.go
# TYPE: go
# SIZE: 4299 bytes
################################################################################
// Package types - Pricing types
package types

import (
	"time"

	"github.com/shopspring/decimal"
)

// PricingSnapshot represents a point-in-time pricing dataset
type PricingSnapshot struct {
	// ID uniquely identifies this snapshot
	ID string `json:"id"`

	// Provider is the cloud provider
	Provider Provider `json:"provider"`

	// Region is the pricing region
	Region string `json:"region"`

	// Timestamp is when the snapshot was taken
	Timestamp time.Time `json:"timestamp"`

	// Hash is a content hash for validation
	Hash string `json:"hash"`

	// Source indicates where the pricing came from
	Source string `json:"source"`

	// Version is the pricing data version
	Version string `json:"version,omitempty"`
}

// Rate represents a pricing rate for a specific SKU
type Rate struct {
	// Key uniquely identifies what this rate applies to
	Key RateKey `json:"key"`

	// Price is the unit price
	Price decimal.Decimal `json:"price"`

	// Unit is the billing unit (e.g., "hour", "GB-month")
	Unit string `json:"unit"`

	// Currency is the price currency
	Currency Currency `json:"currency"`

	// EffectiveFrom is when this rate became effective
	EffectiveFrom time.Time `json:"effective_from"`

	// EffectiveTo is when this rate expires (nil = current)
	EffectiveTo *time.Time `json:"effective_to,omitempty"`

	// SnapshotID links to the pricing snapshot
	SnapshotID string `json:"snapshot_id"`

	// Description provides additional context
	Description string `json:"description,omitempty"`

	// Tiers contains tiered pricing information
	Tiers []PricingTier `json:"tiers,omitempty"`
}

// PricingTier represents a tier in tiered pricing
type PricingTier struct {
	// StartQuantity is the tier start (inclusive)
	StartQuantity decimal.Decimal `json:"start_quantity"`

	// EndQuantity is the tier end (exclusive, nil = unlimited)
	EndQuantity *decimal.Decimal `json:"end_quantity,omitempty"`

	// Price is the unit price for this tier
	Price decimal.Decimal `json:"price"`

	// Unit is the billing unit
	Unit string `json:"unit"`
}

// CalculateTieredCost calculates cost for tiered pricing
func (r *Rate) CalculateTieredCost(quantity decimal.Decimal) decimal.Decimal {
	if len(r.Tiers) == 0 {
		return quantity.Mul(r.Price)
	}

	total := decimal.Zero
	remaining := quantity

	for _, tier := range r.Tiers {
		if remaining.LessThanOrEqual(decimal.Zero) {
			break
		}

		var tierQuantity decimal.Decimal
		if tier.EndQuantity == nil {
			tierQuantity = remaining
		} else {
			tierRange := tier.EndQuantity.Sub(tier.StartQuantity)
			if remaining.LessThan(tierRange) {
				tierQuantity = remaining
			} else {
				tierQuantity = tierRange
			}
		}

		total = total.Add(tierQuantity.Mul(tier.Price))
		remaining = remaining.Sub(tierQuantity)
	}

	return total
}

// PricingResult contains resolved pricing for a set of rate keys
type PricingResult struct {
	// Rates maps rate keys to their resolved rates
	Rates map[string]Rate `json:"rates"`

	// Snapshot is the pricing snapshot used
	Snapshot PricingSnapshot `json:"snapshot"`

	// Missing lists rate keys that couldn't be resolved
	Missing []RateKey `json:"missing,omitempty"`

	// FromCache indicates how many rates were from cache
	FromCache int `json:"from_cache"`

	// FromDB indicates how many rates were from database
	FromDB int `json:"from_db"`

	// FromAPI indicates how many rates were from API
	FromAPI int `json:"from_api"`
}

// GetRate retrieves a rate by its key
func (r *PricingResult) GetRate(key RateKey) (Rate, bool) {
	if r == nil || r.Rates == nil {
		return Rate{}, false
	}
	rate, ok := r.Rates[key.String()]
	return rate, ok
}

// PricingFilter specifies criteria for pricing lookups
type PricingFilter struct {
	// Provider filters by cloud provider
	Provider Provider `json:"provider,omitempty"`

	// Service filters by service name
	Service string `json:"service,omitempty"`

	// Region filters by region
	Region string `json:"region,omitempty"`

	// ProductFamily filters by product family
	ProductFamily string `json:"product_family,omitempty"`

	// Attributes filters by specific attributes
	Attributes map[string]string `json:"attributes,omitempty"`
}

################################################################################
# FILE: :\good projects\cost estimation\core\types\project.go
# TYPE: go
# SIZE: 3240 bytes
################################################################################
// Package types - Project input types
package types

import "time"

// ProjectInput represents a normalized input for estimation
type ProjectInput struct {
	// ID uniquely identifies this input
	ID string `json:"id"`

	// Path is the filesystem path to the project
	Path string `json:"path"`

	// Type is the detected project type
	Type ProjectType `json:"type"`

	// Source indicates where the input came from
	Source InputSource `json:"source"`

	// Metadata contains additional context
	Metadata InputMetadata `json:"metadata"`
}

// ProjectType identifies the type of infrastructure project
type ProjectType string

const (
	ProjectTypeTerraformHCL    ProjectType = "terraform-hcl"
	ProjectTypeTerraformPlan   ProjectType = "terraform-plan"
	ProjectTypeTerragrunt      ProjectType = "terragrunt"
	ProjectTypeCloudFormation  ProjectType = "cloudformation"
	ProjectTypeUnknown         ProjectType = "unknown"
)

// String returns the string representation
func (t ProjectType) String() string {
	return string(t)
}

// InputSource indicates the origin of the input
type InputSource string

const (
	SourceCLI      InputSource = "cli"
	SourceWeb      InputSource = "web"
	SourceGit      InputSource = "git"
	SourceCICD     InputSource = "cicd"
	SourceAPI      InputSource = "api"
)

// String returns the string representation
func (s InputSource) String() string {
	return string(s)
}

// InputMetadata contains metadata about the input
type InputMetadata struct {
	// Repository is the Git repository URL
	Repository string `json:"repository,omitempty"`

	// Branch is the Git branch
	Branch string `json:"branch,omitempty"`

	// Commit is the Git commit SHA
	Commit string `json:"commit,omitempty"`

	// User is the authenticated user
	User string `json:"user,omitempty"`

	// Timestamp is when the input was received
	Timestamp time.Time `json:"timestamp"`

	// Files lists the input files
	Files []string `json:"files,omitempty"`

	// Hash is a content hash for caching
	Hash string `json:"hash,omitempty"`

	// Environment is the target environment
	Environment string `json:"environment,omitempty"`

	// Tags are user-provided tags
	Tags map[string]string `json:"tags,omitempty"`
}

// DetectedProject contains detection results
type DetectedProject struct {
	// Type is the project type
	Type ProjectType `json:"type"`

	// Roots are the Terraform root modules
	Roots []string `json:"roots"`

	// Confidence is the detection confidence (0.0 to 1.0)
	Confidence float64 `json:"confidence"`

	// Files are the detected IaC files
	Files []DetectedFile `json:"files"`
}

// DetectedFile represents a detected infrastructure file
type DetectedFile struct {
	// Path is the file path relative to project root
	Path string `json:"path"`

	// Type is the file type
	Type FileType `json:"type"`
}

// FileType identifies the type of infrastructure file
type FileType string

const (
	FileTypeTerraform      FileType = "terraform"
	FileTypeTerraformVars  FileType = "tfvars"
	FileTypeTerraformPlan  FileType = "tfplan"
	FileTypeTerragrunt     FileType = "terragrunt"
	FileTypeCloudFormation FileType = "cloudformation"
)

################################################################################
# FILE: :\good projects\cost estimation\core\types\types.go
# TYPE: go
# SIZE: 2887 bytes
################################################################################
// Package types defines core domain types shared across all layers.
// This package contains NO business logic - only type definitions.
package types

import "time"

// Provider represents a cloud provider
type Provider string

const (
	ProviderAWS     Provider = "aws"
	ProviderAzure   Provider = "azure"
	ProviderGCP     Provider = "gcp"
	ProviderUnknown Provider = "unknown"
)

// String returns the string representation of the provider
func (p Provider) String() string {
	return string(p)
}

// IsValid checks if the provider is a known provider
func (p Provider) IsValid() bool {
	switch p {
	case ProviderAWS, ProviderAzure, ProviderGCP:
		return true
	default:
		return false
	}
}

// ResourceAddress uniquely identifies a resource in Terraform
// Format: module.name.resource_type.resource_name or resource_type.resource_name
type ResourceAddress string

// String returns the string representation
func (r ResourceAddress) String() string {
	return string(r)
}

// Attribute represents a resource attribute value
type Attribute struct {
	Value       interface{} `json:"value"`
	IsComputed  bool        `json:"is_computed"`
	IsSensitive bool        `json:"is_sensitive"`
	Type        string      `json:"type,omitempty"`
}

// Attributes is a map of attribute names to values
type Attributes map[string]Attribute

// Get retrieves an attribute value, returning nil if not found
func (a Attributes) Get(key string) interface{} {
	if attr, ok := a[key]; ok {
		return attr.Value
	}
	return nil
}

// GetString retrieves a string attribute value
func (a Attributes) GetString(key string) string {
	if v := a.Get(key); v != nil {
		if s, ok := v.(string); ok {
			return s
		}
	}
	return ""
}

// GetInt retrieves an integer attribute value
func (a Attributes) GetInt(key string) int {
	if v := a.Get(key); v != nil {
		switch n := v.(type) {
		case int:
			return n
		case int64:
			return int(n)
		case float64:
			return int(n)
		}
	}
	return 0
}

// GetBool retrieves a boolean attribute value
func (a Attributes) GetBool(key string) bool {
	if v := a.Get(key); v != nil {
		if b, ok := v.(bool); ok {
			return b
		}
	}
	return false
}

// GetFloat retrieves a float64 attribute value
func (a Attributes) GetFloat(key string) float64 {
	if v := a.Get(key); v != nil {
		switch n := v.(type) {
		case float64:
			return n
		case int:
			return float64(n)
		case int64:
			return float64(n)
		}
	}
	return 0
}

// Metadata contains common metadata fields
type Metadata struct {
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	Version   string    `json:"version"`
}

// Region represents a cloud region
type Region string

// String returns the string representation
func (r Region) String() string {
	return string(r)
}

################################################################################
# FILE: :\good projects\cost estimation\core\types\usage.go
# TYPE: go
# SIZE: 6309 bytes
################################################################################
// Package types - Usage estimation types
package types

// UsageMetric identifies a measurable usage dimension
type UsageMetric string

// Common usage metrics across all providers
const (
	// Time-based metrics
	MetricMonthlyHours UsageMetric = "monthly_hours"
	MetricDailyHours   UsageMetric = "daily_hours"

	// Storage metrics
	MetricMonthlyGB        UsageMetric = "monthly_gb"
	MetricMonthlyGBStorage UsageMetric = "monthly_gb_storage"
	MetricMonthlySnapshots UsageMetric = "monthly_snapshots"

	// Transfer metrics
	MetricMonthlyGBTransferOut   UsageMetric = "monthly_gb_transfer_out"
	MetricMonthlyGBTransferIn    UsageMetric = "monthly_gb_transfer_in"
	MetricMonthlyGBInterRegion   UsageMetric = "monthly_gb_inter_region"
	MetricMonthlyGBInterAZ       UsageMetric = "monthly_gb_inter_az"

	// Request metrics
	MetricMonthlyRequests       UsageMetric = "monthly_requests"
	MetricMonthlyReadRequests   UsageMetric = "monthly_read_requests"
	MetricMonthlyWriteRequests  UsageMetric = "monthly_write_requests"
	MetricMonthlyAPIRequests    UsageMetric = "monthly_api_requests"

	// Operation metrics
	MetricMonthlyOperations     UsageMetric = "monthly_operations"
	MetricMonthlyGetOperations  UsageMetric = "monthly_get_operations"
	MetricMonthlyPutOperations  UsageMetric = "monthly_put_operations"
	MetricMonthlyListOperations UsageMetric = "monthly_list_operations"

	// Compute metrics
	MetricMonthlyCPUCredits UsageMetric = "monthly_cpu_credits"
	MetricMonthlyVCPUHours  UsageMetric = "monthly_vcpu_hours"
	MetricMonthlyGBHours    UsageMetric = "monthly_gb_hours"

	// Database metrics
	MetricMonthlyIORequests       UsageMetric = "monthly_io_requests"
	MetricMonthlyBackupStorageGB  UsageMetric = "monthly_backup_storage_gb"

	// Serverless metrics
	MetricMonthlyInvocations   UsageMetric = "monthly_invocations"
	MetricMonthlyGBSeconds     UsageMetric = "monthly_gb_seconds"
	MetricMonthlyDurationMs    UsageMetric = "monthly_duration_ms"
)

// String returns the string representation
func (m UsageMetric) String() string {
	return string(m)
}

// UsageVector represents estimated usage for a specific metric
type UsageVector struct {
	// Metric is the usage dimension being measured
	Metric UsageMetric `json:"metric"`

	// Value is the estimated usage amount
	Value float64 `json:"value"`

	// Confidence is the confidence level (0.0 to 1.0)
	Confidence float64 `json:"confidence"`

	// Source indicates where this estimate came from
	Source UsageSource `json:"source"`

	// Min is the minimum expected value (for range estimates)
	Min *float64 `json:"min,omitempty"`

	// Max is the maximum expected value (for range estimates)
	Max *float64 `json:"max,omitempty"`

	// Description explains the usage estimate
	Description string `json:"description,omitempty"`
}

// UsageSource indicates the origin of usage data
type UsageSource string

const (
	// SourceDefault uses built-in default values
	SourceDefault UsageSource = "default"

	// SourceOverride uses user-provided values
	SourceOverride UsageSource = "override"

	// SourceProfile uses a pre-defined usage profile
	SourceProfile UsageSource = "profile"

	// SourceHistorical uses historical data analysis
	SourceHistorical UsageSource = "historical"

	// SourceML uses machine learning predictions
	SourceML UsageSource = "ml"

	// SourceTerraform uses values from Terraform configuration
	SourceTerraform UsageSource = "terraform"
)

// String returns the string representation
func (s UsageSource) String() string {
	return string(s)
}

// UsageProfile represents a complete usage configuration for an estimation
type UsageProfile struct {
	// Name is the profile identifier
	Name string `json:"name"`

	// Description explains the profile
	Description string `json:"description,omitempty"`

	// Environment is the target environment (dev, staging, prod)
	Environment string `json:"environment,omitempty"`

	// Defaults are default usage values by resource type
	Defaults map[string][]UsageVector `json:"defaults,omitempty"`

	// Overrides are resource-specific usage overrides
	Overrides map[ResourceAddress][]UsageVector `json:"overrides,omitempty"`

	// Multipliers scale usage values for scenario analysis
	Multipliers map[UsageMetric]float64 `json:"multipliers,omitempty"`
}

// NewUsageProfile creates a new usage profile with the given name
func NewUsageProfile(name string) *UsageProfile {
	return &UsageProfile{
		Name:        name,
		Defaults:    make(map[string][]UsageVector),
		Overrides:   make(map[ResourceAddress][]UsageVector),
		Multipliers: make(map[UsageMetric]float64),
	}
}

// GetOverrides returns usage overrides for a specific resource
func (p *UsageProfile) GetOverrides(addr ResourceAddress) []UsageVector {
	if p == nil {
		return nil
	}
	return p.Overrides[addr]
}

// GetDefaults returns default usage for a resource type
func (p *UsageProfile) GetDefaults(resourceType string) []UsageVector {
	if p == nil {
		return nil
	}
	return p.Defaults[resourceType]
}

// ApplyMultiplier applies a multiplier to usage vectors
func (p *UsageProfile) ApplyMultiplier(vectors []UsageVector) []UsageVector {
	if p == nil || len(p.Multipliers) == 0 {
		return vectors
	}

	result := make([]UsageVector, len(vectors))
	for i, v := range vectors {
		result[i] = v
		if multiplier, ok := p.Multipliers[v.Metric]; ok {
			result[i].Value = v.Value * multiplier
			if v.Min != nil {
				min := *v.Min * multiplier
				result[i].Min = &min
			}
			if v.Max != nil {
				max := *v.Max * multiplier
				result[i].Max = &max
			}
		}
	}
	return result
}

// UsageContext provides context for usage estimation
type UsageContext struct {
	// Profile is the active usage profile
	Profile *UsageProfile

	// Environment is the target environment
	Environment string

	// Region is the deployment region
	Region Region

	// Scenario is the estimation scenario (min, typical, max)
	Scenario UsageScenario
}

// UsageScenario represents different usage estimation scenarios
type UsageScenario string

const (
	ScenarioMin     UsageScenario = "min"
	ScenarioTypical UsageScenario = "typical"
	ScenarioMax     UsageScenario = "max"
)

################################################################################
# FILE: :\good projects\cost estimation\core\usage\estimator.go
# TYPE: go
# SIZE: 2653 bytes
################################################################################
// Package usage provides usage estimation interfaces.
// This package estimates how infrastructure will be used.
// Usage is decoupled from resource definitions to enable scenario modeling.
package usage

import (
	"context"

	"terraform-cost/core/types"
)

// Estimator estimates usage for a specific resource type
type Estimator interface {
	// Provider returns the cloud provider
	Provider() types.Provider

	// ResourceType returns the resource type this estimator handles
	ResourceType() string

	// Estimate produces usage vectors for an asset
	Estimate(ctx context.Context, asset *types.Asset, uctx *Context) ([]types.UsageVector, error)
}

// Context provides context for usage estimation
type Context struct {
	// Profile is the active usage profile
	Profile *types.UsageProfile

	// Environment is the target environment (dev, staging, prod)
	Environment string

	// Region is the deployment region
	Region types.Region

	// Scenario is the estimation scenario
	Scenario types.UsageScenario

	// Now is the current time (for time-based calculations)
	Now string

	// CustomDefaults are additional default values
	CustomDefaults map[types.UsageMetric]float64
}

// DefaultContext creates a new usage context with defaults
func DefaultContext() *Context {
	return &Context{
		Environment: "production",
		Scenario:    types.ScenarioTypical,
	}
}

// EstimatorRegistry manages usage estimator registration
type EstimatorRegistry interface {
	// Register adds an estimator to the registry
	Register(estimator Estimator) error

	// GetEstimator returns an estimator for a provider and resource type
	GetEstimator(provider types.Provider, resourceType string) (Estimator, bool)

	// GetProviderEstimators returns all estimators for a provider
	GetProviderEstimators(provider types.Provider) []Estimator
}

// EstimationResult contains usage estimation output
type EstimationResult struct {
	// AssetID is the asset this estimation is for
	AssetID string

	// Vectors are the usage estimates
	Vectors []types.UsageVector

	// Confidence is the overall confidence level
	Confidence float64

	// Assumptions lists assumptions made
	Assumptions []string
}

// Manager orchestrates usage estimation across all assets
type Manager interface {
	// EstimateAll estimates usage for all assets in a graph
	EstimateAll(ctx context.Context, graph *types.AssetGraph, uctx *Context) (map[string]*EstimationResult, error)

	// EstimateAsset estimates usage for a single asset
	EstimateAsset(ctx context.Context, asset *types.Asset, uctx *Context) (*EstimationResult, error)
}

################################################################################
# FILE: :\good projects\cost estimation\core\usage\registry.go
# TYPE: go
# SIZE: 2268 bytes
################################################################################
// Package usage - Usage estimator registry
package usage

import (
	"fmt"
	"sync"

	"terraform-cost/core/types"
)

// DefaultEstimatorRegistry is the default implementation
type DefaultEstimatorRegistry struct {
	mu         sync.RWMutex
	estimators map[string]Estimator // key: provider/resource_type
}

// NewEstimatorRegistry creates a new estimator registry
func NewEstimatorRegistry() *DefaultEstimatorRegistry {
	return &DefaultEstimatorRegistry{
		estimators: make(map[string]Estimator),
	}
}

// Register adds an estimator to the registry
func (r *DefaultEstimatorRegistry) Register(estimator Estimator) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := makeEstimatorKey(estimator.Provider(), estimator.ResourceType())
	if _, exists := r.estimators[key]; exists {
		return fmt.Errorf("estimator already registered: %s", key)
	}

	r.estimators[key] = estimator
	return nil
}

// GetEstimator returns an estimator for a provider and resource type
func (r *DefaultEstimatorRegistry) GetEstimator(provider types.Provider, resourceType string) (Estimator, bool) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	key := makeEstimatorKey(provider, resourceType)
	estimator, ok := r.estimators[key]
	return estimator, ok
}

// GetProviderEstimators returns all estimators for a provider
func (r *DefaultEstimatorRegistry) GetProviderEstimators(provider types.Provider) []Estimator {
	r.mu.RLock()
	defer r.mu.RUnlock()

	var estimators []Estimator
	prefix := string(provider) + "/"
	for key, estimator := range r.estimators {
		if len(key) > len(prefix) && key[:len(prefix)] == prefix {
			estimators = append(estimators, estimator)
		}
	}
	return estimators
}

func makeEstimatorKey(provider types.Provider, resourceType string) string {
	return string(provider) + "/" + resourceType
}

// Global default registry
var defaultEstimatorRegistry = NewEstimatorRegistry()

// RegisterEstimator adds an estimator to the default registry
func RegisterEstimator(estimator Estimator) error {
	return defaultEstimatorRegistry.Register(estimator)
}

// GetDefaultEstimatorRegistry returns the default registry
func GetDefaultEstimatorRegistry() *DefaultEstimatorRegistry {
	return defaultEstimatorRegistry
}

################################################################################
# FILE: :\good projects\cost estimation\examples\aws-simple\main.tf
# TYPE: hcl
# SIZE: 1876 bytes
################################################################################
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "us-east-1"
}

# EC2 Instance
resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.medium"

  root_block_device {
    volume_type = "gp3"
    volume_size = 30
  }

  tags = {
    Name        = "web-server"
    Environment = "production"
  }
}

# RDS Database
resource "aws_db_instance" "main" {
  identifier        = "main-database"
  engine            = "postgres"
  engine_version    = "15.4"
  instance_class    = "db.t3.medium"
  allocated_storage = 100
  storage_type      = "gp2"

  db_name  = "myapp"
  username = "admin"
  password = "changeme123"

  multi_az            = false
  skip_final_snapshot = true

  tags = {
    Name        = "main-database"
    Environment = "production"
  }
}

# NAT Gateway
resource "aws_nat_gateway" "main" {
  allocation_id = "eipalloc-12345678"
  subnet_id     = "subnet-12345678"

  tags = {
    Name = "main-nat"
  }
}

# EBS Volume
resource "aws_ebs_volume" "data" {
  availability_zone = "us-east-1a"
  size              = 500
  type              = "gp3"
  iops              = 3000
  throughput        = 125

  tags = {
    Name = "data-volume"
  }
}

# Lambda Function
resource "aws_lambda_function" "api" {
  function_name = "api-handler"
  role          = "arn:aws:iam::123456789012:role/lambda-role"
  handler       = "index.handler"
  runtime       = "nodejs18.x"
  memory_size   = 256
  timeout       = 30

  filename = "function.zip"

  tags = {
    Name = "api-lambda"
  }
}

# S3 Bucket
resource "aws_s3_bucket" "assets" {
  bucket = "my-app-assets-bucket"

  tags = {
    Name        = "assets"
    Environment = "production"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\internal\config\config.go
# TYPE: go
# SIZE: 4997 bytes
################################################################################
// Package config provides configuration management.
package config

import (
	"encoding/json"
	"os"
	"path/filepath"

	"terraform-cost/core/types"
	"terraform-cost/internal/logging"
)

// Config is the main application configuration
type Config struct {
	// Version is the configuration version
	Version string `json:"version"`

	// Pricing contains pricing configuration
	Pricing PricingConfig `json:"pricing"`

	// Output contains output configuration
	Output OutputConfig `json:"output"`

	// Cache contains cache configuration
	Cache CacheConfig `json:"cache"`

	// Logging contains logging configuration
	Logging logging.Config `json:"logging"`

	// AWS contains AWS-specific configuration
	AWS AWSConfig `json:"aws,omitempty"`

	// Azure contains Azure-specific configuration  
	Azure AzureConfig `json:"azure,omitempty"`

	// GCP contains GCP-specific configuration
	GCP GCPConfig `json:"gcp,omitempty"`
}

// PricingConfig contains pricing-related settings
type PricingConfig struct {
	// DefaultCurrency is the default currency
	DefaultCurrency types.Currency `json:"default_currency"`

	// CacheEnabled enables pricing caching
	CacheEnabled bool `json:"cache_enabled"`

	// CacheTTLSeconds is how long to cache prices
	CacheTTLSeconds int `json:"cache_ttl_seconds"`

	// DatabasePath is the path to the pricing database
	DatabasePath string `json:"database_path"`

	// RefreshOnStart refreshes pricing on startup
	RefreshOnStart bool `json:"refresh_on_start"`
}

// OutputConfig contains output-related settings
type OutputConfig struct {
	// DefaultFormat is the default output format
	DefaultFormat string `json:"default_format"`

	// ShowDetails shows detailed cost breakdown
	ShowDetails bool `json:"show_details"`

	// ShowConfidence shows confidence scores
	ShowConfidence bool `json:"show_confidence"`

	// GroupBy is the default grouping
	GroupBy string `json:"group_by"`
}

// CacheConfig contains cache-related settings
type CacheConfig struct {
	// Enabled enables caching
	Enabled bool `json:"enabled"`

	// Directory is the cache directory
	Directory string `json:"directory"`

	// MaxSizeMB is the maximum cache size in MB
	MaxSizeMB int `json:"max_size_mb"`
}

// AWSConfig contains AWS-specific settings
type AWSConfig struct {
	// DefaultRegion is the default AWS region
	DefaultRegion string `json:"default_region"`

	// Profile is the AWS profile to use
	Profile string `json:"profile,omitempty"`

	// Regions to include in pricing
	Regions []string `json:"regions,omitempty"`
}

// AzureConfig contains Azure-specific settings
type AzureConfig struct {
	// DefaultRegion is the default Azure region
	DefaultRegion string `json:"default_region"`

	// SubscriptionID is the Azure subscription
	SubscriptionID string `json:"subscription_id,omitempty"`
}

// GCPConfig contains GCP-specific settings
type GCPConfig struct {
	// DefaultRegion is the default GCP region
	DefaultRegion string `json:"default_region"`

	// Project is the GCP project
	Project string `json:"project,omitempty"`
}

// Default returns a default configuration
func Default() *Config {
	homeDir, _ := os.UserHomeDir()
	cacheDir := filepath.Join(homeDir, ".terraform-cost", "cache")
	dbPath := filepath.Join(homeDir, ".terraform-cost", "pricing.db")

	return &Config{
		Version: "1.0",
		Pricing: PricingConfig{
			DefaultCurrency: types.CurrencyUSD,
			CacheEnabled:    true,
			CacheTTLSeconds: 86400, // 24 hours
			DatabasePath:    dbPath,
			RefreshOnStart:  false,
		},
		Output: OutputConfig{
			DefaultFormat:  "cli",
			ShowDetails:    true,
			ShowConfidence: false,
			GroupBy:        "resource",
		},
		Cache: CacheConfig{
			Enabled:   true,
			Directory: cacheDir,
			MaxSizeMB: 100,
		},
		Logging: logging.DefaultConfig(),
		AWS: AWSConfig{
			DefaultRegion: "us-east-1",
		},
		Azure: AzureConfig{
			DefaultRegion: "eastus",
		},
		GCP: GCPConfig{
			DefaultRegion: "us-central1",
		},
	}
}

// Load loads configuration from a file
func Load(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return Default(), nil
		}
		return nil, err
	}

	config := Default()
	if err := json.Unmarshal(data, config); err != nil {
		return nil, err
	}

	return config, nil
}

// Save saves configuration to a file
func (c *Config) Save(path string) error {
	// Ensure directory exists
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	data, err := json.MarshalIndent(c, "", "  ")
	if err != nil {
		return err
	}

	return os.WriteFile(path, data, 0644)
}

// Global configuration instance
var globalConfig = Default()

// Get returns the global configuration
func Get() *Config {
	return globalConfig
}

// Set sets the global configuration
func Set(config *Config) {
	globalConfig = config
}

################################################################################
# FILE: :\good projects\cost estimation\internal\errors\errors.go
# TYPE: go
# SIZE: 3810 bytes
################################################################################
// Package errors provides error handling utilities.
package errors

import (
	"fmt"
)

// Type identifies the category of error
type Type string

const (
	// TypeInput indicates an input validation error
	TypeInput Type = "INPUT_ERROR"

	// TypeParsing indicates a parsing error
	TypeParsing Type = "PARSING_ERROR"

	// TypePricing indicates a pricing resolution error
	TypePricing Type = "PRICING_ERROR"

	// TypePolicy indicates a policy evaluation error
	TypePolicy Type = "POLICY_ERROR"

	// TypeConfig indicates a configuration error
	TypeConfig Type = "CONFIG_ERROR"

	// TypeNetwork indicates a network error
	TypeNetwork Type = "NETWORK_ERROR"

	// TypeInternal indicates an internal error
	TypeInternal Type = "INTERNAL_ERROR"

	// TypeNotFound indicates a resource not found error
	TypeNotFound Type = "NOT_FOUND"

	// TypeNotSupported indicates an unsupported operation
	TypeNotSupported Type = "NOT_SUPPORTED"
)

// Error represents a domain error with context
type Error struct {
	Type    Type                   `json:"type"`
	Message string                 `json:"message"`
	Cause   error                  `json:"-"`
	Context map[string]interface{} `json:"context,omitempty"`
}

// Error implements the error interface
func (e *Error) Error() string {
	if e.Cause != nil {
		return fmt.Sprintf("[%s] %s: %v", e.Type, e.Message, e.Cause)
	}
	return fmt.Sprintf("[%s] %s", e.Type, e.Message)
}

// Unwrap returns the underlying error
func (e *Error) Unwrap() error {
	return e.Cause
}

// Is checks if the error is of a specific type
func (e *Error) Is(t Type) bool {
	return e.Type == t
}

// WithContext adds context to the error
func (e *Error) WithContext(key string, value interface{}) *Error {
	if e.Context == nil {
		e.Context = make(map[string]interface{})
	}
	e.Context[key] = value
	return e
}

// New creates a new error
func New(errType Type, message string) *Error {
	return &Error{
		Type:    errType,
		Message: message,
	}
}

// Newf creates a new formatted error
func Newf(errType Type, format string, args ...interface{}) *Error {
	return &Error{
		Type:    errType,
		Message: fmt.Sprintf(format, args...),
	}
}

// Wrap wraps an error with context
func Wrap(errType Type, message string, cause error) *Error {
	return &Error{
		Type:    errType,
		Message: message,
		Cause:   cause,
	}
}

// Wrapf wraps an error with formatted context
func Wrapf(errType Type, cause error, format string, args ...interface{}) *Error {
	return &Error{
		Type:    errType,
		Message: fmt.Sprintf(format, args...),
		Cause:   cause,
	}
}

// IsType checks if an error is of a specific type
func IsType(err error, t Type) bool {
	if e, ok := err.(*Error); ok {
		return e.Type == t
	}
	return false
}

// Input creates an input error
func Input(message string) *Error {
	return New(TypeInput, message)
}

// Parsing creates a parsing error
func Parsing(message string, cause error) *Error {
	return Wrap(TypeParsing, message, cause)
}

// Pricing creates a pricing error
func Pricing(message string, cause error) *Error {
	return Wrap(TypePricing, message, cause)
}

// Policy creates a policy error
func Policy(message string) *Error {
	return New(TypePolicy, message)
}

// NotFound creates a not found error
func NotFound(resourceType, identifier string) *Error {
	return Newf(TypeNotFound, "%s not found: %s", resourceType, identifier)
}

// NotSupported creates a not supported error
func NotSupported(operation string) *Error {
	return Newf(TypeNotSupported, "operation not supported: %s", operation)
}

// Internal creates an internal error
func Internal(message string, cause error) *Error {
	return Wrap(TypeInternal, message, cause)
}

################################################################################
# FILE: :\good projects\cost estimation\internal\logging\logging.go
# TYPE: go
# SIZE: 3090 bytes
################################################################################
// Package logging provides structured logging utilities.
package logging

import (
	"os"

	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

var (
	// Logger is the global logger instance
	Logger *zap.Logger

	// Sugar is the sugared logger for convenience
	Sugar *zap.SugaredLogger
)

// Config contains logging configuration
type Config struct {
	// Level is the minimum log level
	Level string `json:"level"`

	// Format is the output format (json, console)
	Format string `json:"format"`

	// Output is the output destination (stdout, stderr, file path)
	Output string `json:"output"`

	// Development enables development mode
	Development bool `json:"development"`
}

// DefaultConfig returns sensible defaults
func DefaultConfig() Config {
	return Config{
		Level:       "info",
		Format:      "console",
		Output:      "stderr",
		Development: false,
	}
}

// Initialize sets up the global logger
func Initialize(cfg Config) error {
	level, err := zapcore.ParseLevel(cfg.Level)
	if err != nil {
		level = zapcore.InfoLevel
	}

	var encoder zapcore.Encoder
	encoderConfig := zap.NewProductionEncoderConfig()
	encoderConfig.TimeKey = "timestamp"
	encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder

	if cfg.Format == "console" {
		encoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
		encoder = zapcore.NewConsoleEncoder(encoderConfig)
	} else {
		encoder = zapcore.NewJSONEncoder(encoderConfig)
	}

	var writeSyncer zapcore.WriteSyncer
	switch cfg.Output {
	case "stdout":
		writeSyncer = zapcore.AddSync(os.Stdout)
	case "stderr":
		writeSyncer = zapcore.AddSync(os.Stderr)
	default:
		file, err := os.OpenFile(cfg.Output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
		if err != nil {
			return err
		}
		writeSyncer = zapcore.AddSync(file)
	}

	core := zapcore.NewCore(encoder, writeSyncer, level)

	if cfg.Development {
		Logger = zap.New(core, zap.Development(), zap.AddCaller(), zap.AddStacktrace(zapcore.ErrorLevel))
	} else {
		Logger = zap.New(core, zap.AddCaller())
	}

	Sugar = Logger.Sugar()
	return nil
}

// InitializeDefault sets up the logger with default configuration
func InitializeDefault() {
	_ = Initialize(DefaultConfig())
}

// Sync flushes the logger
func Sync() {
	if Logger != nil {
		_ = Logger.Sync()
	}
}

// With returns a logger with additional fields
func With(fields ...zap.Field) *zap.Logger {
	return Logger.With(fields...)
}

// Debug logs at debug level
func Debug(msg string, fields ...zap.Field) {
	Logger.Debug(msg, fields...)
}

// Info logs at info level
func Info(msg string, fields ...zap.Field) {
	Logger.Info(msg, fields...)
}

// Warn logs at warn level
func Warn(msg string, fields ...zap.Field) {
	Logger.Warn(msg, fields...)
}

// Error logs at error level
func Error(msg string, fields ...zap.Field) {
	Logger.Error(msg, fields...)
}

// Fatal logs at fatal level and exits
func Fatal(msg string, fields ...zap.Field) {
	Logger.Fatal(msg, fields...)
}

func init() {
	InitializeDefault()
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\bad_configs\missing_required.tf
# TYPE: hcl
# SIZE: 156 bytes
################################################################################
# Bad Config: Missing required attribute

resource "aws_instance" "missing_ami" {
  # Missing required 'ami' attribute
  instance_type = "t3.micro"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\bad_configs\syntax_error.tf
# TYPE: hcl
# SIZE: 195 bytes
################################################################################
# Bad Config: Syntax error

resource "aws_instance" "broken" {
  ami           = "ami-12345678"
  instance_type = "t3.micro"

  tags = {
    Name = "broken"
  # Missing closing brace
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\basic\multiple_resources.tf
# TYPE: hcl
# SIZE: 925 bytes
################################################################################
# Basic Test: Multiple resource types

resource "aws_instance" "web" {
  ami           = "ami-12345678"
  instance_type = "t3.small"

  root_block_device {
    volume_size = 20
    volume_type = "gp3"
  }

  tags = {
    Name = "web-server"
  }
}

resource "aws_ebs_volume" "data" {
  availability_zone = "us-east-1a"
  size              = 100
  type              = "gp3"

  tags = {
    Name = "data-volume"
  }
}

resource "aws_volume_attachment" "data" {
  device_name = "/dev/sdf"
  volume_id   = aws_ebs_volume.data.id
  instance_id = aws_instance.web.id
}

resource "aws_s3_bucket" "logs" {
  bucket = "my-app-logs-bucket"
}

resource "aws_rds_instance" "db" {
  identifier     = "mydb"
  engine         = "mysql"
  engine_version = "8.0"
  instance_class = "db.t3.micro"

  allocated_storage = 20
  storage_type      = "gp2"

  tags = {
    Name = "app-database"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\basic\single_resource.tf
# TYPE: hcl
# SIZE: 225 bytes
################################################################################
# Basic Test: Simple single resource

resource "aws_instance" "simple" {
  ami           = "ami-12345678"
  instance_type = "t3.micro"

  tags = {
    Name        = "simple-instance"
    Environment = "test"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\dynamic_blocks\nested_dynamic.tf
# TYPE: hcl
# SIZE: 1438 bytes
################################################################################
# Dynamic Block Test: Nested dynamic blocks

variable "load_balancer_config" {
  type = object({
    listeners = list(object({
      port     = number
      protocol = string
      rules = list(object({
        path    = string
        backend = string
      }))
    }))
  })
  default = {
    listeners = [
      {
        port     = 80
        protocol = "HTTP"
        rules = [
          { path = "/api", backend = "api-backend" },
          { path = "/web", backend = "web-backend" }
        ]
      },
      {
        port     = 443
        protocol = "HTTPS"
        rules = [
          { path = "/api", backend = "api-backend" },
          { path = "/admin", backend = "admin-backend" }
        ]
      }
    ]
  }
}

resource "aws_lb_listener" "main" {
  load_balancer_arn = "arn:aws:elasticloadbalancing:us-east-1:123456789:loadbalancer/app/main/abc123"

  dynamic "listener" {
    for_each = var.load_balancer_config.listeners
    content {
      port     = listener.value.port
      protocol = listener.value.protocol

      dynamic "action" {
        for_each = listener.value.rules
        content {
          type = "forward"

          forward {
            target_group_arn = action.value.backend
          }

          condition {
            path_pattern {
              values = [action.value.path]
            }
          }
        }
      }
    }
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\dynamic_blocks\single_dynamic.tf
# TYPE: hcl
# SIZE: 1055 bytes
################################################################################
# Dynamic Block Test: Single dynamic block

variable "ingress_rules" {
  type = list(object({
    port        = number
    protocol    = string
    cidr_blocks = list(string)
  }))
  default = [
    {
      port        = 80
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    },
    {
      port        = 443
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    },
    {
      port        = 22
      protocol    = "tcp"
      cidr_blocks = ["10.0.0.0/8"]
    }
  ]
}

resource "aws_security_group" "example" {
  name        = "dynamic-sg"
  description = "Security group with dynamic blocks"
  vpc_id      = "vpc-12345678"

  dynamic "ingress" {
    for_each = var.ingress_rules
    content {
      from_port   = ingress.value.port
      to_port     = ingress.value.port
      protocol    = ingress.value.protocol
      cidr_blocks = ingress.value.cidr_blocks
    }
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\circular_reference.tf
# TYPE: hcl
# SIZE: 633 bytes
################################################################################
# Edge Case: Circular reference between resources

resource "aws_security_group" "sg_a" {
  name        = "sg-a"
  description = "Security group A"
  vpc_id      = "vpc-12345678"

  ingress {
    from_port       = 80
    to_port         = 80
    protocol        = "tcp"
    security_groups = [aws_security_group.sg_b.id]
  }
}

resource "aws_security_group" "sg_b" {
  name        = "sg-b"
  description = "Security group B"
  vpc_id      = "vpc-12345678"

  ingress {
    from_port       = 443
    to_port         = 443
    protocol        = "tcp"
    security_groups = [aws_security_group.sg_a.id]
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\conditional_resource.tf
# TYPE: hcl
# SIZE: 642 bytes
################################################################################
# Edge Case: Conditional resource (count 0 or 1)

variable "create_instance" {
  type    = bool
  default = true
}

variable "create_bucket" {
  type    = bool
  default = false
}

resource "aws_instance" "conditional" {
  count = var.create_instance ? 1 : 0

  ami           = "ami-12345678"
  instance_type = "t3.micro"
}

resource "aws_s3_bucket" "conditional" {
  count = var.create_bucket ? 1 : 0

  bucket = "my-conditional-bucket"
}

# Resource that depends on conditional resource
resource "aws_eip" "instance_eip" {
  count    = var.create_instance ? 1 : 0
  instance = aws_instance.conditional[0].id
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\self_reference.tf
# TYPE: hcl
# SIZE: 239 bytes
################################################################################
# Edge Case: Self-referencing count

resource "aws_instance" "self_ref" {
  count = length(aws_instance.self_ref) > 0 ? 2 : 1 # This is invalid but should be handled

  ami           = "ami-12345678"
  instance_type = "t3.micro"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\edge_cases\unknown_count.tf
# TYPE: hcl
# SIZE: 280 bytes
################################################################################
# Edge Case: Unknown count value

variable "count_from_external" {
  type = number
  # No default - must be provided
}

resource "aws_instance" "unknown_count" {
  count         = var.count_from_external
  ami           = "ami-12345678"
  instance_type = "t3.micro"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\count_variable.tf
# TYPE: hcl
# SIZE: 309 bytes
################################################################################
# Expansion Test: count from variable

variable "instance_count" {
  type    = number
  default = 3
}

resource "aws_instance" "counted" {
  count         = var.instance_count
  ami           = "ami-12345678"
  instance_type = "t3.micro"

  tags = {
    Name = "instance-${count.index}"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\count_zero.tf
# TYPE: hcl
# SIZE: 168 bytes
################################################################################
# Expansion Test: count=0 produces nothing

resource "aws_instance" "zero" {
  count         = 0
  ami           = "ami-12345678"
  instance_type = "t3.micro"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\for_each_map.tf
# TYPE: hcl
# SIZE: 678 bytes
################################################################################
# Expansion Test: for_each with map

variable "instances" {
  type = map(object({
    instance_type = string
    ami           = string
  }))
  default = {
    web = {
      instance_type = "t3.small"
      ami           = "ami-web12345"
    }
    api = {
      instance_type = "t3.medium"
      ami           = "ami-api12345"
    }
    worker = {
      instance_type = "t3.large"
      ami           = "ami-wrk12345"
    }
  }
}

resource "aws_instance" "multi" {
  for_each      = var.instances
  ami           = each.value.ami
  instance_type = each.value.instance_type

  tags = {
    Name = "instance-${each.key}"
    Role = each.key
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\for_each_set.tf
# TYPE: hcl
# SIZE: 712 bytes
################################################################################
# Expansion Test: for_each with set of strings

variable "availability_zones" {
  type    = set(string)
  default = ["us-east-1a", "us-east-1b", "us-east-1c"]
}

resource "aws_subnet" "main" {
  for_each = var.availability_zones

  vpc_id            = "vpc-12345678"
  cidr_block        = "10.0.${index(tolist(var.availability_zones), each.value)}.0/24"
  availability_zone = each.value

  tags = {
    Name = "subnet-${each.value}"
  }
}

# Resources using the subnets
resource "aws_instance" "per_az" {
  for_each = aws_subnet.main

  ami           = "ami-12345678"
  instance_type = "t3.micro"
  subnet_id     = each.value.id

  tags = {
    Name = "instance-${each.key}"
  }
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\expansion\nested_count_for_each.tf
# TYPE: hcl
# SIZE: 857 bytes
################################################################################
# Expansion Test: Nested count inside for_each

variable "environments" {
  type = map(object({
    replica_count = number
  }))
  default = {
    dev     = { replica_count = 1 }
    staging = { replica_count = 2 }
    prod    = { replica_count = 3 }
  }
}

# Outer for_each
resource "aws_db_instance" "primary" {
  for_each = var.environments

  identifier     = "${each.key}-db-primary"
  engine         = "mysql"
  instance_class = each.key == "prod" ? "db.r5.large" : "db.t3.micro"

  tags = {
    Environment = each.key
    Role        = "primary"
  }
}

# This pattern (count inside module with for_each) is common
module "db_replicas" {
  source   = "./replica"
  for_each = var.environments

  count       = each.value.replica_count
  primary_id  = aws_db_instance.primary[each.key].id
  environment = each.key
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\modules\local_module.tf
# TYPE: hcl
# SIZE: 305 bytes
################################################################################
# Module Test: Local module with count

variable "app_count" {
  type    = number
  default = 2
}

module "app" {
  source = "./app"
  count  = var.app_count

  name          = "app-${count.index}"
  instance_type = "t3.micro"
}

output "app_ids" {
  value = module.app[*].instance_id
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\modules\nested_modules.tf
# TYPE: hcl
# SIZE: 645 bytes
################################################################################
# Module Test: Nested module with for_each

variable "environments" {
  type = map(object({
    instance_count = number
    instance_type  = string
  }))
  default = {
    dev = {
      instance_count = 1
      instance_type  = "t3.micro"
    }
    staging = {
      instance_count = 2
      instance_type  = "t3.small"
    }
    prod = {
      instance_count = 3
      instance_type  = "t3.medium"
    }
  }
}

module "environment" {
  source   = "./environment"
  for_each = var.environments

  name           = each.key
  instance_count = each.value.instance_count
  instance_type  = each.value.instance_type
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\providers\alias_basic.tf
# TYPE: hcl
# SIZE: 646 bytes
################################################################################
# Provider Test: Multiple regions with aliases

provider "aws" {
  region = "us-east-1"
}

provider "aws" {
  alias  = "west"
  region = "us-west-2"
}

provider "aws" {
  alias  = "eu"
  region = "eu-west-1"
}

resource "aws_instance" "east" {
  ami           = "ami-east12345"
  instance_type = "t3.micro"

  tags = {
    Region = "us-east-1"
  }
}

resource "aws_instance" "west" {
  provider      = aws.west
  ami           = "ami-west12345"
  instance_type = "t3.micro"

  tags = {
    Region = "us-west-2"
  }
}

resource "aws_s3_bucket" "eu_bucket" {
  provider = aws.eu
  bucket   = "my-eu-bucket"
}

################################################################################
# FILE: :\good projects\cost estimation\testdata\terraform\providers\alias_module_inherit.tf
# TYPE: hcl
# SIZE: 346 bytes
################################################################################
# Provider Test: Module inheriting provider alias

provider "aws" {
  region = "us-east-1"
}

provider "aws" {
  alias  = "west"
  region = "us-west-2"
}

module "app_east" {
  source = "./app"

  name = "app-east"
}

module "app_west" {
  source = "./app"

  providers = {
    aws = aws.west
  }

  name = "app-west"
}

################################################################################
#                              END OF FILE                                     #
################################################################################

================================================================================
                                SUMMARY
================================================================================

Total Files Combined: 79
Generated: 2026-01-16 00:49:24
Project: cost estimation

Files by Type:  .go : 53 files
  .tf : 20 files
  .md : 1 files
  .mod : 1 files
  (no extension) : 1 files
  .gitignore : 1 files
  .ps1 : 1 files
  .yml : 1 files

================================================================================
